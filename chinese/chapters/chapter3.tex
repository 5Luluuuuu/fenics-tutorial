\chapter{有限元求解器画廊}
\label{ch:gallery}

\begin{quote}
本章的目标是展示一系列重要的内容
科学与工程学院的PDEs可以很快得到解决
FEniCS代码行。 我们从热方程开始，继续
用非线性Poisson方程，线性方程
弹性，Navier-Stokes方程式，最后看看如何
解决非线性对流 - 扩散反应的系统
方程。 这些问题说明了如何解决时间依赖性问题
问题，非线性问题，向量值问题和系统
PDEs。 对于每个问题，我们得出变分公式
在Python中以非常类似的方式表达问题
数学。
\end{quote}

\section{热方程式}
\label{ch:fundamentals:diffusion}

\index{heat equation}
\index{time-dependent problem}

作为前一章的Poisson问题的第一个扩展，
我们考虑时间依赖热方程，或时间依赖性
扩散方程。 这是Poisson的自然延伸
描述体内热量的固定分布的方程式
时间依赖的问题。

我们会看到，通过将时间离散成小时间间隔
采用标准时间步法，可以解决热量
通过求解一系列变分问题的方程式，很像
一个我们遇到的Poisson方程。

\subsection{PDE问题}

我们的时间依赖型PDE的模型问题读取

\begin{alignat}{2}
{\partial u\over\partial t} &= \nabla^2 u + f \quad &&\hbox{in }\Omega\times(0, T],
\label{ch:diffusion0:pde1}\\
u &= \ub &&\hbox{on } \partial \Omega\times(0, T],
\label{ch:diffusion0:pde1:bc}\\
u &= \uI &&\mbox{at } t=0\tp
\label{ch:diffusion0:pde1:ic}
\end{alignat}
在这里，$u$随空间和时间而变化，例如，如果空间，则$u=u(x,y,t)$
域$\Omega$是二维的。 源函数$f$和
边界值$\ub$也可能因空间和时间而异。
初始条件$\uI$仅是空间的函数。

\subsection{变化公式}
\label{ftut:timedep:diffusion1}

一个简单的方法来解决时间依赖的PDEs
有限元方法是首先离散时间导数a
有限差分近似，产生一个序列
固定问题，然后将每个静止问题转化为
变分公式

让上标$n$表示时间$t_n$的数量，其中$n$是一个
整数计数时间级别。 例如，$u^n$表示$u$在时间
级$n$。 时间上的有限差分离散化包括
在某个时间级别对PDE进行采样，说$t_{n + 1}$:

\index{time step}

\begin{equation}
\left({\partial u \over\partial t}\right)^{n+1} = \nabla^2 u^{n+1} + f^{n+1}\tp
\label{ch:diffusion0:pde1:tk}
\end{equation}
时间导数可以通过差商近似。
为了简单和稳定的原因，我们选择一个
简单向后的差异:

\index{implicit Euler}
\index{backward difference}

\begin{equation}
\left({\partial u\over\partial t}\right)^{n+1}\approx {{u^{n+1} - u^n}\over{\dt}},
\label{ch:diffusion0:BE}
\end{equation}
其中$\dt$是时间离散参数。
(\ref{ch:diffusion0:pde1:tk})插入(\ref{ch:diffusion0:BE})产生

\begin{equation}
{{u^{n+1} - u^n}\over{\dt}} = \nabla^2 u^{n+1} + f^{n+1}\tp
\label{ch:diffusion0:pde1:BE}
\end{equation}
这是我们的时间离散版本的热方程
(\ref{ch:diffusion0:pde1})，所谓的\emph{backward Euler}或\emph{implicit
  Euler}离散化。

我们可以重新排序(\ref{ch:diffusion0:pde1:BE})
左侧包含未知$u^{n+1}$的条款
右侧仅包含计算的条件。 结果
是假设为$u^{n+1}$的空间（静态）问题的序列
$u^n$从以前的时间步长是已知的:

\begin{align}
u^0 &= \uI, \label{ch:diffusion0:pde1:u0}\\
u^{n+1} - {\dt}\nabla^2 u^{n+1} &=  u^n + {\dt} f^{n+1},\quad n=0,1,2,\ldots
\label{ch:diffusion0:pde1:uk}
\end{align}

给定$\uI$，我们可以解决$u^0$，$u^1$，$u^2$等。

(\ref{ch:diffusion0:pde1:uk})的替代方法，可以是
方便实施，是收集
平等标志一方的所有术语:

\begin{equation}
u^{n+1} - {\dt}\nabla^2 u^{n+1} -  u^{n} - {\dt} f^{n+1} = 0,\quad n=0,1,2,\ldots
\label{ch:diffusion0:pde1:uk2}
\end{equation}

我们使用有限元方法来解决
(\ref{ch:diffusion0:pde1:u0})和任一方程式
(\ref{ch:diffusion0:pde1:uk})或(\ref{ch:diffusion0:pde1:uk2})。 这个
需要将方程式变为弱形式。 像往常一样，我们倍增
通过一个测试函数$v\in \hat V$并将二阶导数合并
部分。 在$u^{n+1}$（这是自然的）中引入符号$u$
程序），由此产生的弱势形式
配方(\ref{ch:diffusion0:pde1:uk})
可以方便地写入
标准符号:

\[ a(u,v)=L_{n+1}(v),\]
哪里

\begin{align}
a(u,v) &= \int_\Omega\left(uv + {\dt}
\nabla u\cdot \nabla v\right) \dx, \label{ch:diffusion0:pde1:a}\\
L_{n+1}(v) &= \int_\Omega \left(u^n + {\dt}  f^{n+1}\right)v \dx\tp
\label{ch:diffusion0:pde1:L}
\end{align}
替代形式(\ref{ch:diffusion0:pde1:uk2})有一个
抽象配方

\[ F_{n+1}(u;v) = 0,\]
哪里

\begin{equation}
F_{n+1}(u; v) = \int_\Omega \left(uv + {\dt}
\nabla u\cdot \nabla v -
(u^n + {\dt} f^{n+1})v\right) \dx\tp
\label{ch:diffusion0:pde1:F}
\end{equation}

除了每个时间步长要解决的变化问题外，
我们还需要近似初始条件
(\ref{ch:diffusion0:pde1:u0})。 这个方程也可以变成a
变分问题:

\[ a_0(u,v)=L_0(v),\]
哪里

\begin{align}
a_0(u,v) &= \int_\Omega uv \dx, \label{ch:diffusion0:pde1:a0}\\
L_0(v) &= \int_\Omega \uI v \dx\tp \label{ch:diffusion0:pde1:L0}
\end{align}
当解决这个变分问题时，$u^0$成为$L^2$
将给定的初始值$\uI$投影到有限元中
空间。 另一种方式是通过内插来构造$u^0$
初始值$\uI$; 也就是说，如果$u^0=\sum_{j=1}^N U^0_j\phi_j$，我们
只需设置$U_j=\uI(x_j,y_j)$，其中$(x_j,y_j)$是坐标
节点编号$j$。 我们将这两个策略称为计算
初始条件通过投影或插值。 都
在FEniCS中通过单一语句轻松计算操作，
使用\texttt{project}或\texttt{interpolate}函数。 最常见的
选择是\texttt{project}，它计算一个近似值为$\uI$，但是在
一些我们想通过再现来验证代码的应用程序
确切的解决方案，必须使用\texttt{interpolate}(我们使用这样的测试
这里的问题!)。

\index{interpolate@{\rm\texttt{interpolate}}}
\index{project@{\rm\texttt{project}}}

总之，我们需要解决以下变分序列
计算热方程有限元解的问题:
找到$u^0\in V$，以便$a_0(u^0,v)=L_0(v)$对于所有$v\in\hat V$，
然后找到$u^{n+1}\in V$
使得$a(u^{n+1},v)=L_{n+1}(v)$对于$v\in\hat V$，
或者，对于$v\in\hat V$中的$F_{n+1}(u^{n+1},v)=0$，
$n=0,1,2,\ldots$。

\subsection{FEniCS实现}
\label{ftut:timedep:diffusion1:impl}

我们的程序需要手动实现时间步伐，但可以
依靠FEniCS轻松计算$a_0$，$L_0$，$a$和$L$(或
$F_{n+1}$)，并解决未知数的线性系统。

\paragraph{测试问题1：一个已知的分析解决方案。}
就像前一章的Poisson问题一样，我们
构建一个测试问题，使其容易确定是否
计算正确。 既然我们知道我们的一流
时间步长方案对于线性函数是精确的，我们创建一个测试
时间线性变化的问题。 我们把这与一个
空间二次变化。 我们因此而来

\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
\label{ch:diffusion0:pde1:u0test}
\end{equation}
其产生了在节点处的计算值将是的函数
确切的，不管元素的大小和$\dt$，只要
网格被均匀分割。 插入
(\ref{ch:diffusion0:pde1:u0test})转换为热方程
(\ref{ch:diffusion0:pde1})，我们发现右边的$f$必须
由$f(x,y,t)=\beta - 2 - 2\alpha$给出。 边界值
是$\ub(x,y,t)= 1 + x^2 + \alpha y^2 + \beta t$和初始
值为$\uI(x,y)= 1 + x^2 + \alpha y^2$。

\paragraph{FEniCS实现。}
一个新的编程问题是如何处理不同的功能
空间和时间，如边界条件$\ub(x,y,
t)= 1 + x^2 + \alpha y^2 + \beta t$。 一个自然的解决方案是使用
FEniCS \texttt{Expression}与time $t$作为参数，除了
参数$\alpha$和$\beta$:

\index{time-dependent expression}

\begin{python}
alpha = 3; beta = 1.2
u_D = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                 degree=2, alpha=alpha, beta=beta, t=0)
\end{python}
\texttt{Expression}将\texttt{x}的组件用作独立的
变量，而\texttt{alpha}，\texttt{beta}和\texttt{t}是参数。该
time \texttt{t}可以稍后更新

\begin{python}
u_D.t = t
\end{python}

在这种情况下，沿着整个边界的基本边界条件，
以与我们以前实施的相同的方式实施
泊松问题的边界条件:

\begin{python}
def boundary(x, on_boundary):
    return on_boundary

bc = DirichletBC(V, u_D, boundary)
\end{python}

我们将使用变量\texttt{u}作为新的未知$u^{n+1}$
时间步长和变量\verb!u_n! 对于上一次的$u^n$
步。 \verb!u_n!的初始值可以通过任一投影来计算
或插值$\uI$。 由于我们为边界值设置了\texttt{t = 0}
\verb!u_D!,我们可以使用\verb!u_D! 指定初始条件:

\begin{python}
u_n = project(u_D, V)
# or
u_n = interpolate(u_D, V)
\end{python}

\begin{notice}[投影与内插初始条件]
实际恢复确切的解决方案
(\ref{ch:diffusion0:pde1:u0test})到机器精度，这很重要
通过内插$\uI$来计算离散的初始条件。 这个
确保自由度是准确的（机器精度）
在$t=0$。 投影导致节点处的近似值。
\end{notice}

\index{lhs@{\rm\texttt{lhs}}}
\index{rhs@{\rm\texttt{rhs}}}
\index{projection}
\index{interpolation}

我们可以根据上述公式定义$a$或$L$，或者我们
可能只是定义$F$，并要求FEniCS找出哪些术语应该去
进入双线性形式$a$，并且应该进入线性形式
$L$。 后者是方便的，特别是在更复杂的
问题，所以我们说明了建设$a$和$L$:

\begin{python}
u = TrialFunction(V)
v = TestFunction(V)
f = Constant(beta - 2 - 2*alpha)

F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_n + dt*f)*v*dx
a, L = lhs(F), rhs(F)
\end{python}

最后，我们在循环中执行时间步长:

\begin{python}
u = Function(V)
t = 0
for n in range(num_steps):

    # Update current time
    t += dt
    u_D.t = t

    # Solve variational problem
    solve(a == L, u, bc)

    # Update previous solution
    u_n.assign(u)
\end{python}
在时间步长循环的最后一步，我们分配值
变量\texttt{u}(新计算的解决方案)变量\verb!u_n!
包含上一个时间步长的值。 必须这样做
使用\texttt{assign}成员函数。 如果我们反而尝试做\verb!u_n = u!,
我们将设置\verb!u_n! 变量与\texttt{u}变量相同
这不是我们想要的。 (我们需要两个变量，一个是值
在前一个时间步长，另一个是当前时间的值
步。)

\begin{notice}[记住用当前时间更新表达式对象!]
在时间循环内，观察\verb!u_D.t! 必须在之前更新
\texttt{solve}语句强制执行Dirichlet条件的计算
当前时间步长。 一个Dirichlet条件定义为a
\texttt{Expression}查找并应用参数的值，如\texttt{t}
当它被评估并应用于线性系统时。
\end{notice}

上面的时间步进循环不包含任何比较
数字和确切的解决方案，我们必须包括为了
验证实施。 至于Poisson方程式
部分~\ref{ch:poisson0:impl:dissect}，我们计算差异
在\texttt{u}的节点数组和节点数组之间
内插精确解的值。 这可以做到
如下:

\begin{python}
u_e = interpolate(u_D, V)
error = np.abs(u_e.vector().array() - u.vector().array()).max()
print('t = %.2f: error = %.3g' % (t, error))
\end{python}
对于Poisson示例，我们使用了这个函数
\verb!compute_vertex_values! 提取功能值
顶点。 这里我们举例说明一种提取方法
顶点值，通过调用函数\texttt{vector}返回
自由度向量。 对于$\mathsf{P}_1$
功能空间，这个矢量的自由度将等于
通过调用获得的顶点值数组
\verb!compute_vertex_values!,虽然可能有不同的顺序。

解决热方程的完整程序如下:

\begin{python}
from fenics import *
import numpy as np

T = 2.0            # final time
num_steps = 10     # number of time steps
dt = T / num_steps # time step size
alpha = 3          # parameter alpha
beta = 1.2         # parameter beta

# Create mesh and define function space
nx = ny = 8
mesh = UnitSquareMesh(nx, ny)
V = FunctionSpace(mesh, 'P', 1)

# Define boundary condition
u_D = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                 degree=2, alpha=alpha, beta=beta, t=0)

def boundary(x, on_boundary):
    return on_boundary

bc = DirichletBC(V, u_D, boundary)

# Define initial value
u_n = interpolate(u_D, V)
#u_n = project(u_D, V)

# Define variational problem
u = TrialFunction(V)
v = TestFunction(V)
f = Constant(beta - 2 - 2*alpha)

F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_n + dt*f)*v*dx
a, L = lhs(F), rhs(F)

# Time-stepping
u = Function(V)
t = 0
for n in range(num_steps):

    # Update current time
    t += dt
    u_D.t = t

    # Compute solution
    solve(a == L, u, bc)

    # Plot solution
    plot(u)

    # Compute error at vertices
    u_e = interpolate(u_D, V)
    error = np.abs(u_e.vector().array() - u.vector().array()).max()
    print('t = %.2f: error = %.3g' % (t, error))

    # Update previous solution
    u_n.assign(u)

# Hold plot
interactive()
\end{python}
该示例程序可以在文件中找到
\begin{center}
  \url{https://fenicsproject.org/pub/tutorial/python/vol1/ft03_heat.py}
\end{center}
\begin{center}
  {\nolinkurl{ft03_heat.py}}
\end{center}

\index{ft03\_heat.py@{\rm\texttt{ft03\_heat.py}}}

\paragraph{测试问题2:Gaussian函数的扩散。}
让我们现在解决一个更有趣的测试问题，即扩散
一个Gaussian山。 我们以初始值为准

\[ \uI(x,y)= e^{-ax^2 - ay^2}\]
在$a = 5$的域$[-2,2]\times [2,2]$。 为了这
问题我们将使用均匀的Dirichlet边界条件($\ub = 0$)。

\paragraph{FEniCS实现。}
以前的程序需要修改哪些? 一个专业
更改是域不再是单位平方。 新域名可以
使用\texttt{RectangleMesh}在FEniCS中轻松创建:

\begin{python}
nx = ny = 30
mesh = RectangleMesh(Point(-2, -2), Point(2, 2), nx, ny)
\end{python}
请注意，我们比以前使用了比以前更高的分辨率
解决解决方案的功能。 我们还需要重新定义
初始条件和边界条件。 两者都很容易改变
定义一个新的\texttt{Expression}，并在边界上设置$u = 0$。

能够在外部程序中可视化解决方案，如
ParaView，我们将每次将解决方案保存为VTK格式的文件
步。 我们首先用后缀\texttt{.pvd}创建一个\texttt{File}:

\begin{python}
vtkfile = File('heat_gaussian/solution.pvd')
\end{python}
在时间循环中，我们可能会将解值附加到
这个文件:

\begin{python}
vtkfile << (u, t)
\end{python}
在每个时间步骤中调用此行，从而创建
一个包含后缀\texttt{.vtu}的新文件，其中包含时间步长的所有数据
(网格和顶点值)。 文件
\verb!heat_gaussian/solution.pvd! 将包含时间值和
引用\texttt{.vtu}文件，这意味着\texttt{.pvd}文件将是
单个小文件指向大量\texttt{.vtu}文件
包含实际数据。 请注意，我们选择存储解决方案
到一个名为\verb!heat_gaussian!的子目录。 这是为了避免混乱
我们的源目录与所有生成的数据文件。
在运行之前不需要创建目录
程序将由FEniCS自动创建。

\index{VTK format}
\index{.pvd@{\rm\texttt{.pvd}} file}
\index{.vtu@{\rm\texttt{.vtu}} file}

完整的程序如下所示。

\begin{python}
from fenics import *
import time

T = 2.0            # final time
num_steps = 50     # number of time steps
dt = T / num_steps # time step size

# Create mesh and define function space
nx = ny = 30
mesh = RectangleMesh(Point(-2, -2), Point(2, 2), nx, ny)
V = FunctionSpace(mesh, 'P', 1)

# Define boundary condition
def boundary(x, on_boundary):
    return on_boundary

bc = DirichletBC(V, Constant(0), boundary)

# Define initial value
u_0 = Expression('exp(-a*pow(x[0], 2) - a*pow(x[1], 2))',
                 degree=2, a=5)
u_n = interpolate(u_0, V)

# Define variational problem
u = TrialFunction(V)
v = TestFunction(V)
f = Constant(0)

F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_n + dt*f)*v*dx
a, L = lhs(F), rhs(F)

# Create VTK file for saving solution
vtkfile = File('heat_gaussian/solution.pvd')

# Time-stepping
u = Function(V)
t = 0
for n in range(num_steps):

    # Update current time
    t += dt

    # Compute solution
    solve(a == L, u, bc)

    # Save to file and plot solution
    vtkfile << (u, t)
    plot(u)

    # Update previous solution
    u_n.assign(u)

# Hold plot
interactive()
\end{python}
该示例程序可以在文件中找到
\begin{center}
  \url{https://fenicsproject.org/pub/tutorial/python/vol1/ft04_heat_gaussian.py}
\end{center}
\begin{center}
  {\nolinkurl{ft04_heat_gaussian.py}}
\end{center}

\index{ft04\_heat\_gaussian.py@{\rm\texttt{ft04\_heat\_gaussian.py}}}

\paragraph{ParaView中的可视化。}
为了可视化高斯山的扩散，启动ParaView，
选择\textbf{File--Open...}，打开
\verb!heat_gaussian/solution.pvd!,然后点击
\textbf{Apply}在Properties窗格中。 点击播放按钮进行显示
解决方案的动画。 要将动画保存到文件中，请单击
\textbf{File--Save Animation...}并将文件保存为所需的文件格式，
例如AVI或Ogg/Theora。
动画一旦保存到文件中，就可以播放动画
离线使用播放器，如mplayer或VLC，或上传您的
动画到YouTube。 图~\ref{fig:snapshots}显示了一个序列
的解决方案的快照。

%\begin{figure}[!ht]  % fig:snapshots
%  \centerline{\includegraphics[width=0.95\linewidth]{fig/heat.png}}
%  \caption{
%  A sequence of snapshots of the solution of the Gaussian hill problem created with ParaView. \label{fig:snapshots}
%  }
%\end{figure}

\section{非线性Poisson方程}
\label{ftut1:gallery:nonlinearpoisson}

\index{nonlinear problem}

现在我们将介绍如何解决非线性PDE问题。 我们会看到
非线性问题可以像线性问题那样容易地解决
FEniCS，通过简单地定义非线性变分问题和调用
\texttt{solve}功能。 当这样做时，我们会遇到一个微妙的
变分问题如何定义的差异。

\subsection{PDE问题}

作为解决非线性PDE的模型问题，我们
取以下非线性Poisson方程:

\begin{equation}
-\nabla\cdot\left(q(u)\nabla u\right) = f,
\end{equation}
在$\Omega$中，$u=\ub$在边界$\partial\Omega$上。
系数$q = q(u)$使得方程非线性(除非$q(u)$
在$u$中是不变的)。

\subsection{变化公式}

像往常一样，我们的PDE乘以一个测试函数$v\in\hat V$，
整合域，并整合二阶导数
按部件。 由零件整合产生的边界积分
无论我们使用Dirichlet条件，都会消失。 所结果的
我们的模型问题的变分公式变成:找到$u \in V$
就这样

\begin{equation}
F(u; v) = 0 \quad \forall v \in \hat{V},
\label{ch:poisson0:nonlinear1}
\end{equation}
哪里

\begin{equation}
F(u; v) = \int_\Omega (q(u)\nabla u\cdot \nabla v - fv) \dx,
\label{ch:poisson0:nonlinear2}
\end{equation}
和

\begin{align*}
     V      &= \{v \in H^1(\Omega) : v = \ub \mbox{ on } \partial\Omega\},\\
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}\tp
\end{align*}

离散的问题像往常一样通过限制$V$和$\hat V$出现
到一对离散空间。 像以前一样，我们省略了任何下标
离散空间和离散解。
然后将离散的非线性问题写为:找到$u \in V$

\begin{equation}
  F(u; v) = 0 \quad \forall v \in \hat{V},
\label{ch:poisson0:nonlinear:d}
\end{equation}
与$u = \sum_{j=1}^N U_j \phi_j$。 由于$F$是非线性的
$u$，变量语句产生一个系统
未知数$U_1,\ldots,U_N$中的非线性代数方程。

\subsection{FEniCS实现}
\label{ftut:nonlinear:Newton:auto}

\paragraph{测试问题。}
为了解决测试问题，我们需要选择右边的$f$，
系数$q(u)$和边界值$\ub$。 以前，我们
与制造的解决方案一起工作，可以无需复制
近似误差 这在非线性问题上更为困难，
代数更加繁琐。 但是，我们可以利用SymPy
符号计算，并将这些计算集成到FEniCS中
求解。 这允许我们轻松地尝试不同的
制造解决方案。 SymPy的即将到来的代码需要一些
基本熟悉这个包。 特别是我们会用
SymPy函数\texttt{diff}用于符号区分和\texttt{ccode} for
C/C++代码生成。

我们取$q(u) = 1 + u^2$并定义二维制造
$x$和$y$中的线性解决方案:

\begin{python}
# Warning: from fenics import * will import both `sym` and
# `q` from FEniCS. We therefore import FEniCS first and then
# overwrite these objects.
from fenics import *

def q(u):
    "Return nonlinear coefficient"
    return 1 + u**2

# Use SymPy to compute f from the manufactured solution u
import sympy as sym
x, y = sym.symbols('x[0], x[1]')
u = 1 + x + 2*y
f = - sym.diff(q(u)*sym.diff(u, x), x) - sym.diff(q(u)*sym.diff(u, y), y)
f = sym.simplify(f)
u_code = sym.printing.ccode(u)
f_code = sym.printing.ccode(f)
print('u =', u_code)
print('f =', f_code)
\end{python}

\index{SymPy}
\index{method of manufactured solutions}

\begin{notice}[在\texttt{Expression}对象中根据需要定义符号坐标]
请注意，我们通常会写\texttt{x,y = sym.symbols('x,y')}，但是
如果我们希望生成的表达式具有有效的语法
FEniCS \texttt{Expression}对象，我们必须使用\texttt{x[0]}和\texttt{x[1]}。
通过定义\texttt{x}的名称，\texttt{sympy}可以轻松实现这一点
\texttt{y} as \texttt{x[0]}和\texttt{x[1]}:\texttt{x,y = sym.symbols('x[0], x[1]')}。
\end{notice}

将\texttt{u}和\texttt{f}的表达式转换为C或C ++语法
FEniCS \texttt{Expression}对象需要两个步骤。 首先，我们要求C
表达式的代码:

\begin{python}
u_code = sym.printing.ccode(u)
f_code = sym.printing.ccode(f)
\end{python}
在某些情况下，需要编辑结果以匹配所需的结果
\texttt{Expression}对象的语法，但不是这种情况。 (首要的
例如\verb!M_PI! 对于$\pi$在C/C++中必须由\texttt{pi}替代
\texttt{Expression}对象。)在本例中，\verb!u_code!的输出 和
\verb!f_code!是

\begin{c}
x[0] + 2*x[1] + 1
-10*x[0] - 20*x[1] - 10
\end{c}
定义网格，功能空间和边界后，
我们定义边界值\verb!u_D! 如

\begin{python}
u_D = Expression(u_code, degree=1)
\end{python}
类似地，我们定义右边的函数

\begin{python}
f = Expression(f_code, degree=1)
\end{python}

\begin{notice}[命名FEniCS与程序变量之间的冲突]
在上面的程序中，可能会出现奇怪的错误
名字冲突。 如果在做之前定义\texttt{sym}和\texttt{q}
\texttt{from fenics import *}，后一个语句也会导入
变量名为\texttt{sym}和\texttt{q}，覆盖
你以前定义的对象! 这可能会导致奇怪
错误。 最安全的解决方案是做\texttt{import fenics}而不是
\texttt{from fenics import *}，然后前缀所有FEniCS
\texttt{fenics}的对象名称。 下一个最好的解决办法就是做
\texttt{from fenics import *}首先定义你自己的变量
覆盖从\texttt{fenics}导入的那些。 这是可以接受的
如果我们不需要\texttt{fenics}中的\texttt{sym}和\texttt{q}。
\end{notice}

\paragraph{FEniCS实现。}
非线性Poisson方程的求解器很容易
实现线性Poisson方程的求解器。
我们所需要做的就是说明$F$和调用的公式
\texttt{solve(F == 0,u,bc)}，而不是\texttt{solve(a == L,u,bc)}
在线性情况下。 这是一个简约代码:
