<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Finite Element Programming - The FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,DOLFIN mesh,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,time-dependent PDEs,assembly, increasing efficiency,heterogeneous medium,multi-material domain,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),Gateaux derivative,automatic differentiation,Jacobian, automatic computation,nonlinear variational problems,mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,installing FEniCS,troubleshooting,compilation problems,plotting problems">

<title>Introduction to Finite Element Programming - The FEniCS Tutorial</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Acknowledgments', 3, None, '___sec1'),
              (u'To-do list', 1, None, '___sec2'),
              (u'HPL questions', 2, None, '___sec3'),
              (u'Iterative linear solvers info', 3, None, '___sec4'),
              (u'The fundamentals', 0, None, '___sec5'),
              (u'Mathematical problem formulation', 1, None, '___sec6'),
              (u'The Poisson equation',
               2,
               u'tut:poisson1:bvp',
               u'tut:poisson1:bvp'),
              (u'Variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'A basic Poisson solver',
               1,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'A simple code',
               2,
               u'tut:poisson1:impl:code',
               u'tut:poisson1:impl:code'),
              (u'Running the program',
               2,
               u'tut:poisson1:impl:run',
               u'tut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'tut:poisson1:impl:dissect',
               u'tut:poisson1:impl:dissect'),
              (u'The key import line', 3, None, '___sec13'),
              (u'Generating simple meshes', 3, None, '___sec14'),
              (u'Defining a function space corresponding to a mesh',
               3,
               None,
               '___sec15'),
              (u'Defining test and trial functions', 3, None, '___sec16'),
              (u'Specifying the boundary and boundary conditions',
               3,
               None,
               '___sec17'),
              (u'Specifying the right-hand side function',
               3,
               None,
               '___sec18'),
              (u'Specifying the variational formulation',
               3,
               None,
               '___sec19'),
              (u'Forming and solving the linear system', 3, None, '___sec20'),
              (u'Examining the values of the solution', 3, None, '___sec21'),
              (u'Plotting the solution', 3, None, '___sec22'),
              (u'Refactored implementation',
               2,
               u'tut:poisson1:impl2',
               u'tut:poisson1:impl2'),
              (u'A general solver function', 3, None, '___sec24'),
              (u'Plotting for the test problem', 3, None, '___sec25'),
              (u'Make a module!', 3, None, '___sec26'),
              (u'Verification', 3, None, '___sec27'),
              (u'Exercise 1: Solve a Poisson problem', 2, None, '___sec28'),
              (u'Remarks', 3, None, '___sec29'),
              (u'Useful extensions', 1, None, '___sec30'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec32'),
              (u'Linear algebra backend', 3, None, '___sec33'),
              (u'The `parameters` database', 3, None, '___sec34'),
              (u'An extended solver function', 3, None, '___sec35'),
              (u'Remark regarding unit tests', 3, None, '___sec36'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Generating a hypercube', 3, None, '___sec40'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec43'),
              (u'Modifications of the PDE solver', 3, None, '___sec44'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec45'),
              (u'Creating the linear system explicitly',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Visualization', 1, None, '___sec47'),
              (u'Deflection of a circular membrane',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'The problem', 3, None, '___sec49'),
              (u'Scaling', 3, None, '___sec50'),
              (u'Implementation', 3, None, '___sec51'),
              (u'Quick built-in visualization',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'ParaView', 2, u'tut:paraview', u'tut:paraview'),
              (u'Taking advantage of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec55'),
              (u'Finite difference approximations', 3, None, '___sec56'),
              (u'Surface plot', 3, None, '___sec57'),
              (u'Contour plot', 3, None, '___sec58'),
              (u'Curve plot through the mesh', 3, None, '___sec59'),
              (u'Curve plot of the flux', 3, None, '___sec60'),
              (u'Test problem', 3, None, '___sec61'),
              (u'Postprocessing computations', 1, None, '___sec62'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec64'),
              (u'Error functional', 3, None, '___sec65'),
              (u'Flux Functionals', 3, None, '___sec66'),
              (u'Computing convergence rates',
               2,
               u'tut:poisson1:convrates',
               u'tut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec68'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec69'),
              (u'Test problem', 3, None, '___sec70'),
              (u'Experiments', 3, None, '___sec71'),
              (u'Multiple domain and boundaries', 1, None, '___sec72'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'PDE problem', 3, None, '___sec74'),
              (u'Variational formulation', 3, None, '___sec75'),
              (u'Implementation', 3, None, '___sec76'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec78'),
              (u'Classes for marking Dirichlet boundaries',
               3,
               None,
               '___sec79'),
              (u'Working with subdomains',
               2,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:multi:bc',
               u'tut:poisson:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec82'),
              (u'A general model problem', 3, None, '___sec83'),
              (u'Variational formulation', 3, None, '___sec84'),
              (u'Implementation of boundary conditions', 3, None, '___sec85'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec86'),
              (u'Test problem', 3, None, '___sec87'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec88'),
              (u'Implementation of multiple subdomains', 3, None, '___sec89'),
              (u'Refactoring of a solver function into solver and problem classes',
               2,
               None,
               '___sec90'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec91'),
              (u'Mesh', 3, None, '___sec92'),
              (u'Function space', 3, None, '___sec93'),
              (u'Function', 3, None, '___sec94'),
              (u'Time-dependent and nonlinear problems', 0, None, '___sec95'),
              (u'Time-dependent problems', 1, u'tut:timedep', u'tut:timedep'),
              (u'A diffusion problem and its discretization',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'Implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Avoiding assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'Nonlinear problems',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'Solving the nonlinear variational problem directly',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'tut:possion:nD:nmat',
               u'tut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'tut:possion:nD:nmat:PDE',
               u'tut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'tut:possion:nD:nmat:prepro',
               u'tut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'tut:possion:nD:nmat:solve',
               u'tut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec113'),
              (u'Miscellaneous topics', 1, None, '___sec114'),
              (u'Glossary', 2, None, '___sec115'),
              (u'Overview of objects and functions', 2, None, '___sec116'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Installing FEniCS',
               2,
               u'tut:app:install',
               u'tut:app:install'),
              (u'Books on the finite element method',
               2,
               u'tut:appendix:books',
               u'tut:appendix:books'),
              (u'Books on Python',
               2,
               u'tut:appendix:pybooks',
               u'tut:appendix:pybooks'),
              (u'Troubleshooting', 0, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 1, None, '___sec123'),
              (u'Problems with the Instant cache', 2, None, '___sec124'),
              (u'Syntax errors in expressions', 2, None, '___sec125'),
              (u'Example', 3, None, '___sec126'),
              (u'Problems in the solve step', 2, None, '___sec127'),
              (u'Unable to convert object to a UFL form',
               2,
               None,
               '___sec128'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               2,
               None,
               '___sec129'),
              (u'All programs fail to compile', 2, None, '___sec130'),
              (u'Problems with Expression Objects', 1, None, '___sec131'),
              (u'There seems to be some bug in an Expression object',
               2,
               None,
               '___sec132'),
              (u'Segmentation fault when using an Expression object',
               2,
               None,
               '___sec133'),
              (u'Other Problems', 1, None, '___sec134'),
              (u'Very strange error message involving a `mesh` variable',
               2,
               None,
               '___sec135'),
              (u'The plot disapperas quickly from the screen',
               2,
               None,
               '___sec136'),
              (u'Only parts of the program are executed',
               2,
               None,
               '___sec137'),
              (u'Error in the definition of the boundary',
               2,
               None,
               '___sec138'),
              (u'The solver in a nonlinear problems does not converge',
               2,
               None,
               '___sec139'),
              (u'How To Debug a FEniCS Program?', 1, None, '___sec140'),
              (u'Bibliography', 1, None, '___sec141')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\tp}{\thinspace .}
\newcommand{\dt}{\Delta t}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">Introduction to Finite Element Programming - The FEniCS Tutorial</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;To-do list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec5" style="font-size: 80%;"><b>The fundamentals</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A basic Poisson solver</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple code</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key import line</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining a function space corresponding to a mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the boundary and boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the right-hand side function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Useful extensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec45" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deflection of a circular membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quick built-in visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec58" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domain and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classes for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:poisson:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactoring of a solver function into solver and problem classes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec95" style="font-size: 80%;"><b>Time-dependent and nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Time-dependent problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A diffusion problem and its discretization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:poisson:nonlinear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Nonlinear problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the nonlinear variational problem directly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating more complex domains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A General \( d \)-Dimensional multi-material test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More Examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Miscellaneous topics</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:app:install" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installing FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:appendix:books" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Books on the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:appendix:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Books on Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#tut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Very strange error message involving a <code>mesh</code> variable</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disapperas quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0005"></a>
<!-- !split -->

<h1 id="tut:poisson1:impl">A basic Poisson solver</h1>

<p>
The test problem so far has a general domain \( \Omega \) and general functions
\( u_0 \) and \( f \). For our first implementation we must decide on specific
choices of \( \Omega \), \( u_0 \), and \( f \).
It will be wise to construct a specific problem where we can easily
check that the computed solution is correct. Let us start with
specifying an exact solution \( \uex(x,y) \):

$$
\begin{equation}
\tag{1.12}
\uex(x,y) = 1 +x^2 + 2y^2
\end{equation}
$$

on some 2D domain.  By inserting <a href="#mjx-eqn-1.12">(1.12)</a> in
our Poisson problem, we find that \( \uex(x,y) \) is a solution if

$$ f(x,y) = -6,\quad u_0(x,y)=\uex(x,y)=1 + x^2 + 2y^2,$$

regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,

$$ \Omega = [0,1]\times [0,1] .$$

The reason for specifying the solution <a href="#mjx-eqn-1.12">(1.12)</a> is
that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution (\( u \)) with the exact
solution (\( \uex \)). These quantities should be equal to machine
precision <em>at the nodes</em>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Try to verify your code with exact numerical solutions!</b>
The classical way of testing a program is to compare the numerical
solution with an exact analytical solution of the test problem
and conclude that the program works if the error is &quot;small enough&quot;.
Unfortunately, it is impossible to tell if an error \( 10^{-5} \) on
a \( 20\times 20 \) mesh of P1 elements is just all the numerical
approximation errors in the method or if this error also contains
the effect of a bug in the code. All we usually know about the
numerical error is its <em>asymptotic properties</em>, for instance that
it goes like \( h^2 \) if \( h \) is the size of a cell in the mesh. Then we
can compare the error on meshes with different \( h \) values to see if
the asymptotic behavior is correct. This is a very powerful
verification technique and is explained in detail in the section <a href="._ftut008.html#tut:poisson1:convrates">Computing convergence rates</a>. However, if we have a test problem where
we know that there are no numerical approximation errors, we know that
the analytical solution of the PDE problem should be reproduced to
machine precision by the program. That is why we emphasize this kind
of test problems throughout this tutorial.
Typically, elements of degree \( d \) can reproduce polynomials of
degree \( d+1 \) exactly, so this is the starting point for constructing
a solution without numerical approximation errors. Then we fit the
data in the problem (like \( u_0 \) and \( f \)) to this solution.
</div>


<h2 id="tut:poisson1:impl:code">A simple code</h2>

<p>
A FEniCS program for solving the Poisson equation in 2D with the given
choices of \( u_0 \), \( f \), and \( \Omega \) may look as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Find max error</span>
u0_Function <span style="color: #666666">=</span> interpolate(u0, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The complete code can be found in the file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_plain.py" target="_self"><tt>p2D_plain.py</tt></a> in the
directory <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson" target="_self"><tt>src/poisson</tt></a>.

<h2 id="tut:poisson1:impl:run">Running the program</h2>

<p>
To run the program <code>p2D_plain.py</code>, open a terminal window, move to
the directory containing the program and write

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python p2D_plain.py
</pre></div>
<p>
A plot window pops up showing how the solution \( u \) looks like as a surface.
With the left mouse button you can tilt the figure. Click <code>m</code> to bring
up the underlying mesh. Click <code>p</code> to save to a PNG file <code>dolfin_plot_0.png</code>
and <code>P</code> to save to a PDF file <code>dolfin_plot_1.pdf</code>. To kill the
plot window and terminate the application, click <code>Ctrl+q</code> (hold down
the <code>Ctrl</code> key and press <code>q</code>).
Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the surface and the mesh below.
Since \( u \) is a simple quadratic function,
constructed for testing our solver, the
surface looks quite boring.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig:ex1:u"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Plot of the solution in the first FEniCS example.  <!-- caption label: tut:poisson:2D:fig:ex1:u --> </p></center>
<p><img src="fig/ex1_u.png" align="bottom" width=600></p>
</center>

<h2 id="tut:poisson1:impl:dissect">Dissection of the program</h2>

<p>
We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the <a href="http://docs.python.org/tutorial/" target="_self">official Python tutorial</a> to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  the section <a href="._ftut015.html#tut:appendix:pybooks">Books on Python</a> lists some relevant Python books.

<p>
The listed FEniCS program defines a finite element mesh, the discrete
function spaces \( V \) and \( \hat{V} \) corresponding to this mesh and the
element type, boundary conditions for \( u \) (the function \( u_0 \)),
\( a(u,v) \), and \( L(v) \).  Thereafter, the unknown trial function \( u \) is
computed. Then we can compare the numerical and exact solution
as well as investigate \( u \) visually.

<h3 id="___sec13">The key import line </h3>

<p>
The first line in the program,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
imports the key classes <code>UnitSquareMesh</code>, <code>FunctionSpace</code>, <code>Function</code>,
and so forth, from the DOLFIN library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line. DOLFIN is a software library with efficient and convenient C++
classes for finite element computing, and <code>dolfin</code> is a Python package
providing access to this C++ library from Python programs.  You can
think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <code>from dolfin import *</code> statement
imports other components too, but newcomers to FEniCS programming do
not need to care about this.

<h3 id="___sec14">Generating simple meshes </h3>

<p>
The statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
</pre></div>
<p>
defines a uniform finite element mesh over the unit square
\( [0,1]\times [0,1] \). The mesh consists of <em>cells</em>, which are triangles
with straight sides. The parameters 6 and 4 tell that the square is
first divided into \( 6\times 4 \) rectangles, and then each rectangle is
divided into two triangles. The total number of triangles then becomes
48. The total number of vertices in this mesh is \( 7\cdot 5=35 \).
DOLFIN offers some classes for creating meshes over very simple
geometries. For domains of more complicated shape one needs to use a
separate <em>preprocessor</em> program to create the mesh.  The FEniCS
program will then read the mesh from file.

<h3 id="___sec15">Defining a function space corresponding to a mesh </h3>

<p>
Having a mesh, we can define a discrete function space <code>V</code> over this mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.  The
type of element is here &quot;Lagrange&quot;, implying the standard Lagrange
family of elements.  (Some FEniCS programs use <code>'CG'</code>, for Continuous
Galerkin, as a synonym for <code>'Lagrange'</code>.)  With degree 1, we simply
get the standard linear Lagrange element, which is a triangle with
nodes at the three vertices.  Some finite element practitioners refer
to this element as the &quot;linear triangle&quot; or the P1 element.  The
computed \( u \) will be continuous and linearly varying in \( x \) and \( y \)
over each cell in the mesh.  Higher-degree polynomial approximations
over each cell are trivially obtained by increasing the third
parameter in <code>FunctionSpace</code>, which will then generate P2, P3, and so
forth, type of elements. Changing the second parameter to <code>'DG'</code>
creates a function space for discontinuous Galerkin methods.

<h3 id="___sec16">Defining test and trial functions </h3>

<p>
In mathematics, we distinguish between the trial and test spaces \( V \)
and \( \hat{V} \). The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <code>V</code> for the and trial and test functions in the
program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
</pre></div>

<h3 id="___sec17">Specifying the boundary and boundary conditions </h3>

<p>
The next step is to specify the boundary condition: \( u=u_0 \) on
\( \partial\Omega \). This is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)
</pre></div>
<p>
where <code>u0</code> is an instance holding the \( u_0 \) values, and <code>u0_boundary</code>
is a function (or object) describing whether a point lies on the
boundary where \( u \) is specified.

<p>
Boundary conditions of the type \( u=u_0 \) are known as <em>Dirichlet
conditions</em>, and also as <em>essential boundary conditions</em> in a finite
element context.  Naturally, the name of the DOLFIN class holding the
information about Dirichlet boundary conditions is <code>DirichletBC</code>.

<p>
The <code>u0</code> variable refers to an <code>Expression</code> object, which is used to
represent a mathematical function. The typical construction is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(formula)
</pre></div>
<p>
where <code>formula</code> is a string containing the mathematical expression.
This formula is written with C++ syntax. The expression is
automatically turned into an efficient, compiled C++ function. The
independent variables in the function expression are supposed to be
available as a point vector <code>x</code>, where the first element <code>x[0]</code>
corresponds to the \( x \) coordinate, the second element <code>x[1]</code> to the
\( y \) coordinate, and (in a three-dimensional problem) <code>x[2]</code> to the \( z \)
coordinate. With our choice of \( u_0(x,y)=1 + x^2 + 2y^2 \), the formula
string must be written as <code>1 + x[0]*x[0] + 2*x[1]*x[1]</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remember that string expressions must have valid C++ syntax.</b>
The string argument to an <code>Expression</code> object must obey C++ syntax.
Most Python syntax for mathematical expressions are also valid C++ syntax,
but power expressions make an exception: <code>p**a</code> must be written as
<code>pow(p,a)</code> in C++ (this is also an alternative Python syntax).
The following mathematical functions can be used directly
in C++
expressions when defining <code>Expression</code> objects:
<code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>,
<code>atan</code>, <code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>exp</code>,
<code>frexp</code>, <code>ldexp</code>, <code>log</code>, <code>log10</code>, <code>modf</code>,
<code>pow</code>, <code>sqrt</code>, <code>ceil</code>, <code>fabs</code>, <code>floor</code>, and <code>fmod</code>.
Moreover, the number \( \pi \) is available as the symbol <code>pi</code>.
All the listed functions are taken from the <code>cmath</code> C++ header file, and
one may hence
consult documentation of <code>cmath</code> for more information on the
various functions.

<p>
If tests are possible using the C syntax for inline branching. The
function

$$ f(x,y) = \left\lbrace\begin{array}{ll} x^2, & x, y\geq 0\\ 
2, & \hbox{otherwise}\end{array}\right.$$

is implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] &gt;= 0 &amp;&amp; x[1] &gt;= 0? pow(x[0], 2) : 2&#39;</span>)
</pre></div>
<p>
Parameters in expression strings are allowed, but
must be initialized via keyword
arguments when creating the <code>Expression</code> object. For example, the
function \( f(x)=e^{-\kappa\pi^2t}\sin(\pi k x) \) can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;exp(-kappa*pow(pi,2)*t)*sin(pi*k*x[0])&#39;</span>,
               kappa<span style="color: #666666">=1.0</span>, t<span style="color: #666666">=0</span>, k<span style="color: #666666">=4</span>)
</pre></div>
<p>
At any time, parameters can be updated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f<span style="color: #666666">.</span>t <span style="color: #666666">+=</span> dt
f<span style="color: #666666">.</span>k <span style="color: #666666">=</span> <span style="color: #666666">10</span>
</pre></div>
<p>
</div>


<p>
The information about where to apply the <code>u0</code> function as boundary
condition is coded in a function <code>u0_boundary</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary
</pre></div>
<p>
A function like <code>u0_boundary</code> for marking the boundary must return a
boolean value: <code>True</code> if the given point <code>x</code> lies on the Dirichlet
boundary and <code>False</code> otherwise.  The argument <code>on_boundary</code> is <code>True</code>
if <code>x</code> is on the physical boundary of the mesh, so in the present
case, where we are supposed to return <code>True</code> for all points on the
boundary, we can just return the supplied value of <code>on_boundary</code>.  The
<code>u0_boundary</code> function will be called for every discrete point in the
mesh, which allows us to have boundaries where \( u \) are known also
inside the domain, if desired.

<p>
One can also omit the <code>on_boundary</code> argument, but in that case we need
to test on the value of the coordinates in <code>x</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
</pre></div>
<p>
As for the formula in <code>Expression</code> objects, <code>x</code> in the <code>u0_boundary</code>
function represents a point in space with coordinates <code>x[0]</code>, <code>x[1]</code>,
etc. Comparing floating-point values using an exact match test with
<code>==</code> is not good programming practice, because small round-off errors
in the computations of the <code>x</code> values could make a test <code>x[0] == 1</code>
become false even though <code>x</code> lies on the boundary.  A better test is
to check for equality with a tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol
</pre></div>

<h3 id="___sec18">Specifying the right-hand side function </h3>

<p>
Before defining \( a(u,v) \) and \( L(v) \) we have to specify the \( f \) function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-6&#39;</span>)
</pre></div>
<p>
When \( f \) is constant over the domain, <code>f</code> can be
more efficiently represented as a <code>Constant</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
</pre></div>

<h3 id="___sec19">Specifying the variational formulation </h3>

<p>
Now we have all the objects we need in order to specify this problem's
\( a(u,v) \) and \( L(v) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
</pre></div>
<p>
In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas \( \nabla u\cdot\nabla v \dx \) and \( fv \dx \).  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.  The language used to express weak
forms is called UFL (Unified Form Language) <a href="._ftut017.html#UFL_2014">[2]</a> <a href="._ftut017.html#FEniCS">[1]</a>
and is an integral part of FEniCS.

<p>
Instead of <code>nabla_grad</code> we could also just have written <code>grad</code> in the
examples in this tutorial. However, when taking gradients of vector
fields, <code>grad</code> and <code>nabla_grad</code> differ. The latter is consistent with
the tensor algebra commonly used to derive vector and tensor PDEs,
where \( \nabla \) (&quot;nabla&quot;) acts as a vector operator, and therefore
this author prefers to always use <code>nabla_grad</code>.

<h3 id="___sec20">Forming and solving the linear system </h3>

<p>
Having <code>a</code> and <code>L</code> defined, and information about essential
(Dirichlet) boundary conditions in <code>bc</code>, we can compute the solution,
a finite element function <code>u</code>, by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)
</pre></div>
<p>
Some prefer to replace <code>a</code> and <code>L</code> by an <code>equation</code>
variable, which is accomplished by this equivalent code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">equation <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">==</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
u <span style="color: #666666">=</span> Function(V)
solve(equation, u, bc)
</pre></div>
<p>
Note that we first defined the variable <code>u</code> as a <code>TrialFunction</code> and
used it to represent the unknown in the form <code>a</code>.  Thereafter, we
redefined <code>u</code> to be a <code>Function</code> object representing the solution,
i.e., the computed finite element function \( u \).  This redefinition of
the variable <code>u</code> is possible in Python and often done in FEniCS
applications. The two types of objects that <code>u</code> refers to are equal
from a mathematical point of view, and hence it is natural to use the
same variable name for both objects. In a program, however,
<code>TrialFunction</code> objects must always be used for the unknowns in the
problem specification (the form <code>a</code>), while <code>Function</code> objects must be
used for quantities that are computed (known).

<h3 id="___sec21">Examining the values of the solution </h3>

<p>
The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to &quot;prove&quot; that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed <code>u</code> function to <code>u0</code>.

<p>
A finite element function like \( u \) is expressed as a linear combination
of basis functions \( \phi_j \), spanning the space \( V \):

$$
\begin{equation}
u = \sum_{j=1}^N U_j \phi_j \tag{1.13}\tp
\end{equation}
$$

By writing <code>solve(a == L, u, bc)</code> in the program, a linear system
will be formed from \( a \) and \( L \), and this system is solved for the
\( U_1,\ldots,U_N \) values. The \( U_1,\ldots,U_N \) values are known
as <em>degrees of freedom</em> of \( u \). For Lagrange elements (and many other
element types) \( U_k \) is simply the value of \( u \) at the node
with global number \( k \).
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.

<p>
Having <code>u</code> represented as a <code>Function</code> object, we can either evaluate
<code>u(x)</code> at any point <code>x</code> in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values \( U_j \) directly by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_nodal_values <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
</pre></div>
<p>
The result is a DOLFIN <code>Vector</code> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<code>Vector</code> object to a standard <code>numpy</code> array for further
processing:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_array <span style="color: #666666">=</span> u_nodal_values<span style="color: #666666">.</span>array()
</pre></div>
<p>
With <code>numpy</code> arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: <code>u_array[i]</code>,
where the index <code>i</code> always starts at <code>0</code>. However, <code>i</code> corresponds
to \( u \) at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the mesh, see the section <a href="._ftut006.html#tut:poisson1:verify1">Writing out the discrete solution</a>
for details.

<p>
For now, we want to check that the values in <code>u_array</code> are correct:
they should equal our <code>u0</code> function. The most natural approach is
to interpolate our <code>u0</code> expression onto our space
(i.e., the finite element mesh),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_Function <span style="color: #666666">=</span> interpolate(u0, V)
</pre></div>
<p>
The <code>interpolate</code> function returns a <code>Function</code> object, whose degrees
of freedom values can be obtained by <code>.vector().array()</code>.  Our goal is
to show that the degrees of freedom arrays of <code>u</code> and <code>u0_Function</code>
are equal. One safe of doing this is to compute the maximum error,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How to check that the error vanishes?</b>
With inexact arithmetics, as we always have on a computer,
this maximum error is not zero, but should be a small number.
The machine precision is about \( 10^{-16} \), but in finite element
calculations, rounding errors of this size may accumulate, so
the expected accuracy of <code>max_error</code> smaller. Experiments show
that increasing the number of elements and increasing the degree
of the finite element polynomials increase <code>max_error</code>.
For a mesh with \( 2(20\times 20) \) cubic Lagrange elements (degree 3)
<code>max_error</code> is about \( 2\cdot 10^{-12} \), while for 18 linear elements
the maximum error is about \( 2\cdot 10^{-15} \).
</div>


<h3 id="___sec22">Plotting the solution </h3>

<p>
The simplest way of quickly looking at <code>u</code> is to say

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #408080; font-style: italic"># or</span>
plot(u)
interactive()
</pre></div>
<p>
Clicking on <code>Help</code> in the plot windows brings up a list of commands.
For example, typing <code>m</code> brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click <code>Ctrl+q</code> to kill the plot window and
continue execution beyond the <code>plot(u, interactive=True)</code> command or
<code>interactive()</code>.  Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the
resulting \( u \) function.

<p>
Plotting both the solution and the mesh is accomplished by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u)
plot(mesh)
<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
Type <code>Ctrl+w</code> to kill all plot windows and continue execution.

<p>
It is also possible to dump the computed solution to file, e.g., in the
VTK format:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;poisson.pvd&#39;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
</pre></div>
<p>
The <code>poisson.pvd</code> file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The <code>plot</code> function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.

<h2 id="tut:poisson1:impl2">Refactored implementation</h2>

<p>
Our initial program above is &quot;flat&quot;. That is, it is not organized into
logical, reusable units in terms of Python functions. Such flat programs are
popular for quickly testing out some software, but not well suited for
serious problem solving. We shall therefore at once <em>refactor</em> the program,
meaning that we divide it into functions, but this is just a
reordering of the existing statements. During refactoring, we try
make functions as reusable as possible in other contexts, but
statements specific to a certain problem or task are also encapsulated
in (non-reusable) functions.
Being able to distinguish reusable code from specialized code is a key issue
when refactoring code, and this ability depends on a good mathematical
understanding of the problem at hand (&quot;what is general, what is special?&quot;).
In a flat program, general and specialized code (and mathematics)
is often mixed together.

<h3 id="___sec24">A general solver function </h3>

<p>
Some of the code in the previous flat program are needed to solve any
Poisson problem \( -\nabla^2 u=f \) on \( [0,1]\times [0,1] \) with \( u=u_0 \) on
the boundary. Let us collect this code in a reusable function
<code>solver</code>.  Our special test problem will then just be an application
of <code>solver</code> with some additional statements.
We limit the <code>solver</code> function to just <em>compute the numerical
solution</em>. Plotting and comparing the solution with the exact solution
are considered to be problem-specific activities to be performed elsewhere.

<p>
We parameterize <code>solver</code> by \( f \), \( u_0 \), and the
resolution of the mesh. Since it is so trivial to use higher-order
finite element functions by changing the third argument to
<code>FunctionSpace</code>, we let also the degree of the polynomials in the
finite element basis functions be an argument to <code>solver</code>.

<!-- begin inline comment -->
<font color="red">(<b>hpl 4</b>: The refactoring extends functionality. Should we be strict and keep linear elements? The test is better when it tests the degree parameter as well...)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u0 (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>

<h3 id="___sec25">Plotting for the test problem </h3>

<p>
The additional tasks we did in our initial program can be placed in
other functions. For example, plotting the solution in our particular
test problem is placed in an
<code>application_test</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_test</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solution in the test problem.&quot;&quot;&quot;</span>
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    u <span style="color: #666666">=</span> solver(f, u0, <span style="color: #666666">6</span>, <span style="color: #666666">4</span>, <span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
    plot(u)
</pre></div>

<h3 id="___sec26">Make a module! </h3>

<p>
The refactored code is put in a file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_func.py" target="_self"><tt>p2D_func.py</tt></a>. We should make
sure that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program should appear with a test
<code>if __name__ == '__main__':</code>. This test is true if the file is executed
as a program, but false if the file is imported.
If we want to run this file in the same way as we can
run <code>p2D_func.py</code>, the main program is simply a call to
<code>application_test()</code> followed by a call <code>interactive()</code> to hold the plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    application_test()
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>

<h3 id="___sec27">Verification </h3>

<p>
The remaining part of our first program is to compare the numerical and
the exact solution. Every time we edit the code we must rerun the test
and examine that <code>max_error</code> is sufficiently small so we know that the
code still works. To this end, we shall adopt <em>unit testing</em>, meaning
that we create a mathematical test and corresponding software that
can run all our tests automatically and check that all tests pass.
Python has several tools for unit testing. Two very popular ones are
pytest and nose. These are almost identical and very easy to use.
More classical unit testing with test classes is offered by the built-in
tool <code>unittest</code>, but here we are going to use pytest (or nose) since it demands
shorter and clearer code.

<p>
Mathematically, our unit test is that the finite element solution of
our problem when \( f=-6 \) equals the exact solution \( u=u_0=1+x^2+2y^2 \).
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which depends
to the number of elements and the degrees of the polynomials in the finite
element basis functions. In the section <a href="#tut:poisson1:impl:dissect">Dissection of the program</a> we
reported some experiments with the size of the maximum error. If we want
to test that <code>solver</code> works for meshes up to \( 2(20\times 20) \) elements
and cubic Lagrange elements, \( 10^{-11} \) is
an appropriate tolerance for testing that the maximum error vanishes.

<p>
Only three statements are necessary to carry out the unit test. However,
we shall embed these statements in software that the testing frameworks
pytest and nose can recognize. This means that each unit test
must be placed in a function that

<ul>
 <li> has a name starting with <code>test_</code></li>
 <li> has no arguments</li>
 <li> implements the test as <code>assert success, msg</code></li>
</ul>

Regarding the last point, <code>success</code> is a boolean expression that is <code>False</code>
if the test fails, and in that case the string <code>msg</code> is written to the
screen. When the test fails, <code>assert</code> raises an <code>AssertionError</code> exception
in Python, otherwise the statement runs silently. The <code>msg</code> string is
optional, so <code>assert success</code> is the minimal test. In our case, we
will do <code>assert max_error &lt; tol</code>, where <code>tol</code> is the tolerance (\( 10^{-11} \))
mentioned above.

<p>
A proper <em>test function</em> for implementing this unit test in the pytest
or nose testing frameworks has the following form. Note that we perform
the test for different mesh resolutions and degrees of finite elements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-11</span>  <span style="color: #408080; font-style: italic"># This problem&#39;s precision</span>
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">3</span>,<span style="color: #666666">5</span>), (<span style="color: #666666">5</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">20</span>,<span style="color: #666666">20</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh with P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span>
                  <span style="color: #666666">%</span> (Nx, Ny, degree))
            u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree)
            <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u0</span>
            V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
            u0_Function <span style="color: #666666">=</span> interpolate(u0, V)  <span style="color: #408080; font-style: italic"># exact solution</span>
            <span style="color: #408080; font-style: italic"># Check that dof arrays are equal</span>
            u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
            max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> for 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh and degree=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>\ 
                  (max_error, Nx, Ny, degree)
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
We can at any time run

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; py.test -s -v p2D_func.py
</pre></div>
<p>
and the pytest tool will run all functions <code>test_*()</code> in the file and report
how the tests go.

<p>
We shall make it a habit in this book to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented. We dare to assert that this is the only serious way
do reliable computational science with FEniCS.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Print messages in test functions.</b>
The <code>assert</code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code>assert</code>
(as we do in the example above) such that it is clear that the
test really takes place.
(Note that <code>py.test</code> needs the <code>-s</code> option to show printout
from the test functions.)
</div>


<p>
The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section <a href="._ftut007.html#tut:poisson:membrane">Deflection of a circular membrane</a>.  Information in the intermediate sections
can be studied on demand.

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec28">Exercise 1: Solve a Poisson problem </h2>

<p>
Solve the following problem

$$
\begin{align}
\nabla^2 u &= 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x)),
\quad\hbox{ in }\Omega = [0,1]\times [0,1]
\tag{1.14}\\ 
u &= 0\quad\hbox{ on }\partial\Omega
\tag{1.15}
\end{align}
$$

The exact solution is given by

$$ \uex = 2e^{-2x}\sin(\pi x)\sin(\pi y)\tp$$

Compute the maximum numerical approximation error in a mesh with
\( 2(N_x\times N_y) \) elements and in a mesh with double resolution:
\( 4(N_x\times N_y) \) elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
(This is a good verification that the implementation is correct, but
note that the result requires sufficiently fine mesh - here
one may start with \( N_x=N_y=20 \).)
Make an illustrative plot of the solution too.

<p>
<b>a)</b>
Base your implementation on editing the program
<code>p2D_plain.py</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

<p>
In the string for an <code>Expression</code> object, <code>DOLFIN_PI</code> is the value of
\( \pi \). Also note that \( \pi^2 \) must be expressed with syntax
<code>pow(DOLFIN_PI,2)</code> and not (the common Python syntax) <code>DOLFIN_PI**2</code>.

<p>
FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code>/very/long/path/compile.log</code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>p2D_fsin_plain</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_2">

<p>
Looking at the <code>p2D_plain.py</code> code, we realize that
the following edits are required:

<ul>
 <li> Modify the <code>mesh</code> computation.</li>
 <li> Modify <code>u0</code> and <code>f</code>.</li>
 <li> Add expression for the exact solution.</li>
 <li> Modify the computation of the numerical error.</li>
 <li> Insert a loop to enable solving the problem twice.</li>
 <li> Put the error reduction computation and the plot statements after the loop.</li>
</ul>

Here is the modified code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">20</span>
error <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
    Nx <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)
    Ny <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

    <span style="color: #408080; font-style: italic"># Define boundary conditions</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>)
    <span style="color: #408080; font-style: italic"># Note: no need for pi=DOLFIN_PI in f, pi is valid variable</span>
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span>)

    u_e_Function <span style="color: #666666">=</span> interpolate(u_e, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
    u_e_array <span style="color: #666666">=</span> u_e_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
    max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
    error<span style="color: #666666">.</span>append(max_error)

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Error reduction:&#39;</span>, error[<span style="color: #666666">1</span>]<span style="color: #666666">/</span>error[<span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The number \( \pi \) has the symbol <code>M_PI</code> in C and C++, but in C++
strings in <code>Expression</code> objects, the symbol <code>pi</code> can be used directly
(or one can use the less readable <code>DOLFIN_PI</code>).

<p>
<center><p><img src="fig/p2D_fsin.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Base your implementation on a new file that imports functionality
from the module <code>p2D_func.py</code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code>p2D_fsin_func</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_3">

<p>
Solving the two problems is a matter of calling <code>solver</code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code>test_solver</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">p2D_func</span> <span style="color: #008000; font-weight: bold">import</span> (
    solver, Expression, Constant, interpolate, File, plot,
    interactive)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span>)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> u0, f, u_e

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">20</span>
    Ny <span style="color: #666666">=</span> Nx
    error <span style="color: #666666">=</span> []
    <span style="color: #408080; font-style: italic"># Loop over refined meshes</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
        Nx <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        Ny <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
        u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>)
        <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u_e</span>
        V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
        u_e_array <span style="color: #666666">=</span> interpolate(u_e, V)<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># Linf norm</span>
        error<span style="color: #666666">.</span>append(max_error)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(error)):
        error_reduction <span style="color: #666666">=</span> error[i]<span style="color: #666666">/</span>error[i<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error reduction:&#39;</span>, error_reduction)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(error_reduction <span style="color: #666666">-</span> <span style="color: #666666">0.25</span>) <span style="color: #666666">&lt;</span> <span style="color: #666666">0.1</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">40</span>
    Ny <span style="color: #666666">=</span> Nx
    u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, <span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
    plot(u)

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    test_solver()
    application()
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>
<p>
The unit test is embedded in a proper test function <code>test_solver</code>
for the pytest or
nose testing frameworks. Visualization of the solution is encapsulated
in the <code>application</code> function. Since we need <code>u_e</code>, <code>u0</code>, and <code>f</code>
in two functions, we place the definitions in a function <code>data</code> to
avoid copies of these expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec29">Remarks </h3>

<p>
This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code>solver</code> function, requires <em>no modifications</em>
of the <code>p2D_func.py</code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code>p2D_func.py</code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut004.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="._ftut001.html">2</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li class="active"><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li><a href="._ftut009.html">10</a></li>
  <li><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut017.html">18</a></li>
  <li><a href="._ftut006.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

