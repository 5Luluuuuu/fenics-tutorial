<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,time-dependent PDEs,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),visualization,plotting,VTK,rotate PDF plots,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,assembly, increasing efficiency,heterogeneous medium,multi-material domain,nonlinear variational problems,Gateaux derivative,automatic differentiation,Jacobian, automatic computation,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,troubleshooting,compilation problems,plotting problems">

<title>Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'tut:pybooks', u'tut:pybooks'),
              (u'The finite element method',
               2,
               u'tut:fembooks',
               u'tut:fembooks'),
              (u'The fundamentals',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'The Laplace/Poisson equation', 1, None, '___sec14'),
              (u'Mathematical problem formulation', 2, None, '___sec15'),
              (u'Variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'A simple implementation',
               2,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'Test problem', 3, None, '___sec18'),
              (u'The program',
               3,
               u'tut:poisson1:impl:code',
               u'tut:poisson1:impl:code'),
              (u'Running the program',
               2,
               u'tut:poisson1:impl:run',
               u'tut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'tut:poisson1:impl:dissect',
               u'tut:poisson1:impl:dissect'),
              (u'The key import line', 3, None, '___sec22'),
              (u'Generating simple meshes', 3, None, '___sec23'),
              (u'Defining a function space corresponding to a mesh',
               3,
               None,
               '___sec24'),
              (u'Defining test and trial functions', 3, None, '___sec25'),
              (u'Specifying the boundary and boundary conditions',
               3,
               None,
               '___sec26'),
              (u'Specifying the right-hand side function',
               3,
               None,
               '___sec27'),
              (u'Specifying the variational formulation',
               3,
               None,
               '___sec28'),
              (u'Forming and solving the linear system', 3, None, '___sec29'),
              (u'Examining the values of the solution', 3, None, '___sec30'),
              (u'Plotting the solution', 3, None, '___sec31'),
              (u'Deflection of a membrane',
               2,
               u'ftut:poisson:membrane',
               u'ftut:poisson:membrane'),
              (u'Generating the mesh', 3, None, '___sec33'),
              (u'The expression for the load', 3, None, '___sec34'),
              (u'Variational form', 3, None, '___sec35'),
              (u'Visualization', 3, None, '___sec36'),
              (u'The time-dependent diffusion equation',
               1,
               u'tut:timedep',
               u'tut:timedep'),
              (u'Variational formulation',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'A simple implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec40'),
              (u'The code', 3, None, '___sec41'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec42'),
              (u'A nonlinear Poisson equation', 1, None, '___sec43'),
              (u'Variational formulation', 2, None, '___sec44'),
              (u'A simple implementation',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Overview', 3, None, '___sec46'),
              (u'Constructing a test problem with SymPy',
               3,
               None,
               '___sec47'),
              (u'The equations of linear elasticity',
               1,
               u'tut:elast',
               u'tut:elast'),
              (u'Variational formulation',
               2,
               u'tut:elast:varform',
               u'tut:elast:varform'),
              (u'A simple implementation', 2, None, '___sec50'),
              (u'The equations of hyperelasticity?', 1, None, '___sec51'),
              (u'Variational formulation', 2, None, '___sec52'),
              (u'A simple implementation', 2, None, '___sec53'),
              (u'The Navier-Stokes equations', 1, None, '___sec54'),
              (u'Variational formulation', 2, None, '___sec55'),
              (u'A simple implementation', 2, None, '___sec56'),
              (u'The Poisson solver revisited',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'tut:poisson1:impl2',
               u'tut:poisson1:impl2'),
              (u'A general solver function', 2, None, '___sec59'),
              (u'Plotting for the test problem', 3, None, '___sec60'),
              (u'Make a module!', 3, None, '___sec61'),
              (u'Verification and unit tests', 2, None, '___sec62'),
              (u'Exercise 1: Solve a Poisson problem', 2, None, '___sec63'),
              (u'Remarks', 3, None, '___sec64'),
              (u'Useful extensions', 1, None, '___sec65'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec67'),
              (u'Linear algebra backend', 3, None, '___sec68'),
              (u'The `parameters` database', 3, None, '___sec69'),
              (u'An extended solver function', 3, None, '___sec70'),
              (u'Remark regarding unit tests', 3, None, '___sec71'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Generating a hypercube', 3, None, '___sec75'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec78'),
              (u'Modifications of the PDE solver', 3, None, '___sec79'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec80'),
              (u'Creating the linear system explicitly',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Visualization', 1, None, '___sec82'),
              (u'Deflection of a circular membrane',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'The problem', 3, None, '___sec84'),
              (u'Scaling', 3, None, '___sec85'),
              (u'Implementation', 3, None, '___sec86'),
              (u'Test problem', 3, None, '___sec87'),
              (u'Visualization in FEniCS',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'Visualization in ParaView',
               2,
               u'tut:paraview',
               u'tut:paraview'),
              (u'Exercise 2: Visualize a solution in a cube',
               2,
               None,
               '___sec90'),
              (u'Taking advantage of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec92'),
              (u'Finite difference approximations', 3, None, '___sec93'),
              (u'Surface plot', 3, None, '___sec94'),
              (u'Contour plot', 3, None, '___sec95'),
              (u'Curve plot through the mesh', 3, None, '___sec96'),
              (u'Curve plot of the flux', 3, None, '___sec97'),
              (u'Test problem', 3, None, '___sec98'),
              (u'Postprocessing computations', 1, None, '___sec99'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec101'),
              (u'Error functional', 3, None, '___sec102'),
              (u'Flux Functionals', 3, None, '___sec103'),
              (u'Computing convergence rates',
               2,
               u'tut:poisson1:convrates',
               u'tut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec105'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec106'),
              (u'Test problem', 3, None, '___sec107'),
              (u'Experiments', 3, None, '___sec108'),
              (u'Multiple domains and boundaries', 1, None, '___sec109'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'PDE problem', 3, None, '___sec111'),
              (u'Variational formulation', 3, None, '___sec112'),
              (u'Implementation', 3, None, '___sec113'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec115'),
              (u'Working with subdomains',
               2,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec117'),
              (u'Mesh functions', 3, None, '___sec118'),
              (u'C++ strings for subdomain definitions',
               3,
               None,
               '___sec119'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ftut:poisson:exer:eff:expression',
               u'ftut:poisson:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:multi:bc',
               u'tut:poisson:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec122'),
              (u'A general model problem', 3, None, '___sec123'),
              (u'Variational formulation', 3, None, '___sec124'),
              (u'Implementation of boundary conditions',
               3,
               None,
               '___sec125'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec126'),
              (u'Test problem', 3, None, '___sec127'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec128'),
              (u'Implementation of multiple subdomains',
               3,
               None,
               '___sec129'),
              (u'Refactoring of a solver function into solver and problem classes',
               2,
               None,
               '___sec130'),
              (u'The diffusion solver revisited',
               0,
               u'ch:diffusion',
               u'ch:diffusion'),
              (u'Optimization of algorithms and implementations',
               1,
               None,
               '___sec132'),
              (u'Avoiding some assembly', 2, None, '___sec133'),
              (u'Avoiding all assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'Deriving recursive linear systems', 3, None, '___sec135'),
              (u'Implementation', 3, None, '___sec136'),
              (u'Refactored implementation', 1, None, '___sec137'),
              (u'A class-based solver for a general diffusion problem',
               2,
               None,
               '___sec138'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'The nonlinear Poisson solver revisited',
               0,
               u'tut:nonlinear',
               u'tut:nonlinear'),
              (u'Test problem', 3, None, '___sec141'),
              (u'The built-in automated Newton solver',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Computing the Jacobian', 2, None, '___sec143'),
              (u'Setting solver parameters', 2, None, '___sec144'),
              (u'Implementation', 2, None, '___sec145'),
              (u'Manual implementation of solution algorithms',
               1,
               None,
               '___sec146'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'More old stuff', 0, None, '___sec150'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'Coordinate stretching', 3, None, '___sec154'),
              (u'Rectangle to hollow circle mapping', 3, None, '___sec155'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'tut:possion:nD:nmat',
               u'tut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'tut:possion:nD:nmat:PDE',
               u'tut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'tut:possion:nD:nmat:prepro',
               u'tut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'tut:possion:nD:nmat:solve',
               u'tut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec160'),
              (u'Miscellaneous topics', 1, None, '___sec161'),
              (u'Glossary', 2, None, '___sec162'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec163'),
              (u'Mesh', 3, None, '___sec164'),
              (u'Function space', 3, None, '___sec165'),
              (u'Function', 3, None, '___sec166'),
              (u'Overview of objects and functions', 2, None, '___sec167'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Troubleshooting', 0, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 1, None, '___sec171'),
              (u'Problems with the Instant cache', 2, None, '___sec172'),
              (u'Syntax errors in expressions', 2, None, '___sec173'),
              (u'Example', 3, None, '___sec174'),
              (u'Problems in the solve step', 2, None, '___sec175'),
              (u'Unable to convert object to a UFL form',
               2,
               None,
               '___sec176'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               2,
               None,
               '___sec177'),
              (u'All programs fail to compile', 2, None, '___sec178'),
              (u'Problems with Expression Objects', 1, None, '___sec179'),
              (u'There seems to be some bug in an Expression object',
               2,
               None,
               '___sec180'),
              (u'Segmentation fault when using an Expression object',
               2,
               None,
               '___sec181'),
              (u'Other Problems', 1, None, '___sec182'),
              (u'Very strange error message involving a `mesh` variable',
               2,
               None,
               '___sec183'),
              (u'The plot disappears quickly from the screen',
               2,
               None,
               '___sec184'),
              (u'Only parts of the program are executed',
               2,
               None,
               '___sec185'),
              (u'Error in the definition of the boundary',
               2,
               None,
               '___sec186'),
              (u'The solver in a nonlinear problems does not converge',
               2,
               None,
               '___sec187'),
              (u'How To Debug a FEniCS Program?', 1, None, '___sec188'),
              (u'To-do list', 1, None, '___sec189'),
              (u'AL list', 2, None, '___sec190'),
              (u'HPL list', 2, None, '___sec191'),
              (u'HPL questions', 2, None, '___sec192'),
              (u'Iterative linear solvers info', 3, None, '___sec193'),
              (u'Bibliography', 1, None, '___sec194')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#tut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#tut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:fundamentals" style="font-size: 80%;"><b>The fundamentals</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Laplace/Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The program</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key import line</a></li>
     <!-- navigation toc: --> <li><a href="#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining a function space corresponding to a mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the boundary and boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the right-hand side function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating the mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The expression for the load</a></li>
     <!-- navigation toc: --> <li><a href="#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="#tut:timedep" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The time-dependent diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview</a></li>
     <!-- navigation toc: --> <li><a href="#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing a test problem with SymPy</a></li>
     <!-- navigation toc: --> <li><a href="#tut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="#tut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of hyperelasticity?</a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier-Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson" style="font-size: 80%;"><b>The Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Useful extensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deflection of a circular membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#ftut:poisson:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:poisson:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactoring of a solver function into solver and problem classes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion" style="font-size: 80%;"><b>The diffusion solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of algorithms and implementations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding some assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding all assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving recursive linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A class-based solver for a general diffusion problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:nonlinear" style="font-size: 80%;"><b>The nonlinear Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:poisson:nonlinear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The built-in automated Newton solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Manual implementation of solution algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec150" style="font-size: 80%;"><b>More old stuff</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating more complex domains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinate stretching</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle to hollow circle mapping</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:possion:nD:nmat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A General \( d \)-Dimensional multi-material test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More Examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec161" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Miscellaneous topics</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec163" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec165" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec166" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec167" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#tut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#tut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#tut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec172" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec176" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec177" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec180" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec182" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec183" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Very strange error message involving a <code>mesh</code> variable</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec184" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disappears quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec185" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec186" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec187" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec189" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;To-do list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec190" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec191" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0005"></a>
<!-- !split -->

<h2 id="tut:poisson1:impl">A simple implementation</h2>

<h3 id="___sec18">Test problem </h3>

<p>
The PDE problem has so far featured a general domain \( \Omega \) and
general functions \( u_0 \) and \( f \). For our first implementation we must
decide on specific choices of \( \Omega \), \( u_0 \), and \( f \).  It will be
wise to construct a specific problem where we can easily check that
the computed solution is correct. Solutions that are lower-order polynomials
are primary candidates. Lagrange elements of degree \( d \) will exactly
reproduce polynomials of degree \( d \). And even P1 elements are able to
exactly reproduce a quadratic polynomial on a uniformly partitioned mesh.
This
important result can be used to very our implementation. We just
manufacture some quadratic function in 2D as the exact solution, say

$$
\begin{equation}
\tag{2.12}
\uex(x,y) = 1 +x^2 + 2y^2\tp
\end{equation}
$$

By inserting <a href="#mjx-eqn-2.12">(2.12)</a> in
our Poisson problem, we find that \( \uex(x,y) \) is a solution if

$$ f(x,y) = -6,\quad u_0(x,y)=\uex(x,y)=1 + x^2 + 2y^2,$$

regardless of the shape of the domain as long as \( \uex \) is prescribed along
the boundary. We choose here, for simplicity,
the domain to be the unit square,

$$ \Omega = [0,1]\times [0,1] \tp$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Try to verify your code with exact numerical solutions!</b>
The classical way of testing a program is to compare the numerical
solution with an exact analytical solution of the test problem
and conclude that the program works if the error is &quot;small enough&quot;.
Unfortunately, it is impossible to tell if an error \( 10^{-5} \) on
a \( 20\times 20 \) mesh of P1 elements is just all the numerical
approximation errors in the method or if this error also contains
the effect of a bug in the code. All we usually know about the
numerical error is its <em>asymptotic properties</em>, for instance that
it goes like \( h^2 \) if \( h \) is the size of a cell in the mesh. Then we
can compare the error on meshes with different \( h \) values to see if
the asymptotic behavior is correct. This is a very powerful
verification technique and is explained in detail in the section <a href="._ftut009.html#tut:poisson1:convrates">Computing convergence rates</a>. However, if we have a test problem where
we know that there are no numerical approximation errors, we know that
the analytical solution of the PDE problem should be reproduced to
machine precision by the program. That is why we emphasize this kind
of test problems throughout this tutorial.
Typically, elements of degree \( d \) can reproduce polynomials of
degree \( d+1 \) exactly, so this is the starting point for constructing
a solution without numerical approximation errors. Then we fit the
data in the problem (like \( u_0 \) and \( f \)) to this solution.
</div>


<h3 id="tut:poisson1:impl:code">The program</h3>

<p>
A FEniCS program for solving the Poisson equation in 2D with the given
choices of \( u_0 \), \( f \), and \( \Omega \) may look as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Find max error</span>
u0_Function <span style="color: #666666">=</span> interpolate(u0, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The complete code can be found in the file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/ft01_p2D_flat.py" target="_self"><tt>ft01_p2D_flat.py</tt></a>.

<h2 id="tut:poisson1:impl:run">Running the program</h2>

<p>
The Python program must be available in a plain text file, written with a
plain text editor such as Atom, Sublime Text, Emacs, Vim, or similar.

<p>
To run the program <code>ft01_p2D_flat.py</code>, open a terminal window, move to
the directory containing the program and write

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python ft01_p2D_flat.py
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: Say something about this not working in Docker? Many will have Docker, and this is the first example...)</font>
<!-- end inline comment -->

A plot window pops up showing how the solution \( u \) looks like as a
surface.  With the left mouse button you can tilt the figure. Click
<code>m</code> to bring up the underlying mesh. Click <code>p</code> to save to a PNG file
<code>dolfin_plot_0.png</code> and <code>P</code> to save to a PDF file
<code>dolfin_plot_1.pdf</code>. To kill the plot window and terminate the
application, click <code>Ctrl+q</code> (hold down the <code>Ctrl</code> key and press <code>q</code>).
Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the surface and the mesh
below.  Since \( u \) is a simple quadratic function, constructed for
testing our solver, the surface looks quite boring.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig:ex1:u"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Plot of the solution in the first FEniCS example.  <!-- caption label: tut:poisson:2D:fig:ex1:u --> </p></center>
<p><img src="fig/ex1_u.png" align="bottom" width=600></p>
</center>

<h2 id="tut:poisson1:impl:dissect">Dissection of the program</h2>

<p>
We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the <a href="http://docs.python.org/tutorial/" target="_self">official Python tutorial</a> to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  the section <a href="._ftut002.html#tut:pybooks">Programming in Python</a> lists some relevant Python books.

<p>
The listed FEniCS program defines a finite element mesh, the discrete
function spaces \( V \) and \( \hat{V} \) corresponding to this mesh and the
element type, boundary conditions for \( u \) (the function \( u_0 \)),
\( a(u,v) \), and \( L(v) \).  Thereafter, the unknown trial function \( u \) is
computed. Then we can compare the numerical and exact solution
as well as investigate \( u \) visually.

<h3 id="___sec22">The key import line </h3>

<p>
The first line in the program,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
imports the key classes <code>UnitSquareMesh</code>, <code>FunctionSpace</code>, <code>Function</code>,
and so forth, from the FEniCS library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 4</b>: The following paragraph was natural when we did <code>from dolfin import *</code>, but is not longer relevant to explain that syntax. However, it should be somewhere: we should in the tutorial explain the various components of FEniCS since they appear so frequently in all the official demo programs.)</font>
<!-- end inline comment -->

<p>
DOLFIN is a software library with efficient and convenient C++
classes for finite element computing, and <code>dolfin</code> is a Python package
providing access to this C++ library from Python programs.  You can
think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <code>from fenics import *</code> statement
imports other components too, but newcomers to FEniCS programming do
not need to care about this.

<h3 id="___sec23">Generating simple meshes </h3>

<p>
The statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
</pre></div>
<p>
defines a uniform finite element mesh over the unit square
\( [0,1]\times [0,1] \). The mesh consists of <em>cells</em>, which are triangles
with straight sides. The parameters 6 and 4 tell that the square is
first divided into \( 6\times 4 \) rectangles, and then each rectangle is
divided into two triangles. The total number of triangles then becomes
48. The total number of vertices in this mesh is \( 7\cdot 5=35 \).
FEniCS offers some classes for creating meshes over very simple
geometries. For domains of more complicated shape one needs to use a
separate <em>preprocessor</em> program to create the mesh.  The FEniCS
program will then read the mesh from file.

<h3 id="___sec24">Defining a function space corresponding to a mesh </h3>

<p>
Having a mesh, we can define a discrete function space <code>V</code> over this mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.  The
type of element is here &quot;Lagrange&quot;, implying the standard Lagrange
family of elements.  (Some FEniCS programs use <code>'CG'</code>, for Continuous
Galerkin, as a synonym for <code>'Lagrange'</code>.)  With degree 1, we simply
get the standard linear Lagrange element, which is a triangle with
nodes at the three vertices.  Some finite element practitioners refer
to this element as the &quot;linear triangle&quot; or the P1 element.  The
computed \( u \) will be continuous and linearly varying in \( x \) and \( y \)
over each cell in the mesh.  Higher-degree polynomial approximations
over each cell are trivially obtained by increasing the third
parameter in <code>FunctionSpace</code>, which will then generate P2, P3, and so
forth, type of elements. Changing the second parameter to <code>'DG'</code>
creates a function space for discontinuous Galerkin methods.

<h3 id="___sec25">Defining test and trial functions </h3>

<p>
In mathematics, we distinguish between the trial and test spaces \( V \)
and \( \hat{V} \). The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <code>V</code> for the and trial and test functions in the
program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
</pre></div>

<h3 id="___sec26">Specifying the boundary and boundary conditions </h3>

<p>
The next step is to specify the boundary condition: \( u=u_0 \) on
\( \partial\Omega \). This is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)
</pre></div>
<p>
where <code>u0</code> is an instance holding the \( u_0 \) values, and <code>u0_boundary</code>
is a function (or object) describing whether a point lies on the
boundary where \( u \) is specified.

<p>
Boundary conditions of the type \( u=u_0 \) are known as <em>Dirichlet
conditions</em>, and also as <em>essential boundary conditions</em> in a finite
element context.  Naturally, the name of the class holding the
information about Dirichlet boundary conditions is <code>DirichletBC</code>.

<p>
The <code>u0</code> variable refers to an <code>Expression</code> object, which is used to
represent a mathematical function. The typical construction is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(formula)
</pre></div>
<p>
where <code>formula</code> is a string containing the mathematical expression.
This formula is written with C++ syntax. The expression is
automatically turned into an efficient, compiled C++ function. The
independent variables in the function expression are supposed to be
available as a point vector <code>x</code>, where the first element <code>x[0]</code>
corresponds to the \( x \) coordinate, the second element <code>x[1]</code> to the
\( y \) coordinate, and (in a three-dimensional problem) <code>x[2]</code> to the \( z \)
coordinate. With our choice of \( u_0(x,y)=1 + x^2 + 2y^2 \), the formula
string must be written as <code>1 + x[0]*x[0] + 2*x[1]*x[1]</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>String expressions must have valid C++ syntax!</b>
The string argument to an <code>Expression</code> object must obey C++ syntax.
Most Python syntax for mathematical expressions are also valid C++ syntax,
but power expressions make an exception: <code>p**a</code> must be written as
<code>pow(p,a)</code> in C++ (this is also an alternative Python syntax).
The following mathematical functions can be used directly
in C++
expressions when defining <code>Expression</code> objects:
<code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>,
<code>atan</code>, <code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>exp</code>,
<code>frexp</code>, <code>ldexp</code>, <code>log</code>, <code>log10</code>, <code>modf</code>,
<code>pow</code>, <code>sqrt</code>, <code>ceil</code>, <code>fabs</code>, <code>floor</code>, and <code>fmod</code>.
Moreover, the number \( \pi \) is available as the symbol <code>pi</code>.
All the listed functions are taken from the <code>cmath</code> C++ header file, and
one may hence
consult documentation of <code>cmath</code> for more information on the
various functions.

<p>
If tests are possible using the C syntax for inline branching. The
function

$$ f(x,y) = \left\lbrace\begin{array}{ll} x^2, & x, y\geq 0\\ 
2, & \hbox{otherwise}\end{array}\right.$$

is implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] &gt;= 0 &amp;&amp; x[1] &gt;= 0? pow(x[0], 2) : 2&#39;</span>)
</pre></div>
<p>
Parameters in expression strings are allowed, but
must be initialized via keyword
arguments when creating the <code>Expression</code> object. For example, the
function \( f(x)=e^{-\kappa\pi^2t}\sin(\pi k x) \) can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;exp(-kappa*pow(pi,2)*t)*sin(pi*k*x[0])&#39;</span>,
               kappa<span style="color: #666666">=1.0</span>, t<span style="color: #666666">=0</span>, k<span style="color: #666666">=4</span>)
</pre></div>
<p>
At any time, parameters can be updated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">f<span style="color: #666666">.</span>t <span style="color: #666666">+=</span> dt
f<span style="color: #666666">.</span>k <span style="color: #666666">=</span> <span style="color: #666666">10</span>
</pre></div>
<p>
</div>


<p>
The information about where to apply the <code>u0</code> function as boundary
condition is coded in a function <code>u0_boundary</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary
</pre></div>
<p>
A function like <code>u0_boundary</code> for marking the boundary must return a
boolean value: <code>True</code> if the given point <code>x</code> lies on the Dirichlet
boundary and <code>False</code> otherwise.  The argument <code>on_boundary</code> is <code>True</code>
if <code>x</code> is on the physical boundary of the mesh, so in the present
case, where we are supposed to return <code>True</code> for all points on the
boundary, we can just return the supplied value of <code>on_boundary</code>.  The
<code>u0_boundary</code> function will be called for every discrete point in the
mesh, which allows us to have boundaries where \( u \) are known also
inside the domain, if desired.

<p>
One can also omit the <code>on_boundary</code> argument, but in that case we need
to test on the value of the coordinates in <code>x</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
</pre></div>
<p>
As for the formula in <code>Expression</code> objects, <code>x</code> in the <code>u0_boundary</code>
function represents a point in space with coordinates <code>x[0]</code>, <code>x[1]</code>,
etc. Comparing floating-point values using an exact match test with
<code>==</code> is not good programming practice, because small round-off errors
in the computations of the <code>x</code> values could make a test <code>x[0] == 1</code>
become false even though <code>x</code> lies on the boundary.  A better test is
to check for equality with a tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol
</pre></div>

<h3 id="___sec27">Specifying the right-hand side function </h3>

<p>
Before defining \( a(u,v) \) and \( L(v) \) we have to specify the \( f \) function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-6&#39;</span>)
</pre></div>
<p>
When \( f \) is constant over the domain, <code>f</code> can be
more efficiently represented as a <code>Constant</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
</pre></div>

<h3 id="___sec28">Specifying the variational formulation </h3>

<p>
Now we have all the objects we need in order to specify this problem's
\( a(u,v) \) and \( L(v) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
</pre></div>
<p>
In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas \( \nabla u\cdot\nabla v \dx \) and \( fv \dx \).  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.  The language used to express weak
forms is called UFL (Unified Form Language) <a href="._ftut019.html#UFL_2014">[20]</a> <a href="._ftut019.html#FEniCS">[1]</a>
and is an integral part of FEniCS.

<p>
Instead of <code>grad</code> we could also just have written <code>grad</code> in the
examples in this tutorial. However, when taking gradients of vector
fields, <code>grad</code> and <code>grad</code> differ. The latter is consistent with
the tensor algebra commonly used to derive vector and tensor PDEs,
where \( \nabla \) (&quot;nabla&quot;) acts as a vector operator, and therefore
this author prefers to always use <code>grad</code>.

<h3 id="___sec29">Forming and solving the linear system </h3>

<p>
Having <code>a</code> and <code>L</code> defined, and information about essential
(Dirichlet) boundary conditions in <code>bc</code>, we can compute the solution,
a finite element function <code>u</code>, by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)
</pre></div>
<p>
Some prefer to replace <code>a</code> and <code>L</code> by an <code>equation</code>
variable, which is accomplished by this equivalent code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">equation <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">==</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
u <span style="color: #666666">=</span> Function(V)
solve(equation, u, bc)
</pre></div>
<p>
Note that we first defined the variable <code>u</code> as a <code>TrialFunction</code> and
used it to represent the unknown in the form <code>a</code>.  Thereafter, we
redefined <code>u</code> to be a <code>Function</code> object representing the solution,
i.e., the computed finite element function \( u \).  This redefinition of
the variable <code>u</code> is possible in Python and often done in FEniCS
applications. The two types of objects that <code>u</code> refers to are equal
from a mathematical point of view, and hence it is natural to use the
same variable name for both objects. In a program, however,
<code>TrialFunction</code> objects must always be used for the unknowns in the
problem specification (the form <code>a</code>), while <code>Function</code> objects must be
used for quantities that are computed (known).

<h3 id="___sec30">Examining the values of the solution </h3>

<p>
The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to &quot;prove&quot; that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed <code>u</code> function to <code>u0</code>.

<p>
A finite element function like \( u \) is expressed as a linear combination
of basis functions \( \phi_j \), spanning the space \( V \):

$$
\begin{equation}
u = \sum_{j=1}^N U_j \phi_j \tag{2.13}\tp
\end{equation}
$$

By writing <code>solve(a == L, u, bc)</code> in the program, a linear system
will be formed from \( a \) and \( L \), and this system is solved for the
\( U_1,\ldots,U_N \) values. The \( U_1,\ldots,U_N \) values are known
as <em>degrees of freedom</em> of \( u \). For Lagrange elements (and many other
element types) \( U_k \) is simply the value of \( u \) at the node
with global number \( k \).
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.

<p>
Having <code>u</code> represented as a <code>Function</code> object, we can either evaluate
<code>u(x)</code> at any point <code>x</code> in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values \( U_j \) directly by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_nodal_values <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
</pre></div>
<p>
The result is a <code>Vector</code> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<code>Vector</code> object to a standard <code>numpy</code> array for further
processing:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_array <span style="color: #666666">=</span> u_nodal_values<span style="color: #666666">.</span>array()
</pre></div>
<p>
With <code>numpy</code> arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: <code>u_array[i]</code>,
where the index <code>i</code> always starts at <code>0</code>. However, <code>i</code> corresponds
to \( u \) at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the mesh, see the section <a href="._ftut007.html#tut:poisson1:verify1">Writing out the discrete solution</a>
for details.

<p>
For now, we want to check that the values in <code>u_array</code> are correct:
they should equal our <code>u0</code> function. The most natural approach is
to interpolate our <code>u0</code> expression onto our space
(i.e., the finite element mesh),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_Function <span style="color: #666666">=</span> interpolate(u0, V)
</pre></div>
<p>
The <code>interpolate</code> function returns a <code>Function</code> object, whose degrees
of freedom values can be obtained by <code>.vector().array()</code>.  Our goal is
to show that the degrees of freedom arrays of <code>u</code> and <code>u0_Function</code>
are equal. One safe of doing this is to compute the maximum error,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How to check that the error vanishes?</b>
With inexact arithmetics, as we always have on a computer,
this maximum error is not zero, but should be a small number.
The machine precision is about \( 10^{-16} \), but in finite element
calculations, rounding errors of this size may accumulate, so
the expected accuracy of <code>max_error</code> smaller. Experiments show
that increasing the number of elements and increasing the degree
of the finite element polynomials increase <code>max_error</code>.
For a mesh with \( 2(20\times 20) \) cubic Lagrange elements (degree 3)
<code>max_error</code> is about \( 2\cdot 10^{-12} \), while for 18 linear elements
the maximum error is about \( 2\cdot 10^{-15} \).
</div>


<h3 id="___sec31">Plotting the solution </h3>

<p>
The simplest way of quickly looking at <code>u</code> is to say

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #408080; font-style: italic"># or</span>
plot(u)
interactive()
</pre></div>
<p>
Clicking on <code>Help</code> in the plot windows brings up a list of commands.
For example, typing <code>m</code> brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click <code>Ctrl+q</code> to kill the plot window and
continue execution beyond the <code>plot(u, interactive=True)</code> command or
<code>interactive()</code>.  Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the
resulting \( u \) function.

<p>
Plotting both the solution and the mesh is accomplished by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u)
plot(mesh)
<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
Type <code>Ctrl+w</code> to kill all plot windows and continue execution.

<p>
It is also possible to dump the computed solution to file, e.g., in the
VTK format:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;poisson.pvd&#39;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
</pre></div>
<p>
The <code>poisson.pvd</code> file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The <code>plot</code> function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.

<h2 id="ftut:poisson:membrane">Deflection of a membrane</h2>

<p>
The previous problem and code targeted a simple test problem where we
can easily verify the implementation. Now we turn the attention to
a more physically relevant problem, in a non-trivial geometry, and
that results in solutions of somewhat more exciting shape.

<p>
We want to compute the deflection \( w \) of a two-dimensional, circular membrane,
subject to a load \( p \) over the membrane.
A scaled form of this problem
(see the section <a href="._ftut008.html#tut:poisson:membrane">Deflection of a circular membrane</a> for mathematical details) has
the governing equation
\( -\nabla^2 w = p \) over the unit circle, with \( w=0 \) on the boundary, and
the load given as

$$ p = - 4\exp{\left(-\beta^2(x^2 + (y-R_0)^2)\right)},$$

where \( \beta \) and \( R_0 \) are dimensionless numbers reflecting the
extent of the load and its location, respectively. Let us work with
a quite peak-shaped load, for which \( \beta=8 \) and \( R_0=0.6 \) are
relevant parameters.

<p>
Just a few modifications are necessary in our previous program to solve
this new problem.

<h3 id="___sec33">Generating the mesh </h3>

<p>
A mesh over the unit circle can be created by the <code>mshr</code> tool in
FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
mesh <span style="color: #666666">=</span> generate_mesh(domain, n)
</pre></div>
<p>
The <code>Circle</code> shape from <code>mshr</code> takes the center and radius of the circle
as the two first arguments, while <code>n</code> is the resolution, here the
suggested number of cells per radius.

<h3 id="___sec34">The expression for the load </h3>

<p>
The right-hand side pressure function
is represented by an <code>Expression</code> object. There
are two physical parameters in the formula for \( f \) that enter the
expression string and these parameters must have their values set
by keyword arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> Expression(
    <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
    beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)
</pre></div>
<p>
The coordinates in <code>Expression</code> objects <em>must</em> be a vector
with indices 0, 1, and 2, and with the name <code>x</code>. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f<span style="color: #666666">.</span>beta <span style="color: #666666">=</span> <span style="color: #666666">12</span>
f<span style="color: #666666">.</span>R0 <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
</pre></div>

<h3 id="___sec35">Variational form </h3>

<p>
We may introduce <code>w</code> instead of <code>u</code> as primary unknown and <code>p</code> instead
of <code>f</code> as right-hand side function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">w <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
a <span style="color: #666666">=</span> dot(grad(w), grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> p<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

w <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, w, bc)
</pre></div>

<h3 id="___sec36">Visualization </h3>

<p>
It would be of interest to visualize \( p \) along with \( w \) so that we can
examine the pressure force and the membrane's response.  We must then transform
the formula (<code>Expression</code>) to a finite element function
(<code>Function</code>).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from \( p \). That is, we interpolate \( p \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> interpolate(p, V)
</pre></div>
<p>
Calling <code>plot(p)</code> will produce a plot of \( p \). Note that the assignment
to <code>p</code> destroys the previous <code>Expression</code> object <code>p</code>, so if
it is of interest to still have access to this object, another name must be used
for the <code>Function</code> object returned by <code>interpolate</code>.

<p>
We can now plot <code>w</code> and <code>p</code> as well as dump the fields to file in VTK format:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(w, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Deflection&#39;</span>)
plot(p, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Load&#39;</span>)

vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane.pvd&#39;</span>)
vtkfile <span style="color: #666666">&lt;&lt;</span> w
vtkfile <span style="color: #666666">&lt;&lt;</span> p
</pre></div>
<p>
Figure <a href="#ftut:poisson:membrane:fig">2</a> shows the result of the <code>plot</code>
commands.

<p>
<center> <!-- figure label: --> <div id="ftut:poisson:membrane:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Load (left) and resulting deflection (right) of a circular membrane.  <!-- caption label: ftut:poisson:membrane:fig --> </p></center>
<p><img src="fig/membrane_fenics_viz.png" align="bottom" width=800></p>
</center>

<h1 id="tut:timedep">The time-dependent diffusion equation</h1>

<p>
The examples in the section <a href="#tut:poisson1:impl">A simple implementation</a> illustrate that solving
linear, stationary PDE problems with the aid of FEniCS is easy and
requires little programming.  FEniCS clearly automates the spatial
discretization by the finite element method. One can use a separate,
one-dimensional finite element method in the domain as well, but very
often, it is easier to just use a finite difference method, or to
formulate the problem as an ODE system and leave the time-stepping to
an ODE solver.
<!-- The solution of -->
<!-- nonlinear problems, as we showed in Section -->
<!-- <a href="._ftut012.html#tut:poisson:nonlinear">The built-in automated Newton solver</a>, can also be automated (cf. Section -->
<!-- <a href="#tut:nonlinear:Newton:auto">A simple implementation</a>), but many scientists will prefer to -->
<!-- code the solution strategy of the nonlinear problem themselves and -->
<!-- experiment with various combinations of strategies in difficult -->
<!-- problems. Time-dependent problems are somewhat similar in this -->
<!-- respect: we have to add a time discretization scheme, which is often -->
<!-- quite simple, making it natural to explicitly code the details of the -->
<!-- scheme so that the programmer has full control. -->
<!-- We shall explain how -->
<!-- easily this is accomplished through examples. -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 5</b>: Should exemplify all three approaches? With emphasis on simple finite differences?)</font>
<!-- end inline comment -->

<h2 id="tut:timedep:diffusion1">Variational formulation</h2>

<p>
Our time-dependent model problem for teaching purposes is naturally
the simplest extension of the Poisson problem into the time domain,
i.e., the diffusion problem

$$
\begin{align}
{\partial u\over\partial t} &= \nabla^2 u + f\hbox{ in }\Omega,
\tag{2.14}\\ 
u &= u_0\hbox{ on } \partial \Omega,
\tag{2.15}\\ 
u &= I \mbox{ at } t=0\tp
\tag{2.16}
\end{align}
$$

Here, \( u \) varies with space and time, e.g., \( u=u(x,y,t) \) if the spatial
domain \( \Omega \) is two-dimensional. The source function \( f \) and the
boundary values \( u_0 \) may also vary with space and time.
The initial condition \( I \) is a function of space only.

<p>
A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a recursive set of
stationary problems, and then turn each stationary problem into a
variational formulation.

<p>
Let superscript \( k \) denote a quantity at time \( t_k \), where \( k \) is an
integer counting time levels. For example, \( u^k \) means \( u \) at time
level \( k \).  A finite difference discretization in time first consists
in sampling the PDE at some time level, say \( k \):

$$
\begin{equation} {\partial \over\partial t}u^k = \nabla^2 u^k + f^k\tp
\tag{2.17}
\end{equation}
$$

The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:

$$
\begin{equation} {\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{\dt}},
\tag{2.18}
\end{equation}
$$

where \( \dt \) is the time discretization parameter.
Inserting <a href="#mjx-eqn-2.18">(2.18)</a> in <a href="#mjx-eqn-2.17">(2.17)</a> yields

$$
\begin{equation}
{u^k - u^{k-1}\over{\dt}} = \nabla^2 u^k + f^k\tp
\tag{2.19}
\end{equation}
$$

This is our time-discrete version of the diffusion PDE
<a href="#mjx-eqn-2.14">(2.14)</a>.

<p>
We may reorder <a href="#mjx-eqn-2.19">(2.19)</a> so
that the left-hand side contains the terms with the unknown \( u^k \) and
the right-hand side contains computed terms only. The result
is a recursive set of spatial
(stationary) problems for \( u^k \) (assuming \( u^{k-1} \) is known from
computations at the previous time level):

$$
\begin{align}
u^0 &= I, \tag{2.20}\\ 
u^k - {\dt}\nabla^2 u^k &=  u^{k-1} + {\dt} f^k,\quad k=1,2,\ldots
\tag{2.21}
\end{align}
$$

Given \( I \), we can solve for \( u^0 \), \( u^1 \), \( u^2 \), and so on.

<p>
As an alternative to <a href="#mjx-eqn-2.21">(2.21)</a>, which can be
convenient in implementations, we may collect
all terms on one side of the equality sign:

$$
\begin{equation}
u^k - {\dt}\nabla^2 u^k -  u^{k-1} - {\dt} f^k = ,\quad k=1,2,\ldots
\tag{2.22}
\end{equation}
$$

<p>
We use a finite element method to solve
<a href="#mjx-eqn-2.20">(2.20)</a> and either of the equations
<a href="#mjx-eqn-2.21">(2.21)</a> or <a href="#mjx-eqn-2.22">(2.22)</a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function \( v\in \hat V \) and integrate second-derivatives by
parts. Introducing the symbol \( u \) for \( u^k \) (which is natural in the
program), the resulting weak form can be conveniently written in
the standard notation:

$$ a_0(u,v)=L_0(v),$$

for
<a href="#mjx-eqn-2.20">(2.20)</a>. The formulation <a href="#mjx-eqn-2.21">(2.21)</a>
gives rise to

$$ a(u,v)=L(v),$$

where

$$
\begin{align}
a_0(u,v) &= \int_\Omega uv \dx, \tag{2.23}\\ 
L_0(v) &= \int_\Omega Iv \dx, \tag{2.24}\\ 
a(u,v) &= \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v\right) \dx, \tag{2.25}\\ 
L(v) &= \int_\Omega \left(u^{k-1} + {\dt}  f^k\right)v \dx\tp
\tag{2.26}
\end{align}
$$

The alternative formulation <a href="#mjx-eqn-2.22">(2.22)</a>
has a formulation

$$ F(u,v) = 0,$$

where

$$
\begin{equation}
F = \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v -
\left(u^{k-1} - {\dt}  f^k\right)v\right) \dx\tp
\tag{2.27}
\end{equation}
$$

<p>
The continuous variational problem is to find
\( u^0\in V \) such that \( a_0(u^0,v)=L_0(v) \) holds for all \( v\in\hat V \),
and then find \( u^k\in V \)
such that \( a(u^k,v)=L(v) \) for all \( v\in\hat V \),
or alternatively, \( F(u^k,v)=0 \) for all \( v\in\hat V \),
\( k=1,2,\ldots \).

<p>
Approximate solutions in space are found by restricting the functional
spaces \( V \) and \( \hat V \) to finite-dimensional spaces, exactly as we
have done in the Poisson problems.  We shall use the symbol \( u \) for
the finite element approximation at time \( t_k \). In case we need to
distinguish this space-time discrete approximation from the exact
solution of the continuous diffusion problem, we use \( \uex \) for the
latter.  By \( u^{k-1} \) we mean the finite element approximation of the
solution at time \( t_{k-1} \).

<p>
Instead of
solving <a href="#mjx-eqn-2.20">(2.20)</a> by a finite element method, i.e.,
projecting \( I \) onto \( V \) via the problem \( a_0(u,v)=L_0(v) \), we could
simply interpolate \( u^0 \) from \( I \). That is, if \( u^0=\sum_{j=1}^N
U^0_j\phi_j \), we simply set \( U_j=I(x_j,y_j) \), where \( (x_j,y_j) \) are
the coordinates of node number \( j \). We refer to these two strategies
as computing the initial condition by either projecting \( I \) or
interpolating \( I \).  Both operations are easy to compute through one
statement, using either the <code>project</code> or <code>interpolate</code> function.

<h2 id="tut:timedep:diffusion1:impl">A simple implementation</h2>

<p>
Our program needs to implement the time stepping explicitly, but can
rely on FEniCS to easily compute \( a_0 \), \( L_0 \), \( F \), \( a \), and \( L \), and solve
the linear systems for the unknowns.

<h3 id="___sec40">Test problem </h3>

<p>
Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,

$$
\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
\tag{2.28}
\end{equation}
$$

yields a function whose computed values at the nodes will be exact,
regardless of the size of the elements and \( \dt \), as long as the mesh
is uniformly partitioned.  By inserting
<a href="#mjx-eqn-2.28">(2.28)</a> in the PDE problem
<a href="#mjx-eqn-2.14">(2.14)</a>, it follows that \( u_0 \) must be given as
<a href="#mjx-eqn-2.28">(2.28)</a> and that \( f(x,y,t)=\beta - 2 -
2\alpha \) and \( I(x,y)=1+x^2+\alpha y^2 \).

<h3 id="___sec41">The code </h3>

<p>
A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition \( u_0 \) given by
<a href="#mjx-eqn-2.28">(2.28)</a>.  A natural solution is to apply an
<code>Expression</code> object with time \( t \) as a parameter, in addition to the
parameters \( \alpha \) and \( \beta \)
for <code>Expression</code> objects with parameters):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                {<span style="color: #BA2121">&#39;alpha&#39;</span>: alpha, <span style="color: #BA2121">&#39;beta&#39;</span>: beta})
u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
</pre></div>
<p>
This function expression has the components of <code>x</code> as independent
variables, while <code>alpha</code>, <code>beta</code>, and <code>t</code> are parameters.  The
parameters can either be set through a dictionary at construction
time, as demonstrated for <code>alpha</code> and <code>beta</code>, or anytime through
attributes in the function object, as shown for the <code>t</code> parameter.

<p>
The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):  <span style="color: #408080; font-style: italic"># define the Dirichlet boundary</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)
</pre></div>
<p>
We shall use <code>u</code> for the unknown \( u \) at the new time level and <code>u_1</code>
for \( u \) at the previous time level.  The initial value of <code>u_1</code>,
implied by the initial condition on \( u \), can be computed by either
projecting or interpolating \( I \).  The \( I(x,y) \) function is available
in the program through <code>u0</code>, as long as <code>u0.t</code> is zero.  We can then
do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_1 <span style="color: #666666">=</span> interpolate(u0, V)
<span style="color: #408080; font-style: italic"># or</span>
u_1 <span style="color: #666666">=</span> project(u0, V)
</pre></div>
<p>
Note that we could, as an equivalent alternative to using <code>project</code>,
define \( a_0 \) and \( L_0 \) as we did in the section <a href="._ftut007.html#tut:poisson:gradu">Computing derivatives</a> and
form the associated variational problem.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Projecting versus interpolating the initial condition.</b>
To actually recover the
exact solution <a href="#mjx-eqn-2.28">(2.28)</a> to machine precision,
it is important not to compute the discrete initial condition by
projecting \( I \), but by interpolating \( I \) so that the nodal values are
exact at \( t=0 \) (projection results in approximative values at the
nodes).
</div>


<p>
We may either define \( a \) or \( L \) according to the formulas above, or
we may just define \( F \) and ask FEniCS to figure out which terms that
go into the bilinear form \( a \) and which that go into the linear form
\( L \). The latter is convenient, especially in more complicated problems,
so we illustrate that construction:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dt <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>      <span style="color: #408080; font-style: italic"># time step</span>

u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
Finally, we perform the time stepping in a loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># the unknown at a new time level</span>
T <span style="color: #666666">=</span> <span style="color: #666666">2</span>             <span style="color: #408080; font-style: italic"># total simulation time</span>
t <span style="color: #666666">=</span> dt

<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> T:
    u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
    solve(a <span style="color: #666666">==</span> L, u, bc)

    t <span style="color: #666666">+=</span> dt
    u_1<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remember to update expression objects with the current time!</b>
Inside the time loop,
observe that <code>u0.t</code> must be updated before the <code>solve</code> statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the <code>u0</code> object
for values.)
</div>


<p>
The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of <code>u</code> and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after <code>u</code> is found:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_e <span style="color: #666666">=</span> interpolate(u0, V)
max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                   u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, max_error))
</pre></div>
<p>
The complete program code for this time-dependent case goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">4</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)

<span style="color: #408080; font-style: italic"># Initial condition</span>
u_1 <span style="color: #666666">=</span> interpolate(u0, V)
<span style="color: #408080; font-style: italic">#project(u0, V) will not result in exact solution at the nodes!</span>

dt <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>      <span style="color: #408080; font-style: italic"># time step</span>

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)
F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># the unknown at a new time level</span>
T <span style="color: #666666">=</span> <span style="color: #666666">1.9</span>           <span style="color: #408080; font-style: italic"># total simulation time</span>
t <span style="color: #666666">=</span> dt
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> T:
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;time =&#39;</span>, t)
    u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># Verify</span>
    u_e <span style="color: #666666">=</span> interpolate(u0, V)
    max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                       u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, max_error))

    t <span style="color: #666666">+=</span> dt
    u_1<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
The code is available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/d2D_flat1.py" target="_self"><tt>ft02_d2D_flat1.py</tt></a>.

<h2 id="___sec42">Diffusion of a Gaussian function </h2>

<p>
Add dumping to file and some plots.

<h1 id="___sec43">A nonlinear Poisson equation </h1>

<h2 id="___sec44">Variational formulation </h2>

<p>
Now we shall address how to solve nonlinear PDEs in FEniCS. Our
sample PDE for implementation is taken as a nonlinear Poisson equation:

$$
\begin{equation}
-\nabla\cdot\left( q(u)\nabla u\right) = f,
\tag{2.29}
\end{equation}
$$

in \( \Omega \), with \( u=u_0 \) on the boundary \( \partial\Omega \).
The coefficient \( q(u) \) makes the equation nonlinear (unless \( q(u) \)
is constant in \( u \)).

<p>
The variational formulation of our model problem reads:
Find \( u \in V \) such that

$$
\begin{equation} \tag{2.30}
  F(u; v) = 0 \quad \forall v \in \hat{V},
\end{equation}
$$

where

$$
\begin{equation}
\tag{2.31}
F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v \dx,
\end{equation}
$$

and

$$
\begin{align*}
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and }x_0=1\}, \\ 
     V      &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and } v = 1\mbox{ on }x_0=1\}\tp
\end{align*}
$$

<p>
The discrete problem arises as usual by restricting \( V \) and \( \hat V \) to a
pair of discrete spaces. As usual, we omit any subscript on discrete
spaces and simply say \( V \) and \( \hat V \) are chosen finite dimensional
according to some mesh with some element type.
Similarly, we let \( u \) be the discrete solution and use \( \uex \) for
the exact solution if it becomes necessary to distinguish between the two.

<p>
The discrete nonlinear problem is then written as: find \( u\in V \) such that

$$
\begin{equation}
  F(u; v) = 0 \quad \forall v \in \hat{V},
\tag{2.32}
\end{equation}
$$

with \( u = \sum_{j=1}^N U_j \phi_j \). Since \( F \) is a nonlinear function
of \( u \), the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns \( U_1,\ldots,U_N \).

<h2 id="tut:nonlinear:Newton:auto">A simple implementation</h2>

<h3 id="___sec46">Overview </h3>

<p>
A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is the state the formula for \( F \) and call
<code>solve(F == 0, u, bc)</code> instead of <code>solve(a == L, u, bc)</code> as we did
in the linear case. Here is a minimalistic code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">60</span>, <span style="color: #666666">40</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
u0 <span style="color: #666666">=</span> Expression(<span style="color: #666666">...</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> Function(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Expression(f_code)
F <span style="color: #666666">=</span> dot(q(u)<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u, bc)
</pre></div>
<p>
The major difference from a linear problem is that the unknown function
<code>u</code> in the variational form is in the nonlinear case
a <code>Function</code>, not a <code>TrialFunction</code>.

<p>
The <code>solve</code> function takes the nonlinear equations and derives symbolically
the Jacobian matrix and runs a Newton method.

<h3 id="___sec47">Constructing a test problem with SymPy </h3>

<p>
Let us do a specific computation. We then need choices for \( f \) and \( u_0 \).
Previously, we have worked with manufactured solutions that can be
reproduced without approximation errors. This is more difficult in
nonlinear problems, and the algebra is more tedious. However, we may
utilize SymPy for symbolic computing and integrate such computations in the
FEniCS solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package (here, defining symbols, <code>diff</code> for
differentiation, <code>ccode</code> for C/C++ code generation).

<p>
We try out a two-dimensional
solution that is linear in the unknowns:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Warning: from fenics import * imports f, q, and sym</span>
<span style="color: #408080; font-style: italic"># (which overwrites the f and q (function) objects</span>
<span style="color: #408080; font-style: italic"># and also sym if we do import sympy as sym).</span>
<span style="color: #408080; font-style: italic"># Therefore, do fenics import first and then overwrite</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Use sympy to compute f given manufactured solution u</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y
f <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">-</span> \ 
      sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to be have valid syntax for
<code>Expression</code> objects, and then \( x \) reads <code>x[0]</code> and \( y \) must be <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expressions for <code>u</code> and <code>f</code> into C or C++ syntax for
<code>Expression</code> objects needs two steps. First we ask for the C code of
the expressions,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
f_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
</pre></div>
<p>
Sometimes we need some editing of the result to match the required syntax of
<code>Expression</code> objects, but not in this case. (The primary example is
that <code>M_PI</code> for \( \pi \) in C/C++ must be replaced by <code>pi</code> for <code>Expression</code>
objects.) In our case here,
the output of <code>c_code</code> and <code>f_code</code> is

<p>

<!-- code=c (!bc ccod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> <span style="color: #666666">1</span>
<span style="color: #666666">-10*</span>x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">10</span>
</pre></div>
<p>
After having defined the mesh, the function space, and the boundary,
we define the boundary values, <code>u0</code>, as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(u_code)
</pre></div>
<p>
Similarly, we define the right-hand side function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(f_code)
</pre></div>
<p>
The complete code is found in the file
<code>ft03_p2D_flat_nonlinear.py</code>.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Name clash between <code>fenics</code> and program variables.</b>
In a program like the one above, strange errors may occur due to
name clashes. If you define <code>sym</code>, <code>q</code>, and <code>f</code> prior to doing
<code>from fenics import *</code>, the latter statement will also import
variables with the names <code>sym</code>, <code>q</code>, and <code>f</code> and overwrite
the objects you had! This may lead to strange errors. The best
solution is to do <code>import fenics as fe</code> and prefix all FEniCS
object names by <code>fe</code>. The next best solution is to do the
<code>from fenics import *</code> first and then define our own variables
that overwrite those imported from <code>fenics</code>. This is acceptable
if we do not need <code>f</code>, <code>q</code>, and <code>sym</code> from <code>fenics</code>.
</div>


<p>
Running the code gives output that tells how the Newton iteration
progresses. With \( 2(6\times 4) \) cells we get convergence in 7
iterations with a tolerance of \( 10^{-9} \), and the error in the
numerical solution is about \( 10^{-11} \). Using more elements, e.g.,
\( 2(16\times 14) \), brings the error down to about \( 10^{-15} \),
which provides evidence for a correct implementation.

<p>
The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much more manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter <a href="._ftut012.html#tut:nonlinear">The nonlinear Poisson solver revisited</a> and show how we can implement our own solution
algorithms for nonlinear equations and also how we can steer the
parameters in the automated Newton method used above. You will then
realize how easy it is to implement tailored solution strategies for
nonlinear problems in FEniCS.

<h1 id="tut:elast">The equations of linear elasticity</h1>

<h2 id="tut:elast:varform">Variational formulation</h2>

<p>
Work with simple constant \( \lambda \) and \( \mu \) formulation, stationary,
with homogeneous Dirichlet or Neumann conditions, but include body force.
Case: Deflection of
a cantilever beam (could be lego box for the fun of it :-)
Then \( x=0 \) end is clamped with \( u=0 \) and the rest of the boundary can
be traction free (homogeneous Neumann condition).
Let gravity deform the shape.

<h2 id="___sec50">A simple implementation </h2>

<p>
As test example, we may look at a cantilever beam deformed under its own weight.
Then \( f=(0,0,-g) \) is the body force with \( g \) as the acceleration
of gravity. If the beam is box-shaped, we set \( u=(0,0,0) \) at the clamped end,
\( x=0 \). The rest of the boundaries are traction free.

<h1 id="___sec51">The equations of hyperelasticity? </h1>

<h2 id="___sec52">Variational formulation </h2>

<h2 id="___sec53">A simple implementation </h2>

<h1 id="___sec54">The Navier-Stokes equations </h1>

<h2 id="___sec55">Variational formulation </h2>

<h2 id="___sec56">A simple implementation </h2>

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut004.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="._ftut001.html">2</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li class="active"><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li><a href="._ftut009.html">10</a></li>
  <li><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut019.html">20</a></li>
  <li><a href="._ftut006.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

