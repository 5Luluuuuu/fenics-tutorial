<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,DOLFIN mesh,finite element specifications,CG finite element family,Lagrange finite element family,Dirichlet boundary conditions,boundary specification (function),boundary specification (function),UFL,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,degree of freedom,degrees of freedom array,nodal values array,interpolation,Expression with parameters,interpolation,visualization,plotting,VTK,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),projection,Poisson's equation with variable coefficient,functionals,energy functional,error functional,flux functional,structured mesh,visualization, structured mesh,contour plot,Neumann boundary conditions,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),dimension-independent code,time-dependent PDEs,assembly, increasing efficiency,heterogeneous medium,multi-material domain,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),Gateaux derivative,automatic differentiation,Jacobian, automatic computation,nonlinear variational problems,mesh transformations,coordinate stretching,coordinate transformations,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,installing FEniCS,troubleshooting,compilation problems,plotting problems">

<title>FEniCS Tutorial</title>


<style type="text/css">
/* blueish style */

/* Color definitions:  http://www.december.com/html/spec/color0.html
   CSS examples:       http://www.w3schools.com/css/css_examples.asp */

body {
  margin-top: 1.0em;
  background-color: #ffffff;
  font-family: Helvetica, Arial, FreeSans, san-serif;
  color: #000000;
}
h1 { font-size: 1.8em; color: #1e36ce; }
h2 { font-size: 1.6em; color: #1e36ce; }
h3 { font-size: 1.4em; color: #1e36ce; }
a { color: #1e36ce; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u'Fundamentals', 1, u'tut:fundamentals', u'tut:fundamentals'),
              (u'The Poisson equation',
               2,
               u'tut:poisson1:bvp',
               u'tut:poisson1:bvp'),
              (u'Variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'Implementation',
               2,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'The code', 3, None, '___sec4'),
              (u'Running the program', 3, None, '___sec5'),
              (u'Dissection of the program', 3, None, '___sec6'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Examining the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Solving a real physical problem',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'Quick visualization with VTK',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Visualization of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'A linear algebra formulation',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Time-dependent problems', 1, u'tut:timedep', u'tut:timedep'),
              (u'A diffusion problem and its discretization',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'Implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Avoiding assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'Nonlinear problems',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'Solving the nonlinear variational problem directly',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'Handling domains with different materials',
               1,
               None,
               '___sec33'),
              (u'Working with two subdomains',
               2,
               u'tut:possion:2D:2mat:problem',
               u'tut:possion:2D:2mat:problem'),
              (u'Implementation',
               2,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:mat:neumann',
               u'tut:poisson:mat:neumann'),
              (u'More Examples', 1, None, '___sec37'),
              (u'Miscellaneous topics', 1, None, '___sec38'),
              (u'Glossary', 2, None, '___sec39'),
              (u'Overview of objects and functions', 2, None, '___sec40'),
              (u'User-defined functions',
               2,
               u'tut:app:cpp:functions',
               u'tut:app:cpp:functions'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Installing FEniCS',
               2,
               u'tut:app:install',
               u'tut:app:install'),
              (u'Books on the finite element method',
               2,
               u'tut:appendix:books',
               u'tut:appendix:books'),
              (u'Books on Python',
               2,
               u'tut:appendix:pybooks',
               u'tut:appendix:pybooks'),
              (u'Acknowledgments', 2, None, '___sec47'),
              (u'Troubleshooting', 1, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 2, None, '___sec49'),
              (u'Problems with the Instant cache', 3, None, '___sec50'),
              (u'Syntax errors in expressions', 3, None, '___sec51'),
              (u'Problems in the solve step', 3, None, '___sec52'),
              (u'Unable to convert object to a UFL form',
               3,
               None,
               '___sec53'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               3,
               None,
               '___sec54'),
              (u'All programs fail to compile', 3, None, '___sec55'),
              (u'Plotting Problems', 2, None, '___sec56'),
              (u'The plot disapperas quickly from the screen',
               3,
               None,
               '___sec57'),
              (u'Problems with Expression Objects', 2, None, '___sec58'),
              (u'There seems to be some bug in an Expression object',
               3,
               None,
               '___sec59'),
              (u'I get a segmentation fault when using an Expression object',
               3,
               None,
               '___sec60'),
              (u'Other Problems', 2, None, '___sec61'),
              (u'Only parts of the program are executed',
               3,
               None,
               '___sec62'),
              (u'I get an error in the definition of the boundary',
               3,
               None,
               '___sec63'),
              (u'The solver in a nonlinear problems does not converge',
               3,
               None,
               '___sec64'),
              (u'How To Debug a FEniCS Program?', 2, None, '___sec65'),
              (u"What's New", 1, None, '___sec66'),
              (u'Bibliography', 1, None, '___sec67')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<a name="part0003"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._ftut002.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="&laquo; Previous"></a></div>
</td><td>
<div style="text-align: right;"><a href="._ftut004.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="Next &raquo;"></a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="tut:timedep">Time-dependent problems</h1>

<p>
The examples in the section <a href="._ftut002.html#tut:fundamentals">Fundamentals</a> illustrate that solving
linear, stationary PDE problems with the aid of FEniCS is easy and
requires little programming.  That is, FEniCS automates the spatial
discretization by the finite element method.  The solution of
nonlinear problems, as we showed in the section <a href="._ftut004.html#tut:poisson:nonlinear">Nonlinear problems</a>, can also be automated (cf. the section <a href="._ftut004.html#tut:nonlinear:Newton:auto">Solving the nonlinear variational problem directly</a>), but many scientists will prefer to
code the solution strategy of the nonlinear problem themselves and
experiment with various combinations of strategies in difficult
problems. Time-dependent problems are somewhat similar in this
respect: we have to add a time discretization scheme, which is often
quite simple, making it natural to explicitly code the details of the
scheme so that the programmer has full control.  We shall explain how
easily this is accomplished through examples.

<h2 id="tut:timedep:diffusion1">A diffusion problem and its discretization</h2>

<p>
Our time-dependent
model problem for teaching purposes is naturally the simplest
extension of the Poisson problem into the time domain, i.e.,
the diffusion problem

$$
\begin{align}
{\partial u\over\partial t} &= \nabla^2 u + f \mbox{ in } \Omega, \hbox{ for } t>0,
\tag{38}\\ 
    u &= u_0 \mbox{ on } \partial \Omega,\hbox{ for } t>0,
\tag{39}\\ 
    u &= I   \mbox{ at } t=0{\thinspace .}
\tag{40}
\end{align}
$$

Here, \( u \) varies with space and time, e.g., \( u=u(x,y,t) \) if the spatial
domain \( \Omega \) is two-dimensional. The source function \( f \) and the
boundary values \( u_0 \) may also vary with space and time.
The initial condition \( I \) is a function of space only.

<p>
A straightforward approach to solving time-dependent
PDEs by the finite element method is to first discretize the
time derivative by a finite difference approximation, which yields
a recursive set of stationary problems, and then turn each stationary
problem into a variational formulation.

<p>
Let superscript \( k \) denote
a quantity at time \( t_k \),
where \( k \) is an integer counting time levels. For example, \( u^k \) means
\( u \) at time level \( k \).
A finite difference discretization in time first consists in
sampling the PDE at some time level, say \( k \):

$$
\begin{equation} {\partial \over\partial t}u^k = \nabla^2 u^k + f^k{\thinspace .}
\tag{41}
\end{equation}
$$

The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:

$$
\begin{equation} {\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{{\Delta t}}},
\tag{42}
\end{equation}
$$

where \( {\Delta t} \) is the time discretization parameter.
Inserting <a href="#mjx-eqn-42">(42)</a> in <a href="#mjx-eqn-41">(41)</a> yields

$$
\begin{equation}
{u^k - u^{k-1}\over{{\Delta t}}} = \nabla^2 u^k + f^k{\thinspace .}
\tag{43}
\end{equation}
$$

This is our time-discrete version of the diffusion PDE
<a href="#mjx-eqn-38">(38)</a>.
Reordering <a href="#mjx-eqn-43">(43)</a>
so that \( u^k \) appears
on the left-hand side only,
shows that <a href="#mjx-eqn-43">(43)</a> is
a recursive set of
spatial (stationary) problems for \( u^k \) (assuming \( u^{k-1} \) is known from
computations at the previous time level):

$$
\begin{align}
u^0 &= I, \tag{44}\\ 
u^k - {{\Delta t}}\nabla^2 u^k &=  u^{k-1} + {{\Delta t}} f^k,\quad k=1,2,\ldots
\tag{45}
\end{align}
$$

Given \( I \), we can solve for \( u^0 \), \( u^1 \), \( u^2 \), and so on.

<p>
We use a finite element method
to solve the
equations <a href="#mjx-eqn-44">(44)</a> and <a href="#mjx-eqn-45">(45)</a>.
This requires turning the equations into weak forms.
As usual, we multiply by a test function \( v\in \hat V \) and integrate
second-derivatives by parts. Introducing the symbol \( u \) for \( u^k \)
(which is natural in the program too), the resulting weak
form can be conveniently written in the standard notation:
\( a_0(u,v)=L_0(v) \) for <a href="#mjx-eqn-44">(44)</a>
and \( a(u,v)=L(v) \) for <a href="#mjx-eqn-45">(45)</a>, where

$$
\begin{align}
a_0(u,v) &= \int_\Omega uv {\, \mathrm{d}x}, \tag{46}\\ 
L_0(v) &= \int_\Omega Iv {\, \mathrm{d}x}, \tag{47}\\ 
a(u,v) &= \int_\Omega\left( uv + {{\Delta t}}
\nabla u\cdot \nabla v\right) {\, \mathrm{d}x}, \tag{48}\\ 
L(v) &= \int_\Omega \left(u^{k-1} + {{\Delta t}}  f^k\right)v {\, \mathrm{d}x}{\thinspace .}
\tag{49}
\end{align}
$$

The continuous variational problem is to find
\( u^0\in V \) such that \( a_0(u^0,v)=L_0(v) \) holds for all \( v\in\hat V \),
and then find \( u^k\in V \)
such that \( a(u^k,v)=L(v) \) for all \( v\in\hat V \),
\( k=1,2,\ldots \).

<p>
Approximate solutions in space
are found by
restricting the functional spaces \( V \) and \( \hat V \)
to finite-dimensional spaces,
exactly as we have done in the Poisson problems.
We shall use the symbol \( u \) for the finite element
approximation at time \( t_k \). In case we need to distinguish this
space-time discrete approximation from the exact solution of
the continuous diffusion problem, we use \( {u_{\small\mbox{e}}} \) for the latter.
By \( u^{k-1} \) we mean, from now on, the finite element approximation
of the solution at time \( t_{k-1} \).

<p>
Note that the forms \( a_0 \) and \( L_0 \) are identical to the forms
met in the section <a href="._ftut002.html#tut:poisson:gradu">Computing derivatives</a>, except that the test and trial
functions are now
scalar fields and not vector fields.
Instead of solving
<a href="#mjx-eqn-44">(44)</a>
by a finite
element method, i.e., projecting \( I \) onto \( V \) via
the problem \( a_0(u,v)=L_0(v) \), we could simply interpolate \( u^0 \) from
\( I \). That is, if \( u^0=\sum_{j=1}^N U^0_j\phi_j \), we
simply set \( U_j=I(x_j,y_j) \), where \( (x_j,y_j) \) are the coordinates of
node number \( j \). We refer to these two strategies as computing
the initial condition by either projecting \( I \) or interpolating \( I \).
Both operations are easy to compute through one statement, using either
the <code>project</code> or <code>interpolate</code> function.

<h2 id="tut:timedep:diffusion1:impl">Implementation</h2>

<p>
Our program needs to perform the time stepping explicitly, but can
rely on FEniCS to easily compute \( a_0 \), \( L_0 \), \( a \), and \( L \), and solve
the linear systems for the unknowns.  We realize that \( a \) does not
depend on time, which means that its associated matrix also will be
time independent. Therefore, it is wise to explicitly create matrices
and vectors as in the section <a href="._ftut002.html#tut:poisson1:linalg">A linear algebra formulation</a>.  The matrix \( A \)
arising from \( a \) can be computed prior to the time stepping, so that
we only need to compute the right-hand side \( b \), corresponding to \( L \),
in each pass in the time loop. Let us express the solution procedure
in algorithmic form, writing \( u \) for the unknown spatial function at
the new time level (\( u^k \)) and \( u_1 \) for the spatial solution at one
earlier time level (\( u^{k-1} \)):

<ul>
 <li> define Dirichlet boundary condition (\( u_0 \), Dirichlet boundary, etc.)</li>
 <li> if \( u_1 \) is to be computed by projecting \( I \):</li>

<ul>
   <li> define \( a_0 \) and \( L_0 \)</li>
   <li> assemble matrix \( M \) from \( a_0 \) and vector \( b \) from \( L_0 \)</li>
   <li> solve \( MU=b \) and store \( U \) in \( u_1 \)</li>
</ul>

 <li> else:  (interpolation)</li>

<ul>
   <li> let \( u_1 \) interpolate \( I \)</li>
</ul>

 <li> define \( a \) and \( L \)</li>
 <li> assemble matrix \( A \) from \( a \)</li>
 <li> set some stopping time \( T \)</li>
 <li> \( t={{\Delta t}} \)</li>
 <li> while \( t\leq T \)</li>

<ul>
   <li> assemble vector \( b \) from \( L \)</li>
   <li> apply essential boundary conditions</li>
   <li> solve \( AU=b \) for \( U \) and store in \( u \)</li>
   <li> \( t\leftarrow t + {{\Delta t}} \)</li>
   <li> \( u_1 \leftarrow u \) (be ready for next step)</li>
</ul>

</ul>

Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,

$$
\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
\tag{50}
\end{equation}
$$

yields a function whose computed values at the nodes may be exact,
regardless of the size of the elements and \( {\Delta t} \), as long as the
mesh is uniformly partitioned.
By inserting <a href="#mjx-eqn-50">(50)</a> in the PDE problem
<a href="#mjx-eqn-38">(38)</a>, it follows
that \( u_0 \) must be given as
<a href="#mjx-eqn-50">(50)</a> and that \( f(x,y,t)=\beta - 2 - 2\alpha \)
and \( I(x,y)=1+x^2+\alpha y^2 \).

<p>
A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the the boundary condition
\( u_0 \) given by <a href="#mjx-eqn-50">(50)</a>.
A natural solution is
to apply an <code>Expression</code> object with time \( t \) as a parameter,
in addition to the parameters \( \alpha \) and \( \beta \) (see
the section <a href="._ftut002.html#tut:poisson:membrane">Solving a real physical problem</a> for <code>Expression</code>
objects with parameters):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)
</pre></div>
<p>
The time parameter can later be updated by assigning values to <code>u0.t</code>.

<p>
Given a <code>mesh</code> and an associated function space <code>V</code>, we
can specify the \( u_0 \) function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                {<span style="color: #BA2121">&#39;alpha&#39;</span>: alpha, <span style="color: #BA2121">&#39;beta&#39;</span>: beta})
u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
</pre></div>
<p>
This function expression has the components of <code>x</code> as independent
variables, while <code>alpha</code>, <code>beta</code>, and <code>t</code> are parameters.
The parameters can either be set through a dictionary at construction time,
as demonstrated for <code>alpha</code> and <code>beta</code>, or anytime through
attributes in the function
object, as shown for the <code>t</code> parameter.

<p>
The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):  <span style="color: #408080; font-style: italic"># define the Dirichlet boundary</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)
</pre></div>
<p>
We shall use <code>u</code> for the unknown \( u \) at the new time level and
<code>u_1</code> for \( u \) at the previous time level.  The initial value of
<code>u_1</code>, implied by the initial condition on \( u \), can be computed
by either projecting or interpolating \( I \).
The \( I(x,y) \) function is available in the program through
<code>u0</code>,
as long as <code>u0.t</code> is zero.
We can then do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_1 <span style="color: #666666">=</span> interpolate(u0, V)
<span style="color: #408080; font-style: italic"># or</span>
u_1 <span style="color: #666666">=</span> project(u0, V)
</pre></div>
<p>
Note that we could, as an equivalent alternative to using <code>project</code>, define
\( a_0 \) and \( L_0 \) as we did in the section <a href="._ftut002.html#tut:poisson:gradu">Computing derivatives</a> and form
the associated variational problem.
To actually recover the exact solution
<a href="#mjx-eqn-50">(50)</a>
to machine precision,
it is important not to compute the discrete initial condition by
projecting \( I \), but by interpolating \( I \) so that the nodal values are
exact at \( t=0 \) (projection results in approximative values at the nodes).

<p>
The definition of \( a \) and \( L \) goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dt <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>      <span style="color: #408080; font-style: italic"># time step</span>

u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

a <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> (u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

A <span style="color: #666666">=</span> assemble(a)   <span style="color: #408080; font-style: italic"># assemble only once, before the time stepping</span>
</pre></div>
<p>
Finally, we perform the time stepping in a loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># the unknown at a new time level</span>
T <span style="color: #666666">=</span> <span style="color: #666666">2</span>             <span style="color: #408080; font-style: italic"># total simulation time</span>
t <span style="color: #666666">=</span> dt

<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> T:
    b <span style="color: #666666">=</span> assemble(L)
    u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
    bc<span style="color: #666666">.</span>apply(A, b)
    solve(A, u<span style="color: #666666">.</span>vector(), b)

    t <span style="color: #666666">+=</span> dt
    u_1<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
Observe that <code>u0.t</code> must be updated before the <code>bc.apply</code>
statement, to enforce computation of Dirichlet conditions at the
current time level.

<p>
The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of <code>u</code> and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after <code>u</code> is found:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_e <span style="color: #666666">=</span> interpolate(u0, V)
maxdiff <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">-</span>u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Max error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, maxdiff))
</pre></div>
<p>
The right-hand side vector <code>b</code> must obviously
be recomputed at each time level.
With the construction <code>b = assemble(L)</code>, a new
vector for <code>b</code> is allocated in memory in every pass of the time loop.
It would be much more memory friendly to reuse the storage of the <code>b</code>
we already have.
This is easily accomplished by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    b <span style="color: #666666">=</span> assemble(L, tensor<span style="color: #666666">=</span>b)
</pre></div>
<p>
That is, we send in our previous <code>b</code>, which is then filled with new values
and returned from <code>assemble</code>. Now there will be only a single
memory allocation of the right-hand side vector. Before the time loop
we set <code>b = None</code> such that <code>b</code> is defined in the first call to
<code>assemble</code>.

<p>
The complete program code for this time-dependent case goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">2</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Boundary</span>(SubDomain):  <span style="color: #408080; font-style: italic"># define the Dirichlet boundary</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

boundary <span style="color: #666666">=</span> Boundary()
bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)

<span style="color: #408080; font-style: italic"># Initial condition</span>
u_1 <span style="color: #666666">=</span> interpolate(u0, V)
<span style="color: #408080; font-style: italic">#u_1 = project(u0, V)  # will not result in exact solution!</span>

dt <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>      <span style="color: #408080; font-style: italic"># time step</span>

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)
a <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> (u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

A <span style="color: #666666">=</span> assemble(a)   <span style="color: #408080; font-style: italic"># assemble only once, before the time stepping</span>
b <span style="color: #666666">=</span> <span style="color: #008000">None</span>          <span style="color: #408080; font-style: italic"># necessary for memory saving assemeble call</span>

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># the unknown at a new time level</span>
T <span style="color: #666666">=</span> <span style="color: #666666">1.9</span>           <span style="color: #408080; font-style: italic"># total simulation time</span>
t <span style="color: #666666">=</span> dt
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> T:
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;time =&#39;</span>, t)
    b <span style="color: #666666">=</span> assemble(L, tensor<span style="color: #666666">=</span>b)
    u0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
    bc<span style="color: #666666">.</span>apply(A, b)
    solve(A, u<span style="color: #666666">.</span>vector(), b)

    <span style="color: #408080; font-style: italic"># Verify</span>
    u_e <span style="color: #666666">=</span> interpolate(u0, V)
    maxdiff <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Max error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, maxdiff))

    t <span style="color: #666666">+=</span> dt
    u_1<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
The code
is available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/transient/diffusion/d1_d2D.py" target="_self"><tt>d1_d2D.py</tt></a>
in the directory <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/transient/diffusion" target="_self"><tt>transient/diffusion</tt></a>.

<h2 id="tut:timedep:diffusion1:noassemble">Avoiding assembly</h2>

<p>
The purpose of this section is to present a technique for speeding
up FEniCS simulators for time-dependent problems where it is
possible to perform all assembly operations prior to the time loop.
There are two costly operations in the time loop: assembly of the
right-hand side \( b \) and solution of the linear system via the
<code>solve</code> call. The assembly process involves work proportional to
the number of degrees of freedom \( N \), while the solve operation
has a work estimate of \( \mathcal{O}( N^{\alpha}) \), for some \( \alpha\geq 1 \). As
\( N\rightarrow\infty \), the solve operation will dominate for \( \alpha>1 \),
but for the values of \( N \) typically used on smaller computers, the
assembly step may still
represent a considerable part of the total work at each
time level. Avoiding repeated assembly can therefore contribute to a
significant speed-up of a finite element code in time-dependent problems.

<p>
To see how repeated assembly can be avoided, we look at the \( L(v) \)
form in  <a href="#mjx-eqn-49">(49)</a>,
which in general varies with
time through \( u^{k-1} \), \( f^k \), and possibly also with \( {\Delta t} \)
if the time step is adjusted during the simulation.
The technique for avoiding repeated assembly consists in
expanding the finite element functions in sums over the basis functions
\( \phi_i \), as explained
in the section <a href="._ftut002.html#tut:poisson1:linalg">A linear algebra formulation</a>, to identify matrix-vector
products that build up the complete system. We have
\( u^{k-1}=\sum_{j=1}^NU^{k-1}_j\phi_j \), and we can expand \( f^k \) as
\( f^{k}=\sum_{j=1}^NF^{k}_j\phi_j \). Inserting these expressions in \( L(v) \)
and using
\( v=\hat\phi_i \) result in

$$
\begin{align*}
\int_\Omega \left(u^{k-1} + {{\Delta t}}f^k\right)v {\, \mathrm{d}x} &=
\int_\Omega \left(\sum_{j=1}^N U^{k-1}_j\phi_j + {{\Delta t}}\sum_{j=1}^N F^{k}_j\phi_j\right)\hat\phi_i {\, \mathrm{d}x},\\ 
&=\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^{k-1}_j
 + {{\Delta t}}\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)F^{k}_j{\thinspace .}
\end{align*}
$$

Introducing \( M_{ij} = \int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x} \), we see that
the last expression can be written

$$
\begin{equation*}
\sum_{j=1}^NM_{ij}U^{k-1}_j + {{\Delta t}} \sum_{j=1}^NM_{ij}F^{k}_j,
\end{equation*}
$$

which is nothing but two matrix-vector products,

$$
\begin{equation*}
MU^{k-1} + {{\Delta t}} MF^k,
\end{equation*}
$$

if \( M \) is the matrix with entries \( M_{ij} \) and

$$
\begin{equation*}
U^{k-1}=(U^{k-1}_1,\ldots,U^{k-1}_N)^T,
\end{equation*}
$$

and

$$
\begin{equation*}
F^k=(F^{k}_1,\ldots,F^{k}_N)^T{\thinspace .}
\end{equation*}
$$

<p>
We have immediate access to \( U^{k-1} \)
in the program since that is the vector
in the <code>u_1</code> function. The \( F^k \) vector can easily be
computed by interpolating the prescribed \( f \) function (at each time level if
\( f \) varies with time). Given \( M \), \( U^{k-1} \), and \( F^k \), the right-hand side
\( b \) can be calculated as

$$
\begin{equation*}
b = MU^{k-1} + {{\Delta t}} MF^k {\thinspace .}
\end{equation*}
$$

That is, no assembly is necessary to compute \( b \).

<p>
The coefficient matrix \( A \) can also be split into two terms.
We insert \( v=\hat\phi_i \) and \( u^k = \sum_{j=1}^N U^k_j\phi_j \) in
the expression <a href="#mjx-eqn-48">(48)</a> to get

$$
\begin{equation*}
\sum_{j=1}^N \left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^k_j + {{\Delta t}}
\sum_{j=1}^N \left(\int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}\right)U^k_j,
\end{equation*}
$$

which can be written as a sum of matrix-vector products,

$$
\begin{equation*}
MU^k + {{\Delta t}} KU^k = (M + {{\Delta t}} K)U^k,
\end{equation*}
$$

if we identify the matrix \( M \) with entries \( M_{ij} \) as above and
the matrix \( K \) with entries

$$
\begin{equation} K_{ij} = \int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}{\thinspace .}
\tag{51}
\end{equation}
$$

The matrix \( M \) is often called the "mass matrix" while "stiffness matrix"
is a common nickname for \( K \). The associated bilinear forms for these
matrices, as we need them for the assembly process in a FEniCS
program, become

$$
\begin{align}
a_K(u,v) &= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x},
\tag{52}\\ 
a_M(u,v) &= \int_\Omega uv {\, \mathrm{d}x} \tag{53}{\thinspace .}
\end{align}
$$

<p>
The linear system at each time level, written as \( AU^k=b \),
can now be computed by first computing \( M \) and \( K \), and then forming
\( A=M+{{\Delta t}} K \) at \( t=0 \), while \( b \) is computed as
\( b=MU^{k-1} + {{\Delta t}}MF^k \) at each time level.

<p>
The following modifications are needed in the <code>d1_d2D.py</code>
program from the previous section in order to implement the new
strategy of avoiding assembly at each time level:

<ul>
  <li> Define separate forms \( a_M \) and \( a_K \)</li>
  <li> Assemble \( a_M \) to \( M \) and \( a_K \) to \( K \)</li>
  <li> Compute \( A=M+{{\Delta t}} \), \( K \)</li>
  <li> Define \( f \) as an <code>Expression</code></li>
  <li> Interpolate the formula for \( f \) to a finite element function \( F^k \)</li>
  <li> Compute \( b=MU^{k-1} + {{\Delta t}}MF^k \)</li>
</ul>

The relevant code segments become

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># 1.</span>
a_K <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
a_M <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># 2. and 3.</span>
M <span style="color: #666666">=</span> assemble(a_M)
K <span style="color: #666666">=</span> assemble(a_K)
A <span style="color: #666666">=</span> M <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>K

<span style="color: #408080; font-style: italic"># 4.</span>
f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;beta - 2 - 2*alpha&#39;</span>, beta<span style="color: #666666">=</span>beta, alpha<span style="color: #666666">=</span>alpha)

<span style="color: #408080; font-style: italic"># 5. and 6.</span>
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> T:
    f_k <span style="color: #666666">=</span> interpolate(f, V)
    F_k <span style="color: #666666">=</span> f_k<span style="color: #666666">.</span>vector()
    b <span style="color: #666666">=</span> M<span style="color: #666666">*</span>u_1<span style="color: #666666">.</span>vector() <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>M<span style="color: #666666">*</span>F_k
</pre></div>
<p>
The complete program appears in the file <code>d2_d2D.py</code>.

<h2 id="tut:timedep:diffusion2:sin">A physical example</h2>

<p>
With the basic programming techniques for time-dependent problems from
the sections <a href="#tut:timedep:diffusion1:noassemble">Avoiding assembly</a>
and <a href="#tut:timedep:diffusion1:impl">Implementation</a>
we are ready to attack more physically realistic examples.
The next example concerns the question: How is the temperature in the
ground affected by day and night variations at the earth's surface?
We consider some box-shaped domain \( \Omega \) in \( d \) dimensions with
coordinates \( x_0,\ldots,x_{d-1} \) (the problem is meaningful in 1D, 2D, and 3D).
At the top of the domain, \( x_{d-1}=0 \), we have an oscillating
temperature

$$
\begin{equation*}
T_0(t) = T_R + T_A\sin (\omega t),
\end{equation*}
$$

where \( T_R \) is some reference temperature, \( T_A \) is the amplitude of
the temperature variations at the surface, and \( \omega \) is the frequency
of the temperature oscillations.
At all other boundaries we assume
that the temperature does not change anymore when we move away from
the boundary, i.e., the normal derivative is zero.
Initially, the temperature can be taken as \( T_R \) everywhere.
The heat conductivity properties of the soil in the
ground may vary with space so
we introduce a variable coefficient \( \kappa \) reflecting this property.
Figure <a href="#tut:timedep:diffusion2:sin:fig1">6</a> shows a sketch of the
problem, with a small region where the heat conductivity is much lower.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature. <div id="tut:timedep:diffusion2:sin:fig1"></div> </p></center>
<p><img src="fig/daynight.png" align="bottom" width=480></p>
</center>

<p>
The initial-boundary value problem for this problem reads

$$
\begin{align}
\varrho c{\partial T\over\partial t} &= \nabla\cdot\left( \kappa\nabla T\right)\hbox{ in }\Omega\times (0,t_{\hbox{stop}}],
\tag{54}\\ 
T &= T_0(t)\hbox{ on }\Gamma_0,
\tag{55}\\ 
{\partial T\over\partial n} &= 0\hbox{ on }\partial\Omega\backslash\Gamma_0,
\tag{56}\\ 
T &= T_R\hbox{ at }t =0{\thinspace .}
\tag{57}
\end{align}
$$

Here, \( \varrho \) is the density of the soil, \( c \) is the
heat capacity, \( \kappa \) is the thermal conductivity
(heat conduction coefficient)
in the soil, and \( \Gamma_0 \) is the surface boundary \( x_{d-1}=0 \).

<p>
We use a \( \theta \)-scheme in time, i.e., the evolution equation
\( \partial P/\partial t=Q(t) \) is discretized as

$$
\begin{equation*}
{P^k - P^{k-1}\over{{\Delta t}}} = \theta Q^k + (1-\theta )Q^{k-1},
\end{equation*}
$$

where \( \theta\in[0,1] \) is a weighting factor: \( \theta =1 \) corresponds
to the backward difference scheme, \( \theta =1/2 \) to the Crank-Nicolson
scheme, and \( \theta =0 \) to a forward difference scheme.
The \( \theta \)-scheme applied to our PDE results in

$$
\begin{equation*}
\varrho c{T^k-T^{k-1}\over{{\Delta t}}} =
\theta \nabla\cdot\left( \kappa\nabla T^k\right)
+ (1-\theta) \nabla\cdot\left( k\nabla T^{k-1}\right){\thinspace .}
\end{equation*}
$$

Bringing this time-discrete PDE into weak form follows the technique shown
many times earlier in this tutorial. In the standard notation
\( a(T,v)=L(v) \) the weak form has

$$
\begin{align}
a(T,v) &= \int_\Omega
\left( \varrho c Tv + \theta{{\Delta t}} \kappa\nabla T\cdot \nabla v\right) {\, \mathrm{d}x},
\tag{58}\\ 
L(v) &= \int_\Omega \left( \varrho c T^{k-1}v - (1-\theta){{\Delta t}}
\kappa\nabla T^{k-1}\cdot \nabla v\right) {\, \mathrm{d}x}{\thinspace .}
\tag{59}
\end{align}
$$

Observe that boundary integrals vanish because of the Neumann boundary
conditions.

<p>
The size of a 3D box is taken as \( W\times W\times D \), where \( D \) is
the depth and \( W=D/2 \) is the width.
We give the degree of the basis functions at the command line, then \( D \),
and then the divisions of the domain in the various directions.
To make a box, rectangle, or interval of arbitrary (not unit) size,
we have the DOLFIN classes <code>BoxMesh</code>, <code>RectangleMesh</code>, and
<code>IntervalMesh</code> at our disposal. The mesh and the function space
can be created by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">degree <span style="color: #666666">=</span> <span style="color: #008000">int</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
D <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
W <span style="color: #666666">=</span> D<span style="color: #666666">/2.0</span>
divisions <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(arg) <span style="color: #008000; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>:]]
d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(divisions)  <span style="color: #408080; font-style: italic"># no of space dimensions</span>
<span style="color: #008000; font-weight: bold">if</span> d <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
    mesh <span style="color: #666666">=</span> IntervalMesh(divisions[<span style="color: #666666">0</span>], <span style="color: #666666">-</span>D, <span style="color: #666666">0</span>)
<span style="color: #008000; font-weight: bold">elif</span> d <span style="color: #666666">==</span> <span style="color: #666666">2</span>:
    mesh <span style="color: #666666">=</span> RectangleMesh(<span style="color: #666666">-</span>W<span style="color: #666666">/2</span>, <span style="color: #666666">-</span>D, W<span style="color: #666666">/2</span>, <span style="color: #666666">0</span>, divisions[<span style="color: #666666">0</span>], divisions[<span style="color: #666666">1</span>])
<span style="color: #008000; font-weight: bold">elif</span> d <span style="color: #666666">==</span> <span style="color: #666666">3</span>:
    mesh <span style="color: #666666">=</span> BoxMesh(<span style="color: #666666">-</span>W<span style="color: #666666">/2</span>, <span style="color: #666666">-</span>W<span style="color: #666666">/2</span>, <span style="color: #666666">-</span>D, W<span style="color: #666666">/2</span>, W<span style="color: #666666">/2</span>, <span style="color: #666666">0</span>,
               divisions[<span style="color: #666666">0</span>], divisions[<span style="color: #666666">1</span>], divisions[<span style="color: #666666">2</span>])
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)
</pre></div>
<p>
The <code>RectangleMesh</code> and <code>BoxMesh</code> objects are defined by the coordinates
of the "minimum" and "maximum" corners.

<p>
Setting Dirichlet conditions at the upper boundary can be done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T_R <span style="color: #666666">=</span> <span style="color: #666666">0</span>; T_A <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>; omega <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi

T_0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;T_R + T_A*sin(omega*t)&#39;</span>,
                 T_R<span style="color: #666666">=</span>T_R, T_A<span style="color: #666666">=</span>T_A, omega<span style="color: #666666">=</span>omega, t<span style="color: #666666">=0.0</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">surface</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[d<span style="color: #666666">-1</span>]) <span style="color: #666666">&lt;</span> <span style="color: #666666">1E-14</span>

bc <span style="color: #666666">=</span> DirichletBC(V, T_0, surface)
</pre></div>
<p>
The \( \kappa \) function can be defined as a constant \( \kappa_1 \) inside
the particular rectangular area with a special soil composition, as
indicated in Figure <a href="#tut:timedep:diffusion2:sin:fig1">6</a>. Outside
this area \( \kappa \) is a constant \( \kappa_0 \).
The domain of the rectangular area is taken as

$$
\begin{equation*}
[-W/4, W/4]\times [-W/4, W/4]\times [-D/2, -D/2 + D/4]
\end{equation*}
$$

in 3D, with \( [-W/4, W/4]\times [-D/2, -D/2 + D/4] \) in 2D and
\( [-D/2, -D/2 + D/4] \) in 1D.
Since we need some testing in the definition of the \( \kappa(\boldsymbol{x}) \)
function, the most straightforward approach is to define a subclass
of <code>Expression</code>, where we can use a full Python method instead of
just a C++ string formula for specifying a function.
The method that defines the function is called <code>eval</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Kappa</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
        d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x)  <span style="color: #408080; font-style: italic"># no of space dimensions</span>
        material <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #408080; font-style: italic"># 0: outside, 1: inside</span>
        <span style="color: #008000; font-weight: bold">if</span> d <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">&lt;</span> x[d<span style="color: #666666">-1</span>] <span style="color: #666666">&lt;</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">+</span> D<span style="color: #666666">/4.</span>:
                material <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">elif</span> d <span style="color: #666666">==</span> <span style="color: #666666">2</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">&lt;</span> x[d<span style="color: #666666">-1</span>] <span style="color: #666666">&lt;</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">+</span> D<span style="color: #666666">/4.</span> <span style="color: #AA22FF; font-weight: bold">and</span> \ 
               <span style="color: #666666">-</span>W<span style="color: #666666">/4.</span> <span style="color: #666666">&lt;</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> W<span style="color: #666666">/4.</span>:
                material <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">elif</span> d <span style="color: #666666">==</span> <span style="color: #666666">3</span>:
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">&lt;</span> x[d<span style="color: #666666">-1</span>] <span style="color: #666666">&lt;</span> <span style="color: #666666">-</span>D<span style="color: #666666">/2.</span> <span style="color: #666666">+</span> D<span style="color: #666666">/4.</span> <span style="color: #AA22FF; font-weight: bold">and</span> \ 
               <span style="color: #666666">-</span>W<span style="color: #666666">/4.</span> <span style="color: #666666">&lt;</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> W<span style="color: #666666">/4.</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #666666">-</span>W<span style="color: #666666">/4.</span> <span style="color: #666666">&lt;</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;</span> W<span style="color: #666666">/4.</span>:
                material <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> kappa_0 <span style="color: #008000; font-weight: bold">if</span> material <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">else</span> kappa_1
</pre></div>
<p>
The <code>eval</code> method gives great flexibility in defining functions,
but a downside is that C++ calls up <code>eval</code> in Python for
each point <code>x</code>, which is a slow process, and the number of calls
is proportional to the number of nodes in the mesh.
Function expressions in terms of strings are compiled to efficient
C++ functions, being called from C++, so we should try to express functions
as string expressions if possible. (The <code>eval</code> method can also be
defined through C++ code, but this is much
more complicated and not covered here.)
Using inline if-tests in C++, we can make string expressions for
\( \kappa \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">kappa_str <span style="color: #666666">=</span> {}
kappa_str[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;x[0] &gt; -D/2 &amp;&amp; x[0] &lt; -D/2 + D/4 ? kappa_1 : kappa_0&#39;</span>
kappa_str[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\ 
               <span style="color: #BA2121">&#39;&amp;&amp; x[1] &gt; -D/2 &amp;&amp; x[1] &lt; -D/2 + D/4 ? &#39;</span>\ 
               <span style="color: #BA2121">&#39;kappa_1 : kappa_0&#39;</span>
kappa_str[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\ 
               <span style="color: #BA2121">&#39;x[1] &gt; -W/4 &amp;&amp; x[1] &lt; W/4 &#39;</span>\ 
               <span style="color: #BA2121">&#39;&amp;&amp; x[2] &gt; -D/2 &amp;&amp; x[2] &lt; -D/2 + D/4 ?&#39;</span>\ 
               <span style="color: #BA2121">&#39;kappa_1 : kappa_0&#39;</span>

kappa <span style="color: #666666">=</span> Expression(kappa_str[d],
                   D<span style="color: #666666">=</span>D, W<span style="color: #666666">=</span>W, kappa_0<span style="color: #666666">=</span>kappa_0, kappa_1<span style="color: #666666">=</span>kappa_1)
</pre></div>
<p>
Let <code>T</code> denote the unknown spatial temperature function at the
current time level, and let <code>T_1</code> be the corresponding function
at one earlier time level.
We are now ready to define the initial condition and the
<code>a</code> and <code>L</code> forms of our problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T_prev <span style="color: #666666">=</span> interpolate(Constant(T_R), V)

rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>
c <span style="color: #666666">=</span> <span style="color: #666666">1</span>
period <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>omega
t_stop <span style="color: #666666">=</span> <span style="color: #666666">5*</span>period
dt <span style="color: #666666">=</span> period<span style="color: #666666">/20</span>  <span style="color: #408080; font-style: italic"># 20 time steps per period</span>
theta <span style="color: #666666">=</span> <span style="color: #666666">1</span>

T <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
a <span style="color: #666666">=</span> rho<span style="color: #666666">*</span>c<span style="color: #666666">*</span>T<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>kappa<span style="color: #666666">*</span>\ 
    inner(nabla_grad(T), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> (rho<span style="color: #666666">*</span>c<span style="color: #666666">*</span>T_prev<span style="color: #666666">*</span>v <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f<span style="color: #666666">*</span>v <span style="color: #666666">-</span>
     (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>kappa<span style="color: #666666">*</span>inner(nabla_grad(T_1), nabla_grad(v)))<span style="color: #666666">*</span>dx

A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> <span style="color: #008000">None</span>  <span style="color: #408080; font-style: italic"># variable used for memory savings in assemble calls</span>
T <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># unknown at the current time level</span>
</pre></div>
<p>
We could, alternatively, break <code>a</code> and <code>L</code> up in subexpressions
and assemble a mass matrix and stiffness matrix, as exemplified in
the section <a href="#tut:timedep:diffusion1:noassemble">Avoiding assembly</a>, to avoid
assembly of <code>b</code> at every time level. This modification is
straightforward and left as an exercise. The speed-up can be significant
in 3D problems.

<p>
The time loop is very similar to what we have displayed in
the section <a href="#tut:timedep:diffusion1:impl">Implementation</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T <span style="color: #666666">=</span> Function(V)   <span style="color: #408080; font-style: italic"># unknown at the current time level</span>
t <span style="color: #666666">=</span> dt
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;=</span> t_stop:
    b <span style="color: #666666">=</span> assemble(L, tensor<span style="color: #666666">=</span>b)
    T_0<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
    bc<span style="color: #666666">.</span>apply(A, b)
    solve(A, T<span style="color: #666666">.</span>vector(), b)
    <span style="color: #408080; font-style: italic"># visualization statements</span>
    t <span style="color: #666666">+=</span> dt
    T_prev<span style="color: #666666">.</span>assign(T)
</pre></div>
<p>
The complete code in <code>sin_daD.py</code> contains several
statements related to visualization and animation of the solution, both as a
finite element field (<code>plot</code> calls) and as a curve in the
vertical direction. The code also plots the exact analytical solution,

$$
T(x,t) = T_R + T_Ae^{ax}\sin (\omega t + ax),\quad a =\sqrt{\omega\varrho c\over 2\kappa},
$$

which is valid when \( \kappa = \kappa_0=\kappa_1 \).

<p>
Implementing this analytical solution as a Python function
taking scalars and numpy arrays as arguments requires a word of caution.
A straightforward function like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">T_exact</span>(x):
    a <span style="color: #666666">=</span> sqrt(omega<span style="color: #666666">*</span>rho<span style="color: #666666">*</span>c<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>kappa_0))
    <span style="color: #008000; font-weight: bold">return</span> T_R <span style="color: #666666">+</span> T_A<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>sin(omega<span style="color: #666666">*</span>t <span style="color: #666666">+</span> a<span style="color: #666666">*</span>x)
</pre></div>
<p>
will not work and result in an error message from UFL. The reason is that
the names <code>exp</code> and <code>sin</code> are those imported
by the <code>from dolfin import *</code> statement, and these names
come from UFL and are aimed at being used in variational forms.
In the <code>T_exact</code> function where <code>x</code> may be a scalar or a
<code>numpy</code> array, we therefore need to explicitly specify
<code>numpy.exp</code> and <code>numpy.sin</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">T_exact</span>(x):
    a <span style="color: #666666">=</span> sqrt(omega<span style="color: #666666">*</span>rho<span style="color: #666666">*</span>c<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>kappa_0))
    <span style="color: #008000; font-weight: bold">return</span> T_R <span style="color: #666666">+</span> T_A<span style="color: #666666">*</span>numpy<span style="color: #666666">.</span>exp(a<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>numpy<span style="color: #666666">.</span>sin(omega<span style="color: #666666">*</span>t <span style="color: #666666">+</span> a<span style="color: #666666">*</span>x)
</pre></div>
<p>
The complete code is found in the file
The reader
is encouraged to play around with the code and test out various parameter
sets:

<ol>
 <li> \( T_R=0 \), \( T_A=1 \), \( \kappa_0 = \kappa_1=0.2 \), \( \varrho = c = 1 \), \( \omega = 2\pi \)</li>
 <li> \( T_R=0 \), \( T_A=1 \), \( \kappa_0=0.2 \), \( \kappa_1=0.01 \), \( \varrho = c = 1 \), \( \omega = 2\pi \)</li>
 <li> \( T_R=0 \), \( T_A=1 \), \( \kappa_0=0.2 \), \( \kappa_1=0.001 \), \( \varrho = c = 1 \), \( \omega = 2\pi \)</li>
 <li> \( T_R=10 \) C, \( T_A=10 \) C, \( \kappa_0= 2.3 \hbox{ K}^{-1}\hbox{Ns}^{-1} \),
    \( \kappa_1= 100 \hbox{ K}^{-1}\hbox{Ns}^{-1} \),
    \( \varrho = 1500\hbox{ kg/m}^3 \),
    \( c = 1480\hbox{ Nm}\cdot\hbox{kg}^{-1}\hbox{K}^{-1} \),
    \( \omega = 2\pi/24 \) 1/h  \( = 7.27\cdot 10^{-5} \) 1/s, \( D=1.5 \) m</li>
 <li> As above, but \( \kappa_0= 12.3 \hbox{ K}^{-1}\hbox{Ns}^{-1} \) and
    \( \kappa_1= 10^4 \hbox{ K}^{-1}\hbox{Ns}^{-1} \)</li>
</ol>

Data set number 4 is relevant for real temperature variations in
the ground (not necessarily the large value of \( \kappa_1 \)),
while data set number 5
exaggerates the effect of a large heat conduction contrast so that
it becomes clearly visible in an animation.

<p>
<!-- kappa_1 = 1.1, varrho_1 = 1200, c_1 = 1000 => 9.17E-7 -->
<!-- kappa_0 = 2.3, varrho_0 = 1800, c_0 = 1500 => 8.52E-7 -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._ftut002.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="&laquo; Previous"></a></div>
</td><td>
<div style="text-align: right;"><a href="._ftut004.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="Next &raquo;"></a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

