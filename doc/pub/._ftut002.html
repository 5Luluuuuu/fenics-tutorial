<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Finite Element Programming - The FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,DOLFIN mesh,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Dirichlet boundary conditions,boundary specification (function),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,functionals,energy functional,error functional,flux functional,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,Neumann boundary conditions,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),dimension-independent code,time-dependent PDEs,assembly, increasing efficiency,heterogeneous medium,multi-material domain,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),Gateaux derivative,automatic differentiation,Jacobian, automatic computation,nonlinear variational problems,mesh transformations,coordinate stretching,coordinate transformations,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,installing FEniCS,troubleshooting,compilation problems,plotting problems">

<title>Introduction to Finite Element Programming - The FEniCS Tutorial</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u'To-do list', 1, None, '___sec0'),
              (u'HPL questions', 2, None, '___sec1'),
              (u'Iterative linear solvers info', 3, None, '___sec2'),
              (u'The mathematics of the model problem',
               1,
               u'tut:fundamentals',
               u'tut:fundamentals'),
              (u'The Poisson equation',
               2,
               u'tut:poisson1:bvp',
               u'tut:poisson1:bvp'),
              (u'Variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'Implementation of a Poisson solver',
               1,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'A simple code',
               2,
               u'tut:poisson1:impl:code',
               u'tut:poisson1:impl:code'),
              (u'Running the program',
               2,
               u'tut:poisson1:impl:run',
               u'tut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'tut:poisson1:impl:dissect',
               u'tut:poisson1:impl:dissect'),
              (u'The key import line', 3, None, '___sec10'),
              (u'Generating simple meshes', 3, None, '___sec11'),
              (u'Defining a function space corresponding to a mesh',
               3,
               None,
               '___sec12'),
              (u'Defining test and trial functions', 3, None, '___sec13'),
              (u'Specifying the boundary and boundary conditions',
               3,
               None,
               '___sec14'),
              (u'Specifying the right-hand side function',
               3,
               None,
               '___sec15'),
              (u'Specifying the variational formulation',
               3,
               None,
               '___sec16'),
              (u'Forming and solving the linear system', 3, None, '___sec17'),
              (u'Examining the values of the solution', 3, None, '___sec18'),
              (u'Plotting the solution', 3, None, '___sec19'),
              (u'Refactored implementation',
               2,
               u'tut:poisson1:impl2',
               u'tut:poisson1:impl2'),
              (u'A general solver function', 3, None, '___sec21'),
              (u'Plotting for the test problem', 3, None, '___sec22'),
              (u'Make a module!', 3, None, '___sec23'),
              (u'Verification', 3, None, '___sec24'),
              (u'Exercise 1: Solve a Poisson problem', 2, None, '___sec25'),
              (u'Remarks', 3, None, '___sec26'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec28'),
              (u'Linear algebra backend', 3, None, '___sec29'),
              (u'The `parameters` database', 3, None, '___sec30'),
              (u'An extended solver function', 3, None, '___sec31'),
              (u'Remark regarding unit tests', 3, None, '___sec32'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Deflection of a circular membrane',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'The problem', 3, None, '___sec36'),
              (u'Scaling', 3, None, '___sec37'),
              (u'Implementation', 3, None, '___sec38'),
              (u'Quick visualization with VTK',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec42'),
              (u'Modifications of the PDE solver', 3, None, '___sec43'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec44'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec46'),
              (u'Error functional', 3, None, '___sec47'),
              (u'Flux Functionals', 3, None, '___sec48'),
              (u'Computing convergence rates',
               2,
               u'tut:poisson1:convrates',
               u'tut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec50'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec51'),
              (u'Test problem', 3, None, '___sec52'),
              (u'Experiments', 3, None, '___sec53'),
              (u'Visualization of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec55'),
              (u'Finite difference approximations', 3, None, '___sec56'),
              (u'Surface plot', 3, None, '___sec57'),
              (u'Contour plot', 3, None, '___sec58'),
              (u'Curve plot through the mesh', 3, None, '___sec59'),
              (u'Curve plot of the flux', 3, None, '___sec60'),
              (u'Test problem', 3, None, '___sec61'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'A linear algebra formulation',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec66'),
              (u'Mesh', 3, None, '___sec67'),
              (u'Function space', 3, None, '___sec68'),
              (u'Function', 3, None, '___sec69'),
              (u'Time-dependent problems', 1, u'tut:timedep', u'tut:timedep'),
              (u'A diffusion problem and its discretization',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'Implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Avoiding assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'Nonlinear problems',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'Solving the nonlinear variational problem directly',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'Handling domains with different materials',
               1,
               None,
               '___sec83'),
              (u'Working with two subdomains',
               2,
               u'tut:possion:2D:2mat:problem',
               u'tut:possion:2D:2mat:problem'),
              (u'Implementation',
               2,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:mat:neumann',
               u'tut:poisson:mat:neumann'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'tut:possion:nD:nmat',
               u'tut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'tut:possion:nD:nmat:PDE',
               u'tut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'tut:possion:nD:nmat:prepro',
               u'tut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'tut:possion:nD:nmat:solve',
               u'tut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec91'),
              (u'Miscellaneous topics', 1, None, '___sec92'),
              (u'Glossary', 2, None, '___sec93'),
              (u'Overview of objects and functions', 2, None, '___sec94'),
              (u'User-defined functions',
               2,
               u'tut:app:cpp:functions',
               u'tut:app:cpp:functions'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Installing FEniCS',
               2,
               u'tut:app:install',
               u'tut:app:install'),
              (u'Books on the finite element method',
               2,
               u'tut:appendix:books',
               u'tut:appendix:books'),
              (u'Books on Python',
               2,
               u'tut:appendix:pybooks',
               u'tut:appendix:pybooks'),
              (u'Acknowledgments', 2, None, '___sec101'),
              (u'Troubleshooting', 1, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 2, None, '___sec103'),
              (u'Problems with the Instant cache', 3, None, '___sec104'),
              (u'Syntax errors in expressions', 3, None, '___sec105'),
              (u'Problems in the solve step', 3, None, '___sec106'),
              (u'Unable to convert object to a UFL form',
               3,
               None,
               '___sec107'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               3,
               None,
               '___sec108'),
              (u'All programs fail to compile', 3, None, '___sec109'),
              (u'Plotting Problems', 2, None, '___sec110'),
              (u'The plot disapperas quickly from the screen',
               3,
               None,
               '___sec111'),
              (u'Problems with Expression Objects', 2, None, '___sec112'),
              (u'There seems to be some bug in an Expression object',
               3,
               None,
               '___sec113'),
              (u'I get a segmentation fault when using an Expression object',
               3,
               None,
               '___sec114'),
              (u'Other Problems', 2, None, '___sec115'),
              (u'Only parts of the program are executed',
               3,
               None,
               '___sec116'),
              (u'I get an error in the definition of the boundary',
               3,
               None,
               '___sec117'),
              (u'The solver in a nonlinear problems does not converge',
               3,
               None,
               '___sec118'),
              (u'How To Debug a FEniCS Program?', 2, None, '___sec119'),
              (u'Bibliography', 1, None, '___sec120')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\tp}{\thinspace .}
\newcommand{\dt}{\Delta t}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">Introduction to Finite Element Programming - The FEniCS Tutorial</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>To-do list</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="#tut:fundamentals" style="font-size: 80%;"><b>The mathematics of the model problem</b></a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl" style="font-size: 80%;"><b>Implementation of a Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A simple code</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key import line</a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining a function space corresponding to a mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the boundary and boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the right-hand side function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 1: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a circular membrane</a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Quick visualization with VTK</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#tut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="#___sec48" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="#tut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Visualization of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec58" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A linear algebra formulation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#tut:timedep" style="font-size: 80%;"><b>Time-dependent problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#tut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A diffusion problem and its discretization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#tut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#tut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Avoiding assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#tut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson:nonlinear" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving the nonlinear variational problem directly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:prepro" style="font-size: 80%;"><b>Creating more complex domains</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec83" style="font-size: 80%;"><b>Handling domains with different materials</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:possion:2D:2mat:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with two subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson:mat:neumann" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:possion:nD:nmat" style="font-size: 80%;"><b>A General \( d \)-Dimensional multi-material test problem</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec91" style="font-size: 80%;"><b>More Examples</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec92" style="font-size: 80%;"><b>Miscellaneous topics</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:app:cpp:functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;User-defined functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:app:install" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Installing FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:appendix:books" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Books on the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#tut:appendix:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Books on Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Plotting Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disapperas quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I get a segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I get an error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec120" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0002"></a>
<!-- !split -->

<h1 id="___sec0">To-do list </h1>

<p>
Remember: cannot exceed 150 pages (as reported at the end of <code>ftut.log</code>).
Solutions to exercises will not appear in the printed book. If we run
out of pages, we can also remove the exercises by putting if-else
constructs around them. There will be one short printed tutorial and
then extended e-versions with exercises (and optionally solution) on our
github web site.

<p>
Regarding layout, we must use <code>svmono.cls</code> for the printed book, but
are allowed to use gray background in code boxes and lmodern instead
of Courier for monospace font. Springer's official ebook has exactly
the same layout. For all other versions on our github
web site, we can choose whatever layout we want.

<ul>
 <li> Reorganize sections into chapters. (HPL)</li>
 <li> Rethink how to organize example programs in directories.
   Find a naming convention. (AL)
   HPL suggestion: Drop the <code>stationary</code> and <code>transient</code> directories,
   have at most separate directories for each PDE.</li>
 <li> Programs are now flat demos. Educate the reader with
   better software engineering habits: functions, classes, unit tests.
   Avoid copy-and-edit flat programs implied by today's collection. (HPL)</li>
 <li> Compute maximum error already in the first example so we can create
   a unit test as early as possible. (Done, HPL)</li>
 <li> Find successful exercises from various tutorials (AL) and add as
   exercises in the book (HPL/AL). Exercises are key for learning
   software so having them (in an extended version?) sends an important
   signal about their relevance.</li>
 <li> Write about installation in a way that does not get outdated.
   More as a guide to a newcomer: What to choose? (AL)</li>
 <li> Multi-boundary examples do not work with FEniCS 1.6: <code>dnr*.py</code>. (AL)</li>
 <li> <code>membrane2.py</code> referred to, but it is still in sandbox. (HPL)</li>
 <li> Meshr domains. Set up some common continuum mechanics examples first. (HPL/AL)</li>
 <li> Decide on an elasticity problem.</li>
 <li> Simple Navier-Stokes solver. Do backward facing step and flow around a
   cylinder.</li>
 <li> According to the <code>plot</code> doc string, it should be easy to
   plot the element a la <code>plot(u.function_space().ufl_element())</code> but I
   did not get this to work. Not crucial, but plotting the element is a
   nice feature :-)</li>
 <li> Show how the definition of boundaries can be done via strings
   compiled to C++ (as soon as we have an example with non-trivial
   boundary segments), cf. Navier-Stokes FEniCS demo.</li>
 <li> Can we change the value of <code>DOLFIN_EPS</code>? <code>imort dolfin; dolfin.DOLFIN_EPS=...</code> will work, but then all modules in the simulator must do <code>import dolfin</code>. Note that its value is very strict, e.g., <code>10.1+10.2</code> has rounding \( 3.5 10^{-15} \), so <code>DOLFIN_EPS</code> is strictly for scaled problems only where all variables are in \( [0,1] \).</li>

<ul>
  <li> Comment regarding FEniCS demos: The documented demos mention a lot
    of packages: DOLFIN, FFC, Fiat, ... Make sure the reader of the tutorial
    does not get lost in the jungle of packages and make sure this is
    explained somewhere such that the tutorial is a good background for
    understanding every demo in every detail.</li>
</ul>

</ul>

<h2 id="___sec1">HPL questions </h2>

<h3 id="___sec2">Iterative linear solvers info </h3>

<p>
We can get this printed out on the screen, but is there any method to
extract this text inside the program, such that we can see how many
Krylov iterations we do etc.? Any way for Python to capture the standard
output stream in C++?

<p>
Easy to write a script that post-processes
the output, but we have to wait until the simulator has terminated, or
we can pipe to a script <code>process.py</code> that treats the output in some
desired way (could append some into to a file and that is reopened
by the simulator):

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python mysolver.py | process.py
</pre></div>
<p>
where the simplest <code>process.py</code> is

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">time</span>
t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">True</span>:
    line <span style="color: #666666">=</span> sys<span style="color: #666666">.</span>stdin<span style="color: #666666">.</span>readline()
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> line:
        <span style="color: #008000; font-weight: bold">break</span>
    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;after </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> seconds: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t1<span style="color: #666666">-</span>t0, line<span style="color: #666666">.</span>rstrip())
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;END&#39;</span>
</pre></div>
<p>
FEniCS is a user-friendly tool for solving partial differential
equations (PDEs). The goal of this tutorial is to get you started with
FEniCS through a series of simple examples that demonstrate

<ul>
  <li> how to define the PDE problem in terms of a variational problem,</li>
  <li> how to define simple domains,</li>
  <li> how to deal with Dirichlet, Neumann, and Robin conditions,</li>
  <li> how to deal with variable coefficients,</li>
  <li> how to deal with domains built of several materials (subdomains),</li>
  <li> how to compute derived quantities like the flux vector field or
    a functional of the solution,</li>
  <li> how to quickly visualize the mesh, the solution, the flux, etc.,</li>
  <li> how to solve nonlinear PDEs in various ways,</li>
  <li> how to deal with time-dependent PDEs,</li>
  <li> how to set parameters governing solution methods for linear systems,</li>
  <li> how to create domains of more complex shape.</li>
</ul>

The mathematics of the illustrations is kept simple to better focus
on FEniCS functionality and syntax. This means that we mostly use
the Poisson equation and the time-dependent diffusion equation
as model problems, often with input data adjusted such that we get
a very simple solution that can be exactly reproduced by any standard
finite element method over a uniform, structured mesh. This
latter property greatly simplifies the verification of the implementations.
Occasionally we insert a physically more relevant example
to remind the reader that changing the PDE and boundary
conditions to something more real might often be a trivial task.

<p>
<!-- With the fundamentals explained, we move on to physically more -->
<!-- complicated problems, including systems of PDEs, and show how to build -->
<!-- more complete simulation codes. -->

<p>
FEniCS may seem to require a thorough understanding of the abstract
mathematical version of the finite element method as well as
familiarity with the Python programming language.  Nevertheless, it
turns out that many are able to pick up the fundamentals of finite
elements <em>and</em> Python programming as they go along with this
tutorial. Simply keep on reading and try out the examples. You will be
amazed of how easy it is to solve PDEs with FEniCS!

<p>
Reading this tutorial obviously requires access to a machine where the
FEniCS software is installed. The section <a href="._ftut009.html#tut:app:install">Installing FEniCS</a> explains
briefly how to install the necessary tools.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Rethink how to organize program examples!)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 2</b>: Drop transient and stationary.)</font>
<!-- end inline comment -->

<p>
All the examples discussed in the following are available as
executable Python source code files in a <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src" target="_self">directory tree</a>.
File paths reflect the nature of the PDE problem being solved. For
example, <code>poisson/p2D_iter.py</code> has a descriptive directory
path and a very brief Unix-style filename (here <code>p2D</code> for Poisson 2D
problem, and <code>_iter</code> for a version with iterative linear solvers).

<p>
<b>The FEniCS version.</b>
This document is up-to-date with FEniCS version 1.6. To see which version
you have, run the following command in a Unix/Linux terminal window if
you run Python version 2.7:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;import dolfin; print dolfin.__version__&#39;
1.6.0
</pre></div>
<p>
In Python version 3.x you must write

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;import dolfin; print(dolfin.__version__)&#39;
1.6.0
</pre></div>
<p>
<b>The Python version.</b>
Python comes in two versions, 2 and 3, and these are not compatible.
FEniCS has a code base that runs under both versions.
All the programs in this tutorial are also developed such that they
can be run under both Python 2 and 3. Programs that need to print must
then start with

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function
</pre></div>
<p>
to  enable the <code>print</code> function from Python 3 in Python 2. All
use of <code>print</code> in the programs consists of function calls, like
<code>print('a:', a)</code>. Almost all other constructions are of a form that looks the
same in Python 2 and 3.

<h1 id="tut:fundamentals">The mathematics of the model problem</h1>

<h2 id="tut:poisson1:bvp">The Poisson equation</h2>

<p>
Let us start with a &quot;Hello, World!&quot; program in the world of PDEs - it
must be a program that solves the Laplace or Poisson equation.
Our first example regards the following Poisson problem,

$$
\begin{align}
- \nabla^2 u(\x) &= f(\x),\quad \x\mbox{ in } \Omega,
\tag{1}\\ 
u(\x) &= u_0(\x),\quad \x\mbox{ on } \partial \Omega\tp \tag{2}
\end{align}
$$

Here, \( u(\x) \) is the unknown function, \( f(\x) \) is a
prescribed function, \( \nabla^2 \) is the Laplace operator (also
often written as \( \Delta \)), \( \Omega \) is the spatial domain, and
\( \partial\Omega \) is the boundary of \( \Omega \). A stationary PDE like
this, together with a complete set of boundary conditions, constitute
a <em>boundary-value problem</em>, which must be precisely stated before
it makes sense to start solving it with FEniCS.

<p>
In two space dimensions with coordinates \( x \) and \( y \), we can write out
the Poisson equation as

$$
\begin{equation}
- {\partial^2 u\over\partial x^2} -
{\partial^2 u\over\partial y^2} = f(x,y)\tp
\tag{3}
\end{equation}
$$

The unknown \( u \) is now a function of two variables, \( u(x,y) \), defined
over a two-dimensional domain \( \Omega \).

<p>
The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier-Stokes equations.

<p>
Solving a physical problem with FEniCS consists of the following steps:

<ol>
 <li> Identify the PDE and its boundary conditions.</li>
 <li> Reformulate the PDE problem as a variational problem.</li>
 <li> Make a Python program where the formulas in the variational
    problem are coded, along with definitions of input data such as
    \( f \), \( u_0 \), and a mesh for the spatial domain \( \Omega \).</li>
 <li> Add statements in the program for solving the variational
    problem, computing derived quantities such as \( \nabla u \), and
    visualizing the results.</li>
</ol>

We shall now go through steps 2-4 in detail.  The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.

<h2 id="tut:poisson1:varform">Variational formulation</h2>

<p>
FEniCS makes it easy to solve PDEs if finite elements are used for
discretization in space and the problem is expressed as a <em>variational
problem</em>. Readers who are not familiar with variational problems will
get a brief introduction to the topic in this tutorial, but getting
and reading a proper book on the finite element method in addition is
encouraged.  The section <a href="._ftut009.html#tut:appendix:books">Books on the finite element method</a> contains a list of some
suitable books.

<p>
The core of the recipe for turning a PDE into a variational problem is
to multiply the PDE by a function \( v \), integrate the resulting
equation over \( \Omega \), and perform integration by parts of terms with
second-order derivatives. The function \( v \) which multiplies the PDE is
in the mathematical finite element literature called a <em>test
function</em>. The unknown function \( u \) to be approximated is referred to
as a <em>trial function</em>. The terms test and trial function are used in
FEniCS programs too.  Suitable function spaces must be specified for
the test and trial functions.  For standard PDEs arising in physics
and mechanics such spaces are well known.

<p>
In the present case, we first multiply the Poisson equation
by the test function \( v \) and integrate,

$$
\begin{equation}
\tag{4}
 -\int_\Omega (\nabla^2 u)v \dx = \int_\Omega fv \dx\tp \end{equation}
$$

Then we apply integration by parts to the integrand with
second-order derivatives,

$$
\begin{equation}
\tag{5}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds ,
\end{equation}
$$

where \( \frac{\partial u}{\partial n} \) is the derivative of \( u \) in the
outward normal direction at the boundary.  The test function \( v \) is
required to vanish on the parts of the boundary where \( u \) is known,
which in the present problem implies that \( v=0 \) on the whole boundary
\( \partial\Omega \).  The second term on the right-hand side of
<a href="#mjx-eqn-5">(5)</a> therefore vanishes.  From
<a href="#mjx-eqn-4">(4)</a> and <a href="#mjx-eqn-5">(5)</a> it
follows that

$$
\begin{equation}
\int_\Omega\nabla u\cdot\nabla v \dx = \int_\Omega fv \dx\tp
\tag{6}
\end{equation}
$$

This equation is supposed to hold for all \( v \) in some function space
\( \hat V \). The trial function \( u \) lies in some (possibly different)
function space \( V \).  We refer to <a href="#mjx-eqn-6">(6)</a> as the
<em>weak form</em> or <em>variational form</em> of the original boundary-value
problem <a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a>.

<p>
The proper statement of
our variational problem now goes as follows:
Find \( u \in V \) such that

$$
\begin{equation} \tag{7}
  \int_{\Omega} \nabla u \cdot \nabla v \dx =
  \int_{\Omega} fv \dx
  \quad \forall v \in \hat{V}.
\end{equation}
$$

The test and trial spaces \( \hat{V} \) and \( V \) are in the present
problem defined as

$$
\begin{align*}
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}, \\ 
     V      &= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}\tp
\end{align*}
$$

In short,
\( H^1(\Omega) \) is the mathematically well-known Sobolev space containing
functions \( v \) such that \( v^2 \) and \( ||\nabla v||^2 \) have finite integrals over
\( \Omega \). The solution of the underlying
PDE
must lie in a function space where also the derivatives are continuous,
but the Sobolev space \( H^1(\Omega) \) allows functions with discontinuous
derivatives.
This weaker continuity requirement of \( u \) in the variational
statement <a href="#mjx-eqn-7">(7)</a>,
caused by the integration by parts, has
great practical consequences when it comes to constructing
finite elements.

<p>
To solve the Poisson equation numerically, we need to transform the
continuous variational problem
<a href="#mjx-eqn-7">(7)</a>
to a discrete variational
problem. This is done by introducing <em>finite-dimensional</em> test and
trial spaces, often denoted as
\( \hat{V}_h\subset\hat{V} \) and \( V_h\subset{V} \). The
discrete variational problem reads:
Find \( u_h \in V_h \subset V \) such that

$$
\begin{equation} \tag{8}
  \int_{\Omega} \nabla u_h \cdot \nabla v \dx =
  \int_{\Omega} fv \dx
  \quad \forall v \in \hat{V}_h \subset \hat{V}\tp
\end{equation}
$$

The choice of \( \hat{V}_h \) and \( V_h \) follows directly from the
kind of finite elements we want to apply in our problem. For example,
choosing the well-known linear triangular element with three nodes
implies that
\( \hat V_h \) and \( V_h \) are the spaces of all piecewise linear functions
over a mesh of triangles,
where the functions in \( \hat V_h \)
are zero on the boundary
and those in \( V_h \) equal \( u_0 \) on the boundary.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>What we mean by the notation \( u \) and \( V \).</b>
The mathematics literature on variational problems writes \( u_h \) for
the solution of the discrete problem and \( u \) for the solution of the
continuous problem. To obtain (almost) a one-to-one relationship
between the mathematical formulation of a problem and the
corresponding FEniCS program, we shall use \( u \) for the solution of
the discrete problem and \( \uex \) for the exact solution of the
continuous problem, <em>if</em> we need to explicitly distinguish
between the two.

<p>
In most cases, we will introduce the PDE problem with
\( u \) as unknown, derive a variational equation \( a(u,v)=L(v) \) with \( u\in
V \) and \( v\in \hat V \), and then simply discretize the problem by saying
that we choose finite-dimensional spaces for \( V \) and \( \hat V \), without
adding any subscript to \( V \) or \( \hat V \). This
restriction of \( V \) simply implies that \( u \) becomes a discrete finite element
function.  In practice, this means that we turn our PDE problem into a
continuous variational problem, create a mesh and specify an element
type, and then let \( V \) correspond to this mesh and element choice.
Depending upon whether \( V \) is infinite- or finite-dimensional, \( u \)
will be the exact or approximate solution.
</div>


<p>
It turns out to be convenient to
introduce the following unified notation for linear weak forms:

$$
\begin{equation}
a(u, v) = L(v)\tp
\tag{9}
\end{equation}
$$

In the present problem we have that

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{10}\\ 
L(v) &= \int_{\Omega} fv \dx\tp  \tag{11}
\end{align}
$$

From the mathematics literature,
\( a(u,v) \) is known as a <em>bilinear form</em> and \( L(v) \) as a
<em>linear form</em>.
We shall in every linear problem we solve identify the terms with the
unknown \( u \) and collect them in \( a(u,v) \), and similarly collect
all terms with only known functions in \( L(v) \). The formulas for \( a \) and
\( L \) are then coded directly in the program.

<p>
To summarize, before making a FEniCS program for solving a PDE,
we must first perform two steps:

<ul>
  <li> Turn the PDE problem into a discrete
    variational problem: find \( u\in V \)
    such that \( a(u,v) = L(v)\quad\forall v\in \hat{V} \).</li>
  <li> Specify the choice of spaces (\( V \) and \( \hat V \)), which means
    specifying the mesh and type of finite elements.</li>
</ul>

<h1 id="tut:poisson1:impl">Implementation of a Poisson solver</h1>

<p>
The test problem so far has a general domain \( \Omega \) and general functions
\( u_0 \) and \( f \). For our first implementation we must decide on specific
choices of \( \Omega \), \( u_0 \), and \( f \).
It will be wise to construct a specific problem where we can easily
check that the computed solution is correct. Let us start with
specifying an exact solution \( \uex(x,y) \):

$$
\begin{equation}
\tag{12}
\uex(x,y) = 1 +x^2 + 2y^2
\end{equation}
$$

on some 2D domain.  By inserting <a href="#mjx-eqn-12">(12)</a> in
our Poisson problem, we find that \( \uex(x,y) \) is a solution if

$$ f(x,y) = -6,\quad u_0(x,y)=\uex(x,y)=1 + x^2 + 2y^2,$$

regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,

$$ \Omega = [0,1]\times [0,1] .$$

The reason for specifying the solution <a href="#mjx-eqn-12">(12)</a>
is that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution (\( u \)) with the exact
solution (\( \uex \)). These quantities should be equal
to machine precision <em>at the nodes</em>.
Test problems with this property will be frequently constructed
throughout this tutorial.

<h2 id="tut:poisson1:impl:code">A simple code</h2>

<p>
A FEniCS program for solving the Poisson equation in 2D with the given
choices of \( u_0 \), \( f \), and \( \Omega \) may look as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Find max error</span>
u0_Function <span style="color: #666666">=</span> interpolate(u0, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The complete code can be found in the file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_plain.py" target="_self"><tt>p2D_plain.py</tt></a> in the
directory <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson" target="_self"><tt>src/poisson</tt></a>.

<h2 id="tut:poisson1:impl:run">Running the program</h2>

<p>
To run the program <code>p2D_plain.py</code>, open a terminal window, move to
the directory containing the program and write

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python p2D_plain.py
</pre></div>
<p>
A plot window pops up showing how the solution \( u \) looks like as a surface.
With the left mouse button you can tilt the figure. Click <code>m</code> to bring
up the underlying mesh. Click <code>p</code> to save to a PNG file <code>dolfin_plot_0.png</code>
and <code>P</code> to save to a PDF file <code>dolfin_plot_1.pdf</code>. To kill the
plot window and terminate the application, click <code>Ctrl+q</code> (hold down
the <code>Ctrl</code> key and press <code>q</code>).
Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the surface and the mesh below.
Since \( u \) is a simple quadratic function,
constructed for testing our solver, the
surface looks quite boring.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig:ex1:u"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Plot of the solution in the first FEniCS example.  <!-- caption label: tut:poisson:2D:fig:ex1:u --> </p></center>
<p><img src="fig/ex1_u.png" align="bottom" width=600></p>
</center>

<h2 id="tut:poisson1:impl:dissect">Dissection of the program</h2>

<p>
We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the <a href="http://docs.python.org/tutorial/" target="_self">official Python tutorial</a> to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  the section <a href="._ftut009.html#tut:appendix:pybooks">Books on Python</a> lists some relevant Python books.

<p>
The listed FEniCS program defines a finite element mesh, the discrete
function spaces \( V \) and \( \hat{V} \) corresponding to this mesh and the
element type, boundary conditions for \( u \) (the function \( u_0 \)),
\( a(u,v) \), and \( L(v) \).  Thereafter, the unknown trial function \( u \) is
computed. Then we can compare the numerical and exact solution
as well as investigate \( u \) visually.

<h3 id="___sec10">The key import line </h3>

<p>
The first line in the program,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
imports the key classes <code>UnitSquareMesh</code>, <code>FunctionSpace</code>, <code>Function</code>,
and so forth, from the DOLFIN library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line. DOLFIN is a software library with efficient and convenient C++
classes for finite element computing, and <code>dolfin</code> is a Python package
providing access to this C++ library from Python programs.  You can
think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <code>from dolfin import *</code> statement
imports other components too, but newcomers to FEniCS programming do
not need to care about this.

<h3 id="___sec11">Generating simple meshes </h3>

<p>
The statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">6</span>, <span style="color: #666666">4</span>)
</pre></div>
<p>
defines a uniform finite element mesh over the unit square
\( [0,1]\times [0,1] \). The mesh consists of <em>cells</em>, which are triangles
with straight sides. The parameters 6 and 4 tell that the square is
first divided into \( 6\times 4 \) rectangles, and then each rectangle is
divided into two triangles. The total number of triangles then becomes
48. The total number of vertices in this mesh is \( 7\cdot 5=35 \).
DOLFIN offers some classes for creating meshes over very simple
geometries. For domains of more complicated shape one needs to use a
separate <em>preprocessor</em> program to create the mesh.  The FEniCS
program will then read the mesh from file.

<h3 id="___sec12">Defining a function space corresponding to a mesh </h3>

<p>
Having a mesh, we can define a discrete function space <code>V</code> over this mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.  The
type of element is here &quot;Lagrange&quot;, implying the standard Lagrange
family of elements.  (Some FEniCS programs use <code>'CG'</code>, for Continuous
Galerkin, as a synonym for <code>'Lagrange'</code>.)  With degree 1, we simply
get the standard linear Lagrange element, which is a triangle with
nodes at the three vertices.  Some finite element practitioners refer
to this element as the &quot;linear triangle&quot; or the P1 element.  The
computed \( u \) will be continuous and linearly varying in \( x \) and \( y \)
over each cell in the mesh.  Higher-degree polynomial approximations
over each cell are trivially obtained by increasing the third
parameter in <code>FunctionSpace</code>, which will then generate P2, P3, and so
forth, type of elements. Changing the second parameter to <code>'DG'</code>
creates a function space for discontinuous Galerkin methods.

<h3 id="___sec13">Defining test and trial functions </h3>

<p>
In mathematics, we distinguish between the trial and test spaces \( V \)
and \( \hat{V} \). The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <code>V</code> for the and trial and test functions in the
program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
</pre></div>

<h3 id="___sec14">Specifying the boundary and boundary conditions </h3>

<p>
The next step is to specify the boundary condition: \( u=u_0 \) on
\( \partial\Omega \). This is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)
</pre></div>
<p>
where <code>u0</code> is an instance holding the \( u_0 \) values, and <code>u0_boundary</code>
is a function (or object) describing whether a point lies on the
boundary where \( u \) is specified.

<p>
Boundary conditions of the type \( u=u_0 \) are known as <em>Dirichlet
conditions</em>, and also as <em>essential boundary conditions</em> in a finite
element context.  Naturally, the name of the DOLFIN class holding the
information about Dirichlet boundary conditions is <code>DirichletBC</code>.

<p>
The <code>u0</code> variable refers to an <code>Expression</code> object, which is used to
represent a mathematical function. The typical construction is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(formula)
</pre></div>
<p>
where <code>formula</code> is a string containing the mathematical expression.
This formula is written with C++ syntax (the expression is
automatically turned into an efficient, compiled C++ function, see
the section <a href="._ftut009.html#tut:app:cpp:functions">User-defined functions</a> for details on the syntax). The
independent variables in the function expression are supposed to be
available as a point vector <code>x</code>, where the first element <code>x[0]</code>
corresponds to the \( x \) coordinate, the second element <code>x[1]</code> to the
\( y \) coordinate, and (in a three-dimensional problem) <code>x[2]</code> to the \( z \)
coordinate. With our choice of \( u_0(x,y)=1 + x^2 + 2y^2 \), the formula
string must be written as <code>1 + x[0]*x[0] + 2*x[1]*x[1]</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
</pre></div>
<p>
The information about where to apply the <code>u0</code> function as boundary
condition is coded in a function <code>u0_boundary</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary
</pre></div>
<p>
A function like <code>u0_boundary</code> for marking the boundary must return a
boolean value: <code>True</code> if the given point <code>x</code> lies on the Dirichlet
boundary and <code>False</code> otherwise.  The argument <code>on_boundary</code> is <code>True</code>
if <code>x</code> is on the physical boundary of the mesh, so in the present
case, where we are supposed to return <code>True</code> for all points on the
boundary, we can just return the supplied value of <code>on_boundary</code>.  The
<code>u0_boundary</code> function will be called for every discrete point in the
mesh, which allows us to have boundaries where \( u \) are known also
inside the domain, if desired.

<p>
One can also omit the <code>on_boundary</code> argument, but in that case we need
to test on the value of the coordinates in <code>x</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>
</pre></div>
<p>
As for the formula in <code>Expression</code> objects, <code>x</code> in the <code>u0_boundary</code>
function represents a point in space with coordinates <code>x[0]</code>, <code>x[1]</code>,
etc. Comparing floating-point values using an exact match test with
<code>==</code> is not good programming practice, because small round-off errors
in the computations of the <code>x</code> values could make a test <code>x[0] == 1</code>
become false even though <code>x</code> lies on the boundary.  A better test is
to check for equality with a tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> \ 
           <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol
</pre></div>

<h3 id="___sec15">Specifying the right-hand side function </h3>

<p>
Before defining \( a(u,v) \) and \( L(v) \) we have to specify the \( f \) function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-6&#39;</span>)
</pre></div>
<p>
When \( f \) is constant over the domain, <code>f</code> can be
more efficiently represented as a <code>Constant</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
</pre></div>

<h3 id="___sec16">Specifying the variational formulation </h3>

<p>
Now we have all the objects we need in order to specify this problem's
\( a(u,v) \) and \( L(v) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
</pre></div>
<p>
In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas \( \nabla u\cdot\nabla v \dx \) and \( fv \dx \).  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.  The language used to express weak
forms is called UFL (Unified Form Language) and is an integral part of
FEniCS.

<p>
Instead of <code>nabla_grad</code> we could also just have written <code>grad</code> in the
examples in this tutorial. However, when taking gradients of vector
fields, <code>grad</code> and <code>nabla_grad</code> differ. The latter is consistent with
the tensor algebra commonly used to derive vector and tensor PDEs,
where \( \nabla \) (&quot;nabla&quot;) acts as a vector operator, and therefore
this author prefers to always use <code>nabla_grad</code>.

<h3 id="___sec17">Forming and solving the linear system </h3>

<p>
Having <code>a</code> and <code>L</code> defined, and information about essential
(Dirichlet) boundary conditions in <code>bc</code>, we can compute the solution,
a finite element function <code>u</code>, by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)
</pre></div>
<p>
Some prefer to replace <code>a</code> and <code>L</code> by an <code>equation</code>
variable, which is accomplished by this equivalent code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">equation <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">==</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
u <span style="color: #666666">=</span> Function(V)
solve(equation, u, bc)
</pre></div>
<p>
Note that we first defined the variable <code>u</code> as a <code>TrialFunction</code> and
used it to represent the unknown in the form <code>a</code>.  Thereafter, we
redefined <code>u</code> to be a <code>Function</code> object representing the solution,
i.e., the computed finite element function \( u \).  This redefinition of
the variable <code>u</code> is possible in Python and often done in FEniCS
applications. The two types of objects that <code>u</code> refers to are equal
from a mathematical point of view, and hence it is natural to use the
same variable name for both objects. In a program, however,
<code>TrialFunction</code> objects must always be used for the unknowns in the
problem specification (the form <code>a</code>), while <code>Function</code> objects must be
used for quantities that are computed (known).

<h3 id="___sec18">Examining the values of the solution </h3>

<p>
The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to &quot;prove&quot; that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed <code>u</code> function to <code>u0</code>.

<p>
A finite element function like \( u \) is expressed as a linear combination
of basis functions \( \phi_j \), spanning the space \( V \):

$$
\begin{equation}
u = \sum_{j=1}^N U_j \phi_j \tag{13}\tp
\end{equation}
$$

By writing <code>solve(a == L, u, bc)</code> in the program, a linear system
will be formed from \( a \) and \( L \), and this system is solved for the
\( U_1,\ldots,U_N \) values. The \( U_1,\ldots,U_N \) values are known
as <em>degrees of freedom</em> of \( u \). For Lagrange elements (and many other
element types) \( U_k \) is simply the value of \( u \) at the node
with global number \( k \).
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.

<p>
Having <code>u</code> represented as a <code>Function</code> object, we can either evaluate
<code>u(x)</code> at any point <code>x</code> in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values \( U_j \) directly by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_nodal_values <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
</pre></div>
<p>
The result is a DOLFIN <code>Vector</code> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<code>Vector</code> object to a standard <code>numpy</code> array for further
processing:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_array <span style="color: #666666">=</span> u_nodal_values<span style="color: #666666">.</span>array()
</pre></div>
<p>
With <code>numpy</code> arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: <code>u_array[i]</code>,
where the index <code>i</code> always starts at <code>0</code>. However, <code>i</code> corresponds
to \( u \) at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the mesh, see the section <a href="#tut:poisson1:verify1">Writing out the discrete solution</a>
for details.

<p>
For now, we want to check that the values in <code>u_array</code> are correct:
they should equal our <code>u0</code> function. The most natural approach is
to interpolate our <code>u0</code> expression onto our space
(i.e., the finite element mesh),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_Function <span style="color: #666666">=</span> interpolate(u0, V)
</pre></div>
<p>
The <code>interpolate</code> function returns a <code>Function</code> object, whose degrees
of freedom values can be obtained by <code>.vector().array()</code>.  Our goal is
to show that the degrees of freedom arrays of <code>u</code> and <code>u0_Function</code>
are equal. One safe of doing this is to compute the maximum error,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How to check that the error vanishes?</b>
With inexact arithmetics, as we always have on a computer,
this maximum error is not zero, but should be a small number.
The machine precision is about \( 10^{-16} \), but in finite element
calculations, rounding errors of this size may accumulate, so
the expected accuracy of <code>max_error</code> smaller. Experiments show
that increasing the number of elements and increasing the degree
of the finite element polynomials increase <code>max_error</code>.
For a mesh with \( 2(20\times 20) \) cubic Lagrange elements (degree 3)
<code>max_error</code> is about \( 2\cdot 10^{-12} \), while for 18 linear elements
the maximum error is about \( 2\cdot 10^{-15} \).
</div>


<h3 id="___sec19">Plotting the solution </h3>

<p>
The simplest way of quickly looking at <code>u</code> is to say

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #408080; font-style: italic"># or</span>
plot(u)
interactive()
</pre></div>
<p>
Clicking on <code>Help</code> in the plot windows brings up a list of commands.
For example, typing <code>m</code> brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click <code>Ctrl+q</code> to kill the plot window and
continue execution beyond the <code>plot(u, interactive=True)</code> command or
<code>interactive()</code>.  Figure <a href="#tut:poisson:2D:fig:ex1:u">1</a> displays the
resulting \( u \) function.

<p>
Plotting both the solution and the mesh is accomplished by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(u)
plot(mesh)
<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
Type <code>Ctrl+w</code> to kill all plot windows and continue execution.

<p>
It is also possible to dump the computed solution to file, e.g., in the
VTK format:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;poisson.pvd&#39;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
</pre></div>
<p>
The <code>poisson.pvd</code> file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The <code>plot</code> function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.

<h2 id="tut:poisson1:impl2">Refactored implementation</h2>

<p>
Our initial program above is &quot;flat&quot;. That is, it is not organized into
logical, reusable units in terms of Python functions. Such flat programs are
popular for quickly testing out some software, but not well suited for
serious problem solving. We shall therefore at once <em>refactor</em> the program,
meaning that we divide it into functions, but this is just a
reordering of the existing statements. During refactoring, we try
make functions as reusable as possible in other contexts, but
statements specific to a certain problem or task are also encapsulated
in (non-reusable) functions.
Being able to distinguish reusable code from specialized code is a key issue
when refactoring code, and this ability depends on a good mathematical
understanding of the problem at hand (&quot;what is general, what is special?&quot;).
In a flat program, general and specialized code (and mathematics)
is often mixed together.

<h3 id="___sec21">A general solver function </h3>

<p>
Some of the code in the previous flat program are needed to solve any
Poisson problem \( -\nabla^2 u=f \) on \( [0,1]\times [0,1] \) with \( u=u_0 \) on
the boundary. Let us collect this code in a reusable function
<code>solver</code>.  Our special test problem will then just be an application
of <code>solver</code> with some additional statements.
We limit the <code>solver</code> function to just <em>compute the numerical
solution</em>. Plotting and comparing the solution with the exact solution
are considered to be problem-specific activities to be performed elsewhere.

<p>
We parameterize <code>solver</code> by \( f \), \( u_0 \), and the
resolution of the mesh. Since it is so trivial to use higher-order
finite element functions by changing the third argument to
<code>FunctionSpace</code>, we let also the degree of the polynomials in the
finite element basis functions be an argument to <code>solver</code>.

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: The refactoring extends functionality. Should we be strict and keep linear elements? The test is better when it tests the degree parameter as well...)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u0 (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>

<h3 id="___sec22">Plotting for the test problem </h3>

<p>
The additional tasks we did in our initial program can be placed in
other functions. For example, plotting the solution in our particular
test problem is placed in an
<code>application_test</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_test</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solution in the test problem.&quot;&quot;&quot;</span>
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    u <span style="color: #666666">=</span> solver(f, u0, <span style="color: #666666">6</span>, <span style="color: #666666">4</span>, <span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
    plot(u)
</pre></div>

<h3 id="___sec23">Make a module! </h3>

<p>
The refactored code is put in a file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_func.py" target="_self"><tt>p2D_func.py</tt></a>. We should make
sure that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program should appear with a test
<code>if __name__ == '__main__':</code>. This test is true if the file is executed
as a program, but false if the file is imported.
If we want to run this file in the same way as we can
run <code>p2D_func.py</code>, the main program is simply a call to
<code>application_test()</code> followed by a call <code>interactive()</code> to hold the plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    application_test()
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>

<h3 id="___sec24">Verification </h3>

<p>
The remaining part of our first program is to compare the numerical and
the exact solution. Every time we edit the code we must rerun the test
and examine that <code>max_error</code> is sufficiently small so we know that the
code still works. To this end, we shall adopt <em>unit testing</em>, meaning
that we create a mathematical test and corresponding software that
can run all our tests automatically and check that all tests pass.
Python has several tools for unit testing. Two very popular ones are
pytest and nose. These are almost identical and very easy to use.
More classical unit testing with test classes is offered by the built-in
tool <code>unittest</code>, but here we are going to use pytest (or nose) since it demands
shorter and clearer code.

<p>
Mathematically, our unit test is that the finite element solution of
our problem when \( f=-6 \) equals the exact solution \( u=u_0=1+x^2+2y^2 \).
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which depends
to the number of elements and the degrees of the polynomials in the finite
element basis functions. In the section <a href="#tut:poisson1:impl:dissect">Dissection of the program</a> we
reported some experiments with the size of the maximum error. If we want
to test that <code>solver</code> works for meshes up to \( 2(20\times 20) \) elements
and cubic Lagrange elements, \( 10^{-11} \) is
an appropriate tolerance for testing that the maximum error vanishes.

<p>
Only three statements are necessary to carry out the unit test. However,
we shall embed these statements in software that the testing frameworks
pytest and nose can recognize. This means that each unit test
must be placed in a function that

<ul>
 <li> has a name starting with <code>test_</code></li>
 <li> has no arguments</li>
 <li> implements the test as <code>assert success, msg</code></li>
</ul>

Regarding the last point, <code>success</code> is a boolean expression that is <code>False</code>
if the test fails, and in that case the string <code>msg</code> is written to the
screen. When the test fails, <code>assert</code> raises an <code>AssertionError</code> exception
in Python, otherwise the statement runs silently. The <code>msg</code> string is
optional, so <code>assert success</code> is the minimal test. In our case, we
will do <code>assert max_error &lt; tol</code>, where <code>tol</code> is the tolerance (\( 10^{-11} \))
mentioned above.

<p>
A proper <em>test function</em> for implementing this unit test in the pytest
or nose testing frameworks has the following form. Note that we perform
the test for different mesh resolutions and degrees of finite elements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-11</span>  <span style="color: #408080; font-style: italic"># This problem&#39;s precision</span>
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">3</span>,<span style="color: #666666">5</span>), (<span style="color: #666666">5</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">20</span>,<span style="color: #666666">20</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x) mesh with P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span>
                  <span style="color: #666666">%</span> (Nx, Ny, degree))
            u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree)
            <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u0</span>
            V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
            u0_Function <span style="color: #666666">=</span> interpolate(u0, V)  <span style="color: #408080; font-style: italic"># exact solution</span>
            <span style="color: #408080; font-style: italic"># Check that dof arrays are equal</span>
            u0_array <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
            max_error <span style="color: #666666">=</span> (u0_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> for 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh and degree=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>\ 
                  (max_error, Nx, Ny, degree)
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
We can at any time run

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; py.test -s -v p2D_func.py
</pre></div>
<p>
and the pytest tool will run all functions <code>test_*()</code> in the file and report
how the tests go.

<p>
We shall make it a habit in this book to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented. We dare to assert that this is the only serious way
do reliable computational science with FEniCS.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Print messages in test functions.</b>
The <code>assert</code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code>assert</code>
(as we do in the example above) such that it is clear that the
test really takes place.
(Note that <code>py.test</code> needs the <code>-s</code> option to show printout
from the test functions.)
</div>


<p>
The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section <a href="#tut:poisson:membrane">Deflection of a circular membrane</a>.  Information in the intermediate sections
can be studied on demand.

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec25">Exercise 1: Solve a Poisson problem </h2>

<p>
Solve the following problem

$$
\begin{align}
\nabla^2 u &= 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x)),
\quad\hbox{ in }\Omega = [0,1]\times [0,1]
\tag{14}\\ 
u &= 0\quad\hbox{ on }\partial\Omega
\tag{15}
\end{align}
$$

The exact solution is given by

$$ \uex = 2e^{-2x}\sin(\pi x)\sin(\pi y)\tp$$

Compute the maximum numerical approximation error in a mesh with
\( 2(N_x\times N_y) \) elements and in a mesh with double resolution:
\( 4(N_x\times N_y) \) elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
(This is a good verification that the implementation is correct, but
note that the result requires sufficiently fine mesh - here
one may start with \( N_x=N_y=20 \).)
Make an illustrative plot of the solution too.

<p>
<b>a)</b>
Base your implementation on editing the program
<code>p2D_plain.py</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

<p>
In the string for an <code>Expression</code> object, <code>DOLFIN_PI</code> is the value of
\( \pi \). Also note that \( \pi^2 \) must be expressed with syntax
<code>pow(DOLFIN_PI,2)</code> and not (the common Python syntax) <code>DOLFIN_PI**2</code>.

<p>
FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <code>error:</code> in the
<code>/very/long/path/compile.log</code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>p2D_fsin_plain</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_2">

<p>
Looking at the <code>p2D_plain.py</code> code, we realize that
the following edits are required:

<ul>
 <li> Modify the <code>mesh</code> computation.</li>
 <li> Modify <code>u0</code> and <code>f</code>.</li>
 <li> Add expression for the exact solution.</li>
 <li> Modify the computation of the numerical error.</li>
 <li> Insert a loop to enable solving the problem twice.</li>
 <li> Put the error reduction computation and the plot statements after the loop.</li>
</ul>

Here is the modified code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">20</span>
error <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
    Nx <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)
    Ny <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

    <span style="color: #408080; font-style: italic"># Define boundary conditions</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>, pi<span style="color: #666666">=</span>DOLFIN_PI)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*DOLFIN_PI*x[0])*sin(DOLFIN_PI*x[1])&#39;</span>)

    u_e_Function <span style="color: #666666">=</span> interpolate(u_e, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
    u_e_array <span style="color: #666666">=</span> u_e_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
    max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
    error<span style="color: #666666">.</span>append(max_error)

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Error reduction:&#39;</span>, error[<span style="color: #666666">1</span>]<span style="color: #666666">/</span>error[<span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The number \( \pi \) has the symbol <code>M_PI</code> in C and C++, but in FEniCS C++
expressions the symbol <code>DOLFIN_PI</code> must be used. Above, we introduce
the variable <code>pi</code> in the expression for <code>f</code>, since we find it more
readable, and then we define <code>pi</code> as <code>DOLFIN_PI</code> as an extra parameter
to <code>Expression</code>. The alternative of using <code>DOLFIN_PI</code> inside the
string <code>f</code> gives a more difficult-to-read expression.

<p>
<center><p><img src="fig/p2D_fsin.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Base your implementation on a new file that imports functionality
from the module <code>p2D_func.py</code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code>p2D_fsin_func</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_3">

<p>
Solving the two problems is a matter of calling <code>solver</code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code>test_solver</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">p2D_func</span> <span style="color: #008000; font-weight: bold">import</span> (
    solver, Expression, Constant, interpolate, File, plot,
    interactive)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*DOLFIN_PI*x[0])*sin(DOLFIN_PI*x[1])&#39;</span>)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>, pi<span style="color: #666666">=</span>DOLFIN_PI)
    <span style="color: #008000; font-weight: bold">return</span> u0, f, u_e

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">20</span>
    Ny <span style="color: #666666">=</span> Nx
    error <span style="color: #666666">=</span> []
    <span style="color: #408080; font-style: italic"># Loop over refined meshes</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
        Nx <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        Ny <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
        u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>)
        <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u_e</span>
        V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
        u_e_array <span style="color: #666666">=</span> interpolate(u_e, V)<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># Linf norm</span>
        error<span style="color: #666666">.</span>append(max_error)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(error)):
        error_reduction <span style="color: #666666">=</span> error[i]<span style="color: #666666">/</span>error[i<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error reduction:&#39;</span>, error_reduction)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(error_reduction <span style="color: #666666">-</span> <span style="color: #666666">0.25</span>) <span style="color: #666666">&lt;</span> <span style="color: #666666">0.1</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">40</span>
    Ny <span style="color: #666666">=</span> Nx
    u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, <span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
    plot(u)

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    test_solver()
    application()
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>
<p>
The unit test is embedded in a proper test function <code>test_solver</code>
for the pytest or
nose testing frameworks. Visualization of the solution is encapsulated
in the <code>application</code> function. Since we need <code>u_e</code>, <code>u0</code>, and <code>f</code>
in two functions, we place the definitions in a function <code>data</code> to
avoid copies of these expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec26">Remarks </h3>

<p>
This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code>solver</code> function, requires <em>no modifications</em>
of the <code>p2D_func.py</code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code>p2D_func.py</code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension.

<p>
<!-- --- end exercise --- -->

<h2 id="tut:poisson1:solve:prm">Controlling the solution process</h2>

<p>
Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.
Consequently, we must tell you already now how you can take
advantage of state-of-the-art iterative solution methods in FEniCS.

<h3 id="___sec28">Setting linear solver parameters </h3>

<p>
Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite coefficient matrix, for
which the optimal Krylov solver is the Conjugate Gradient (CG)
method. However, the CG method requires boundary conditions to be
implemented in a symmetric way. This is not the case by default, so
then a Krylov solver for non-symmetric system, such as GMRES, is a
better choice.  Incomplete LU factorization (ILU) is a popular and
robust all-round preconditioner, so let us try the GMRES-ILU pair:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solve(a <span style="color: #666666">==</span> L, u, bc)
      solver_parameters<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                         <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>})
<span style="color: #408080; font-style: italic"># Alternative syntax</span>
solve(a <span style="color: #666666">==</span> L, u, bc,
      solver_parameters<span style="color: #666666">=</span><span style="color: #008000">dict</span>(linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;gmres&#39;</span>,
                             preconditioner<span style="color: #666666">=</span><span style="color: #BA2121">&#39;ilu&#39;</span>))
</pre></div>
<p>
the section <a href="._ftut009.html#tut:app:solver:prec">Linear solvers and preconditioners</a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.

<h3 id="___sec29">Linear algebra backend </h3>

<p>
The actual GMRES and ILU implementations that are brought into action
depends on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology.  PETSc is the default choice if DOLFIN is compiled
with PETSc, otherwise uBLAS.  Epetra (Trilinos), Eigen, MTL4 are other
supported backends.  Which backend to apply can be controlled by
setting

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>] <span style="color: #666666">=</span> backendname
</pre></div>
<p>
where <code>backendname</code> is a string, either <code>'Eigen'</code>, <code>'PETSc'</code>, <code>'uBLAS'</code>,
<code>'Epetra'</code>, or <code>'MTL4'</code>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear systems
of equations.

<p>
A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the
default linear algebra backend.  The default solver is sparse LU
decomposition (<code>'lu'</code>), and the actual software that is called is then
the sparse LU solver from UMFPACK (which PETSc has an interface
to). The available linear algebra backends in a FEniCS installation is
listed by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">list_linear_algebra_backends()
</pre></div>

<h3 id="___sec30">The <code>parameters</code> database </h3>

<p>
We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method.  Such parameters can be set by accessing the <em>global
parameter database</em>, which is called <code>parameters</code> and which behaves as
a nested dictionary. Write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">info(parameters, verbose<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code>info</code>.
According to this output, the relevant parameter set is
named <code>'krylov_solver'</code>, and the parameters are set like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>]  <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-10</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-6</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.

<p>
To get a printout of the number of actual iterations to reach the
stopping criterion, we can insert

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">set_log_level(PROGRESS)
<span style="color: #408080; font-style: italic"># or</span>
set_log_level(DEBUG)
</pre></div>
<p>
A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <code>PROGRESS</code>, while
<code>DEBUG</code> results in more information, including CPU time spent in
the various parts of the matrix assembly and solve process.

<p>
We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">File(<span style="color: #BA2121">&#39;dolfin_parameters.xml&#39;</span>) <span style="color: #666666">&lt;&lt;</span> parameters
</pre></div>
<p>
If a <code>dolfin_parameters.xml</code> file is found in the directory where a
FEniCS program is run, this file is read and used to initialize the
<code>parameters</code> object. Otherwise, the file
<code>.config/fenics/dolfin_parameters.xml</code> in the user's home directory is
read, if it exists.  Another alternative is to load the XML (with any
name) manually in the program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">File(<span style="color: #BA2121">&#39;dolfin_parameters.xml&#39;</span>) <span style="color: #666666">&gt;&gt;</span> parameters
</pre></div>
<p>
The XML file can also be in gzip'ed form with the extension <code>.xml.gz</code>.

<h3 id="___sec31">An extended solver function </h3>

<p>
Let us extend the previous solver function from
<code>p2D_func.py</code> such that it also offers the GMRES+ILU
preconditioned Krylov solver.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u0 (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solve(a <span style="color: #666666">==</span> L, u, bc, solver_parameters<span style="color: #666666">=</span>solver_parameters)
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_objects</span>(
    f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;As solver, but use objects for linear variational problem</span>
<span style="color: #BA2121; font-style: italic">    and solver.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bc)
    solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;linear_solver&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;gmres&#39;</span>
        solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;preconditioner&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ilu&#39;</span>
        prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solver<span style="color: #666666">.</span>solve()
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
This new <code>solver</code> function, found in the file
<code>p2D_iter.py</code>, replaces the one in <code>p2D_func.py</code>:
it has all the functionality of the previous <code>solver</code> function,
but can also solve the linear system with
iterative methods and report the progress of such solvers.

<h3 id="___sec32">Remark regarding unit tests </h3>

<p>
Regarding verification of the new <code>solver</code> function in terms of unit
tests, it turns out that unit testing in a problem where the
approximation error vanishes is gets more complicated when we use
iterative methods. The problem is to keep the error due to iterative
solution smaller than the tolerance used in the verification
tests. First of all this means that the tolerances used in the Krylov
solvers must be smaller than the tolerance used in the <code>assert</code> test,
but this is no guarantee to keep the linear solver error this small.
For linear elements and small meshes, a tolerance of \( 10^{-11} \) works
well in the case of Krylov solvers too (using a tolerance \( 10^{-12} \)
in those solvers. However, as soon as we switch to P2 elements, it is
hard to force the linear solver error below \( 10^{-6} \). Consequently,
tolerances in tests depend on the numerical methods. The interested
reader is referred to the <code>test_solver</code> function in
<code>p2D_iter.py</code> for details: this test function tests the
numerical solution for direct and iterative linear solvers, for
different meshes, and different degrees of the polynomials in the
finite element basis functions.

<h2 id="tut:poisson1:solver:problem">Linear variational problem and solver objects</h2>

<p>
The <code>solve(a == L, u, bc)</code> call is just a compact syntax alternative to a
slightly more comprehensive specification of the variational equation
and the solution of the associated linear system.  This alternative
syntax is used in a lot of FEniCS applications and will also be
used later in this tutorial, so we show it already now:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bc)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
Many objects have an attribute <code>parameters</code> corresponding to
a parameter set in the global <code>parameters</code> database,
but local to the object. Here, <code>solver.parameters</code> play that
role. Setting the CG method with ILU preconditioning as solution
method and specifying solver-specific parameters can be done
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;linear_solver&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;gmres&#39;</span>
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;preconditioner&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ilu&#39;</span>
prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Settings in the global <code>parameters</code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as done above.

<p>
The linear variational problem and solver objects as outlined above
are incorporated in an alternative solver function, named
<code>solver_objects</code>, in
<code>p2D_iter.py</code>. Otherwise, this function is parallel to the
previously shown <code>solver</code> function.

<h2 id="tut:poisson1:verify1">Writing out the discrete solution</h2>

<p>
We have seen how to grab the degrees of freedom array from a
finite element function <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_array <span style="color: #666666">=</span> `u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
The elements in <code>u_array</code> correspond to function values of <code>u</code> at nodes
in the mesh.  Now, a fundamental question is: What are the
coordinates of node <code>i</code> whose value is <code>u_array[i]</code>? To answer this
question, we need to understand how to get our hands on the
coordinates, and in particular, the numbering of degrees of freedom
and the numbering of vertices in the mesh. We start with P1 (1st order
Lagrange) elements where all the nodes are vertices in the mesh.

<p>
The function <code>mesh.coordinates()</code> returns the coordinates of the
vertices as a <code>numpy</code> array with shape \( (M,d \)), \( M \) being the number
of vertices in the mesh and \( d \) being the number of space dimensions:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
<span style="color: #666666">&gt;&gt;&gt;</span> coor
array([[ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">1.</span> ]])
</pre></div>
<p>
We see from this output that vertices are first numbered along \( y=0 \)
with increasing \( x \) coordinate, then along \( y=0.5 \), and so on.

<p>
Next we compute a function <code>u</code> on this mesh, e.g., the \( u=x+y \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> interpolate(Expression(<span style="color: #BA2121">&#39;x[0]+x[1]&#39;</span>), V)
<span style="color: #666666">&gt;&gt;&gt;</span> plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u_array <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
<span style="color: #666666">&gt;&gt;&gt;</span> u_array
array([ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ,  <span style="color: #666666">2.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">1.</span> ])
</pre></div>
<p>
We observe that <code>u_array[0]</code> is <em>not</em> the value of \( x+y \) at vertex number 0,
since this vertex has coordinates \( x=y=0 \). The numbering of the
degrees of freedom \( U_1,\ldots,U_{N} \) is obviously not the same as the
numbering of the vertices.

<p>
In the plot of <code>u</code>, type <code>w</code> to turn on wireframe instead of fully colored
surface, <code>m</code> to show the mesh, and then <code>v</code> to show the
numbering of the vertices.

<p>
<br />
<br />

<p>
<center><p><img src="fig/vertex_numbering.png" align="bottom" width=500></p></center>

<p>
<br />
<br />

<p>
The vertex values of a <code>Function</code> object can be extracted by
<code>u.compute_vertex_values()</code>, which returns an array where element <code>i</code>
is the value of <code>u</code> at vertex <code>i</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: u_at_vertices[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121">u(</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
<span style="color: #666666">...</span>           (i, i, u_at_vertices[i], x, u(x)))
vertex <span style="color: #666666">0</span>: u_at_vertices[<span style="color: #666666">0</span>]<span style="color: #666666">=0</span>	u([ <span style="color: #666666">0.</span>  <span style="color: #666666">0.</span>])<span style="color: #666666">=8.46545e-16</span>
vertex <span style="color: #666666">1</span>: u_at_vertices[<span style="color: #666666">1</span>]<span style="color: #666666">=0.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.</span> ])<span style="color: #666666">=0.5</span>
vertex <span style="color: #666666">2</span>: u_at_vertices[<span style="color: #666666">2</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">1.</span>  <span style="color: #666666">0.</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">3</span>: u_at_vertices[<span style="color: #666666">3</span>]<span style="color: #666666">=0.5</span>	u([ <span style="color: #666666">0.</span>   <span style="color: #666666">0.5</span>])<span style="color: #666666">=0.5</span>
vertex <span style="color: #666666">4</span>: u_at_vertices[<span style="color: #666666">4</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.5</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">5</span>: u_at_vertices[<span style="color: #666666">5</span>]<span style="color: #666666">=1.5</span>	u([ <span style="color: #666666">1.</span>   <span style="color: #666666">0.5</span>])<span style="color: #666666">=1.5</span>
vertex <span style="color: #666666">6</span>: u_at_vertices[<span style="color: #666666">6</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">0.</span>  <span style="color: #666666">1.</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">7</span>: u_at_vertices[<span style="color: #666666">7</span>]<span style="color: #666666">=1.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">1.</span> ])<span style="color: #666666">=1.5</span>
vertex <span style="color: #666666">8</span>: u_at_vertices[<span style="color: #666666">8</span>]<span style="color: #666666">=2</span>	u([ <span style="color: #666666">1.</span>  <span style="color: #666666">1.</span>])<span style="color: #666666">=2</span>
</pre></div>
<p>
Alternatively, we can ask for the mapping from vertex numbering to degrees
of freedom numbering in the space \( V \):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v2d = vertex_to_dof_map(V)
</pre></div>
<p>
Now, <code>u_array[v2d[i]]</code> will give us the value of the
degree of freedom in <code>u</code> corresponding
to vertex <code>i</code> (<code>v2d[i]</code>). In particular, <code>u_array[v2d]</code> is an array
with all the elements in the same (vertex numbered) order as <code>coor</code>.
The inverse map, from degrees of freedom
number to vertex number is given by <code>dof_to_vertex_map(V)</code>, so
<code>coor[dof_to_vertex_map(V)]</code> results in an array of all the
coordinates in the same order as the degrees of freedom.

<p>
For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices.

<!-- begin inline comment -->
<font color="red">(<b>hpl 4</b>: Anders, is the following true?)</font>
<!-- end inline comment -->
 There is no simple way of getting the
coordinates associated with the non-vertex degrees of freedom, so
if we want to write out the values of a finite element solution,
the following code snippet does the task at the vertices, and this
will work for all kinds of Lagrange elements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compare_exact_and_numerical_solution</span>(Nx, Ny, degree<span style="color: #666666">=1</span>):
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    <span style="color: #408080; font-style: italic"># Grab exact and numerical solution at the vertices and compare</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    u0_Function <span style="color: #666666">=</span> interpolate(u0, V)
    u0_at_vertices <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>compute_vertex_values()
    u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
    coor <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">): error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span>
              <span style="color: #666666">%</span> (i, x[<span style="color: #666666">0</span>], x[<span style="color: #666666">1</span>],
                 u0_at_vertices[i] <span style="color: #666666">-</span> u_at_vertices[i]))
        <span style="color: #408080; font-style: italic"># Could compute u0(x) - u_at_vertices[i] but this</span>
        <span style="color: #408080; font-style: italic"># is much more expensive and gives more rounding errors</span>
    center <span style="color: #666666">=</span> (<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>)
    error <span style="color: #666666">=</span> u0(center) <span style="color: #666666">-</span> u(center)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical error at </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (center, error))
</pre></div>
<p>
As expected, the error is either identically zero or about \( 10^{-15} \) or
\( 10^{-16} \).

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Cheap vs expensive function evaluation.</b>
Given a <code>Function</code> object <code>u</code>, we can evaluate its values in various
ways:

<ol>
<li> <code>u(x)</code> for an arbitrary point <code>x</code></li>
<li> <code>u.vector().array()[i]</code> for degree of freedom number <code>i</code></li>
<li> <code>u.compute_vertex_values()[i]</code> at vertex number <code>i</code></li>
</ol>

The first method, though very flexible, is in general very expensive
while the other two are very efficient (but limited to certain points).
</div>


<p>
To demonstrate the use of point evaluations of <code>Function</code> objects,
we write out the computed <code>u</code> at the center point
of the domain and compare it with the exact solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">center <span style="color: #666666">=</span> (<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>)
error <span style="color: #666666">=</span> u0(center) <span style="color: #666666">-</span> u(center)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical error at </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (center, error)
</pre></div>
<p>
Trying a \( 2(3\times 3) \) mesh, the output from the
previous snippet becomes

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">numerical error at (0.5, 0.5): -0.0833333
</pre></div>
<p>
The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell,
and <code>u</code> varies linearly over the cell while
<code>u0</code> is a quadratic function. When the center point is a node, as in
a \( 2(t\times 2) \) or \( 2(4\times 4) \) mesh, the error is of the order
\( 10^{-15} \).

<p>
We have seen how to extract the nodal values in a <code>numpy</code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that \( \max_j U_j = 1 \). Then we
must divide all \( U_j \) values
by \( \max_j U_j \). The following function performs the task:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">normalize_solution</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Normalize u: return u divided by max(u).&quot;&quot;&quot;</span>
    u_array <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
    u_max <span style="color: #666666">=</span> u_array<span style="color: #666666">.</span>max()
    u_array <span style="color: #666666">/=</span> u_max
    u<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_array
    u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>set_local(u_array)  <span style="color: #408080; font-style: italic"># alternative</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
That is, we manipulate <code>u_array</code> as desired, and then we insert this
array into <code>u</code>'s <code>Vector</code> object.  The <code>/=</code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <code>u_array</code> are divided by the value <code>max_u</code>.
Alternatively, one could write <code>u_array = u_array/max_u</code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code>u_array</code>.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Be careful when manipulating degrees of freedom.</b>
A call like <code>u.vector().array()</code> returns a <em>copy</em> of the data in
<code>u.vector()</code>. One must therefore never perform assignments like
<code>u.vector.array()[:] = ...</code>, but instead extract the <code>numpy</code> array
(i.e., a copy), manipulate it, and insert it back with <code>u.vector()[:]
= </code> or <code>u.set_local(...)</code>.
</div>


<p>
All the code in this subsection can be found in the file <code>p2D_iter.py</code>
in the <code>poisson</code> directory.

<h2 id="tut:poisson:membrane">Deflection of a circular membrane</h2>

<p>
Perhaps you are not particularly amazed by viewing the simple surface
of \( u \) in the test problem from the section <a href="#tut:poisson1:impl">Implementation of a Poisson solver</a>.
However, solving a real physical problem
with a more interesting and amazing solution on the screen is only a
matter of specifying a more exciting domain, boundary condition,
and/or right-hand side \( f \).

<h3 id="___sec36">The problem </h3>

<p>
One possible physical problem regards the deflection \( D(x,y) \) of an
elastic circular membrane with radius \( R \), subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is

$$
\begin{equation}
-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},
\tag{16}
\end{equation}
$$

with

$$
\begin{equation}
p(x,y) = {A\over 2\pi\sigma}\exp{\left(
- {1\over2}\left( {x-x_0\over\sigma}\right)^2
- {1\over2}\left( {y-y_0\over\sigma}\right)^2
\right)}\, .
\tag{17}
\end{equation}
$$

Here, \( T \) is the tension in the membrane (constant), \( p \) is the external
pressure load,
\( A \) the amplitude of the pressure, \( (x_0,y_0) \) the localization of
the Gaussian pressure function, and \( \sigma \) the &quot;width&quot; of this
function. The boundary of the membrane has no
deflection, implying \( D=0 \) as boundary condition.

<p>
<!-- For scaling and verification it is convenient to simplify the problem -->
<!-- to find an analytical solution. In the limit \( \sigma\rightarrow\infty \), -->
<!-- \( p\rightarrow A/(2\pi\sigma) \) (constant pressure throughout \( \Omega \)), -->
<!-- and we can easily find an analytical solution -->
<!-- of the problem by integrating the Poisson equation in the -->
<!-- radial coordinate: \( r\in [0,R] \). The result becomes -->
<!-- \( D(r)=(r^2-R^2)A/(8\pi\sigma T) \). -->

<h3 id="___sec37">Scaling </h3>

<p>
The localization of the pressure, \( (x_0,y_0) \), is for simplicity
set to \( (0, R_0) \).
There are many physical parameters in this problem, and we can benefit
from grouping them by means of scaling. Let us introduce dimensionless
coordinates \( \bar x = x/R \), \( \bar y = y/R \), and a dimensionless
deflection \( w=D/D_c \), where \( D_c \) is a characteristic size of the
deflection. Introducing \( \bar R_0=R_0/R \), we get

$$ \frac{\partial^2 w}{\partial\bar x^2} +
\frac{\partial^2 w}{\partial\bar y^2}= \alpha
\exp{\left(
- \beta^2(\bar x^2
+ (\bar y-\bar R_0)^2)\right)}\hbox{ for } \bar x^2 + \bar y^2 < 1,$$

where

$$ \alpha = \frac{R^2A}{2\pi T D_c\sigma},\quad\beta = \frac{R}{\sqrt{2}\sigma}\tp$$

With an appropriate scaling, \( \bar w \) and its derivatives are of size
unity, so the left-hand side of the scaled PDE is about unity in size,
while the right-hand side has \( \alpha \) as its characteristic size.
This suggest choosing \( \alpha \) to be unity, or around unit.
We shall in particular choose \( \alpha=4 \). With this value,
the solution is \( w(\bar x,\bar y) = 1-\bar x^2 - \bar y^2 \).
(One can also find the analytical solution in scaled coordinates and show
that the maximum deflection \( D(0,0) \) is \( D_c \) if we choose \( \alpha=4 \)
to determine \( D_c \).)
With \( D_c=AR^2/(8\pi\sigma T) \)
and dropping the bars we get the scaled problem

$$
\begin{equation}
\nabla^2w = 4\exp{\left(
- \beta^2(x^2
+ (y-R_0)^2)\right)},
\tag{18}
\end{equation}
$$

to be solved over the unit circle with \( w=0 \) on the boundary.
Now there are only two parameters to vary: the dimensionless extent
of the pressure, \( \beta \), and the localization of the pressure peak, \( R_0\in [0,1] \).
As \( \beta\rightarrow 0 \), we
have a special case with solution \( w=1-x^2-y^2 \).

<p>
Given a computed \( w \), the physical deflection is given by

$$ D = \frac{AR^2}{8\pi\sigma T}w\tp$$

<h3 id="___sec38">Implementation </h3>

<p>
Very few modifications of the software in
<code>p2D_iter.py</code> are required. Actually, the <code>solver</code> function
can be reused, except that the domain is now a circle and not a
square. We change the <code>solver</code> function by letting the mesh be
an argument <code>mesh</code> (instead of <code>Nx</code> and <code>Ny</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u0, mesh, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    <span style="color: #666666">...</span>):
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)
    <span style="color: #666666">...</span>
</pre></div>
<p>
A mesh over the unit circle can be created by the <code>mshr</code> tool in
FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
mesh <span style="color: #666666">=</span> generate_mesh(domain, n)
</pre></div>
<p>
The <code>Circle</code> shape from <code>mshr</code> takes the center and radius of the circle
as the two first arguments, while <code>n</code> is the resolution, here the
suggested number of cells per radius.

<p>
The right-hand side pressure function
is represented by an <code>Expression</code> object. There
are two physical parameters in the formula for \( f \) that enter the
expression string and these parameters must have their values set
by keyword arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> Expression(
    <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
    beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)
</pre></div>
<p>
The coordinates in <code>Expression</code> objects <em>must</em> be a vector
with indices 0, 1, and 2, and with the name <code>x</code>. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f<span style="color: #666666">.</span>beta <span style="color: #666666">=</span> <span style="color: #666666">12</span>
f<span style="color: #666666">.</span>R0 <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
</pre></div>
<p>
It would be of interest to visualize \( p \) along with \( w \) so that we can
examine the pressure force and the membrane's response.  We must then transform
the formula (<code>Expression</code>) to a finite element function
(<code>Function</code>).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from \( p \). That is, we interpolate \( p \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> interpolate(p, V)
</pre></div>
<p>
Calling <code>plot(p)</code> will produce a plot of \( p \). Note that the assignment
to <code>p</code> destroys the previous <code>Expression</code> object <code>p</code>, so if
it is of interest to still have access to this object, another name must be used
for the <code>Function</code> object returned by <code>interpolate</code>.

<p>
We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case \( \beta =0 \).

<p>
The final program is found in the file <code>membrane.py</code>, located
in the <code>poisson</code> directory. The key function to simulate
membrane deflection is named <code>application</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u0, mesh, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u)=f on given mesh with Lagrange elements</span>
<span style="color: #BA2121; font-style: italic">    of specified degree and u=u0 (Expresssion) on the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solve(a <span style="color: #666666">==</span> L, u, bc, solver_parameters<span style="color: #666666">=</span>solver_parameters)
    <span style="color: #008000; font-weight: bold">return</span> u


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>(beta, R0, num_elements_radial_dir):
    <span style="color: #408080; font-style: italic"># Scaled pressure function</span>
    p <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
        beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)

    <span style="color: #408080; font-style: italic"># Generate mesh over the unit circle</span>
    domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
    mesh <span style="color: #666666">=</span> generate_mesh(domain, num_elements_radial_dir)

    w <span style="color: #666666">=</span> solver(p, Constant(<span style="color: #666666">0</span>), mesh, degree<span style="color: #666666">=1</span>,
               linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    w<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;w&#39;</span>, <span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># set name and label (description)</span>

    <span style="color: #408080; font-style: italic"># Plot scaled solution, mesh and pressure</span>
    plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Mesh over scaled domain&#39;</span>)
    plot(w, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> w<span style="color: #666666">.</span>label())
    V <span style="color: #666666">=</span> w<span style="color: #666666">.</span>function_space()
    p <span style="color: #666666">=</span> interpolate(p, V)
    p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;p&#39;</span>, <span style="color: #BA2121">&#39;pressure&#39;</span>)
    plot(p, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> p<span style="color: #666666">.</span>label())
</pre></div>
<p>
Choosing a very peak-formed pressure with large \( \beta \) (e.g., \( \beta \geq 20 \))
and a location \( R_0 \)
toward the circular boundary (e.g., \( R_0=0.5 \)), may produce an exciting visual
demonstrations of the very smoothed elastic
response to a peak force (or mathematically, the smoothing properties
of the inverse of the Laplace operator).  One needs to experiment with
the mesh resolution to get a smooth visual representation of \( p \).  You
are strongly encouraged to play around with the plots and different
mesh resolutions:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;import membrane as m; m.application()&#39; \ 
          membrane.py
</pre></div>

<h2 id="tut:quickviz">Quick visualization with VTK</h2>

<p>
As we go along with examples it is fun to play around with
<code>plot</code> commands and visualize what is computed. This section explains
some useful visualization features.

<p>
The <code>plot</code> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.

<p>
We have made a program <code>membrane.py</code> for the membrane deflection
problem in the section <a href="#tut:poisson:membrane">Deflection of a circular membrane</a> and added various
demonstrations of plotting capabilities. You are encouraged to play around with
<code>membrane.py</code> and modify the code as you read about various features.

<p>
The <code>plot</code> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Finite element mesh&#39;</span>)
plot(w, wireframe<span style="color: #666666">=</span><span style="color: #008000">True</span>, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Solution&#39;</span>)
</pre></div>
<p>
Axes can be turned on by the <code>axes=True</code> argument, while
<code>interactive=True</code> makes the program hang at the plot command - you have
to type <code>q</code> in the plot window to terminate the plot and continue execution.

<p>
The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <code>Help</code> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,

<ul>
 <li> pressing <code>m</code> turns visualization of the mesh on and off,</li>
 <li> pressing <code>b</code> turns on and off a bounding box,</li>
 <li> pressing <code>p</code> dumps the plot to a PNG file,</li>
 <li> pressing <code>P</code> dumps the plot to a PDF file,</li>
 <li> pressing `Ctrl +' stretches the surface in the \( z \) direction,</li>
 <li> pressing `Ctrl -' shrinks++ the surface in the \( z \) direction,</li>
 <li> pressing `Ctrl w' closes the plot window,</li>
 <li> pressing `Ctrl q' closes all plot windows.</li>
</ul>

The plots created by pressing <code>p</code> or <code>P</code> are stored in files with
names <code>dolfin_plot_X.png</code> or <code>dolfin_plot_X.pdf</code>,
where <code>X</code> is an integer that is increase by one from the last plot
that was made. The file stem <code>dolfin_plot_</code> can be set to something
more suitable through the <code>hardcopy_prefix</code> keyword argument to the
<code>plot</code> function,
for instance, <code>plot(f, hardcopy_prefix='pressure')</code>.

<p>
Plots stored in PDF format need to be rotated 90 degrees before
inclusion in documents. This can be done by the <code>convert -rotate 90</code>
command (from the ImageMagick utility), but the resulting file has
then no more high-resolution PDF vector graphics. A better solution
is therefore to use <code>pdftk</code> to preserve the vector graphics:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; pdftk dolfin_plot_1.pdf cat 1-endnorth output out.pdf
</pre></div>
<p>
For making plots in batch, we can do the following:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">viz_w <span style="color: #666666">=</span> plot(w, interactive<span style="color: #666666">=</span><span style="color: #008000">False</span>)
viz_w<span style="color: #666666">.</span>elevate(<span style="color: #666666">-10</span>)  <span style="color: #408080; font-style: italic"># adjust (lift) camera from the default view</span>
viz_w<span style="color: #666666">.</span>plot(w)       <span style="color: #408080; font-style: italic"># bring new settings into action</span>
viz_w<span style="color: #666666">.</span>write_png(<span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># make deflection.png</span>
viz_w<span style="color: #666666">.</span>write_pdf(<span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># make deflection.pdf</span>
<span style="color: #408080; font-style: italic"># Rotate pdf file (right) from landscape to portrait</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>
os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;pdftk deflection.pdf cat 1-endnorth output w.pdf&#39;</span>)
</pre></div>
<p>
The commands above appear in the <code>application2</code>
function in the <code>membrane.py</code> file.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Plot of the deflection of a membrane.  <!-- caption label: tut:poisson:2D:fig1 --> </p></center>
<p><img src="fig/membrane_deflection.png" align="bottom" width=480></p>
</center>

<h2 id="tut:poisson:gradu">Computing derivatives</h2>

<p>
In Poisson and many other problems, the gradient of the solution is
of interest. The computation is in principle simple:
since
\( u = \sum_{j=1}^N U_j \phi_j \), we have that

$$
\begin{equation*}
\nabla u = \sum_{j=1}^N U_j \nabla \phi_j\tp
\end{equation*}
$$

Given the solution variable <code>u</code> in the program, its gradient is
obtained by <code>grad(u)</code> or <code>nabla_grad(u)</code>.  However, the gradient of a
piecewise continuous finite element scalar field is a discontinuous
vector field since the \( \phi_j \) has discontinuous derivatives at the
boundaries of the cells. For example, using Lagrange elements of
degree 1, \( u \) is linear over each cell, and the numerical \( \nabla u \)
becomes a piecewise constant vector field. On the contrary, the exact
gradient is continuous.  For visualization and data analysis purposes
we often want the computed gradient to be a continuous vector
field. Typically, we want each component of \( \nabla u \) to be
represented in the same way as \( u \) itself. To this end, we can project
the components of \( \nabla u \) onto the same function space as we used
for \( u \).  This means that we solve \( w = \nabla u \) approximately by a
finite element method, using the same elements for the components of
\( w \) as we used for \( u \). This process is known as <em>projection</em>.

<p>
Not surprisingly, projection is a so common operation in finite
element programs that FEniCS has a function for doing the task:
<code>project(q, W)</code>, which returns the projection of some <code>Function</code> or
<code>Expression</code> object named <code>q</code> onto the <code>FunctionSpace</code> (if <code>q</code> is
scalar) or <code>VectorFunctionSpace</code> (if <code>q</code> is vector-valued) named <code>W</code>.
Specifically, in our case where <code>u</code> is computed and we want to project
the vector-valued <code>grad(u)</code> onto the <code>VectorFunctionSpace</code> where each
component has the same <code>Function</code> space as <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
degree <span style="color: #666666">=</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
W <span style="color: #666666">=</span> VectorFunctionSpace(V<span style="color: #666666">.</span>mesh(), <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)

grad_u <span style="color: #666666">=</span> project(grad(u), W)
</pre></div>
<p>
Figure <a href="#tut:poisson:2D:fig:ex1:gradu">3</a> shows
example of how such a smoothed <code>gradu(u)</code> vector field is visualized.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig:ex1:gradu"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Example of visualizing the vector field \( \nabla u \) by arrows at the nodes.  <!-- caption label: tut:poisson:2D:fig:ex1:gradu --> </p></center>
<p><img src="fig/ex1_gradu.png" align="bottom" width=480></p>
</center>

<p>
The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.

<p>
The scalar component fields of the gradient
can be extracted as separate fields and, e.g., visualized:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_x, grad_u_y <span style="color: #666666">=</span> grad_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)
plot(grad_u_x, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x-component of grad(u)&#39;</span>)
plot(grad_u_y, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y-component of grad(u)&#39;</span>)
</pre></div>
<p>
The <code>deepcopy=True</code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code>deepcopy=False</code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)

<p>
The <code>grad_u_x</code> and <code>grad_u_y</code> variables behave as
<code>Function</code> objects. In particular, we can extract the underlying
arrays of nodal values by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_x_array <span style="color: #666666">=</span> grad_u_x<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
grad_u_y_array <span style="color: #666666">=</span> grad_u_y<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
The degrees of freedom of the <code>grad_u</code> vector field can also be
reached by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_array <span style="color: #666666">=</span> grad_u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
but this is a flat <code>numpy</code> array where the degrees of freedom for the
\( x \) component of the gradient is stored in the first part, then the
degrees of freedom of the \( y \) component, and so on. This is less convenient
to work with.

<p>
The function <code>gradient(u)</code> in <code>p2D_iter.py</code>
returns a projected (smoothed) \( \nabla u \) vector field, given some
finite element function <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">gradient</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
    grad_u <span style="color: #666666">=</span> project(grad(u), V_g)
    grad_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;grad(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous gradient field&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> grad_u
</pre></div>
<p>
Examining the arrays with vertex values of <code>grad_u_x</code> and <code>grad_u_y</code>
quickly reveals that the computed <code>grad_u</code> field does not equal the
exact gradient \( (2x, 4y) \) in this particular test problem where
\( u=1+x^2+2y^2 \).  There are inaccuracies at the boundaries, arising
from the approximation problem for \( w \). Increasing the mesh resolution
shows, however, that the components of the gradient vary linearly as
\( 2x \) and \( 4y \) in the interior of the mesh (i.e., as soon as we are one
element away from the boundary).  The <code>application_test_gradient</code>
function in <code>p2D_iter.py</code> performs some experiments.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Detour: Manual projection.</b>
Although you will always use <code>project</code> to project a finite element
function, it can be constructive this point in the tutorial to formulate the
projection mathematically and implement its steps manually in FEniCS.

<p>
Looking at the component \( \partial u/\partial x \) of the gradient, we
project the (discrete) derivative \( \sum_jU_j{\partial \phi_j/\partial
x} \) onto a function space with basis \( \phi_1,\phi_2,\ldots \) such that
the derivative in this space is expressed by the standard sum
\( \sum_j\bar U_j \phi_j \), for suitable (new) coefficients \( \bar U_j \).

<p>
The variational problem for \( w \) reads: find  \( w\in \Vg \) such that

$$
\begin{equation}
a(w, v) = L(v)\quad\forall v\in \hat{\Vg},
\tag{19}
\end{equation}
$$

where

$$
\begin{align}
a(w, v) &= \int_\Omega w\cdot v \dx,
\tag{20}\\ 
L(v) &= \int_\Omega \nabla u\cdot v \dx\tp
\tag{21}
\end{align}
$$

The function spaces \( \Vg \) and \( \hat{\Vg} \) (with the superscript g
denoting &quot;gradient&quot;) are vector versions of the function space for
\( u \), with boundary conditions removed (if \( V \) is the space we used for
\( u \), with no restrictions on boundary values, \( \Vg = \hat{\Vg} =
[V]^d \), where \( d \) is the number of space dimensions).  For example, if
we used piecewise linear functions on the mesh to approximate \( u \), the
variational problem for \( w \) corresponds to approximating each
component field of \( w \) by piecewise linear functions.

<p>
The variational problem for the vector field
\( w \), called <code>grad_u</code> in the code, is easy to solve in FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)
w <span style="color: #666666">=</span> TrialFunction(V_g)
v <span style="color: #666666">=</span> TestFunction(V_g)

a <span style="color: #666666">=</span> inner(w, v)<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> inner(grad(u), v)<span style="color: #666666">*</span>dx
grad_u <span style="color: #666666">=</span> Function(V_g)
solve(a <span style="color: #666666">==</span> L, grad_u)

plot(grad_u, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;grad(u)&#39;</span>)
</pre></div>
<p>
The boundary condition argument to <code>solve</code> is dropped since there are
no essential boundary conditions in this problem.
The new thing is basically that we work with a <code>VectorFunctionSpace</code>,
since the unknown is now a vector field, instead of the
<code>FunctionSpace</code> object for scalar fields.
</div>


<h2 id="tut:possion:2D:varcoeff">A variable-coefficient Poisson problem</h2>

<p>
Suppose we have a variable coefficient \( p(x,y) \) in the Laplace operator,
as in the boundary-value problem

$$
\begin{equation} \tag{22}
  \begin{split}
    - \nabla\cdot \left\lbrack
p(x,y)\nabla u(x,y)\right\rbrack &= f(x,y) \quad \mbox{in } \Omega,
    \\ 
    u(x,y) &= u_0(x,y) \quad \mbox{on}\  \partial\Omega\tp
  \end{split}
\end{equation}
$$

We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS program.

<h3 id="___sec42">Test problem </h3>

<p>
Let us continue to use our favorite solution \( u(x,y)=1+x^2+2y^2 \) and
then prescribe \( p(x,y)=x+y \). It follows that
\( u_0(x,y) = 1 + x^2 + 2y^2 \) and \( f(x,y)=-8x-10y \).

<h3 id="___sec43">Modifications of the PDE solver </h3>

<p>
What are the modifications we need to do in the previously shown codes
to incorporate the variable coefficient \( p \)?
from the section <a href="#tut:poisson1:verify1">Writing out the discrete solution</a>?

<ul>
  <li> <code>solver</code> must take <code>p</code> as argument,</li>
  <li> <code>f</code> in our test problem
    must be an <code>Expression</code> since it is no longer a constant,</li>
  <li> a new <code>Expression p</code> must be defined for the variable coefficient,</li>
  <li> the formula for \( a(u,v) \) in the variational problem is slightly changed.</li>
</ul>

First we address the modified variational problem. Multiplying
the PDE by a test function \( v \) and
integrating by parts now results
in

$$
\begin{equation*}
\int_\Omega p\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} p{\partial u\over
\partial n}v \ds = \int_\Omega fv \dx\tp
\end{equation*}
$$

The function spaces for \( u \) and \( v \) are the same as in
the section <a href="#tut:poisson1:varform">Variational formulation</a>, implying that the boundary integral
vanishes since \( v=0 \) on \( \partial\Omega \) where we have Dirichlet conditions.
The weak form \( a(u,v)=L(v) \) then has

$$
\begin{align}
a(u,v) &= \int_\Omega p\nabla u\cdot\nabla v \dx,
\tag{23}\\ 
L(v) &= \int_\Omega fv \dx\tp
\tag{24}
\end{align}
$$

In the code for solving \( -\nabla^2u=f \) we must replace

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> p<span style="color: #666666">*</span>inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
to solve \( -\nabla\cdot(p\nabla u)=f \). Moreover,
the definitions of <code>p</code> and <code>f</code> in the test problem read

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
</pre></div>
<p>
No additional modifications are necessary. The file
<code>p2D_vc.py</code> (variable-coefficient Poisson problem in 2D)
is a copy of <code>p2D_iter.py</code> with the mentioned changes
incorporated. Observe that \( p=1 \) recovers the original problem in
<code>p2D_iter.py</code>.

<p>
You can run it and confirm
that it recovers the exact \( u \) at the nodes.

<h3 id="___sec44">Modifications of the flux computations </h3>

<p>
The flux \( -p\nabla u \) may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section <a href="#tut:poisson:gradu">Computing derivatives</a>,
we normally want the piecewise discontinuous flux or gradient to be
approximated by a continuous vector field, using the same elements as
used for the numerical solution \( u \). The approximation now consists of
solving \( w = -p\nabla u \) by a finite element method: find \( w\in \Vg \)
such that

$$
\begin{equation}
a(w, v) = L(v)\quad\forall v\in \hat{\Vg},
\tag{25}
\end{equation}
$$

where

$$
\begin{align}
a(w, v) &= \int_\Omega w\cdot v \dx,
\tag{26}\\ 
L(v) &= \int_\Omega (-p \nabla u)\cdot v \dx\tp
\tag{27}
\end{align}
$$

This problem is identical to the one in the section <a href="#tut:poisson:gradu">Computing derivatives</a>,
except that \( p \) enters the integral in \( L \).

<p>
The relevant Python statement for computing the flux field take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>grad(u),
               VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degreee))
</pre></div>
<p>
An appropriate function for computing the flux based on <code>u</code> and <code>p</code> is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">flux</span>(u, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return p*grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    degree <span style="color: #666666">=</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
    V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)
    grad_u <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>grad(u), V_g)
    grad_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous flux field&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> grad_u
</pre></div>
<p>
Plotting the flux vector field is naturally as easy as plotting
the gradient (see the section <a href="#tut:poisson:gradu">Computing derivatives</a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(flux, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;flux field&#39;</span>)

flux_x, flux_y <span style="color: #666666">=</span> flux<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)  <span style="color: #408080; font-style: italic"># extract components</span>
plot(flux_x, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x-component of flux (-p*grad(u))&#39;</span>)
plot(flux_y, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y-component of flux (-p*grad(u))&#39;</span>)
</pre></div>
<p>
For data analysis of the nodal values of the flux field we can
grab the underlying <code>numpy</code> arrays (demands a <code>deepcopy=True</code>
in the split of <code>flux</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_x_array <span style="color: #666666">=</span> flux_x<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
flux_y_array <span style="color: #666666">=</span> flux_y<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 5</b>: The following is not done properly in the revised version.)</font>
<!-- end inline comment -->

The function <code>application_test_gradient</code> in the
program <code>p2D_vc.py</code> contains in addition some plots,
including a curve plot
comparing <code>flux_x</code> and the exact counterpart along the line \( y=1/2 \).
The associated programming details related to this visualization
are explained in the section <a href="#tut:structviz">Visualization of structured mesh data</a>.

<h2 id="tut:poisson1:functionals">Computing functionals</h2>

<p>
After the solution \( u \) of a PDE is computed, we occasionally want to compute
functionals of \( u \), for example,

$$
\begin{equation}
{1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u \dx,
\tag{28}
\end{equation}
$$

which often reflects some energy quantity.
Another frequently occurring functional is the error

$$
\begin{equation}
||\uex-u|| = \left(\int_\Omega (\uex-u)^2 \dx\right)^{1/2},
\tag{29}
\end{equation}
$$

where \( \uex \) is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part \( \Gamma \) of
the boundary \( \partial\Omega \),

$$
\begin{equation}
F = -\int_\Gamma p\nabla u\cdot\normalvec \ds,
\tag{30}
\end{equation}
$$

where \( \normalvec \) is an outward unit normal at \( \Gamma \) and \( p \) is a
coefficient (see the problem in the section <a href="#tut:possion:2D:varcoeff">A variable-coefficient Poisson problem</a>
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.

<h3 id="___sec46">Energy functional </h3>

<p>
The integrand of the
energy functional
<a href="#mjx-eqn-28">(28)</a>
is described in the UFL language in the same manner as we describe
weak forms:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">energy <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>inner(grad(u), grad(u))<span style="color: #666666">*</span>dx
E <span style="color: #666666">=</span> assemble(energy)
</pre></div>
<p>
The <code>assemble</code> call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section <a href="._ftut006.html#tut:poisson:mat:neumann">Multiple Neumann, Robin, and Dirichlet condition</a>.

<h3 id="___sec47">Error functional </h3>

<p>
Computation of <a href="#mjx-eqn-29">(29)</a> is typically done
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_exact)<span style="color: #666666">**2*</span>dx
E <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))
</pre></div>
<p>
The exact solution \( \uex \) is here in a <code>Function</code> or
<code>Expression</code> object <code>u_exact</code>, while <code>u</code> is the
finite element approximation.
(Sometimes, for very small error values, the result of
<code>assemble(error)</code> can be a (very small) negative number, so we have
used <code>abs</code> in the expression for <code>E</code> above to ensure a positive value
for the <code>sqrt</code> function.)

<p>
As will be explained and demonstrate in the section <a href="#tut:poisson1:convrates">Computing convergence rates</a>, the integration of <code>(u - u_exact)**2*dx</code>
can result in too optimistic convergence rates unless one is careful
how <code>u_exact</code> is transferred onto a mesh. The general recommendation
for reliable error computation is to use the <code>errornorm</code> function
(see <code>pydoc dolfin.errornorm</code> and the section <a href="#tut:poisson1:convrates">Computing convergence rates</a>
for more information):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">E <span style="color: #666666">=</span> errornorm(u_exact, u)
</pre></div>

<h3 id="___sec48">Flux Functionals </h3>

<p>
To compute flux integrals like \( F = -\int_\Gamma p\nabla
u\cdot\normalvec \ds \) we need to define the \( \normalvec \) vector,
referred to as <em>facet normal</em> in FEniCS. If the surface domain
\( \Gamma \) in the flux integral is the complete
boundary we can perform the flux computation by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> FacetNormal(mesh)
flux <span style="color: #666666">=</span> <span style="color: #666666">-</span>p<span style="color: #666666">*</span>dot(nabla_grad(u), n)<span style="color: #666666">*</span>ds
total_flux <span style="color: #666666">=</span> assemble(flux)
</pre></div>
<p>
Although <code>nabla_grad(u)</code> and <code>grad(u)</code> are interchangeable
in the above expression when <code>u</code> is a scalar function, we have
chosen to write <code>nabla_grad(u)</code> because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With <code>grad(u)</code> we must in that
case write <code>dot(n, grad(u))</code>.

<p>
It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section <a href="._ftut006.html#tut:poisson:mat:neumann">Multiple Neumann, Robin, and Dirichlet condition</a>. Assuming that the
part corresponds to subdomain number <code>i</code>, the relevant syntax for
the variational formulation of the
flux is <code>-p*inner(grad(u), n)*ds(i)</code>.

<h2 id="tut:poisson1:convrates">Computing convergence rates</h2>

<p>
To illustrate error computations and convergence of finite element
solutions, we have included a function <code>convergence_rate</code> in
the <code>p2D_vc.py</code> program. This is a tool that is very
handy when verifying finite element codes and will therefore be explained in
detail here.

<p>
The \( L^2 \) norm of the error in a finite element approximation \( u \),
\( \uex \) being the exact solution, is given by

<h3 id="___sec50">Various ways of computing the error </h3>

$$ E = \left(\int_\Omega (u_e-u)^2 \dx\right)^{1/2},$$

and implemented in FEniCS by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
E <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))
</pre></div>
<p>
Sometimes, for very small error values, the result of
<code>assemble(error)</code> can be a (very small) negative number, so we have
used <code>abs</code> in the expression for <code>E</code> above to ensure a positive value
for the <code>sqrt</code> function.

<p>
We remark that <code>u_e</code> will, in the expression
above, be interpolated onto the function space <code>V</code> before <code>assemble</code>
can perform the integration over the domain. This implies that the
exact solution used in the integral will vary linearly over the cells,
and not as a sine function, if <code>V</code> corresponds to linear Lagrange
elements.  This situation may yield a smaller error <code>u - u_e</code> than
what is actually true.  More accurate representation of the exact
solution is easily achieved by interpolating the formula onto a space
defined by higher-order elements, say of third degree:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Ve <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree<span style="color: #666666">=3</span>)
u_e_Ve <span style="color: #666666">=</span> interpolate(u_e, Ve)
error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e_Ve)<span style="color: #666666">**2*</span>dx
E <span style="color: #666666">=</span> sqrt(assemble(error))
</pre></div>
<p>
To achieve complete mathematical control of which function space the
computations are carried out in, we can explicitly interpolate <code>u</code> to
the same space:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_Ve <span style="color: #666666">=</span> interpolate(u, Ve)
error <span style="color: #666666">=</span> (u_Ve <span style="color: #666666">-</span> u_e_Ve)<span style="color: #666666">**2*</span>dx
</pre></div>
<p>
The square in the expression for <code>error</code> will be expanded and lead to
a lot of terms that almost cancel when the error is small, with the
potential of introducing significant rounding errors.  The function
<code>errornorm</code> is available for avoiding this effect by first
interpolating <code>u</code> and <code>u_exact</code> to a space with higher-order elements,
then subtracting the degrees of freedom, and then performing the
integration of the error field. The usage is simple:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">E <span style="color: #666666">=</span> errornorm(u_exact, u, normtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;L2&#39;</span>, degree<span style="color: #666666">=3</span>)
</pre></div>
<p>
It is illustrative to look at the short implementation of <code>errornorm</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">errornorm</span>(u_exact, u, Ve):
    u_Ve <span style="color: #666666">=</span> interpolate(u, Ve)
    u_e_Ve <span style="color: #666666">=</span> interpolate(u_exact, Ve)
    e_Ve <span style="color: #666666">=</span> Function(Ve)
    <span style="color: #408080; font-style: italic"># Subtract degrees of freedom for the error field</span>
    e_Ve<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_e_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> \ 
                       u_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
    error <span style="color: #666666">=</span> e_Ve<span style="color: #666666">**2*</span>dx
    <span style="color: #008000; font-weight: bold">return</span> sqrt(assemble(error))
</pre></div>
<p>
The <code>errornorm</code> procedure turns out to be identical to computing
the expression <code>(u_e - u)**2*dx</code> directly in
the present test case.

<p>
Sometimes it is of interest to compute the error of the
gradient field: \( ||\nabla (u-\uex)|| \)
(often referred to as the \( H^1 \) seminorm of the error).
Given the error field <code>e_Ve</code> above, we simply write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">H1seminorm <span style="color: #666666">=</span> sqrt(assemble(inner(grad(e_Ve), grad(e_Ve))<span style="color: #666666">*</span>dx))
</pre></div>
<p>
All the various types of error computations here are placed in a
function <code>compute_errors</code> in <code>p2D_vc.py</code>:

<!-- begin inline comment -->
<font color="red">(<b>hpl 6</b>: Necessary to repeat code? New info is essentiall the return dict.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 7</b>: Anders, I (in 2010...) ran into problems with <code>dolfin.errornorm</code>, see comments in the code below, and made the version below. We should check out these problems again and adjust <code>dolfin.errornorm</code> if necessary.)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_errors</span>(u, u_exact):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span style="color: #BA2121; font-style: italic">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Compute error norm (for very small errors, the value can be</span>
    <span style="color: #408080; font-style: italic"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()

    <span style="color: #408080; font-style: italic"># Function - Expression</span>
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_exact)<span style="color: #666666">**2*</span>dx
    E1 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_e onto the same space as u:</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E2 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span style="color: #408080; font-style: italic"># u will also be interpolated to the space Ve before integration</span>
    Ve <span style="color: #666666">=</span> FunctionSpace(V<span style="color: #666666">.</span>mesh(), <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">5</span>)  <span style="color: #408080; font-style: italic"># mesh here: BUG, module mesh in dolfin...make warning box</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, Ve)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E3 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># dolfin.errornorm interpolates u and u_e to a space with</span>
    <span style="color: #408080; font-style: italic"># given degree, and creates the error field by subtracting</span>
    <span style="color: #408080; font-style: italic"># the degrees of freedom, then the error field is integrated</span>
    <span style="color: #408080; font-style: italic"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span style="color: #408080; font-style: italic">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span style="color: #408080; font-style: italic"># Manual implementation errornorm to get around the bug:</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">errornorm</span>(u_exact, u, Ve):
        u_Ve <span style="color: #666666">=</span> interpolate(u, Ve)
        u_e_Ve <span style="color: #666666">=</span> interpolate(u_exact, Ve)
        e_Ve <span style="color: #666666">=</span> Function(Ve)
        <span style="color: #408080; font-style: italic"># Subtract degrees of freedom for the error field</span>
        e_Ve<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_e_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        <span style="color: #408080; font-style: italic"># More efficient computation (avoids the rhs array result above)</span>
        <span style="color: #408080; font-style: italic">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span style="color: #408080; font-style: italic">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        error <span style="color: #666666">=</span> e_Ve<span style="color: #666666">**2*</span>dx(Ve<span style="color: #666666">.</span>mesh())
        <span style="color: #008000; font-weight: bold">return</span> sqrt(<span style="color: #008000">abs</span>(assemble(error))), e_Ve
    E4, e_Ve <span style="color: #666666">=</span> errornorm(u_exact, u, Ve)

    <span style="color: #408080; font-style: italic"># Infinity norm based on nodal values</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    E5 <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()

    <span style="color: #408080; font-style: italic"># H1 seminorm</span>
    error <span style="color: #666666">=</span> inner(grad(e_Ve), grad(e_Ve))<span style="color: #666666">*</span>dx
    E6 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Collect error measures in a dictionary with self-explanatory keys</span>
    errors <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;u - u_exact&#39;</span>: E1,
              <span style="color: #BA2121">&#39;u - interpolate(u_exact,V)&#39;</span>: E2,
              <span style="color: #BA2121">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span>: E3,
              <span style="color: #BA2121">&#39;errornorm&#39;</span>: E4,
              <span style="color: #BA2121">&#39;infinity norm (of dofs)&#39;</span>: E5,
              <span style="color: #BA2121">&#39;grad(error) H1 seminorm&#39;</span>: E6}

    <span style="color: #008000; font-weight: bold">return</span> errors
</pre></div>

<h3 id="___sec51">Computing convergence rates empirically </h3>

<p>
Calling the <code>solver</code> function for finer and finer meshes enables us to
study the convergence rate. Define the element size \( h=1/n \), where \( n \)
is the number of cell divisions in \( x \) and \( y \) direction (<code>n=Nx=Ny</code> in
the code). We perform experiments with \( h_0>h_1>h_2\cdots \) and compute
the corresponding errors \( E_0, E_1, E_3 \) and so forth.  Assuming
\( E_i=Ch_i^r \) for unknown constants \( C \) and \( r \), we can compare two
consecutive experiments, \( E_i=Ch_i^r \) and \( E_{i-1}=Ch_{i-1}^r \), and
solve for \( r \):

$$
\begin{equation*}
r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}\tp
\end{equation*}
$$

The \( r \) values should approach the expected convergence
rate <code>degree+1</code> as \( i \) increases.

<p>
The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by <code>compute_errors</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rate</span>(u_exact, f, u0, p, degrees,
                     n<span style="color: #666666">=</span>[<span style="color: #666666">2**</span>(k<span style="color: #666666">+3</span>) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">5</span>)]):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute convergence rates for various error norms for a</span>
<span style="color: #BA2121; font-style: italic">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span style="color: #BA2121; font-style: italic">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span style="color: #BA2121; font-style: italic">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    h <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Discretization parameter, h[degree][experiment]</span>
    E <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Error measure(s), E[degree][experiment][error_type]</span>
    P_degrees <span style="color: #666666">=</span> <span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>
    num_meshes <span style="color: #666666">=</span> <span style="color: #666666">5</span>

    <span style="color: #408080; font-style: italic"># Perform experiments with meshes and element types</span>
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        n <span style="color: #666666">=</span> <span style="color: #666666">4</span>   <span style="color: #408080; font-style: italic"># Coarsest mesh division</span>
        h[degree] <span style="color: #666666">=</span> []
        E[degree] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
            n <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
            h[degree]<span style="color: #666666">.</span>append(<span style="color: #666666">1.0/</span>n)
            u <span style="color: #666666">=</span> solver(p, f, u0, n, n, degree,
                       linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
            errors <span style="color: #666666">=</span> compute_errors(u, u_exact)
            E[degree]<span style="color: #666666">.</span>append(errors)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;2*(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh, </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> unknowns, E1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (n, n, degree, u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
                   errors[<span style="color: #BA2121">&#39;u - u_exact&#39;</span>]))
    <span style="color: #408080; font-style: italic"># Convergence rates</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log <span style="color: #008000; font-weight: bold">as</span> ln  <span style="color: #408080; font-style: italic"># log is a dolfin name too</span>
    error_types <span style="color: #666666">=</span> <span style="color: #008000">list</span>(E[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>keys())
    rates <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        rates[degree] <span style="color: #666666">=</span> {}
        <span style="color: #008000; font-weight: bold">for</span> error_type <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(error_types):
            rates[degree][error_type] <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
                Ei   <span style="color: #666666">=</span> E[degree][i][error_type]
                Eim1 <span style="color: #666666">=</span> E[degree][i<span style="color: #666666">-1</span>][error_type]
                r <span style="color: #666666">=</span> ln(Ei<span style="color: #666666">/</span>Eim1)<span style="color: #666666">/</span>ln(h[degree][i]<span style="color: #666666">/</span>h[degree][i<span style="color: #666666">-1</span>])
                rates[degree][error_type]<span style="color: #666666">.</span>append(<span style="color: #008000">round</span>(r,<span style="color: #666666">2</span>))
    <span style="color: #008000; font-weight: bold">return</span> rates

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rate_sin</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute convergence rates for u=sin(x)*sin(y) solution.&quot;&quot;&quot;</span>
    omega <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
    u_exact <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span>,
                         omega<span style="color: #666666">=</span>omega)
    f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>omega<span style="color: #666666">**2*</span>pi<span style="color: #666666">**2*</span>u_exact
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Note: P4 for n&gt;=128 seems to break down</span>
    rates <span style="color: #666666">=</span> convergence_rates(u_exact, f, u0, p, degrees<span style="color: #666666">=4</span>,
                              n<span style="color: #666666">=</span>[<span style="color: #666666">2**</span>(k<span style="color: #666666">+3</span>) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">5</span>)])
    <span style="color: #408080; font-style: italic"># Print rates</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n\n</span><span style="color: #BA2121">&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> error_type <span style="color: #AA22FF; font-weight: bold">in</span> error_types:
        <span style="color: #008000; font-weight: bold">print</span>(error_type)
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (degree, <span style="color: #008000">str</span>(rates[degree][error_type])[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]))
</pre></div>
<p>
Note how make a complete general function <code>convergence_rate</code>, aimed at
any 2D Poisson problem in the class we now can solve, and then call
this general function in <code>convergence_rate_sin</code> for a special test
case.

<h3 id="___sec52">Test problem </h3>

<p>
The section <a href="#tut:poisson:gradu">Computing derivatives</a> and specify a more complicated solution,

$$
\begin{equation*}
u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)
\end{equation*}
$$

on the unit square.
This choice implies \( f(x,y)=2\omega^2\pi^2 u(x,y) \).
With \( \omega \) restricted to an integer
it follows that \( u_0=0 \).

<p>
We need to define the
appropriate boundary conditions, the exact solution, and the \( f \) function
in the code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0.0</span>), boundary)

omega <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
u_e <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span>,
                 omega<span style="color: #666666">=</span>omega)

f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">**2*</span>omega<span style="color: #666666">**2*</span>u_e
</pre></div>

<h3 id="___sec53">Experiments </h3>

<p>
Calling <code>convergence_rate_sin()</code> gives some interesting results.
Using the error measure <code>E5</code> based on the infinity norm of the
difference of the degrees of freedom, we have

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>element</b></td> <td align="center">\( n=8 \)</td> <td align="center">\( n=16 \)</td> <td align="center">\( n=32 \)</td> <td align="center">\( n=64 \)</td> <td align="center">\( n=128 \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   P1         </td> <td align="right">   1.99         </td> <td align="right">   1.97          </td> <td align="right">   1.99          </td> <td align="right">   2.0           </td> <td align="right">   2.0            </td> </tr>
<tr><td align="left">   P2         </td> <td align="right">   3.99         </td> <td align="right">   3.96          </td> <td align="right">   3.99          </td> <td align="right">   4.0           </td> <td align="right">   3.99           </td> </tr>
<tr><td align="left">   P3         </td> <td align="right">   3.96         </td> <td align="right">   3.89          </td> <td align="right">   3.96          </td> <td align="right">   3.99          </td> <td align="right">   4.0            </td> </tr>
<tr><td align="left">   P4         </td> <td align="right">   3.75         </td> <td align="right">   4.99          </td> <td align="right">   5.0           </td> <td align="right">   5.0           </td> <td align="right">                  </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-6 -->
</div> <!-- cell row -->
<p>
The computations with P4 elements on a \( 128\times 128 \) with a
direct solver (UMFPACK) on a small laptop broke down.
Otherwise we achieve expected results: the error goes like
\( h^{d+1} \) for elements of degree \( d \). Also \( L^2 \) norms based
on the <code>errornorm</code> gives the expected \( h^{d+1} \) rate for
\( u \) and \( h^d \) for \( \nabla u \).

<p>
However, using <code>(u - u_exact)**2</code> for the error computation, which implies
interpolating <code>u_exact</code> onto the same space as <code>u</code>, results in \( h^4 \)
convergence for P2 elements.

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>element</b></td> <td align="center">\( n=8 \)</td> <td align="center">\( n=16 \)</td> <td align="center">\( n=32 \)</td> <td align="center">\( n=64 \)</td> <td align="center">\( n=128 \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   P1         </td> <td align="right">   1.98         </td> <td align="right">   1.94          </td> <td align="right">   1.98          </td> <td align="right">   2.0           </td> <td align="right">   2.0            </td> </tr>
<tr><td align="left">   P2         </td> <td align="right">   3.98         </td> <td align="right">   3.95          </td> <td align="right">   3.99          </td> <td align="right">   3.99          </td> <td align="right">   3.99           </td> </tr>
<tr><td align="left">   P3         </td> <td align="right">   3.69         </td> <td align="right">   4.03          </td> <td align="right">   4.01          </td> <td align="right">   3.95          </td> <td align="right">   2.77           </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-6 -->
</div> <!-- cell row -->
<p>
This is an example where it is important to interpolate <code>u_exact</code> to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.

<p>
<!-- Problems with interpolate(u,Ve) - interpolate(u_exact,Ve) for -->
<!-- high degree and large meshes. Rounding errors? errornorm is the -->
<!-- remedy? -->
<!-- interpolate(u,Ve) - interpolate(u_exact,Ve) -->
<!-- P1: 1.98, 1.96, 1.99, 2.0, 2.0 -->
<!-- P2: 3.01, 3.03, 3.01, 3.0, 3.02 -->
<!-- P3: 2.7, 4.02, 4.0, 2.63, 0.17 -->
<!-- P4: 1.54, 5.11, 0.91, 0.15, -0.01 -->

<p>
Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section <a href="#tut:poisson1:verify1">Writing out the discrete solution</a> and many other places in this tutorial).

<h2 id="tut:structviz">Visualization of structured mesh data</h2>

<p>
When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.

<p>
A necessary first step is to transform our <code>mesh</code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.
The second step is to
transform the one-dimensional array of nodal values to a
two-dimensional array holding the values at the corners of the cells
in the structured mesh. We want to access a value by
its \( i \) and \( j \) indices, \( i \) counting cells in the \( x \) direction, and
\( j \) counting cells in the \( y \) direction.  This transformation is in
principle straightforward, yet it frequently leads to obscure indexing
errors, so using software tools to ease the work is advantageous.

<p>
In the directory <code>src/modules</code>, associated with this booklet,
we have included a Python module <code>BoxField</code> that can take a finite
element function <code>u</code> computed by a FEniCS software and represent
it on a structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code>[i]</code> in 1D, <code>[i,j]</code> in 2D, and
<code>[i,j,k]</code> in 3D. Given a finite element function <code>u</code>,
the following function returns a <code>BoxField</code> object that represents
<code>u</code> on a structured mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">structured_mesh</span>(u, divisions):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    u2 <span style="color: #666666">=</span> u <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
         interpolate(u, FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>))
    mesh <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">BoxField</span> <span style="color: #008000; font-weight: bold">import</span> dolfin_function2BoxField
    u_box <span style="color: #666666">=</span> dolfin_function2BoxField(
        u2, mesh, divisions, uniform_mesh<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u_box
</pre></div>
<p>
Note that we can only turn functions on meshes with P1 elements into
<code>BoxField</code> objects, so if <code>u</code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code>divisions</code>).

<p>
The <code>u_box</code> object contains several useful data structures:

<ul>
 <li> <code>u_box.grid</code>: object for the structured mesh</li>
 <li> <code>u_box.grid.coor[X]</code>: grid coordinates in <code>X=0</code> direction</li>
 <li> <code>u_box.grid.coor[Y]</code>: grid coordinates in <code>Y=1</code> direction</li>
 <li> <code>u_box.grid.coor[Z]</code>: grid coordinates in <code>Z=2</code> direction</li>
 <li> <code>u_box.grid.coorv[X]</code>: vectorized version of <code>u_box.grid.coor[X]</code>
   (for vectorized computations or surface plotting)</li>
 <li> <code>u_box.grid.coorv[Y]</code>: vectorized version of <code>u_box.grid.coor[Y]</code></li>
 <li> <code>u_box.grid.coorv[Z]</code>: vectorized version of <code>u_box.grid.coor[Z]</code></li>
 <li> <code>u_box.values</code>: <code>numpy</code> array holding the <code>u</code> values;
   <code>u_box.values[i,j]</code> holds <code>u</code> at the mesh point with coordinates <br />
   <code>(u_box.grid.coor[X], u_box.grid.coor[Y])</code></li>
</ul>

<h3 id="___sec55">Iterating over points and values </h3>

<p>
Let us go back to the <code>solver</code> function in the
<code>p2D_vc.py</code> code from
the section <a href="#tut:possion:2D:varcoeff">A variable-coefficient Poisson problem</a>, compute <code>u</code>, map it onto a
<code>BoxField</code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> solver(p, f, u0, nx, ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
u_box <span style="color: #666666">=</span> structured_mesh(u, (nx, ny))
u_ <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>values       <span style="color: #408080; font-style: italic"># numpy array</span>
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  Y <span style="color: #666666">=</span> <span style="color: #666666">1</span>           <span style="color: #408080; font-style: italic"># for indexing in x and y direction</span>

<span style="color: #408080; font-style: italic"># Iterate over 2D mesh points (i,j)</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_ is defined on a structured mesh with </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
      <span style="color: #008000">str</span>(u_<span style="color: #666666">.</span>shape))
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=u(</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (i, j,
               u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][i], u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][j],
               u_[i,j]))
</pre></div>

<h3 id="___sec56">Finite difference approximations </h3>

<p>
Note that with <code>u_</code>, we can easily express finite difference approximation
of derivatives:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X]
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
u_xx <span style="color: #666666">=</span> (u_[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_[i,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">+1</span>,j])<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
</pre></div>

<h3 id="___sec57">Surface plot </h3>

<p>
The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a href="#tut:structviz:fig1">4</a> (upper left):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
cv <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coorv  <span style="color: #408080; font-style: italic"># vectorized mesh coordinates</span>
ax<span style="color: #666666">.</span>plot_surface(cv[X], cv[Y], u_, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Surface plot of solution&#39;</span>)
</pre></div>
<p>
The key issue is to know that the coordinates needed for the surface
plot is in <code>u_box.grid.coorv</code> and that the values are in <code>u_</code>.

<p>
<center> <!-- figure label: --> <div id="tut:structviz:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 4:  Various plots of the solution on a structured mesh.  <!-- caption label: tut:structviz:fig1 --> </p></center>
<p><img src="fig/p2D_vc_structmesh2.png" align="bottom" width=800></p>
</center>

<h3 id="___sec58">Contour plot </h3>

<p>
A contour plot can also be made by Matplotlib:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca()
levels <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">2.0</span>, <span style="color: #666666">2.5</span>, <span style="color: #666666">3.5</span>]
cs <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>contour(cv[X], cv[Y], u_, levels<span style="color: #666666">=</span>levels)
plt<span style="color: #666666">.</span>clabel(cs)  <span style="color: #408080; font-style: italic"># add labels to contour lines</span>
plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;equal&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Contour plot of solution&#39;</span>)
</pre></div>
<p>
The result appears in Figure <a href="#tut:structviz:fig1">4</a> (upper right).

<h3 id="___sec59">Curve plot through the mesh </h3>

<p>
A handy feature of <code>BoxField</code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot \( u \) along
the line \( y=0.4 \). The mesh points, <code>x</code>, and the \( u \) values
along this line, <code>u_val</code>, are extracted by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
</pre></div>
<p>
The variable <code>snapped</code> is true if the line had to be snapped onto a
gridline and in that case <code>y_fixed</code> holds the snapped
(altered) \( y \) value. To avoid interpolation in the structured mesh,
<code>snapped</code> is in fact <em>always</em> true.

<p>
A comparison of the numerical and exact solution along the line
\( y=0.5 \) (snapped from \( y=0.4 \)) is made by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
u_e_val <span style="color: #666666">=</span> [u0((x_, y_fixed)) <span style="color: #008000; font-weight: bold">for</span> x_ <span style="color: #AA22FF; font-weight: bold">in</span> x]

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, u_e_val, <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
See Figure <a href="#tut:structviz:fig1">4</a> (lower left) for the resulting curve plot.

<h3 id="___sec60">Curve plot of the flux </h3>

<p>
Let us also compare the numerical and
exact flux \( -p\partial u/\partial x \) along the same line as above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u <span style="color: #666666">=</span> flux(u, p)
flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)

<span style="color: #408080; font-style: italic"># Plot the numerical and exact flux along the same line</span>
flux2_x <span style="color: #666666">=</span> flux_u_x <span style="color: #008000; font-weight: bold">if</span> flux_u_x<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> \ 
          <span style="color: #008000; font-weight: bold">else</span> interpolate(flux_x,
               FunctionSpace(u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh(),
                             <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>))
flux_u_x_box <span style="color: #666666">=</span> structured_mesh(flux_u_x, (nx,ny))
x, flux_u_val, y_fixed, snapped <span style="color: #666666">=</span> \ 
   flux_u_x_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
y <span style="color: #666666">=</span> y_fixed

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, flux_u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, flux_u_x_exact(x, y_fixed), <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Flux along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
The second <code>plt.plot</code> command
requires a Python function <code>flux_u_x_exact(x,y)</code> to be
available for the exact flux expression.

<p>
Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a href="https://github.com/hplgit/scitools" target="_self">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.

<h3 id="___sec61">Test problem </h3>

<p>
The graphics referred to in Figure <a href="#tut:structviz:fig1">4</a> correspond to
a test problem with prescribed solution \( \uex = H(x)H(y) \), where

$$ H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x)\tp$$

We just fit a function \( f(x,y) \) in the PDE (can choose \( p=1 \)),
and notice that \( u=0 \) along the
boundary of the unit square. Although it is easy to carry out the
differentiation of \( f \) by hand and hardcode the resulting expressions
in an <code>Expression</code> object, a more reliable habit is to use Python's
symbolic computing engine, <code>sympy</code>, to perform mathematics and
automatically turn formulas into C++ syntax for <code>Expression</code> objects.
The following text assumes some familiarity with <code>sympy</code> and illustrates
how FEniCS programmers may take advantage of symbolic computing.

<p>
We start out with defining the exact solution in <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, pi  <span style="color: #408080; font-style: italic"># for use in math formulas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
H <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: exp(<span style="color: #666666">-16*</span>(x<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>sin(<span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>x)
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0], x[1]&#39;</span>)
u <span style="color: #666666">=</span> H(x)<span style="color: #666666">*</span>H(y)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to be have valid syntax for
<code>Expression</code> objects, and then \( x \) reads <code>x[0]</code> and \( y \) must be <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expression for <code>u</code> into C or C++ syntax for <code>Expression</code> objects
needs two steps. First we ask for the C code of the expression,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
</pre></div>
<p>
Then we do some editing of <code>u_c</code> to match the required syntax of
<code>Expression</code> objects. Printing <code>u_c</code> gives (here manually broken up as
two lines)

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
<p>
The necessary syntax adjustment is replacing
the symbol <code>M_PI</code> for \( \pi \) in C/C++ by <code>DOLFIN_PI</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> u_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;DOLFIN_PI&#39;</span>)
u0 <span style="color: #666666">=</span> Expression(u_c)
</pre></div>
<p>
Thereafter, we can progress with the computation of \( f = -\nabla\cdot(p\nabla u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">+</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
f_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
f_c <span style="color: #666666">=</span> f_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;DOLFIN_PI&#39;</span>)
f <span style="color: #666666">=</span> Expression(f_c)
</pre></div>
<p>
We also need a Python function for the exact flux \( -p\partial u/\partial x \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u_x_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y], <span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x),
                              modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
</pre></div>
<p>
It remains to define <code>p = Constant(1)</code> and set <code>nx</code> and <code>ny</code> before calling
<code>solver</code> to compute the finite element solution of this problem.

<p>
<!-- FIGURE: [fig/p2D_vc_structmesh, width=800 frac=1] Various plots of the solution on a structured mesh. <div id="tut:structviz:fig1a"></div> -->

<h2 id="tut:poisson1:DN">Combining Dirichlet and Neumann conditions</h2>

<p>
Let us make a slight extension of our two-dimensional Poisson problem
from the section <a href="#tut:poisson1:bvp">The Poisson equation</a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition \( u=u_0 \) at the left and right sides, \( x=0 \) and
\( x=1 \), while the Neumann condition

$$
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
$$

is applied to the remaining
sides \( y=0 \) and \( y=1 \).
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).

<p>
Let \( \Gamma_D \) and \( \Gamma_N \) denote the parts of \( \partial\Omega \)
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

$$
\begin{align}
    - \nabla^2 u &= f \mbox{ in } \Omega,  
\tag{31}\\ 
    u &= u_0 \mbox{ on } \Gamma_D,       
\tag{32}\\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N  \tp
\tag{33}
\end{align}
$$

Again we choose \( u=1+x^2 + 2y^2 \) as the exact solution and adjust \( f \), \( g \), and
\( u_0 \) accordingly:

$$
\begin{align*}
f &= -6,\\ 
g &= \left\lbrace\begin{array}{ll}
-4, & y=1\\ 
0,  & y=0
\end{array}\right.\\ 
u_0 &= 1 + x^2 + 2y^2\tp
\end{align*}
$$

For ease of programming we may introduce a \( g \) function defined over the whole
of \( \Omega \) such that \( g \) takes on the right values at \( y=0 \) and
\( y=1 \). One possible extension is

$$
\begin{equation*}
g(x,y) = -4y\tp
\end{equation*}
$$

<p>
The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
\( v \) is only zero on \( \Gamma_D \). We have

$$
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
$$

and since \( v=0 \) on \( \Gamma_D \),

$$
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v \ds
= \int_{\Gamma_N}gv \ds,
\end{equation*}
$$

by applying the boundary condition on \( \Gamma_N \).
The resulting weak form reads

$$
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx +
\int_{\Gamma_N} gv \ds
= \int_{\Omega} fv \dx\tp
\tag{34}
\end{equation}
$$

Expressing this equation
in the standard notation \( a(u,v)=L(v) \) is straightforward with

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{35}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\Gamma_N} gv \ds\tp  \tag{36}
\end{align}
$$

<p>
How does the Neumann condition impact the implementation?
Starting with any of the previous files <code>d*_p2D.py</code>, say
<code>d4_p2D.py</code>, we realize that the statements remain almost the same.
Only two adjustments are necessary:

<ul>
  <li> The function describing the boundary where Dirichlet conditions
    apply must be modified.</li>
  <li> The new boundary term must be added to the expression in <code>L</code>.</li>
</ul>

Step 1 can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">if</span> on_boundary:
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
</pre></div>
<p>
A more compact implementation reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
As pointed out already in the section <a href="#tut:poisson1:impl">Implementation of a Poisson solver</a>,
testing for an exact match of real numbers is
not good programming practice so we introduce a tolerance in the test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> \ 
           (<span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol)
</pre></div>
<p>
The second adjustment of our program concerns the definition of <code>L</code>,
where we have to add a boundary integral and a definition of the \( g \)
function to be integrated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-4*x[1]&#39;</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds
</pre></div>
<p>
The <code>ds</code> variable implies a boundary integral, while <code>dx</code>
implies an integral over the domain \( \Omega \).
No more modifications are necessary.

<p>
The file <code>dn1_p2D.py</code> in the <code>poisson</code> directory
implements this problem. Running the program verifies the implementation:
\( u \) equals the exact solution at all the nodes,
regardless of how many elements we use.

<h2 id="tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</h2>

<p>
The PDE problem from the previous section applies a function \( u_0(x,y) \)
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have \( m \) functions for
setting Dirichlet conditions on \( m \) parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

<p>
Let us
return to the case from the section <a href="#tut:poisson1:DN">Combining Dirichlet and Neumann conditions</a>
and define two separate functions for
the two Dirichlet conditions:

$$
\begin{align*}
    - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
    u &= u_L \mbox{ on } \Gamma_0, \\ 
    u &= u_R \mbox{ on } \Gamma_1, \\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N \tp
\end{align*}
$$

Here, \( \Gamma_0 \) is the boundary \( x=0 \), while
\( \Gamma_1 \) corresponds to the boundary \( x=1 \).
We have that \( u_L = 1 + 2y^2 \), \( u_R = 2 + 2y^2 \), and \( g=-4y \).
For the left boundary \( \Gamma_0 \) we
define
the usual triple of a function for the boundary value,
a function for defining
the boundary of interest, and a <code>DirichletBC</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">left_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_0 <span style="color: #666666">=</span> DirichletBC(V, u_L, left_boundary)
</pre></div>
<p>
For the boundary \( x=1 \) we write a similar code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">right_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

Gamma_1 <span style="color: #666666">=</span> DirichletBC(V, u_R, right_boundary)
</pre></div>
<p>
The various essential conditions are then collected in a list
and used in the solution process:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> [Gamma_0, Gamma_1]
<span style="color: #666666">...</span>
solve(a <span style="color: #666666">==</span> L, u, bcs)
<span style="color: #408080; font-style: italic"># or</span>
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bcs)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
In other problems, where the \( u \) values are constant at a part of the
boundary, we may use a simple <code>Constant</code> object instead of an
<code>Expression</code> object.

<p>
Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <code>get_boundary_values</code> method in the <code>DirichletBC</code> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding  essential conditions as values. In the present
problem we can write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
<span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
    <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (dof, bc_dict[dof],
	      <span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Lagrange_1st_order <span style="color: #666666">=</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>
<span style="color: #008000; font-weight: bold">if</span> Lagrange_1st_order:
    coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
    d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
    <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
        bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
        <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof])),
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
The output for a mesh made by <code>UnitSquareMesh(3, 2)</code> becomes
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dof  0: u=1 	 at point (0.0, 0.0)
dof  8: u=3 	 at point (0.0, 1.0)
dof  4: u=1.5 	 at point (0.0, 0.5)
dof  3: u=2 	 at point (1.0, 0.0)
dof 11: u=4 	 at point (1.0, 1.0)
dof  7: u=2.5 	 at point (1.0, 0.5)
</pre></div>
<p>
The file <code>dn2_p2D.py</code> contains a complete program which
demonstrates the constructions above.
An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the mesh function concept and is therefore
left to the section <a href="._ftut006.html#tut:poisson:mat:neumann">Multiple Neumann, Robin, and Dirichlet condition</a>.

<h2 id="tut:poisson1:linalg">A linear algebra formulation</h2>

<p>
Given \( a(u,v)=L(v) \), the discrete solution \( u \) is computed by
inserting \( u=\sum_{j=1}^N U_j \phi_j \) into \( a(u,v) \) and demanding
\( a(u,v)=L(v) \) to be fulfilled for \( N \) test functions
\( \hat\phi_1,\ldots,\hat\phi_N \). This implies

$$
\begin{equation*}
\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,
\end{equation*}
$$

which is nothing but a linear system,

$$
\begin{equation*}
  AU = b,
\end{equation*}
$$

where the entries in \( A \) and \( b \) are given by

$$
\begin{align*}
  A_{ij} &= a(\phi_j, \hat{\phi}_i), \\ 
  b_i &= L(\hat\phi_i)\tp
\end{align*}
$$

<p>
The examples so far have specified the left- and right-hand side of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it.  An alternative to is explicitly call
functions for assembling the coefficient matrix \( A \) and the right-side
vector \( b \), and then solve the linear system \( AU=b \) with respect to
the \( U \) vector.  Instead of <code>solve(a == L, u, b)</code> we now write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
bc<span style="color: #666666">.</span>apply(A, b)
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
solve(A, U, b)
</pre></div>
<p>
The variables <code>a</code> and <code>L</code> are as before. That is, <code>a</code> refers to the
bilinear form involving a <code>TrialFunction</code> object (say <code>u</code>)
and a <code>TestFunction</code> object (<code>v</code>), and <code>L</code> involves a
<code>TestFunction</code> object (<code>v</code>). From <code>a</code> and <code>L</code>,
the <code>assemble</code> function can
compute \( A \) and \( b \).

<p>
The matrix \( A \) and vector \( b \) are first assembled without incorporating
essential (Dirichlet) boundary conditions. Thereafter, the
call <code>bc.apply(A, b)</code> performs the necessary modifications of
the linear system such that <code>u</code> is guaranteed to equal the prescribed
boundary values.
When we have multiple Dirichlet conditions stored in a list <code>bcs</code>,
as explained in the section <a href="#tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>, we must apply
each condition in <code>bcs</code> to the system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># bcs is a list of DirichletBC objects</span>
<span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc<span style="color: #666666">.</span>apply(A, b)
</pre></div>
<p>
There is an alternative function <code>assemble_system</code>, which can
assemble the system and take boundary conditions into account in one call:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A, b <span style="color: #666666">=</span> assemble_system(a, L, bcs)
</pre></div>
<p>
The <code>assemble_system</code> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.
The conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.
<!-- That is, for each degree of freedom -->
<!-- that is known, the corresponding row and column is zero'ed out and 1 -->
<!-- is placed on the main diagonal, and the right-hand side <code>b</code> is -->
<!-- modified by subtracting the column in <code>A</code> times the value of the -->
<!-- degree of, and then the corresponding entry in <code>b</code> is replaced by the -->
<!-- known value of the degree of freedom. -->
With <code>bc.apply(A, b)</code> the
matrix <code>A</code> is modified in an nonsymmetric way.
<!-- : The row is zero'ed out -->
<!-- and 1 is placed on the main diagonal, and the degree of freedom value -->
<!-- is inserted in <code>b</code>. -->

<p>
Note that the solution <code>u</code> is, as before, a <code>Function</code> object.
The degrees of freedom, \( U=A^{-1}b \), are filled
into <code>u</code>'s <code>Vector</code> object (<code>u.vector()</code>)
by the <code>solve</code> function.

<p>
The object <code>A</code> is of type <code>Matrix</code>, while <code>b</code> and
<code>u.vector()</code> are of type <code>Vector</code>. We may convert the
matrix and vector data to <code>numpy</code> arrays by calling the
<code>array()</code> method as shown before. If you wonder how essential
boundary conditions are incorporated in the linear system, you can
print out <code>A</code> and <code>b</code> before and after the
<code>bc.apply(A, b)</code> call:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>:  <span style="color: #408080; font-style: italic"># print for small meshes only</span>
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
bc<span style="color: #666666">.</span>apply(A, b)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>:
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
</pre></div>
<p>
With access to the elements in <code>A</code> through a <code>numpy</code> array we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code>eig</code> function in <code>numpy.linalg</code>). We can alternatively dump
<code>A.array()</code> and <code>b.array()</code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.io</span>
scipy<span style="color: #666666">.</span>io<span style="color: #666666">.</span>savemat(<span style="color: #BA2121">&#39;Ab.mat&#39;</span>, {<span style="color: #BA2121">&#39;A&#39;</span>: A<span style="color: #666666">.</span>array(), <span style="color: #BA2121">&#39;b&#39;</span>: b<span style="color: #666666">.</span>array()})
</pre></div>
<p>
Writing <code>load Ab.mat</code> in MATLAB or Octave will then make
the array variables <code>A</code> and <code>b</code> available for computations.

<p>
Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code>numpy</code> arrays or matrices in MATLAB
file format are dense matrices. DOLFIN also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <code>demo/la/eigenvalue</code> in the DOLFIN source code tree
for a demo).

<p>
A complete code where the linear system \( AU=b \) is explicitly assembled and
solved is found in the file <code>dn3_p2D.py</code> in the directory
<code>poisson</code>. This code solves the same problem as in
<code>dn2_p2D.py</code>
(the section <a href="#tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>).  For small
linear systems, the program writes out <code>A</code> and <code>b</code> before and
after incorporation of essential boundary conditions and illustrates
the difference between <code>assemble</code> and <code>assemble_system</code>.
The reader is encouraged to run the code for a \( 2\times 1 \)
mesh (<code>UnitSquareMesh(2, 1)</code> and study the output of <code>A</code>.

<p>
By default, <code>solve(A, U, b)</code> applies sparse LU decomposition
as solver. Specification of an iterative solver and preconditioner
is done through two optional arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solve(A, U, b, <span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
</pre></div>
<p>
Appropriate names of solvers and preconditioners are found in
the section <a href="._ftut009.html#tut:app:solver:prec">Linear solvers and preconditioners</a>.

<p>
To control tolerances in the stopping criterion and the maximum
number of iterations, one can explicitly form a <code>KrylovSolver</code> object
and set items in its <code>parameters</code> attribute
(see also the section <a href="#tut:poisson1:solver:problem">Linear variational problem and solver objects</a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solver <span style="color: #666666">=</span> KrylovSolver(<span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
set_log_level(DEBUG)
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
The program <code>dn4_p2D.py</code> is a modification of <code>dn3_p2D.py</code>
illustrating this latter approach.

<p>
The choice of start vector for the iterations in a linear solver is often
important. With the <code>solver.solve(A, U, b)</code> call the default start vector
is the zero vector. A start vector
with random numbers in the interval \( [-100,100] \) can be computed as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>size
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
U[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">-100</span>, <span style="color: #666666">100</span>, n)
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
Note that we must turn off the default behavior of setting the start
vector ("initial guess") to zero.
A random start vector is included in the <code>dn4_p2D.py</code> code.

<p>
Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, \( A \) may
be constant throughout a time-dependent simulation, so we can avoid
recalculating \( A \) at every time level and save a significant amount
of simulation time.  The sections <a href="._ftut003.html#tut:timedep:diffusion1:impl">Implementation</a>
and <a href="._ftut003.html#tut:timedep:diffusion1:noassemble">Avoiding assembly</a> deal with this topic
in detail.

<p>
<!-- In other problems, we may divide the variational -->
<!-- problem and linear system into different terms, say \( A=M + {\dt} K \), -->
<!-- where \( M \) is a matrix arising from a term like \( \partial u/\partial t \), -->
<!-- \( K \) is a term corresponding to a Laplace operator, and \( \dt \) is -->
<!-- a time discretization parameter. When \( \dt \) is changed in time, -->
<!-- we can efficiently recompute \( A = M + {\dt} K \) without -->
<!-- reassembling the constant matrices \( M \) and \( K \). This strategy may -->
<!-- speed up simulations significantly. -->

<h2 id="tut:poisson:nD">Parameterizing the number of space dimensions</h2>

<p>
FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory programs <code>p2D_plain.py</code> or <code>p2D_func.py</code> in the <code>poisson</code> directory
and change the mesh construction from <code>UnitSquareMesh(6, 4)</code> to
<code>UnitCubeMesh(6, 4, 5)</code>. Now the domain is the unit cube partitioned into
\( 6\times 4\times 5 \) boxes, and each box is divided into six
tetrahedra-shaped finite elements for computations.  Run the program
and observe that we can solve a 3D problem without any other
modifications (!). The visualization allows you to rotate the cube and
observe the function values as colors on the boundary.

<p>
The forthcoming material introduces some convenient
technicalities such that the same program can run in 1D, 2D, or 3D
without any modifications.
Consider the simple model problem

$$
\begin{equation}
u''(x) = 2\hbox{ in }[0,1],\quad u(0)=0,\ u(1)=1,
\tag{37}
\end{equation}
$$

with exact solution \( u(x)=x^2 \). Our aim is to formulate and solve this
problem in a 2D and a 3D domain as well.
We may generalize the domain \( [0,1] \) to a rectangle or box of any size
in the \( y \) and \( z \) directions and pose homogeneous Neumann
conditions \( \partial u/\partial n = 0 \) at all additional boundaries
\( y=\mbox{const} \) and \( z=\mbox{const} \) to ensure that \( u \) only varies with
\( x \). For example, let us choose
a unit hypercube as domain: \( \Omega = [0,1]^d \), where \( d \) is the number
of space dimensions. The generalized \( d \)-dimensional Poisson problem
then reads

$$
\begin{equation} \tag{38}
  \begin{array}{rcll}
    \nabla^2 u &=& 2 &\mbox{in } \Omega, \\ 
    u &=& 0 &\mbox{on } \Gamma_0,\\ 
    u &=& 1 &\mbox{on } \Gamma_1,\\ 
{\partial u\over\partial n} &=& 0 &\mbox{on } \partial\Omega\backslash\left(
\Gamma_0\cup\Gamma_1\right),
  \end{array}
\end{equation}
$$

where \( \Gamma_0 \) is the side of the hypercube where \( x=0 \), and
where \( \Gamma_1 \) is the side where \( x=1 \).

<p>
Implementing a PDE for any \( d \) is no more
complicated than solving a problem with a specific number of dimensions.
The only non-trivial part of the code is actually to define the mesh.
We use the command line for the user-input to the program. The first argument
can be the degree of the polynomial in the finite element basis functions.
Thereafter, we supply the
cell divisions in the various spatial directions. The number of
command-line arguments will then imply the number of space dimensions.
For example, writing <code>3 10 3 4</code> on the command line means that
we want to approximate \( u \) by piecewise polynomials of degree 3,
and that the domain is a three-dimensional cube with \( 10\times 3\times 4 \)
divisions in the \( x \), \( y \), and \( z \) directions, respectively.
<!-- Each of the \( 10\times 3\times 4 = 120 \) boxes will -->
<!-- be divided into six tetrahedra. -->
The Python code can be quite compact:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">degree <span style="color: #666666">=</span> <span style="color: #008000">int</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
divisions <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(arg) <span style="color: #008000; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>:]]
d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(divisions)
domain_type <span style="color: #666666">=</span> [UnitIntervalMesh, UnitSquareMesh, UnitCubeMesh]
mesh <span style="color: #666666">=</span> domain_type[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, degree)
</pre></div>
<p>
First note that although <code>sys.argv[2:]</code> holds the divisions of
the mesh, all elements of the list <code>sys.argv[2:]</code> are string objects,
so we need to explicitly convert each element to an integer.
The construction <code>domain_type[d-1]</code> will pick the right name of the
object used to define the domain and generate the mesh.
Moreover, the argument <code>*divisions</code>
sends all the component of the list <code>divisions</code> as separate
arguments. For example, in a 2D problem where <code>divisions</code> has
two elements, the statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> domain_type[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
</pre></div>
<p>
is equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitSquareMesh(divisions[<span style="color: #666666">0</span>], divisions[<span style="color: #666666">1</span>])
</pre></div>
<p>
The next part of the program is to set up the boundary conditions.
Since the Neumann conditions have \( \partial u/\partial n=0 \) we can
omit the boundary integral from the weak form. We then only
need to take care of Dirichlet conditions at two sides:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary0</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary1</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

bc0 <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), Dirichlet_boundary0)
bc1 <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">1</span>), Dirichlet_boundary1)
bcs <span style="color: #666666">=</span> [bc0, bc1]
</pre></div>
<p>
Note that this code is independent of the number of space dimensions.
So are the statements defining and solving
the variational problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-2</span>)
a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bcs)
</pre></div>
<p>
The complete code is found in the file <code>paD.py</code> (Poisson problem in "anyD").

<p>
If we want to parameterize the direction in which \( u \) varies, say by
the space direction number <code>e</code>, we only need to replace <code>x[0]</code> in the
code by <code>x[e]</code>. The parameter <code>e</code> could be given as a second
command-line argument.  The reader is encouraged to perform this
modification.

<h2 id="___sec66">Handy methods in key FEniCS objects </h2>

<p>
In general,
<code>pydoc dolfin.X</code> shows the documentation of any DOLFIN name <code>X</code>
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.

<h3 id="___sec67">Mesh </h3>

<p>
Let <code>mesh</code> be a <code>Mesh</code> object.

<ul>
  <li> <code>mesh.coordinates()</code> returns an array of the coordinates of
     the vertices in the mesh.</li>
  <li> <code>mesh.num_cells()</code> returns the number of cells (triangles)
    in the mesh,</li>
  <li> <code>mesh.num_vertices()</code> returns the number of vertices in
    the mesh (with our choice of linear Lagrange elements this equals the
    number of nodes, <code>len(u_array)</code>, or dimension of the space <code>V.dim()</code>),</li>
  <li> <code>mesh.cells()</code> returns the vertex numbers of the vertices in
    each cell as a <code>numpy</code> array with shape
    (<em>number of cells</em>, <em>number of vertices in a cell</em>),</li>
  <li> <code>mesh.hmin()</code> returns the minimum cell diameter (&quot;smallest cell&quot;),</li>
  <li> <code>mesh.hmax()</code> returns the maximum cell diameter (&quot;largest cell&quot;).</li>
</ul>

Writing <code>print(mesh)</code> dumps a short, pretty-print description
of the mesh (<code>print(mesh)</code> actually displays the result of <code>str(mesh)</code>,
which defines the pretty print):

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>

<h3 id="___sec68">Function space </h3>

<p>
Let <code>V</code> be a <code>FunctionSpace</code> object.

<ul>
 <li> <code>V.mesh()</code> returns the associated mesh.</li>
 <li> <code>V.dim()</code> returns the dimension (number of degrees of freedom).</li>
 <li> <code>V.ufl_element()</code> returns the associated finite element.</li>
</ul>

<h3 id="___sec69">Function </h3>

<p>
Let <code>u</code> be a <code>Function</code> object.

<ul>
 <li> <code>u.function_space()</code> returns the associated function space.</li>
 <li> <code>u.vector()</code> returns the DOLFIN vector of degrees of freedom.</li>
 <li> <code>u.vector().array()</code> returns a copy of the degrees of freedom
   in a <code>numpy</code> array.</li>
</ul>

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut001.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="._ftut001.html">2</a></li>
  <li class="active"><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li><a href="._ftut009.html">10</a></li>
  <li><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut003.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

