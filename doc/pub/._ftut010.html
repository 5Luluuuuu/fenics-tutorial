<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,assembly, increasing efficiency,heterogeneous medium,multi-material domain,nonlinear variational problems,Gateaux derivative,automatic differentiation,Jacobian, automatic computation,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,troubleshooting,compilation problems,plotting problems">

<title>The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals', 0, u'ch:fundamentals', u'ch:fundamentals'),
              (u'The Poisson equation', 1, None, '___sec14'),
              (u'Mathematical problem formulation',
               2,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ftut:poisson1:varform',
               u'ftut:poisson1:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ftut:poisson1:abstrat',
               u'ftut:poisson1:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ftut:poisson1:testproblem',
               u'ftut:poisson1:testproblem'),
              (u'FEniCS implementation',
               2,
               u'ftut:poisson1:impl',
               u'ftut:poisson1:impl'),
              (u'Running the program',
               2,
               u'ftut:poisson1:impl:run',
               u'ftut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'ftut:poisson1:impl:dissect',
               u'ftut:poisson1:impl:dissect'),
              (u'The important first line', 3, None, '___sec22'),
              (u'Generating simple meshes', 3, None, '___sec23'),
              (u'Defining the finite element function space',
               3,
               None,
               '___sec24'),
              (u'Defining the trial and test functions', 3, None, '___sec25'),
              (u'Defining the boundary and the boundary conditions',
               3,
               None,
               '___sec26'),
              (u'Defining the source term', 3, None, '___sec27'),
              (u'Defining the variational problem', 3, None, '___sec28'),
              (u'Forming and solving the linear system', 3, None, '___sec29'),
              (u'Examining the values of the solution', 3, None, '___sec30'),
              (u'Plotting the solution', 3, None, '___sec31'),
              (u'Plotting in ParaView', 2, None, '___sec32'),
              (u'Deflection of a membrane',
               1,
               u'ftut:poisson:membrane',
               u'ftut:poisson:membrane'),
              (u'Scaling', 2, None, '___sec34'),
              (u'Defining the mesh', 2, None, '___sec35'),
              (u'Defining the load', 2, None, '___sec36'),
              (u'Variational form', 2, None, '___sec37'),
              (u'Visualization', 2, None, '___sec38'),
              (u'Curve plots through the domain', 2, None, '___sec39'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec42'),
              (u'The time-dependent diffusion equation',
               1,
               u'ftut:timedep',
               u'ftut:timedep'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec46'),
              (u'The code', 3, None, '___sec47'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec48'),
              (u'The mathematical problem', 3, None, '___sec49'),
              (u'Implementation', 3, None, '___sec50'),
              (u'Visualization in ParaView', 3, None, '___sec51'),
              (u'A nonlinear Poisson equation', 1, None, '___sec52'),
              (u'Variational formulation', 2, None, '___sec53'),
              (u'A simple implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Overview', 3, None, '___sec55'),
              (u'Constructing a test problem with SymPy',
               3,
               None,
               '___sec56'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple implementation', 2, None, '___sec59'),
              (u'Test problem', 3, None, '___sec60'),
              (u'Code', 3, None, '___sec61'),
              (u'The Navier--Stokes equations', 1, None, '___sec62'),
              (u'Variational formulation', 2, None, '___sec63'),
              (u'A simple implementation', 2, None, '___sec64'),
              (u'The Poisson solver revisited',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'ftut:poisson1:impl2',
               u'ftut:poisson1:impl2'),
              (u'A general solver function', 2, None, '___sec67'),
              (u'Plotting for the test problem', 3, None, '___sec68'),
              (u'Make a module!', 3, None, '___sec69'),
              (u'Verification and unit tests', 2, None, '___sec70'),
              (u'Exercise 2: Solve a Poisson problem', 2, None, '___sec71'),
              (u'Remarks', 3, None, '___sec72'),
              (u'Exercise 3: Refactor the code for membrane deflection',
               2,
               u'ftut:poisson:exer:membrane',
               u'ftut:poisson:exer:membrane'),
              (u'Useful extensions', 1, None, '___sec74'),
              (u'Controlling the solution process',
               2,
               u'ftut:poisson1:solve:prm',
               u'ftut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec76'),
              (u'Linear algebra backend', 3, None, '___sec77'),
              (u'The `parameters` database', 3, None, '___sec78'),
              (u'An extended solver function', 3, None, '___sec79'),
              (u'Remark regarding unit tests', 3, None, '___sec80'),
              (u'Linear variational problem and solver objects',
               2,
               u'ftut:poisson1:solver:problem',
               u'ftut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'ftut:poisson1:verify1',
               u'ftut:poisson1:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ftut:poisson:nD',
               u'ftut:poisson:nD'),
              (u'Generating a hypercube', 3, None, '___sec84'),
              (u'Computing derivatives',
               2,
               u'ftut:poisson:gradu',
               u'ftut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec87'),
              (u'Modifications of the PDE solver', 3, None, '___sec88'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec89'),
              (u'Creating the linear system explicitly',
               2,
               u'ftut:poisson1:linalg',
               u'ftut:poisson1:linalg'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec92'),
              (u'Finite difference approximations', 3, None, '___sec93'),
              (u'Surface plot', 3, None, '___sec94'),
              (u'Contour plot', 3, None, '___sec95'),
              (u'Curve plot through the mesh', 3, None, '___sec96'),
              (u'Curve plot of the flux', 3, None, '___sec97'),
              (u'Test problem', 3, None, '___sec98'),
              (u'Postprocessing computations', 1, None, '___sec99'),
              (u'Computing functionals',
               2,
               u'ftut:poisson1:functionals',
               u'ftut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec101'),
              (u'Error functional', 3, None, '___sec102'),
              (u'Flux Functionals', 3, None, '___sec103'),
              (u'Computing convergence rates',
               2,
               u'ftut:poisson1:convrates',
               u'ftut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec105'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec106'),
              (u'Test problem', 3, None, '___sec107'),
              (u'Experiments', 3, None, '___sec108'),
              (u'Multiple domains and boundaries', 1, None, '___sec109'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'ftut:poisson1:DN',
               u'ftut:poisson1:DN'),
              (u'PDE problem', 3, None, '___sec111'),
              (u'Variational formulation', 3, None, '___sec112'),
              (u'Implementation', 3, None, '___sec113'),
              (u'Multiple Dirichlet conditions',
               2,
               u'ftut:poisson:multiple:Dirichlet',
               u'ftut:poisson:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec115'),
              (u'Working with subdomains',
               2,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec117'),
              (u'Mesh functions', 3, None, '___sec118'),
              (u'C++ strings for subdomain definitions',
               3,
               None,
               '___sec119'),
              (u'Exercise 4: Efficiency of Python vs C++ expressions',
               2,
               u'ftut:poisson:exer:eff:expression',
               u'ftut:poisson:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'ftut:poisson:multi:bc',
               u'ftut:poisson:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec122'),
              (u'A general model problem', 3, None, '___sec123'),
              (u'Variational formulation', 3, None, '___sec124'),
              (u'Implementation of boundary conditions',
               3,
               None,
               '___sec125'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec126'),
              (u'Test problem', 3, None, '___sec127'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec128'),
              (u'Implementation of multiple subdomains',
               3,
               None,
               '___sec129'),
              (u'Refactoring of a solver function into solver and problem classes',
               2,
               None,
               '___sec130'),
              (u'The diffusion solver revisited',
               0,
               u'ch:diffusion',
               u'ch:diffusion'),
              (u'Optimization of algorithms and implementations',
               1,
               None,
               '___sec132'),
              (u'Avoiding some assembly', 2, None, '___sec133'),
              (u'Avoiding all assembly',
               2,
               u'ftut:timedep:diffusion1:noassemble',
               u'ftut:timedep:diffusion1:noassemble'),
              (u'Deriving recursive linear systems', 3, None, '___sec135'),
              (u'Implementation', 3, None, '___sec136'),
              (u'A welding example with post processing and animation',
               1,
               u'ch:diffusion:welding',
               u'ch:diffusion:welding'),
              (u'Post processing data and saving to file',
               2,
               u'ch:diffusion:welding:cbcpost',
               u'ch:diffusion:welding:cbcpost'),
              (u'Installation', 3, None, '___sec139'),
              (u'Basic commands', 3, None, '___sec140'),
              (u'Heat transfer due to a moving welding source',
               2,
               u'ch:diffusion:welding:problem',
               u'ch:diffusion:welding:problem'),
              (u'Scaling of the welding problem',
               2,
               u'ch:diffusion:welding:scaling',
               u'ch:diffusion:welding:scaling'),
              (u'A function-based solver',
               2,
               u'ch:diffusion:welding:funcsolver',
               u'ch:diffusion:welding:funcsolver'),
              (u'Refactored implementation',
               1,
               u'ch:diffusion:refactor',
               u'ch:diffusion:refactor'),
              (u'A class-based solver for a general diffusion problem',
               2,
               u'ch:diffusion:refactor:class_solver',
               u'ch:diffusion:refactor:class_solver'),
              (u'Exercise 5: Implement second-order schemes in time',
               2,
               None,
               '___sec146'),
              (u'A physical example',
               2,
               u'ftut:timedep:diffusion2:sin',
               u'ftut:timedep:diffusion2:sin'),
              (u'The nonlinear Poisson solver revisited',
               0,
               u'ftut:nonlinear',
               u'ftut:nonlinear'),
              (u'Test problem', 3, None, '___sec149'),
              (u'The built-in automated Newton solver',
               1,
               u'ftut:poisson:nonlinear',
               u'ftut:poisson:nonlinear'),
              (u'Computing the Jacobian', 2, None, '___sec151'),
              (u'Setting solver parameters', 2, None, '___sec152'),
              (u'Implementation', 2, None, '___sec153'),
              (u'Manual implementation of solution algorithms',
               1,
               None,
               '___sec154'),
              (u'Picard iteration',
               2,
               u'ftut:nonlinear:Picard',
               u'ftut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'ftut:nonlinear:Newton:algebraic',
               u'ftut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'ftut:nonlinear:Newton:pdelevel',
               u'ftut:nonlinear:Newton:pdelevel'),
              (u'More old stuff', 0, None, '___sec158'),
              (u'Creating more complex domains',
               1,
               u'ftut:prepro',
               u'ftut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'ftut:prepro:builtin',
               u'ftut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'ftut:mesh:transform:cyl',
               u'ftut:mesh:transform:cyl'),
              (u'Coordinate stretching', 3, None, '___sec162'),
              (u'Rectangle to hollow circle mapping', 3, None, '___sec163'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'ftut:possion:nD:nmat',
               u'ftut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'ftut:possion:nD:nmat:PDE',
               u'ftut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'ftut:possion:nD:nmat:prepro',
               u'ftut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'ftut:possion:nD:nmat:solve',
               u'ftut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec168'),
              (u'Miscellaneous topics', 1, None, '___sec169'),
              (u'Glossary', 2, None, '___sec170'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec171'),
              (u'Mesh', 3, None, '___sec172'),
              (u'Function space', 3, None, '___sec173'),
              (u'Function', 3, None, '___sec174'),
              (u'Overview of objects and functions', 2, None, '___sec175'),
              (u'Linear solvers and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'ftut:Epetra',
               u'ftut:Epetra'),
              (u'Troubleshooting', 0, u'ftut:trouble', u'ftut:trouble'),
              (u'Compilation Problems', 1, None, '___sec179'),
              (u'Problems with the Instant cache', 2, None, '___sec180'),
              (u'Syntax errors in expressions', 2, None, '___sec181'),
              (u'Example', 3, None, '___sec182'),
              (u'Problems in the solve step', 2, None, '___sec183'),
              (u'Unable to convert object to a UFL form',
               2,
               None,
               '___sec184'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               2,
               None,
               '___sec185'),
              (u'All programs fail to compile', 2, None, '___sec186'),
              (u'Problems with Expression Objects', 1, None, '___sec187'),
              (u'There seems to be some bug in an Expression object',
               2,
               None,
               '___sec188'),
              (u'Segmentation fault when using an Expression object',
               2,
               None,
               '___sec189'),
              (u'Other Problems', 1, None, '___sec190'),
              (u'Very strange error message involving a `mesh` variable',
               2,
               None,
               '___sec191'),
              (u'The plot disappears quickly from the screen',
               2,
               None,
               '___sec192'),
              (u'Only parts of the program are executed',
               2,
               None,
               '___sec193'),
              (u'Error in the definition of the boundary',
               2,
               None,
               '___sec194'),
              (u'The solver in a nonlinear problems does not converge',
               2,
               None,
               '___sec195'),
              (u'How To Debug a FEniCS Program?', 1, None, '___sec196'),
              (u'To-do list', 1, None, '___sec197'),
              (u'AL list', 2, None, '___sec198'),
              (u'HPL list', 2, None, '___sec199'),
              (u'HPL questions', 2, None, '___sec200'),
              (u'Iterative linear solvers info', 3, None, '___sec201'),
              (u'Bibliography', 1, None, '___sec202')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ftut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ftut:poisson1:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#ftut:poisson1:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:poisson1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:timedep" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The time-dependent diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec48" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing a test problem with SymPy</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#ch:poisson" style="font-size: 80%;"><b>The Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#ftut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#ftut:poisson:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Useful extensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec77" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#ftut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#ftut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:poisson:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:poisson:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactoring of a solver function into solver and problem classes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion" style="font-size: 80%;"><b>The diffusion solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of algorithms and implementations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding some assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ftut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding all assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving recursive linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:welding" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A welding example with post processing and animation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:welding:cbcpost" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Post processing data and saving to file</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic commands</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:welding:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heat transfer due to a moving welding source</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:welding:scaling" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling of the welding problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:welding:funcsolver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A function-based solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:refactor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:diffusion:refactor:class_solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A class-based solver for a general diffusion problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Implement second-order schemes in time</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ftut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:nonlinear" style="font-size: 80%;"><b>The nonlinear Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:poisson:nonlinear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The built-in automated Newton solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Manual implementation of solution algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec158" style="font-size: 80%;"><b>More old stuff</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ftut:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating more complex domains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ftut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ftut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinate stretching</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec163" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle to hollow circle mapping</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:possion:nD:nmat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A General \( d \)-Dimensional multi-material test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More Examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Miscellaneous topics</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec172" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#ftut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec180" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec182" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec183" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec184" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec185" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec186" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec187" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec189" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec190" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec191" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Very strange error message involving a <code>mesh</code> variable</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disappears quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec195" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec196" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec197" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;To-do list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec198" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec199" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec201" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec202" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0010"></a>
<!-- !split -->

<h1 id="___sec109">Multiple domains and boundaries </h1>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 11</b>: Need a little intro.)</font>
<!-- end inline comment -->

<h2 id="ftut:poisson1:DN">Combining Dirichlet and Neumann conditions</h2>

<p>
Let us make a slight extension of our two-dimensional Poisson problem
from the section <a href="._ftut004.html#ftut:poisson1:bvp">Mathematical problem formulation</a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition \( u=u_0 \) at the left and right sides, \( x=0 \) and
\( x=1 \), while the Neumann condition

$$
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
$$

is applied to the remaining
sides \( y=0 \) and \( y=1 \).
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).

<h3 id="___sec111">PDE problem </h3>

<p>
Let \( \Gamma_D \) and \( \Gamma_N \) denote the parts of \( \partial\Omega \)
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

$$
\begin{align}
    - \nabla^2 u &= f \mbox{ in } \Omega,  
\tag{3.15}\\ 
    u &= u_0 \mbox{ on } \Gamma_D,       
\tag{3.16}\\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N  \tp
\tag{3.17}
\end{align}
$$

Again we choose \( u=1+x^2 + 2y^2 \) as the exact solution and adjust \( f \), \( g \), and
\( u_0 \) accordingly:

$$
\begin{align*}
f &= -6,\\ 
g &= \left\lbrace\begin{array}{ll}
-4, & y=1\\ 
0,  & y=0
\end{array}\right.\\ 
u_0 &= 1 + x^2 + 2y^2\tp
\end{align*}
$$

For ease of programming we may introduce a \( g \) function defined over the whole
of \( \Omega \) such that \( g \) takes on the right values at \( y=0 \) and
\( y=1 \). One possible extension is

$$
\begin{equation*}
g(x,y) = -4y\tp
\end{equation*}
$$

<h3 id="___sec112">Variational formulation </h3>

<p>
The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
\( v \) is only zero on \( \Gamma_D \). We have

$$
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
$$

and since \( v=0 \) on \( \Gamma_D \),

$$
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v \ds
= \int_{\Gamma_N}gv \ds,
\end{equation*}
$$

by applying the boundary condition on \( \Gamma_N \).
The resulting weak form reads

$$
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx +
\int_{\Gamma_N} gv \ds
= \int_{\Omega} fv \dx\tp
\tag{3.18}
\end{equation}
$$

Expressing this equation
in the standard notation \( a(u,v)=L(v) \) is straightforward with

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{3.19}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\Gamma_N} gv \ds\tp  \tag{3.20}
\end{align}
$$

<h3 id="___sec113">Implementation </h3>

<p>
How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code>ft01_poisson_flat.py</code>, from
the section <a href="._ftut006.html#ftut:poisson1:impl:code">ftut:poisson1:impl:code</a>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:

<ul>
  <li> The function describing the boundary where Dirichlet conditions
    apply must be modified.</li>
  <li> The new boundary term must be added to the expression in <code>L</code>.</li>
</ul>

The first adjustment can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">if</span> on_boundary:
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
</pre></div>
<p>
A more compact implementation reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Never use <code>==</code> for comparing real numbers!</b>
A list like <code>x[0] == 1</code> should never be used if <code>x[0]</code> is a real number,
because rounding errors in <code>x[0]</code> may make the test fail even when it is
mathematically correct. Consider

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span> <span style="color: #666666">==</span> <span style="color: #666666">0.3</span>
<span style="color: #008000">False</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span>
<span style="color: #666666">0.30000000000000004</span>
</pre></div>
<p>
Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">0.1+0.2</span> <span style="color: #666666">-</span> <span style="color: #666666">0.3</span>)
<span style="color: #666666">5.551115123125783e-17</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1.1+1.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10.1+10.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20.3</span>)
<span style="color: #666666">3.552713678800501e-15</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">100.1+100.2</span> <span style="color: #666666">-</span> <span style="color: #666666">200.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1000.1+1000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2000.3</span>)
<span style="color: #666666">2.2737367544323206e-13</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10000.1+10000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20000.3</span>)
<span style="color: #666666">3.637978807091713e-12</span>
</pre></div>
<p>
For numbers around unity, tolerances as low as \( 3\cdot 10^{-16} \) can be used
(in fact, this tolerance is known as the constant <code>DOLFIN_EPS</code> in FEniCS),
otherwise an appropriate tolerance must be found.

<p>
Testing for <code>x[0] == 1</code> should therefore be implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol:
    <span style="color: #666666">...</span>
</pre></div>
<p>
</div>


<p>
Here is a new boundary function using tolerances in the test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> \ 
           (<span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol)
</pre></div>
<p>
The second adjustment of our program concerns the definition of <code>L</code>,
where we have to add a boundary integral and a definition of the \( g \)
function to be integrated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-4*x[1]&#39;</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds
</pre></div>
<p>
The <code>ds</code> variable implies a boundary integral, while <code>dx</code>
implies an integral over the domain \( \Omega \).
No more modifications are necessary.

<h2 id="ftut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</h2>

<p>
The PDE problem from the previous section applies a function \( u_0(x,y) \)
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have \( m \) functions for
setting Dirichlet conditions on \( m \) parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

<p>
Let us return to the case from the section <a href="#ftut:poisson1:DN">Combining Dirichlet and Neumann conditions</a> and define
two separate functions for the two Dirichlet conditions:

$$
\begin{align*}
    - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
    u &= u_L \mbox{ on } \Gamma_0, \\ 
    u &= u_R \mbox{ on } \Gamma_1, \\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N \tp
\end{align*}
$$

Here, \( \Gamma_0 \) is the boundary \( x=0 \), while \( \Gamma_1 \) corresponds
to the boundary \( x=1 \).  We have that \( u_L = 1 + 2y^2 \), \( u_R = 2 +
2y^2 \), and \( g=-4y \).

<h3 id="___sec115">Functions for marking Dirichlet boundaries </h3>

<p>
For the left boundary \( \Gamma_0 \) we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code>DirichletBC</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">left_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_0 <span style="color: #666666">=</span> DirichletBC(V, u_L, left_boundary)
</pre></div>
<p>
For the boundary \( x=1 \) we write a similar code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">right_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

Gamma_1 <span style="color: #666666">=</span> DirichletBC(V, u_R, right_boundary)
</pre></div>
<p>
The various essential conditions are then collected in a list
and used in the solution process:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> [Gamma_0, Gamma_1]
<span style="color: #666666">...</span>
solve(a <span style="color: #666666">==</span> L, u, bcs)
<span style="color: #408080; font-style: italic"># or</span>
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bcs)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
In other problems, where the \( u \) values are constant at a part of the
boundary, we may use a simple <code>Constant</code> object instead of an
<code>Expression</code> object.

<h2 id="ftut:possion:2D:2mat:impl">Working with subdomains</h2>

<p>
Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent
the various materials. We can thereafter define material properties
through functions, known in FEniCS as <em>mesh functions</em>, that are
piecewise constant in each subdomain.  A simple example with two
materials (subdomains) in 2D will demonstrate the basic steps in the
process.

<p>
<center> <!-- figure label: --> <div id="ftut:possion:2D:2mat:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Medium with discontinuous material properties.  <!-- caption label: ftut:possion:2D:2mat:fig1 --> </p></center>
<p><img src="fig/layered_medium_2.png" align="bottom" width=400></p>
</center>

<p>
Suppose we want to solve

$$
\begin{equation} \tag{3.21}
    \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,
\end{equation}
$$

in a domain \( \Omega \) consisting of two subdomains where \( k \) takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain \( \Omega = [0,1]\times [0,1] \) and divide it into two equal
subdomains,
as depicted in Figure <a href="#ftut:possion:2D:2mat:fig1">10</a>,

$$
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
$$

We define \( k(x,y)=k_0 \) in \( \Omega_0 \) and \( k(x,y)=k_1 \) in \( \Omega_1 \),
where \( k_0>0 \) and \( k_1>0 \) are given constants.

<p>
Physically, the present problem may correspond to heat conduction, where
the heat conduction in \( \Omega_1 \) is more efficient than
in \( \Omega_0 \). An alternative interpretation is flow in porous media
with two geological layers, where the layers' ability to transport
the fluid differ.

<h3 id="___sec117">Expression objects with if test </h3>

<p>
The simplest way of implementing a variable \( k \) is to define an
<code>Expression</code> object where we return the appropriate \( k \) value
depending on the position in space.  Since we need some testing on the
coordinates, the most straightforward approach is to define a subclass
of <code>Expression</code>, where we can use a full Python method instead of just
a C++ string formula for specifying a function.  The method that
defines the function is called <code>eval</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">K</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_k_values</span>(<span style="color: #008000">self</span>, k0, k1):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k0, <span style="color: #008000">self</span><span style="color: #666666">.</span>k1 <span style="color: #666666">=</span> k0, k1

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
	<span style="color: #408080; font-style: italic"># Fill in-place value[0] for scalar function,</span>
	<span style="color: #408080; font-style: italic"># value[:] for vector function (no return)</span>

	tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol:
	    value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k0
	<span style="color: #008000; font-weight: bold">else</span>:
	    value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k1

<span style="color: #408080; font-style: italic"># Initialize</span>
k <span style="color: #666666">=</span> K()
k<span style="color: #666666">.</span>set_k_values(<span style="color: #666666">1</span>, <span style="color: #666666">0.01</span>)
</pre></div>
<p>
The <code>eval</code> method gives great flexibility in defining functions, but a
downside is that C++ calls up <code>eval</code> in Python for each point <code>x</code>,
which is a slow process, and the number of calls is proportional to
the number of numerical integration points in the mesh (about the
number of degrees of freedom).  Function expressions in terms of
strings are compiled to efficient C++ functions, being called from
C++, so we should try to express functions as string expressions if
possible. (The <code>eval</code> method can also be defined through C++ code, but
this is much more complicated and not covered here.)  The idea is to
use inline if tests in C++:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
k0 <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
k1 <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
k <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[1] &lt;= 0.5+tol? k0 : k1&#39;</span>,
               tol<span style="color: #666666">=</span>tol, k0<span style="color: #666666">=</span>k0, k1<span style="color: #666666">=</span>k1)
</pre></div>
<p>
The method with if tests on the location is feasible when the
subdomains have very simple shapes. A completely general method,
utilizing <em>mesh functions</em>, is described next.

<h3 id="___sec118">Mesh functions </h3>

<p>
We now address how to specify the subdomains \( \Omega_0 \) and \( \Omega_1 \)
so that the method also works for subdomains of any shape. For this
purpose we need to use subclasses of class <code>SubDomain</code>, not only plain
functions as we have used so far for specifying boundaries. Consider
the boundary function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
for defining the boundary \( x=0 \). Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <code>SubDomain</code>,
which implements the <code>inside</code> method as an alternative to the
<code>boundary</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Boundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

boundary <span style="color: #666666">=</span> Boundary()
bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)
</pre></div>
<p>
A word about computer science terminology may be used here: The term
<em>instance</em> means a Python object of a particular type (such as
<code>SubDomain</code>, <code>Function</code>, <code>FunctionSpace</code>, etc.).  Many use <em>instance</em>
and <em>object</em> as interchangeable terms. In other computer programming
languages one may also use the term <em>variable</em> for the same thing.  We
mostly use the well-known term <em>object</em> in this text.

<p>
A subclass of <code>SubDomain</code> with an <code>inside</code> method offers functionality
for marking parts of the domain or the boundary. Now we need to define
one class for the subdomain \( \Omega_0 \) where \( y\leq 1/2 \) and another
for the subdomain \( \Omega_1 \) where \( y\geq 1/2 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol
</pre></div>
<p>
Notice the use of <code>&lt;=</code> and <code>&gt;=</code> in both tests. For a cell to belong
to, e.g., \( \Omega_1 \), the <code>inside</code> method must return <code>True</code> for all
the vertices <code>x</code> of the cell. So to make the cells at the internal
boundary \( y=1/2 \) belong to \( \Omega_1 \), we need the test <code>x[1] &gt;=
0.5</code>. However, because of potential rounding errors in the coordinates
<code>x[1]</code>, we use a tolerance in the comparisons: <code>x[1] &gt;= 0.5-tol</code>.

<p>
The next task is to use a <em>mesh function</em> to mark all cells in
\( \Omega_0 \) with the subdomain number 0 and all cells in \( \Omega_1 \)
with the subdomain number 1.  Our convention is to number subdomains
as \( 0,1,2,\ldots \).

<p>
A <code>MeshFunction</code> object is a discrete function that can be evaluated
at a set of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <code>MeshFunction</code> over cells is suitable
to represent subdomains (materials), while a <code>MeshFunction</code> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous
fields.  The specialized classes <code>CellFunction</code> and <code>FacetFunction</code>
are used to construct mesh functions of cells and facets,
respectively.

<p>
Since we need to define subdomains of \( \Omega \) in the present example,
we make use of a <code>CellFunction</code>. The constructor
is fed with two arguments: 1) the type of value: <code>'int'</code> for integers,
<code>'uint'</code> for positive (unsigned) integers, <code>'double'</code> for real
numbers, and <code>'bool'</code> for logical values; 2) a <code>Mesh</code> object.
Alternatively, the constructor can take just a filename and initialize
the <code>CellFunction</code> from data in a file.

<p>
We start with creating a <code>CellFunction</code> whose values are non-negative
integers (<code>'uint'</code>) for numbering the subdomains.
The appropriate code for two subdomains then reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
<span style="color: #408080; font-style: italic"># Mark subdomains with numbers 0 and 1</span>
subdomain0 <span style="color: #666666">=</span> Omega0()
subdomain0<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">0</span>)
subdomain1 <span style="color: #666666">=</span> Omega1()
subdomain1<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Alternative</span>
materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)
subdomain1<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">1</span>)
</pre></div>
<p>
Calling <code>materials.array()</code> returns a <code>numpy</code> array of the
subdomain values. That is, <code>materials.array()[i]</code> is
the subdomain value of cell number <code>i</code>. This array is used to
look up the subdomain or material number of a specific element.

<p>
We need a function <code>k</code> that is constant in each subdomain \( \Omega_0 \)
and \( \Omega_1 \). Since we want <code>k</code> to be a finite element function, it
is natural to choose a space of functions that is constant over each
element.  The family of discontinuous Galerkin methods, in FEniCS
denoted by <code>'DG'</code>, is suitable for this purpose. Since we want
functions that are piecewise constant, the value of the degree
parameter is zero:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
k  <span style="color: #666666">=</span> Function(V0)
</pre></div>
<p>
To fill <code>k</code> with the right values in each element, we loop over
all cells (i.e., indices in <code>materials.array()</code>),
extract the corresponding subdomain number of a cell,
and assign the corresponding \( k \) value to the <code>k.vector()</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k_values <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">50</span>]  <span style="color: #408080; font-style: italic"># values of k in the two subdomains</span>
<span style="color: #008000; font-weight: bold">for</span> cell_no <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(materials<span style="color: #666666">.</span>array())):
    material_no <span style="color: #666666">=</span> materials<span style="color: #666666">.</span>array()[cell_no]
    k<span style="color: #666666">.</span>vector()[cell_no] <span style="color: #666666">=</span> k_values[material_no]
</pre></div>
<p>
Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <code>numpy</code> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<code>materials.array()</code>, but where the value <code>i</code> of an entry
in <code>materials.array()</code> is replaced by <code>k_values[i]</code>.
Such an operation is carried out by the <code>numpy</code> function <code>choose</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">help <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>numpy<span style="color: #666666">.</span>int32)
k<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>choose(help, k_values)
</pre></div>
<p>
The <code>help</code> array is required since <code>choose</code> cannot work with
<code>materials.array()</code> because this array has elements of
type <code>uint32</code>. We must therefore transform this array to an array
<code>help</code> with standard <code>int32</code> integers.

<p>
The next section exemplifies a complete solver with a piecewise
constant coefficient, like \( k \), defined through <code>SubDomain</code> objects,
combined with different types of boundary conditions.

<h3 id="___sec119">C++ strings for subdomain definitions </h3>

<p>
The <code>SubDomain</code> class in Python is convenient, but leads to lots of
function calls from C++ to Python, which are slow. In large problems,
the subdomains should be defined through C++ code. This is easy to achieve
using the <code>CompiledSubDomain</code> object. Consider the definition of
classes <code>Omega0</code> and <code>Omega1</code> above in Python.
The key strings that define these subdomain can be expressed in
C++ syntax and fed to <code>CompiledSubDomain</code> as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

subdomain0 <span style="color: #666666">=</span> CompiledSubDomain(
                <span style="color: #BA2121">&#39;x[1] &lt;= boundary+tol&#39;</span>, tol<span style="color: #666666">=1E-14</span>, boundary<span style="color: #666666">=0.5</span>)
subdomain1 <span style="color: #666666">=</span> CompiledSubDomain(
                <span style="color: #BA2121">&#39;x[1] &gt;= boundary-tol&#39;</span>, tol<span style="color: #666666">=1E-14</span>, boundary<span style="color: #666666">=0.5</span>)
</pre></div>
<p>
As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, <code>subdomain0</code> and <code>subdomain1</code>, can be used
as ordinary <code>SubDomain</code> objects.

<p>
Compiled subdomain strings can be applied for specifying boundaries as
well, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">y_R <span style="color: #666666">=</span> CompiledSubDomain(<span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[1], R, eps=tol)&#39;</span>,
                        tol<span style="color: #666666">=1E-14</span>, R<span style="color: #666666">=2</span>)   <span style="color: #408080; font-style: italic"># y=2</span>
</pre></div>
<p>
It is possible to feed the C++ string (without parameters) directly as
the third argument to <code>DirichletBC</code> without explicitly constructing a
<code>CompiledSubDomain</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bc1 <span style="color: #666666">=</span> DirichletBC(V, value, <span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[1], 2, 1E-14)&#39;</span>)
</pre></div>
<p>
<!-- --- begin exercise --- -->

<h2 id="ftut:poisson:exer:eff:expression">Exercise 4: Efficiency of Python vs C++ expressions</h2>

<p>
Consider a cube mesh with \( N \) cells in each spatial direction.
We want to define a <code>Function</code> on this mesh where the
values are given by the mathematical function \( f(x,y,z)=a\sin(bxyz) \),
where \( a \) and \( b \) are two parameters. Write a <code>class SineXYZ</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_parameters</span>(<span style="color: #008000">self</span>, a, b):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])
</pre></div>
<p>
Create an alternative <code>Expression</code> based on giving the formula for \( f(x,y,z) \)
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using <code>time.clock()</code> to measure the CPU time).

<p>
The <code>sin</code> function used in class <code>SineXYZ.eval</code> can mean many things.
This is an advanced FEniCS function if imported from <code>fenics</code>.
Much more efficient versions for sin of numbers are found in <code>math.sin</code>
and <code>numpy.sin</code>. Compare the use <code>sin</code> from <code>fenics</code>, <code>math</code>, <code>numpy</code>, and
<code>sympy</code> (note that <code>sin</code> from <code>sympy</code> is very slow).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
Here is an appropriate program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">make_sine_Function</span>(N, method):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Fill a Function with sin(x*y*z) values.&quot;&quot;&quot;</span>
    mesh <span style="color: #666666">=</span> UnitCubeMesh(N, N, N)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">2</span>)

    <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&#39;Python&#39;</span>):
        <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;fenics.sin&#39;</span>):
            <span style="color: #408080; font-style: italic"># Need sin as local variable in this function</span>
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;math.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;numpy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;sympy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">NotImplementedError</span>(<span style="color: #BA2121">&#39;method=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> method)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;sin:&#39;</span>, sin, <span style="color: #008000">type</span>(sin))

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_parameters</span>(<span style="color: #008000">self</span>, a, b):
                <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
                value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])

        expr <span style="color: #666666">=</span> SineXYZ()
        expr<span style="color: #666666">.</span>set_parameters(a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    <span style="color: #008000; font-weight: bold">elif</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;C++&#39;</span>:
        expr <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;a*sin(b*x[0]*x[1]*x[2])&#39;</span>, a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    u <span style="color: #666666">=</span> interpolate(expr, V)
    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> u, t1<span style="color: #666666">-</span>t0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(N):
    u, cpu_py_fenics  <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-fenics.sin&#39;</span>)
    u, cpu_py_math    <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-math.sin&#39;</span>)
    u, cpu_py_numpy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-numpy.sin&#39;</span>)
    u, cpu_py_sympy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-sympy.sin&#39;</span>)
    u, cpu_cpp <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;C++&#39;</span>)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;&quot;&quot;DOFs: </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Python:</span>
<span style="color: #BA2121">fenics.sin: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">math.sin:   </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">numpy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">sympy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">C++:        </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Speed-up:   math: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">  sympy: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&quot;&quot;&quot;</span> <span style="color: #666666">%</span>
          (u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
           cpu_py_fenics, cpu_py_math,
           cpu_py_numpy, cpu_py_sympy,
           cpu_cpp,
           cpu_py_math<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp),
           cpu_py_sympy<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp)))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">profile</span>():
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">cProfile</span>
    prof <span style="color: #666666">=</span> cProfile<span style="color: #666666">.</span>Profile()
    prof<span style="color: #666666">.</span>runcall(main)
    prof<span style="color: #666666">.</span>dump_stats(<span style="color: #BA2121">&quot;tmp.profile&quot;</span>)
    <span style="color: #408080; font-style: italic"># http://docs.python.org/2/library/profile.html</span>

main(<span style="color: #666666">20</span>)
<span style="color: #408080; font-style: italic">#profile()</span>
</pre></div>
<p>
Running the program shows that <code>sin</code> from <code>math</code> is the most efficient choice,
but a string C++ runs 40 times faster. Note that <code>fenics.sin</code>, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the <code>sin</code>
functions for numbers in <code>math</code> and <code>numpy</code>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>Expression_efficiency</code>.

<p>
<!-- --- end exercise --- -->

<h2 id="ftut:poisson:multi:bc">Multiple Neumann, Robin, and Dirichlet condition</h2>

<p>
Consider the model problem from the section <a href="#ftut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a> where we had both Dirichlet and
Neumann conditions.  The term <code>v*g*ds</code> in the expression for <code>L</code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate <code>v*g*ds</code> only over the parts of the boundary where
we actually have Neumann conditions.  And more importantly, in other
problems one may have different Neumann conditions or other conditions
like the Robin type condition.  With the mesh function concept we can
mark different parts of the boundary and integrate over specific
parts.  The same concept can also be used to treat multiple Dirichlet
conditions.  The forthcoming text illustrates how this is done.

<h3 id="___sec122">Three types of boundary conditions </h3>

<p>
We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin.  Dirichlet conditions apply to some
parts \( \Gamma_{D,0} \), \( \Gamma_{D,1} \), \( ... \), of the boundary:

$$ u_{0,0}\hbox{ on }\Gamma_{D,0},\quad
u_{0,1}\hbox{ on }\Gamma_{D,1}, \ldots$$

where \( u_{0,i} \) are prescribed functions, \( i=0,1,\ldots \)
On other parts, \( \Gamma_{N,0} \), \( \Gamma_{N,1} \), and so on, we have
Neumann conditions

$$ -p{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{N,0},\quad
-p{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{N,1},\quad \ldots
$$

Finally, we have <em>Robin conditions</em>

$$
\begin{equation*}
-p{\partial u\over\partial n} = r(u-s),
\tag{3.22}
\end{equation*}
$$

where \( r \) and \( s \) are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, \( r \) is a heat
transfer coefficient, and \( s \) is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts \( \Gamma_{R,0} \), \( \Gamma_{R,1} \), and so forth:

$$ -p{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\Gamma_{R,0},\quad
-p{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\Gamma_{R,1},\quad \ldots
$$

<h3 id="___sec123">A general model problem </h3>

<p>
With the notation above,
the model problem to be solved with multiple Dirichlet, Neumann, and
Robin conditions can formally be defined as

$$
\begin{align}
-\nabla\cdot(p\nabla u) &= -f, \mbox{ in } \Omega, \tag{3.23}\\ 
u &= u_{0,i} \mbox{ on } \Gamma_{D,i},\quad i=0,1,\ldots
\tag{3.24}\\ 
-p{\partial u\over\partial n} &= g_i \mbox{ on } \Gamma_{N,i},\quad
i=0,1,\ldots
\tag{3.25}\\ 
-p{\partial u\over\partial n} &= r_i(u-s_i) \mbox{ on } \Gamma_{R,i},\quad
i=0,1,\ldots
\tag{3.26}
\end{align}
$$

<h3 id="___sec124">Variational formulation </h3>

<p>
Integration by parts of \( -\int_\Omega v\nabla\cdot(p\nabla u) \dx \) becomes
as usual

$$
\begin{equation*}
 -\int_\Omega v\nabla\cdot(p\nabla u) \dx
= \int_\Omega p\nabla u\cdot \nabla v \dx -
\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds\tp
\end{equation*}
$$

The boundary integral does not apply to the parts of
the boundary where we have Dirichlet conditions (\( \Gamma_{D,i} \)).
Moreover, on the remaining parts, we must split the boundary integral
into the parts where we have Neumann and Robin conditions such that we
insert the right conditions as integrands.
Specifically, we have

$$
\begin{align*}
-\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds
&=
-\sum_i\int_{\Gamma_{N,i}}p\frac{\partial u}{\partial n} \ds
-\sum_i\int_{\Gamma_{R,i}}p\frac{\partial u}{\partial n} \ds\\ 
&=
\sum_i\int_{\Gamma_{N,i}}g_i \ds +
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i) \ds\tp
\end{align*}
$$

The variational formulation then becomes

$$
\begin{equation}
F = \int_{\Omega} p\nabla u\cdot \nabla v \dx +
\sum_i\int_{\Gamma_{N,i}} g_iv \ds +
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i)v \ds
- \int_{\Omega} fv \dx =0\tp
\tag{3.27}
\end{equation}
$$

<p>
We have been used to writing
this variational formulation in the standard notation
\( a(u,v)=L(v) \), which requires that we identify all integrals with
<em>both</em> \( u \) and \( v \), and collect these in \( a(u,v) \), while the remaining
integrals with \( v \) and not \( u \) go into \( L(v) \).  The integral from the
Robin condition must of this reason be split in two parts:

$$
\begin{equation*}
\int_{\Gamma_{R,i}}r_i(u-s_i)v \ds
= \int_{\Gamma_{R,i}} r_iuv \ds - \int_{\Gamma_{R,i}}r_is_iv \ds\tp
\end{equation*}
$$

We then have

$$
\begin{align}
a(u, v) &= \int_{\Omega} p\nabla u\cdot \nabla v \dx
+ \sum_i\int_{\Gamma_{R,i}}r_iuv \ds,
\tag{3.28}\\ 
L(v) &= \int_{\Omega} fv \dx -
\sum_i\int_{\Gamma_{N,i}} g_i v \ds + \sum_i\int_{\Gamma_{R,i}}r_is_iv \ds\tp
\tag{3.29}
\end{align}
$$

<h3 id="___sec125">Implementation of boundary conditions </h3>

<p>
Looking at our previous <code>solver</code> functions for solving the 2D Poisson equation,
the following new aspects must be taken care of:

<ol>
 <li> definition of a mesh function over the boundary,</li>
 <li> marking each side as a subdomain, using the mesh function,</li>
 <li> splitting a boundary integral into parts.</li>
</ol>

A general approach to the first task is to mark each of the desired
boundaries with markers 0, 1, 2, and so forth. Here we aim at
the four sides of the unit square, marked with
0 (\( x=0 \)), 1 (\( x=1 \)), 2 (\( y=0 \)), and 3 (\( y=1 \)).
The marking of boundaries makes use of a mesh function object, but contrary to
the section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a>, this is not a function over
cells, but a function over cell facets. We apply the <code>FacetFunction</code>
for this purpose:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary_parts <span style="color: #666666">=</span> FacetFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
</pre></div>
<p>
As in the section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a> we use a subclass of
<code>SubDomain</code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the \( x=0 \) boundary can be marked by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

bx0 <span style="color: #666666">=</span> BoundaryX0()
bx0<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">0</span>)
</pre></div>
<p>
Similarly, we make the classes <code>BoundaryX1</code> for the \( x=1 \) boundary,
<code>BoundaryY0</code> for the \( y=0 \) boundary, and <code>BoundaryY1</code> for the \( y=1 \)
boundary, and mark these as subdomains 1, 2, and 3, respectively.

<p>
For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary_conditions = {
  0: {&#39;Dirichlet&#39;: u0},
  1: {&#39;Robin&#39;: (r, s)},
  2: {&#39;Neumann: g}},
  3: {&#39;Neumann&#39;, 0}}
</pre></div>
<p>
specifies

<ul>
 <li> a Dirichlet condition, with values implemented by an <code>Expression</code>
   or <code>Constant</code> object
   <code>u0</code>, on subdomain 0, i.e., the \( x=1 \) boundary;</li>
 <li> a Robin condition <a href="#mjx-eqn-3.22">(3.22)</a>
   on subdomain 1, \( x=1 \), with <code>Expression</code> or <code>Constant</code> objects
   <code>r</code> and <code>s</code> specifying \( r \) and \( s \);</li>
 <li> a Neumann condition \( \partial u/\partial n=g \) on subdomain 2, \( y=0 \),
   where an <code>Expression</code> or <code>Constant</code> object <code>g</code> implements the value \( g \);</li>
 <li> a homogeneous Neumann condition \( \partial u/\partial n=0 \) on
   subdomain 3, \( y=1 \).</li>
</ul>

As explained in the section <a href="#ftut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>,
multiple Dirichlet conditions must be collected in a list of
<code>DirichletBC</code> objects. Based on the <code>boundary_conditions</code> data
structure above, we can construct this list by the following snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># List of Dirichlet conditions</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Dirichlet&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        bcs<span style="color: #666666">.</span>append(
            DirichletBC(V, boundary_conditions[n][<span style="color: #BA2121">&#39;Dirichlet&#39;</span>],
                        boundary_parts, n))
</pre></div>
<p>
The new aspect of the variational problem is the two distinct
boundary integrals over \( \Gamma_{N,i} \) and \( \Gamma_{R,i} \).
Having a mesh function over exterior cell facets (our
<code>boundary_parts</code> object), where subdomains (boundary parts) are
numbered as \( 0,1,2,\ldots \), the special symbol <code>ds(0)</code>
implies integration over subdomain (part) 0, <code>ds(1)</code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code>ds</code>-type objects generalizes to volume
integrals too: <code>dx(0)</code>, <code>dx(1)</code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside \( \Omega \).

<p>
Before we have <code>ds(n)</code> for integers <code>n</code> defined, we must do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">ds <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;ds&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>boundaries_parts)
</pre></div>
<p>
Similarly, if we want integration of different parts of the domain,
we redefine <code>dx</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dx <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;dx&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>domains)
</pre></div>
<p>
where <code>domains</code> is a <code>CellFunction</code> defining subdomains in \( \Omega \).

<p>
Suppose we have a Robin condition with values <code>r</code> and <code>s</code> on subdomain
<code>R</code>, a Neumann condition with value <code>g</code> on subdomain <code>N</code>, the
variational form can be written

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(N) <span style="color: #666666">+</span> r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
</pre></div>
<p>
In our case things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code>boundary_conditions</code> data structure. We can collect
all Neumann conditions by the code

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
Neumann_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Neumann&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        <span style="color: #008000; font-weight: bold">if</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>] <span style="color: #666666">!=</span> <span style="color: #666666">0</span>:
            g <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>]
            Neumann_integrals<span style="color: #666666">.</span>append(g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
Applying <code>sum(Nemann_integrals)</code> will apply the <code>+</code> operator to
the variational forms in the <code>Numeann_integrals</code> list and result
in the integrals we need for the right-hand side <code>L</code> of the
variational form.

<p>
The integrals in the Robin condition can similarly be collected
in lists:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Robin_a_integrals <span style="color: #666666">=</span> []
Robin_L_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        Robin_a_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
        Robin_L_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
We are now in a position to define the <code>a</code> and <code>L</code> expressions
in the variational formulation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
    <span style="color: #008000">sum</span>(Robin_a_integrals)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> <span style="color: #008000">sum</span>(Neumann_integrals) <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Robin_L_integrals)
</pre></div>

<h3 id="___sec126">Simplified handling of the variational formulation </h3>

<p>
We carefully ordered the terms in the variational formulation above
into the \( a \) and \( L \) parts. This requires a splitting of the Robin
condition and makes the <code>a</code> and <code>L</code> expressions less readable (still we
think understanding this splitting is key for any finite element programmer!).
Fortunately, UFL allow us to specify the complete variational form
<a href="#mjx-eqn-3.27">(3.27)</a> as <em>one expression</em> and offer tools to
extract what goes into the bilinear form \( a(u,v) \) and the linear form
\( L(v) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">F <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
    <span style="color: #008000">sum</span>(Robin_integrals) <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Neumann_integrals)
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
This time we can more naturally define the integrals from the
Robin condition as <code>r*(u-s)*v*ds(n)</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Robin_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        Robin_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>(u<span style="color: #666666">-</span>s)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
The complete code is in the <code>solver_bc</code> function in the
<code>ft06_poisson_vc.py</code> file.

<h3 id="___sec127">Test problem </h3>

<p>
Let us continue to use \( \uex=1+x^2+2y^2 \) as the exact solution, and
set \( p=1 \) and \( f=-6 \) in the PDE.  Our domain is the unit square, and
we assign Dirichlet conditions at \( x=0 \) and \( x=1 \), a Neumann condition
at \( y=1 \), and a Robin condition at \( y=0 \). With the given \( \uex \), we
realize that the Neumann condition is \( -4y \) (which means \( -4 \) at
\( y=1 \)), while the Robin
condition can be selected in many ways. Since \( \partial u/\partial
n=-\partial u/\partial y=0 \) at \( y=0 \), we can select \( s=u \) and have \( r \)
arbitrary in the Robin condition.

<p>
The boundary parts are \( \Gamma_{D,0} \): \( x=0 \), \( \Gamma_{D,1} \): \( x=1 \),
\( \Gamma_{R,0} \): \( y=0 \), and \( \Gamma_{N,0} \): \( y=1 \).

<p>
When implementing this test problem (and especially other test problems
with more complicated expressions), it is advantageous to use
symbolic computing. Below we define \( \uex \) as a <code>sympy</code> expression
and derive other functions from their mathematical definitions.
Then we turn these expressions into C/C++ code, which can be
fed into <code>Expression</code> objects.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_bc_test</span>():
    <span style="color: #408080; font-style: italic"># Define manufactured solution in sympy and derive f, g, etc.</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)  <span style="color: #408080; font-style: italic"># UFL needs x[0] for x etc.</span>
    u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x, <span style="color: #666666">2</span>) <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(u, y, <span style="color: #666666">2</span>)  <span style="color: #408080; font-style: italic"># -Laplace(u)</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
    u_00 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># x=0 boundary</span>
    u_01 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary</span>
    g <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, y)<span style="color: #666666">.</span>subs(y, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary, du/dn=-du/dy</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">1000</span> <span style="color: #408080; font-style: italic"># any function can go here</span>
    s <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Turn to C/C++ code for UFL expressions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
    u_00 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_00)
    u_01 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_01)
    g <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(g)
    r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(r)
    s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(s)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Test problem (C/C++):</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">f = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u, f))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_00: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u_01: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">g = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">r = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">s = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
          (u_00, u_01, g, r, s))

    <span style="color: #408080; font-style: italic"># Turn into FEniCS objects</span>
    u_00 <span style="color: #666666">=</span> Expression(u_00)
    u_01 <span style="color: #666666">=</span> Expression(u_01)
    f <span style="color: #666666">=</span> Expression(f)
    g <span style="color: #666666">=</span> Expression(g)
    r <span style="color: #666666">=</span> Expression(r)
    s <span style="color: #666666">=</span> Expression(s)
    u_exact <span style="color: #666666">=</span> Expression(sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u))

    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_00},   <span style="color: #408080; font-style: italic"># x=0</span>
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_01},   <span style="color: #408080; font-style: italic"># x=1</span>
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Robin&#39;</span>: (r, s)},     <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: g}}        <span style="color: #408080; font-style: italic"># y=1</span>

    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    u, p <span style="color: #666666">=</span> solver_bc(
        p, f, boundary_conditions, Nx, Ny, degree<span style="color: #666666">=1</span>,
        linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>,
        debug<span style="color: #666666">=2*</span>Nx<span style="color: #666666">*</span>Ny <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>,  <span style="color: #408080; font-style: italic"># for small problems only</span>
        )

    <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                       u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Max error:&#39;</span>, max_error)

    <span style="color: #408080; font-style: italic"># Print numerical and exact solution at the vertices</span>
    <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>:  <span style="color: #408080; font-style: italic"># (small problems only)</span>
        u_e_at_vertices <span style="color: #666666">=</span> u_e<span style="color: #666666">.</span>compute_vertex_values()
        u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
        coor <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
        <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">): error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> vs </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span>
                  <span style="color: #666666">%</span> (i, x[<span style="color: #666666">0</span>], x[<span style="color: #666666">1</span>],
                     u_e_at_vertices[i] <span style="color: #666666">-</span> u_at_vertices[i],
                     u_e_at_vertices[i], u_at_vertices[i]))
</pre></div>
<p>
This simple test problem is turned into a real unit test for different
function spaces in the function <code>test_solver_bc</code>.

<h3 id="___sec128">Debugging the setting of boundary conditions </h3>

<p>
It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code>SubDomain.inside</code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the output.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> debug:
    <span style="color: #408080; font-style: italic"># Print the vertices that are on the boundaries</span>
    coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> coor:
        <span style="color: #008000; font-weight: bold">if</span> bx0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> bx1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=1&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=1&#39;</span> <span style="color: #666666">%</span> x)
    <span style="color: #408080; font-style: italic"># Print the Dirichlet conditions</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;No of Dirichlet conditions:&#39;</span>, <span style="color: #008000">len</span>(bcs))
    d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
    <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
        bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
        <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof]))
            <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;   at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                      (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
In addition, it is helpful to print the exact and the numerical solution
at all the vertices as shown in the section <a href="._ftut008.html#ftut:poisson1:verify1">Writing out the discrete solution</a>.

<h3 id="___sec129">Implementation of multiple subdomains </h3>

<p>
The section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a> explains how to deal with
multiple subdomains of \( \Omega \) and a piecewise constant coefficient
function \( p \) that takes on different constant values in the different
subdomains. We can easily add this type of \( p \) coefficient to the
<code>solver_bc</code> function. The signature of the function is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_bc</span>(
    p, f,                   <span style="color: #408080; font-style: italic"># Coefficients in the PDE</span>
    boundary_conditions,    <span style="color: #408080; font-style: italic"># Dict of boundary conditions</span>
    Nx, Ny,                 <span style="color: #408080; font-style: italic"># Cell division of the domain</span>
    degree<span style="color: #666666">=1</span>,               <span style="color: #408080; font-style: italic"># Polynomial degree</span>
    subdomains<span style="color: #666666">=</span>[],          <span style="color: #408080; font-style: italic"># List of SubDomain objects in domain</span>
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    debug<span style="color: #666666">=</span><span style="color: #008000">False</span>,
    ):
<span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">return</span> u, p   <span style="color: #408080; font-style: italic"># p may be modified</span>
</pre></div>
<p>
If <code>subdomain</code> is an empty list, we assume there are no subdomains, and
\( p \) is an <code>Expression</code> or <code>Constant</code> object specifying a formula for
\( p \). If not, <code>subdomain</code> is a list of <code>SubDomain</code> objects, defining
different parts of the domain. The first element is a dummy object,
defining &quot;the rest&quot; of the domain. The next elements define specific
geometries in the <code>inside</code> methods. We start by marking all elements
with subdomain number 0, this will then be &quot;the rest&quot; after marking
subdomains 1, 2, and so on. The next step is to define <code>p</code> as a
piecewise constant function over cells and fill it with values.
We assume that the user-argument <code>p</code> is an array (or list) holding
the values of \( p \) in the different parts corresponding to <code>subdomains</code>.
The returned <code>p</code> is needed for flux computations. If there are no
subdomains, the returned <code>p</code> is just the original <code>p</code> argument.

<p>
The appropriate code for computing <code>p</code> becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">if</span> subdomains:
    <span style="color: #408080; font-style: italic"># subdomains is list of SubDomain objects,</span>
    <span style="color: #408080; font-style: italic"># p is array of corresponding constant values of p</span>
    <span style="color: #408080; font-style: italic"># in each subdomain</span>
    materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
    materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># &quot;the rest&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> m, subdomain <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(subdomains[<span style="color: #666666">1</span>:], <span style="color: #666666">1</span>):
        subdomain<span style="color: #666666">.</span>mark(materials, m)

    p_values <span style="color: #666666">=</span> p
    V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
    p  <span style="color: #666666">=</span> Function(V0)
    help <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int32)
    p<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>choose(help, p_values)
</pre></div>
<p>
We define \( p(x,y)=p_0 \) in \( \Omega_0 \) and \( k(x,y)=p_1 \) in \( \Omega_1 \),
where \( p_0>0 \) and \( p_1>0 \) are given constants.
As boundary conditions, we choose \( u=0 \) at \( y=0 \), \( u=1 \) at \( y=1 \),
and \( \partial u/\partial n=0 \) at \( x=0 \) and \( x=1 \).
One can show that the exact solution is now given by

$$
\begin{equation}
u(x, y) = \left\lbrace\begin{array}{ll}
{2yp_1\over p_0+p_1}, & y \leq 1/2\\ 
{(2y-1)p_0 + p_1\over p_0+p_1}, & y \geq 1/2
\end{array}\right.
\tag{3.30}
\end{equation}
$$

As long as the element boundaries coincide with the internal boundary
\( y=1/2 \), this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We can use this property to verify
the implementation and make a unit test for a series of function
spaces:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solvers_bc_2mat</span>():
    tol <span style="color: #666666">=</span> <span style="color: #666666">2E-13</span>  <span style="color: #408080; font-style: italic"># Tolerance for comparisons</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol

    subdomains <span style="color: #666666">=</span> [Omega0(), Omega1()]
    p_values <span style="color: #666666">=</span> [<span style="color: #666666">2.0</span>, <span style="color: #666666">13.0</span>]
    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">0</span>)}, <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">1</span>)}, <span style="color: #408080; font-style: italic"># y=1</span>
        }

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_exact <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span style="color: #BA2121">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span>,
        p_0<span style="color: #666666">=</span>p_values[<span style="color: #666666">0</span>], p_1<span style="color: #666666">=</span>p_values[<span style="color: #666666">1</span>])

    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), (<span style="color: #666666">2</span>,<span style="color: #666666">4</span>), (<span style="color: #666666">8</span>,<span style="color: #666666">4</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            u, p <span style="color: #666666">=</span> solver_bc(
                p_values, f, boundary_conditions, Nx, Ny, degree,
                linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, subdomains<span style="color: #666666">=</span>subdomains,
                debug<span style="color: #666666">=</span><span style="color: #008000">False</span>)

            <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
            u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
            <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
            max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                           u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> max_error
</pre></div>
<p>
<!-- Refactoring with classes? Separate section? -->

<h2 id="___sec130">Refactoring of a solver function into solver and problem classes </h2>

<p>
A FEniCS solver for a PDE can be implemented in a general way, but
the problem-dependent data, like boundary conditions, must be specified
in each case by the user. The implementation in the previous section
required the user to supply a <code>boundary_conditions</code> dictionary with
specifications of the boundary condition on each of the four sides of
the unit square. If we, e.g., want two Dirichlet conditions at one
side, as our mathematical formulation of the problem in the previous
section in fact supports, this is not possible without extending
the <code>solver_bc</code> function.

<p>
A different software design is to introduce a problem class and
methods, supplied by the user from case to case, where boundary
conditions and other input data are defined. Such a design is used in
a lot of more advanced FEniCS application codes, and it is time to
exemplify it here.  As a counterpart to the solver function, we
introduce a solver class, but all the arguments for various input data
are instead method calls to an instance of a <em>problem class</em>. This
puts a somewhat greater burden on the programmer, but it allows for
more flexibility, and the code for, e.g., boundary conditions can be
more tailored to the problem at hand than the code we introduced in
the <code>solver_bc</code> function in the previous section.

<p>
The solver class will need problem information and for this purpose
call up the methods in a problem class. For example, the solver
gets the \( f \) and \( p \) functions in the PDE problem by calling
<code>problem.f_rhs()</code> and <code>problem.p_coeff()</code>. The mesh object and the
polynomial degree of the elements are supposed to be returned from
<code>problem.mesh_degree()</code>. Furthermore, the problem class defines the
boundary conditions in the problem as lists of minimal information
from which the solver can build proper data structures.

<p>
The solver class is a wrapping of the previous <code>solver_bc</code> and <code>flux</code>
functions as methods in a class, but some of the code for handling
boundary conditions in <code>solver_bc</code> is now delegated to the user in
the problem class.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Solver</span>(<span style="color: #008000">object</span>):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, problem, debug<span style="color: #666666">=</span><span style="color: #008000">False</span>):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh, degree <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>mesh_degree()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>V <span style="color: #666666">=</span> V <span style="color: #666666">=</span> FunctionSpace(<span style="color: #008000">self</span><span style="color: #666666">.</span>mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
        Dirichlet_cond <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>Dirichlet_conditions()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(Dirichlet_cond, (Expression)):
            <span style="color: #408080; font-style: italic"># Just one Expression for Dirichlet conditions on</span>
            <span style="color: #408080; font-style: italic"># the entire boundary</span>
            <span style="color: #008000">self</span><span style="color: #666666">.</span>bcs <span style="color: #666666">=</span> [DirichletBC(
                V, Dirichlet_cond,
                <span style="color: #008000; font-weight: bold">lambda</span> x, on_boundary: on_boundary)]
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #408080; font-style: italic"># Boundary SubDomain markers</span>
            <span style="color: #008000">self</span><span style="color: #666666">.</span>bcs <span style="color: #666666">=</span> [
                DirichletBC(V, value, boundaries, index)
                <span style="color: #008000; font-weight: bold">for</span> value, boundaries, index
                <span style="color: #AA22FF; font-weight: bold">in</span> Dirichlet_cond]

        <span style="color: #008000; font-weight: bold">if</span> debug:
            <span style="color: #408080; font-style: italic"># Print the Dirichlet conditions</span>
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;No of Dirichlet conditions:&#39;</span>, <span style="color: #008000">len</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>bcs))
            coor <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh<span style="color: #666666">.</span>coordinates()
            d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
            <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>bcs:
                bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
                <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
                    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof]))
                    <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
                        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;   at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                              (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))

        u <span style="color: #666666">=</span> TrialFunction(V)
        v <span style="color: #666666">=</span> TestFunction(V)
        p <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>p_coeff()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>p <span style="color: #666666">=</span> p  <span style="color: #408080; font-style: italic"># store for flux computations</span>
        f <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>f_rhs()
        F <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx
        F <span style="color: #666666">-=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
        F <span style="color: #666666">-=</span> <span style="color: #008000">sum</span>([g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds_
                  <span style="color: #008000; font-weight: bold">for</span> g, ds_ <span style="color: #AA22FF; font-weight: bold">in</span> problem<span style="color: #666666">.</span>Neumann_conditions()])
        F <span style="color: #666666">+=</span> <span style="color: #008000">sum</span>([r<span style="color: #666666">*</span>(u<span style="color: #666666">-</span>s)<span style="color: #666666">*</span>ds_
                  <span style="color: #008000; font-weight: bold">for</span> r, s, ds_ <span style="color: #AA22FF; font-weight: bold">in</span> problem<span style="color: #666666">.</span>Robin_conditions()])
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>L <span style="color: #666666">=</span> lhs(F), rhs(F)

        <span style="color: #008000; font-weight: bold">if</span> debug <span style="color: #AA22FF; font-weight: bold">and</span> V<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>:
            A <span style="color: #666666">=</span> assemble(<span style="color: #008000">self</span><span style="color: #666666">.</span>a)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A<span style="color: #666666">.</span>array())
            b <span style="color: #666666">=</span> assemble(<span style="color: #008000">self</span><span style="color: #666666">.</span>L)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b<span style="color: #666666">.</span>array())

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solve</span>(<span style="color: #008000">self</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>):
        <span style="color: #408080; font-style: italic"># Compute solution</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>u <span style="color: #666666">=</span> Function(<span style="color: #008000">self</span><span style="color: #666666">.</span>V)

        <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
            solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                                 <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
        <span style="color: #008000; font-weight: bold">else</span>:
            solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

        solve(<span style="color: #008000">self</span><span style="color: #666666">.</span>a <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>L, <span style="color: #008000">self</span><span style="color: #666666">.</span>u, <span style="color: #008000">self</span><span style="color: #666666">.</span>bcs,
              solver_parameters<span style="color: #666666">=</span>solver_parameters)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">flux</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute and return flux -p*grad(u).&quot;&quot;&quot;</span>
        mesh <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
        degree <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
        V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>flux_u <span style="color: #666666">=</span> project(<span style="color: #666666">-</span><span style="color: #008000">self</span><span style="color: #666666">.</span>p<span style="color: #666666">*</span>grad(<span style="color: #008000">self</span><span style="color: #666666">.</span>u), V_g)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>flux_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous flux field&#39;</span>)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>flux_u
</pre></div>
<p>
Note that this is a general Poisson problem solver that works in any number
of space dimensions and with any mesh and composition of boundary conditions.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Be careful with the <code>mesh</code> variable!</b>
In classes, one often stores the mesh in <code>self.mesh</code>. When you need
the mesh, it is easy to write just <code>mesh</code>, but this gives rise to
peculiar error messages, since <code>mesh</code> is a Python module imported
by <code>from fenics import *</code> and already available as a name in your file.
When encountering strange error messages in statements containing a
variable <code>mesh</code>, make sure you use <code>self.mesh</code>.
</div>


<p>
Below is the specific problem class for solving a scaled 2D Poisson
problem.  We have a two-material domain where a rectangle
\( [0.3,0.7]\times [0.3,0.7] \) is embedded in the unit square and where
\( p \) has a constant value inside the rectangle and another value
outside. On \( x=0 \) and \( x=1 \) we have homogeneous Neumann conditions,
and on \( y=0 \) and \( y=1 \) we have the Dirichlet conditions \( u=1 \) and
\( u=0 \), respectively.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Problem1</span>(Problem):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    -div(p*grad(u)=f on the unit square.</span>
<span style="color: #BA2121; font-style: italic">    General Dirichlet, Neumann, or Robin condition along each</span>
<span style="color: #BA2121; font-style: italic">    side. Can have multiple subdomains with p constant in</span>
<span style="color: #BA2121; font-style: italic">    each subdomain.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, Nx, Ny):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Initialize mesh, boundary parts, and p.&quot;&quot;&quot;</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)

        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX0</span>(SubDomain):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
                <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX1</span>(SubDomain):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
                <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryY0</span>(SubDomain):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
                <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryY1</span>(SubDomain):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
                <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

        <span style="color: #408080; font-style: italic"># Mark boundaries</span>
        <span style="color: #408080; font-style: italic">#self.boundary_parts = FacetFunction(&#39;size_t&#39;, mesh)</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts <span style="color: #666666">=</span> FacetFunction(<span style="color: #BA2121">&#39;uint&#39;</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts<span style="color: #666666">.</span>set_all(<span style="color: #666666">9999</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>bx0 <span style="color: #666666">=</span> BoundaryX0()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>bx1 <span style="color: #666666">=</span> BoundaryX1()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>by0 <span style="color: #666666">=</span> BoundaryY0()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>by1 <span style="color: #666666">=</span> BoundaryY1()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>bx0<span style="color: #666666">.</span>mark(<span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">0</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>bx1<span style="color: #666666">.</span>mark(<span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>by0<span style="color: #666666">.</span>mark(<span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">2</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>by1<span style="color: #666666">.</span>mark(<span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">3</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>ds <span style="color: #666666">=</span>  Measure(
            <span style="color: #BA2121">&#39;ds&#39;</span>, domain<span style="color: #666666">=</span><span style="color: #008000">self</span><span style="color: #666666">.</span>mesh,
            subdomain_data<span style="color: #666666">=</span><span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts)

        <span style="color: #408080; font-style: italic"># The domain is the unit square with an embedded rectangle</span>
        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Rectangle</span>(SubDomain):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.3</span> <span style="color: #666666">&lt;=</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.7</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #666666">0.3</span> <span style="color: #666666">&lt;=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.7</span>

        <span style="color: #008000">self</span><span style="color: #666666">.</span>materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># &quot;the rest&quot;</span>
        subdomain <span style="color: #666666">=</span> Rectangle()
        subdomain<span style="color: #666666">.</span>mark(<span style="color: #008000">self</span><span style="color: #666666">.</span>materials, <span style="color: #666666">1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>V0 <span style="color: #666666">=</span> FunctionSpace(<span style="color: #008000">self</span><span style="color: #666666">.</span>mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>p <span style="color: #666666">=</span> Function(<span style="color: #008000">self</span><span style="color: #666666">.</span>V0)
        help <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(<span style="color: #008000">self</span><span style="color: #666666">.</span>materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int32)
        p_values <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">1E-3</span>]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>p<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>choose(help, p_values)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mesh_degree</span>(<span style="color: #008000">self</span>):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>mesh, <span style="color: #666666">2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">p_coeff</span>(<span style="color: #008000">self</span>):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>p

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_rhs</span>(<span style="color: #008000">self</span>):
        <span style="color: #008000; font-weight: bold">return</span> Constant(<span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_conditions</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of (value,boundary) pairs.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> [(<span style="color: #666666">1.0</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">2</span>),
                (<span style="color: #666666">0.0</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>boundary_parts, <span style="color: #666666">3</span>)]

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Neumann_conditions</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return list of g*ds(n) values.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> [(<span style="color: #666666">0</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>ds(<span style="color: #666666">0</span>)), (<span style="color: #666666">0</span>, <span style="color: #008000">self</span><span style="color: #666666">.</span>ds(<span style="color: #666666">1</span>))]
</pre></div>
<p>
A specific problem can be solved by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>():
    problem <span style="color: #666666">=</span> Problem1(Nx<span style="color: #666666">=20</span>, Ny<span style="color: #666666">=20</span>)
    problem<span style="color: #666666">.</span>solve(linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    u <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>solution()
    u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;potential&#39;</span>)  <span style="color: #408080; font-style: italic"># name &#39;u&#39; is used in plot</span>
    plot(u)
    flux_u <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>solver<span style="color: #666666">.</span>flux()
    plot(flux_u)
    vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;poisson.pvd&#39;</span>)
    vtkfile <span style="color: #666666">&lt;&lt;</span> u
    interactive()
</pre></div>
<p>
The complete code is found in the file <code>ft08_poisson_class.py</code>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Pros and cons of solver/problem classes vs solver function.</b>
What are the advantages of class <code>Solver</code> and <code>Problem</code> over the
function implementation in the section <a href="#ftut:poisson:multi:bc">Multiple Neumann, Robin, and Dirichlet condition</a>?
The primary advantage is that
the class version works for any mesh and any composition of
boundary conditions, while the solver function is tied to a mesh
over the unit square, only one type of boundary condition on a
each side, and a piecewise constant \( p \) function. The programmer has
to supply more code in the class version, but gets greater flexibility.
The disadvantage of the class version is that it applies the class
concept so one needs experience with Python class programming.
</div>


<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut009.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li><a href="._ftut009.html">10</a></li>
  <li class="active"><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="._ftut015.html">16</a></li>
  <li><a href="._ftut016.html">17</a></li>
  <li><a href="._ftut017.html">18</a></li>
  <li><a href="._ftut018.html">19</a></li>
  <li><a href="._ftut019.html">20</a></li>
  <li><a href="._ftut011.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

