<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,assembly, increasing efficiency,heterogeneous medium,multi-material domain,nonlinear variational problems,Gateaux derivative,automatic differentiation,Jacobian, automatic computation,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,troubleshooting,compilation problems,plotting problems">

<title>The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'The Fundamentals: A Poisson equation solver',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'The Poisson equation', 1, None, '___sec14'),
              (u'Mathematical problem formulation',
               2,
               u'ch:poisson0:bvp',
               u'ch:poisson0:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               2,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               2,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 3, None, '___sec25'),
              (u'Generating simple meshes', 3, None, '___sec26'),
              (u'Defining the finite element function space',
               3,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 3, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               3,
               None,
               '___sec29'),
              (u'Defining the source term', 3, None, '___sec30'),
              (u'Defining the variational problem', 3, None, '___sec31'),
              (u'Forming and solving the linear system', 3, None, '___sec32'),
              (u'Plotting the solution', 3, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               3,
               None,
               '___sec34'),
              (u'Computing the error', 3, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The time-dependent diffusion equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec51'),
              (u'The code', 3, None, '___sec52'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec53'),
              (u'The mathematical problem', 3, None, '___sec54'),
              (u'Implementation', 3, None, '___sec55'),
              (u'Visualization in ParaView', 3, None, '___sec56'),
              (u'A nonlinear Poisson equation', 1, None, '___sec57'),
              (u'Variational formulation', 2, None, '___sec58'),
              (u'A simple implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Overview', 3, None, '___sec60'),
              (u'Constructing a test problem with SymPy',
               3,
               None,
               '___sec61'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple implementation', 2, None, '___sec64'),
              (u'Test problem', 3, None, '___sec65'),
              (u'Code', 3, None, '___sec66'),
              (u'The Navier--Stokes equations', 1, None, '___sec67'),
              (u'Variational formulation', 2, None, '___sec68'),
              (u'A simple implementation', 2, None, '___sec69'),
              (u'The Poisson solver revisited',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A general solver function', 2, None, '___sec72'),
              (u'Plotting for the test problem', 3, None, '___sec73'),
              (u'Make a module!', 3, None, '___sec74'),
              (u'Verification and unit tests', 2, None, '___sec75'),
              (u'Exercise 2: Solve a Poisson problem', 2, None, '___sec76'),
              (u'Remarks', 3, None, '___sec77'),
              (u'Exercise 3: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Useful extensions', 1, None, '___sec79'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec81'),
              (u'Linear algebra backend', 3, None, '___sec82'),
              (u'The `parameters` database', 3, None, '___sec83'),
              (u'An extended solver function', 3, None, '___sec84'),
              (u'Remark regarding unit tests', 3, None, '___sec85'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Generating a hypercube', 3, None, '___sec89'),
              (u'Computing derivatives',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec92'),
              (u'Modifications of the PDE solver', 3, None, '___sec93'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec94'),
              (u'Creating the linear system explicitly',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec97'),
              (u'Finite difference approximations', 3, None, '___sec98'),
              (u'Surface plot', 3, None, '___sec99'),
              (u'Contour plot', 3, None, '___sec100'),
              (u'Curve plot through the mesh', 3, None, '___sec101'),
              (u'Curve plot of the flux', 3, None, '___sec102'),
              (u'Test problem', 3, None, '___sec103'),
              (u'Postprocessing computations', 1, None, '___sec104'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec106'),
              (u'Error functional', 3, None, '___sec107'),
              (u'Flux Functionals', 3, None, '___sec108'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec110'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec111'),
              (u'Test problem', 3, None, '___sec112'),
              (u'Experiments', 3, None, '___sec113'),
              (u'Multiple domains and boundaries', 1, None, '___sec114'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 3, None, '___sec116'),
              (u'Variational formulation', 3, None, '___sec117'),
              (u'Implementation', 3, None, '___sec118'),
              (u'Multiple Dirichlet conditions',
               2,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec120'),
              (u'Working with subdomains',
               2,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec122'),
              (u'Mesh functions', 3, None, '___sec123'),
              (u'C++ strings for subdomain definitions',
               3,
               None,
               '___sec124'),
              (u'Exercise 4: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec127'),
              (u'A general model problem', 3, None, '___sec128'),
              (u'Variational formulation', 3, None, '___sec129'),
              (u'Implementation of boundary conditions',
               3,
               None,
               '___sec130'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec131'),
              (u'Test problem', 3, None, '___sec132'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec133'),
              (u'Implementation of multiple subdomains',
               3,
               None,
               '___sec134'),
              (u'Refactoring of a solver function into solver and problem classes',
               2,
               None,
               '___sec135'),
              (u'The diffusion solver revisited',
               0,
               u'ch:diffusion',
               u'ch:diffusion'),
              (u'Optimization of algorithms and implementations',
               1,
               u'ch:diffusion:opt',
               u'ch:diffusion:opt'),
              (u'Avoiding some assembly',
               2,
               u'ch:diffusion:opt:bassembly',
               u'ch:diffusion:opt:bassembly'),
              (u'Avoiding all assembly',
               2,
               u'ch:diffusion:opt:noassembly',
               u'ch:diffusion:opt:noassembly'),
              (u'Deriving recursive linear systems', 3, None, '___sec140'),
              (u'Implementation', 3, None, '___sec141'),
              (u'A welding example with post processing and animation',
               1,
               u'ch:diffusion:welding',
               u'ch:diffusion:welding'),
              (u'Post processing data and saving to file',
               2,
               u'ch:diffusion:welding:cbcpost',
               u'ch:diffusion:welding:cbcpost'),
              (u'Installation', 3, None, '___sec144'),
              (u'Basic commands', 3, None, '___sec145'),
              (u'Heat transfer due to a moving welding source',
               2,
               u'ch:diffusion:welding:problem',
               u'ch:diffusion:welding:problem'),
              (u'Scaling of the welding problem',
               2,
               u'ch:diffusion:welding:scaling',
               u'ch:diffusion:welding:scaling'),
              (u'A function-based solver',
               2,
               u'ch:diffusion:welding:funcsolver',
               u'ch:diffusion:welding:funcsolver'),
              (u'Refactored implementation',
               1,
               u'ch:diffusion:refactor',
               u'ch:diffusion:refactor'),
              (u'Mathematical problem',
               2,
               u'ch:diffusion:refactor:math',
               u'ch:diffusion:refactor:math'),
              (u'A class-based solver for a general diffusion problem',
               2,
               u'ch:diffusion:refactor:class_solver',
               u'ch:diffusion:refactor:class_solver'),
              (u'Exercise 5: Implement second-order schemes in time',
               2,
               None,
               '___sec152'),
              (u'A physical example',
               2,
               u'ftut:timedep:diffusion2:sin',
               u'ftut:timedep:diffusion2:sin'),
              (u'The nonlinear Poisson solver revisited',
               0,
               u'ftut:nonlinear',
               u'ftut:nonlinear'),
              (u'Test problem', 3, None, '___sec155'),
              (u'The built-in automated Newton solver',
               1,
               u'ch:poisson0:nonlinear',
               u'ch:poisson0:nonlinear'),
              (u'Computing the Jacobian', 2, None, '___sec157'),
              (u'Setting solver parameters', 2, None, '___sec158'),
              (u'Implementation', 2, None, '___sec159'),
              (u'Manual implementation of solution algorithms',
               1,
               None,
               '___sec160'),
              (u'Picard iteration',
               2,
               u'ftut:nonlinear:Picard',
               u'ftut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'ftut:nonlinear:Newton:algebraic',
               u'ftut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'ftut:nonlinear:Newton:pdelevel',
               u'ftut:nonlinear:Newton:pdelevel'),
              (u'More old stuff', 0, None, '___sec164'),
              (u'Creating more complex domains',
               1,
               u'ftut:prepro',
               u'ftut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'ftut:prepro:builtin',
               u'ftut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'ftut:mesh:transform:cyl',
               u'ftut:mesh:transform:cyl'),
              (u'Coordinate stretching', 3, None, '___sec168'),
              (u'Rectangle to hollow circle mapping', 3, None, '___sec169'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'ftut:possion:nD:nmat',
               u'ftut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'ftut:possion:nD:nmat:PDE',
               u'ftut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'ftut:possion:nD:nmat:prepro',
               u'ftut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'ftut:possion:nD:nmat:solve',
               u'ftut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec174'),
              (u'Miscellaneous topics', 1, None, '___sec175'),
              (u'Glossary', 2, None, '___sec176'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec177'),
              (u'Mesh', 3, None, '___sec178'),
              (u'Function space', 3, None, '___sec179'),
              (u'Function', 3, None, '___sec180'),
              (u'Overview of objects and functions', 2, None, '___sec181'),
              (u'Linear solvers and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'ftut:Epetra',
               u'ftut:Epetra'),
              (u'Troubleshooting', 0, u'ftut:trouble', u'ftut:trouble'),
              (u'Compilation Problems', 1, None, '___sec185'),
              (u'Problems with the Instant cache', 2, None, '___sec186'),
              (u'Syntax errors in expressions', 2, None, '___sec187'),
              (u'Example', 3, None, '___sec188'),
              (u'Problems in the solve step', 2, None, '___sec189'),
              (u'Unable to convert object to a UFL form',
               2,
               None,
               '___sec190'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               2,
               None,
               '___sec191'),
              (u'All programs fail to compile', 2, None, '___sec192'),
              (u'Problems with Expression Objects', 1, None, '___sec193'),
              (u'There seems to be some bug in an Expression object',
               2,
               None,
               '___sec194'),
              (u'Segmentation fault when using an Expression object',
               2,
               None,
               '___sec195'),
              (u'Other Problems', 1, None, '___sec196'),
              (u'Very strange error message involving a `mesh` variable',
               2,
               None,
               '___sec197'),
              (u'The plot disappears quickly from the screen',
               2,
               None,
               '___sec198'),
              (u'Only parts of the program are executed',
               2,
               None,
               '___sec199'),
              (u'Error in the definition of the boundary',
               2,
               None,
               '___sec200'),
              (u'The solver in a nonlinear problems does not converge',
               2,
               None,
               '___sec201'),
              (u'How To Debug a FEniCS Program?', 1, None, '___sec202'),
              (u'To-do list', 1, None, '___sec203'),
              (u'AL list', 2, None, '___sec204'),
              (u'HPL list', 2, None, '___sec205'),
              (u'HPL questions', 2, None, '___sec206'),
              (u'Iterative linear solvers info', 3, None, '___sec207'),
              (u'Bibliography', 1, None, '___sec208')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:fundamentals" style="font-size: 80%;"><b>The Fundamentals: A Poisson equation solver</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:poisson0:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The time-dependent diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec58" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing a test problem with SymPy</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#ch:poisson" style="font-size: 80%;"><b>The Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#___sec77" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut009.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Useful extensions</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec120" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactoring of a solver function into solver and problem classes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion" style="font-size: 80%;"><b>The diffusion solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of algorithms and implementations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:opt:bassembly" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding some assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:opt:noassembly" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding all assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving recursive linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:welding" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A welding example with post processing and animation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:welding:cbcpost" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Post processing data and saving to file</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic commands</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:welding:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heat transfer due to a moving welding source</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:welding:scaling" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling of the welding problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:welding:funcsolver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A function-based solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:refactor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:refactor:math" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ch:diffusion:refactor:class_solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A class-based solver for a general diffusion problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Implement second-order schemes in time</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#ftut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:nonlinear" style="font-size: 80%;"><b>The nonlinear Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ch:poisson0:nonlinear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The built-in automated Newton solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec157" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec159" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Manual implementation of solution algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#ftut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec164" style="font-size: 80%;"><b>More old stuff</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#ftut:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating more complex domains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#ftut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#ftut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinate stretching</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle to hollow circle mapping</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:possion:nD:nmat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A General \( d \)-Dimensional multi-material test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#ftut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More Examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Miscellaneous topics</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec176" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec177" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec180" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#ftut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#ftut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec185" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec186" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec187" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec189" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec190" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec191" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec195" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec196" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec197" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Very strange error message involving a <code>mesh</code> variable</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec198" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disappears quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec199" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec201" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec202" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec203" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;To-do list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec204" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec205" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec206" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec207" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut021.html#___sec208" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0010"></a>
<!-- !split -->
<!-- Or Useful extensions and recipies? -->

<h1 id="___sec79">Useful extensions </h1>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 11</b>: Need a little intro.)</font>
<!-- end inline comment -->

<h2 id="ch:poisson0:solve:prm">Controlling the solution process</h2>

<p>
Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.
The forthcoming text tells you how to
advantage of state-of-the-art iterative solution methods in FEniCS.

<h3 id="___sec81">Setting linear solver parameters </h3>

<p>
Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite coefficient matrix, for
which the optimal Krylov solver is the Conjugate Gradient (CG)
method. However, the CG method requires boundary conditions to be
implemented in a symmetric way. This is not the case by default, so
then a Krylov solver for non-symmetric system, such as GMRES, is a
better choice.  Incomplete LU factorization (ILU) is a popular and
robust all-round preconditioner, so let us try the GMRES-ILU pair:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solve(a <span style="color: #666666">==</span> L, u, bc)
      solver_parameters<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                         <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>})
<span style="color: #408080; font-style: italic"># Alternative syntax</span>
solve(a <span style="color: #666666">==</span> L, u, bc,
      solver_parameters<span style="color: #666666">=</span><span style="color: #008000">dict</span>(linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;gmres&#39;</span>,
                             preconditioner<span style="color: #666666">=</span><span style="color: #BA2121">&#39;ilu&#39;</span>))
</pre></div>
<p>
the section <a href="._ftut018.html#ftut:app:solver:prec">Linear solvers and preconditioners</a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.

<h3 id="___sec82">Linear algebra backend </h3>

<p>
The actual GMRES and ILU implementations that are brought into action
depends on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology.  PETSc is the default choice if FEniCS is compiled
with PETSc, otherwise uBLAS.  Epetra (Trilinos), Eigen, MTL4 are other
supported backends. Which backend to apply can be controlled by
setting

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>] <span style="color: #666666">=</span> backendname
</pre></div>
<p>
where <code>backendname</code> is a string, either <code>'Eigen'</code>, <code>'PETSc'</code>, <code>'uBLAS'</code>,
<code>'Epetra'</code>, or <code>'MTL4'</code>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear systems
of equations.

<p>
A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the
default linear algebra backend.  The default solver is sparse LU
decomposition (<code>'lu'</code>), and the actual software that is called is then
the sparse LU solver from UMFPACK (which PETSc has an interface
to). The available linear algebra backends in a FEniCS installation is
listed by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">list_linear_algebra_backends()
</pre></div>

<h3 id="___sec83">The <code>parameters</code> database </h3>

<p>
We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method.  Such parameters can be set by accessing the <em>global
parameter database</em>, which is called <code>parameters</code> and which behaves as
a nested dictionary. Write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">info(parameters, verbose<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code>info</code>.
According to this output, the relevant parameter set is
named <code>'krylov_solver'</code>, and the parameters are set like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>]  <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-10</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-6</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.

<p>
To get a printout of the number of actual iterations to reach the
stopping criterion, we can insert

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">set_log_level(PROGRESS)
<span style="color: #408080; font-style: italic"># or</span>
set_log_level(DEBUG)
</pre></div>
<p>
A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <code>PROGRESS</code>, while
<code>DEBUG</code> results in more information, including CPU time spent in
the various parts of the matrix assembly and solve process.

<p>
We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">File(<span style="color: #BA2121">&#39;fenics_parameters.xml&#39;</span>) <span style="color: #666666">&lt;&lt;</span> parameters
</pre></div>
<p>
If a <code>fenics_parameters.xml</code> file is found in the directory where a
FEniCS program is run, this file is read and used to initialize the
<code>parameters</code> object. Otherwise, the file
<code>.config/fenics/fenics_parameters.xml</code> in the user's home directory is
read, if it exists.  Another alternative is to load the XML (with any
name) manually in the program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">File(<span style="color: #BA2121">&#39;fenics_parameters.xml&#39;</span>) <span style="color: #666666">&gt;&gt;</span> parameters
</pre></div>
<p>
The XML file can also be in gzip'ed form with the extension <code>.xml.gz</code>.

<h3 id="___sec84">An extended solver function </h3>

<p>
Let us extend the previous solver function from
<code>ft04_poisson_func.py</code> such that it also offers the GMRES+ILU
preconditioned Krylov solver.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u0 (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solve(a <span style="color: #666666">==</span> L, u, bc, solver_parameters<span style="color: #666666">=</span>solver_parameters)
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_objects</span>(
    f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;As solver, but use objects for linear variational problem</span>
<span style="color: #BA2121; font-style: italic">    and solver.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bc)
    solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;linear_solver&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;gmres&#39;</span>
        solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;preconditioner&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ilu&#39;</span>
        prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solver<span style="color: #666666">.</span>solve()
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
This new <code>solver</code> function, found in the file
<code>ft05_poisson_iter.py</code>, replaces the one in <code>ft04_poisson_func.py</code>:
it has all the functionality of the previous <code>solver</code> function,
but can also solve the linear system with
iterative methods and report the progress of such solvers.

<h3 id="___sec85">Remark regarding unit tests </h3>

<p>
Regarding verification of the new <code>solver</code> function in terms of unit
tests, it turns out that unit testing in a problem where the
approximation error vanishes is gets more complicated when we use
iterative methods. The problem is to keep the error due to iterative
solution smaller than the tolerance used in the verification
tests. First of all this means that the tolerances used in the Krylov
solvers must be smaller than the tolerance used in the <code>assert</code> test,
but this is no guarantee to keep the linear solver error this small.
For linear elements and small meshes, a tolerance of \( 10^{-11} \) works
well in the case of Krylov solvers too (using a tolerance \( 10^{-12} \)
in those solvers. However, as soon as we switch to P2 elements, it is
hard to force the linear solver error below \( 10^{-6} \). Consequently,
tolerances in tests depend on the numerical methods. The interested
reader is referred to the <code>test_solver</code> function in
<code>ft05_poisson_iter.py</code> for details: this test function tests the
numerical solution for direct and iterative linear solvers, for
different meshes, and different degrees of the polynomials in the
finite element basis functions.

<h2 id="ch:poisson0:solver:problem">Linear variational problem and solver objects</h2>

<p>
The <code>solve(a == L, u, bc)</code> call is just a compact syntax alternative to a
slightly more comprehensive specification of the variational equation
and the solution of the associated linear system.  This alternative
syntax is used in a lot of FEniCS applications and will also be
used later in this tutorial, so we show it already now:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bc)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
Many objects have an attribute <code>parameters</code> corresponding to
a parameter set in the global <code>parameters</code> database,
but local to the object. Here, <code>solver.parameters</code> play that
role. Setting the CG method with ILU preconditioning as solution
method and specifying solver-specific parameters can be done
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;linear_solver&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;gmres&#39;</span>
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;preconditioner&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ilu&#39;</span>
prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Settings in the global <code>parameters</code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as done above.

<p>
The linear variational problem and solver objects as outlined above
are incorporated in an alternative solver function, named
<code>solver_objects</code>, in
<code>ft05_poisson_iter.py</code>. Otherwise, this function is parallel to the
previously shown <code>solver</code> function.

<h2 id="ch:poisson0:verify1">Writing out the discrete solution</h2>

<p>
We have seen how to grab the degrees of freedom array from a
finite element function <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_array <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
The elements in <code>u_array</code> correspond to function values of <code>u</code> at nodes
in the mesh.  Now, a fundamental question is: What are the
coordinates of node <code>i</code> whose value is <code>u_array[i]</code>? To answer this
question, we need to understand how to get our hands on the
coordinates, and in particular, the numbering of degrees of freedom
and the numbering of vertices in the mesh. We start with P1 (1st order
Lagrange) elements where all the nodes are vertices in the mesh.

<p>
The function <code>mesh.coordinates()</code> returns the coordinates of the
vertices as a <code>numpy</code> array with shape \( (M,d \)), \( M \) being the number
of vertices in the mesh and \( d \) being the number of space dimensions:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
<span style="color: #666666">&gt;&gt;&gt;</span> coor
array([[ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">1.</span> ]])
</pre></div>
<p>
We see from this output that vertices are first numbered along \( y=0 \)
with increasing \( x \) coordinate, then along \( y=0.5 \), and so on.

<p>
Next we compute a function <code>u</code> on this mesh, e.g., the \( u=x+y \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> interpolate(Expression(<span style="color: #BA2121">&#39;x[0]+x[1]&#39;</span>), V)
<span style="color: #666666">&gt;&gt;&gt;</span> plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u_array <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
<span style="color: #666666">&gt;&gt;&gt;</span> u_array
array([ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ,  <span style="color: #666666">2.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">1.</span> ])
</pre></div>
<p>
We observe that <code>u_array[0]</code> is <em>not</em> the value of \( x+y \) at vertex number 0,
since this vertex has coordinates \( x=y=0 \). The numbering of the
degrees of freedom \( U_1,\ldots,U_{N} \) is obviously not the same as the
numbering of the vertices.

<p>
In the plot of <code>u</code>, type <code>w</code> to turn on wireframe instead of fully colored
surface, <code>m</code> to show the mesh, and then <code>v</code> to show the
numbering of the vertices.

<p>
<br />
<br />

<p>
<center><p><img src="fig/vertex_numbering.png" align="bottom" width=500></p></center>

<p>
<br />
<br />

<p>
Already in the section <a href="._ftut006.html#ch:poisson0:impl:dissect">Dissection of the program</a> we explained that
the vertex values of a <code>Function</code> object can be extracted
<code>u.compute_vertex_values()</code>, which returns an array where element <code>i</code>
is the value of <code>u</code> at vertex <code>i</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: u_at_vertices[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121">u(</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
<span style="color: #666666">...</span>           (i, i, u_at_vertices[i], x, u(x)))
vertex <span style="color: #666666">0</span>: u_at_vertices[<span style="color: #666666">0</span>]<span style="color: #666666">=0</span>	u([ <span style="color: #666666">0.</span>  <span style="color: #666666">0.</span>])<span style="color: #666666">=8.46545e-16</span>
vertex <span style="color: #666666">1</span>: u_at_vertices[<span style="color: #666666">1</span>]<span style="color: #666666">=0.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.</span> ])<span style="color: #666666">=0.5</span>
vertex <span style="color: #666666">2</span>: u_at_vertices[<span style="color: #666666">2</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">1.</span>  <span style="color: #666666">0.</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">3</span>: u_at_vertices[<span style="color: #666666">3</span>]<span style="color: #666666">=0.5</span>	u([ <span style="color: #666666">0.</span>   <span style="color: #666666">0.5</span>])<span style="color: #666666">=0.5</span>
vertex <span style="color: #666666">4</span>: u_at_vertices[<span style="color: #666666">4</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.5</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">5</span>: u_at_vertices[<span style="color: #666666">5</span>]<span style="color: #666666">=1.5</span>	u([ <span style="color: #666666">1.</span>   <span style="color: #666666">0.5</span>])<span style="color: #666666">=1.5</span>
vertex <span style="color: #666666">6</span>: u_at_vertices[<span style="color: #666666">6</span>]<span style="color: #666666">=1</span>	u([ <span style="color: #666666">0.</span>  <span style="color: #666666">1.</span>])<span style="color: #666666">=1</span>
vertex <span style="color: #666666">7</span>: u_at_vertices[<span style="color: #666666">7</span>]<span style="color: #666666">=1.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">1.</span> ])<span style="color: #666666">=1.5</span>
vertex <span style="color: #666666">8</span>: u_at_vertices[<span style="color: #666666">8</span>]<span style="color: #666666">=2</span>	u([ <span style="color: #666666">1.</span>  <span style="color: #666666">1.</span>])<span style="color: #666666">=2</span>
</pre></div>
<p>
Alternatively, we can ask for the mapping from vertex numbering to degrees
of freedom numbering in the space \( V \):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v2d = vertex_to_dof_map(V)
</pre></div>
<p>
Now, <code>u_array[v2d[i]]</code> will give us the value of the
degree of freedom in <code>u</code> corresponding
to vertex <code>i</code> (<code>v2d[i]</code>). In particular, <code>u_array[v2d]</code> is an array
with all the elements in the same (vertex numbered) order as <code>coor</code>.
The inverse map, from degrees of freedom
number to vertex number is given by <code>dof_to_vertex_map(V)</code>, so
<code>coor[dof_to_vertex_map(V)]</code> results in an array of all the
coordinates in the same order as the degrees of freedom.

<p>
For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices.

<!-- begin inline comment -->
<font color="red">(<b>hpl 12</b>: Anders, is the following true?)</font>
<!-- end inline comment -->
 There is no simple way of getting the
coordinates associated with the non-vertex degrees of freedom, so
if we want to write out the values of a finite element solution,
the following code snippet does the task at the vertices, and this
will work for all kinds of Lagrange elements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compare_exact_and_numerical_solution</span>(Nx, Ny, degree<span style="color: #666666">=1</span>):
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    <span style="color: #408080; font-style: italic"># Grab exact and numerical solution at the vertices and compare</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    u0_Function <span style="color: #666666">=</span> interpolate(u0, V)
    u0_at_vertices <span style="color: #666666">=</span> u0_Function<span style="color: #666666">.</span>compute_vertex_values()
    u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
    coor <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">): error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span>
              <span style="color: #666666">%</span> (i, x[<span style="color: #666666">0</span>], x[<span style="color: #666666">1</span>],
                 u0_at_vertices[i] <span style="color: #666666">-</span> u_at_vertices[i]))
        <span style="color: #408080; font-style: italic"># Could compute u0(x) - u_at_vertices[i] but this</span>
        <span style="color: #408080; font-style: italic"># is much more expensive and gives more rounding errors</span>
    center <span style="color: #666666">=</span> (<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>)
    error <span style="color: #666666">=</span> u0(center) <span style="color: #666666">-</span> u(center)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical error at </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (center, error))
</pre></div>
<p>
As expected, the error is either identically zero or about \( 10^{-15} \) or
\( 10^{-16} \).

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Cheap vs expensive function evaluation.</b>
Given a <code>Function</code> object <code>u</code>, we can evaluate its values in various
ways:

<ol>
<li> <code>u(x)</code> for an arbitrary point <code>x</code></li>
<li> <code>u.vector().array()[i]</code> for degree of freedom number <code>i</code></li>
<li> <code>u.compute_vertex_values()[i]</code> at vertex number <code>i</code></li>
</ol>

The first method, though very flexible, is in general very expensive
while the other two are very efficient (but limited to certain points).
</div>


<p>
To demonstrate the use of point evaluations of <code>Function</code> objects,
we write out the computed <code>u</code> at the center point
of the domain and compare it with the exact solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">center <span style="color: #666666">=</span> (<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>)
error <span style="color: #666666">=</span> u0(center) <span style="color: #666666">-</span> u(center)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical error at </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (center, error)
</pre></div>
<p>
Trying a \( 2(3\times 3) \) mesh, the output from the
previous snippet becomes

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">numerical error at (0.5, 0.5): -0.0833333
</pre></div>
<p>
The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell,
and <code>u</code> varies linearly over the cell while
<code>u0</code> is a quadratic function. When the center point is a node, as in
a \( 2(t\times 2) \) or \( 2(4\times 4) \) mesh, the error is of the order
\( 10^{-15} \).

<p>
We have seen how to extract the nodal values in a <code>numpy</code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that \( \max_j U_j = 1 \). Then we
must divide all \( U_j \) values
by \( \max_j U_j \). The following function performs the task:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">normalize_solution</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Normalize u: return u divided by max(u).&quot;&quot;&quot;</span>
    u_array <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
    u_max <span style="color: #666666">=</span> u_array<span style="color: #666666">.</span>max()
    u_array <span style="color: #666666">/=</span> u_max
    u<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_array
    u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>set_local(u_array)  <span style="color: #408080; font-style: italic"># alternative</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
That is, we manipulate <code>u_array</code> as desired, and then we insert this
array into <code>u</code>'s <code>Vector</code> object.  The <code>/=</code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <code>u_array</code> are divided by the value <code>max_u</code>.
Alternatively, one could write <code>u_array = u_array/max_u</code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code>u_array</code>.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Be careful when manipulating degrees of freedom.</b>
A call like <code>u.vector().array()</code> returns a <em>copy</em> of the data in
<code>u.vector()</code>. One must therefore never perform assignments like
<code>u.vector.array()[:] = ...</code>, but instead extract the <code>numpy</code> array
(i.e., a copy), manipulate it, and insert it back with <code>u.vector()[:]
= </code> or <code>u.set_local(...)</code>.
</div>


<p>
All the code in this subsection can be found in the file <code>ft05_poisson_iter.py</code>.

<h2 id="ch:poisson0:nD">Parameterizing the number of space dimensions</h2>

<p>
FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory programs <code>ft01_poisson_flat.py</code> or
<code>ft04_poisson_func.py</code> and change the
mesh construction from <code>UnitSquareMesh(6, 4)</code> to <code>UnitCubeMesh(6, 4,
5)</code>. Now the domain is the unit cube partitioned into \( 6\times 4\times
5 \) boxes, and each box is divided into six tetrahedra-shaped
finite elements for computations.  Run the program and observe that we
can solve a 3D problem without any other modifications (!). The
visualization allows you to rotate the cube and observe the function
values as colors on the boundary.

<h3 id="___sec89">Generating a hypercube </h3>

<p>
The syntax for generating a unit interval, square, or box is different,
so we need to encapsulate this part of the code. Given a list or
tuple with the divisions into cells in the various spatial direction,
the following function returns the mesh in a \( d \)-dimensional problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">unit_hypercube</span>(divisions, degree):
    mesh_classes <span style="color: #666666">=</span> [UnitIntervalMesh, UnitSquareMesh, UnitCubeMesh]
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(divisions)
    mesh <span style="color: #666666">=</span> mesh_classes[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
    <span style="color: #008000; font-weight: bold">return</span> V, mesh
</pre></div>
<p>
The construction <code>mesh_class[d-1]</code> will pick the right name of the
object used to define the domain and generate the mesh.
Moreover, the argument <code>*divisions</code>
sends all the component of the list <code>divisions</code> as separate
arguments. For example, in a 2D problem where <code>divisions</code> has
two elements, the statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> mesh_classes[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
</pre></div>
<p>
is equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitSquareMesh(divisions[<span style="color: #666666">0</span>], divisions[<span style="color: #666666">1</span>])
</pre></div>
<p>
Replacing the <code>Nx</code> and <code>Ny</code> parameters by <code>divisions</code> and calling
<code>unit_hypercube</code> to create the mesh are the two modifications that
we need in any of the previously shown <code>solver</code> functions to turn
them into solvers for \( d \)-dimensional problems!

<h2 id="ch:poisson0:gradu">Computing derivatives</h2>

<p>
In Poisson and many other problems, the gradient of the solution is
of interest. The computation is in principle simple:
since
\( u = \sum_{j=1}^N U_j \phi_j \), we have that

$$
\begin{equation*}
\nabla u = \sum_{j=1}^N U_j \nabla \phi_j\tp
\end{equation*}
$$

Given the solution variable <code>u</code> in the program, its gradient is
obtained by <code>grad(u)</code> or <code>grad(u)</code>.  However, the gradient of a
piecewise continuous finite element scalar field is a discontinuous
vector field since the \( \phi_j \) has discontinuous derivatives at the
boundaries of the cells. For example, using Lagrange elements of
degree 1, \( u \) is linear over each cell, and the numerical \( \nabla u \)
becomes a piecewise constant vector field. On the contrary, the exact
gradient is continuous.  For visualization and data analysis purposes
we often want the computed gradient to be a continuous vector
field. Typically, we want each component of \( \nabla u \) to be
represented in the same way as \( u \) itself. To this end, we can project
the components of \( \nabla u \) onto the same function space as we used
for \( u \).  This means that we solve \( w = \nabla u \) approximately by a
finite element method, using the same elements for the components of
\( w \) as we used for \( u \). This process is known as <em>projection</em>.

<p>
Not surprisingly, projection is a so common operation in finite
element programs that FEniCS has a function for doing the task:
<code>project(q, W)</code>, which returns the projection of some <code>Function</code> or
<code>Expression</code> object named <code>q</code> onto the <code>FunctionSpace</code> (if <code>q</code> is
scalar) or <code>VectorFunctionSpace</code> (if <code>q</code> is vector-valued) named <code>W</code>.
Specifically, in our case where <code>u</code> is computed and we want to project
the vector-valued <code>grad(u)</code> onto the <code>VectorFunctionSpace</code> where each
component has the same <code>Function</code> space as <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
degree <span style="color: #666666">=</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
W <span style="color: #666666">=</span> VectorFunctionSpace(V<span style="color: #666666">.</span>mesh(), <span style="color: #BA2121">&#39;P&#39;</span>, degree)

grad_u <span style="color: #666666">=</span> project(grad(u), W)
</pre></div>
<p>
Figure <a href="#ch:poisson0:2D:fig:ex1:gradu">8</a> shows
example of how such a smoothed <code>gradu(u)</code> vector field is visualized.

<p>
<center> <!-- figure label: --> <div id="ch:poisson0:2D:fig:ex1:gradu"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 8:  Example of visualizing the vector field \( \nabla u \) by arrows at the nodes.  <!-- caption label: ch:poisson0:2D:fig:ex1:gradu --> </p></center>
<p><img src="fig/ex1_gradu.png" align="bottom" width=480></p>
</center>

<p>
The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.

<p>
The scalar component fields of the gradient
can be extracted as separate fields and, e.g., visualized:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_x, grad_u_y <span style="color: #666666">=</span> grad_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)
plot(grad_u_x, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x-component of grad(u)&#39;</span>)
plot(grad_u_y, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y-component of grad(u)&#39;</span>)
</pre></div>
<p>
The <code>deepcopy=True</code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code>deepcopy=False</code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)

<p>
The <code>grad_u_x</code> and <code>grad_u_y</code> variables behave as
<code>Function</code> objects. In particular, we can extract the underlying
arrays of nodal values by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_x_array <span style="color: #666666">=</span> grad_u_x<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
grad_u_y_array <span style="color: #666666">=</span> grad_u_y<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
The degrees of freedom of the <code>grad_u</code> vector field can also be
reached by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grad_u_array <span style="color: #666666">=</span> grad_u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
but this is a flat <code>numpy</code> array where the degrees of freedom for the
\( x \) component of the gradient is stored in the first part, then the
degrees of freedom of the \( y \) component, and so on. This is less convenient
to work with.

<p>
The function <code>gradient(u)</code> in <code>ft05_poisson_iter.py</code>
returns a projected (smoothed) \( \nabla u \) vector field, given some
finite element function <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">gradient</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
    grad_u <span style="color: #666666">=</span> project(grad(u), V_g)
    grad_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;grad(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous gradient field&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> grad_u
</pre></div>
<p>
Examining the arrays with vertex values of <code>grad_u_x</code> and <code>grad_u_y</code>
quickly reveals that the computed <code>grad_u</code> field does not equal the
exact gradient \( (2x, 4y) \) in this particular test problem where
\( u=1+x^2+2y^2 \).  There are inaccuracies at the boundaries, arising
from the approximation problem for \( w \). Increasing the mesh resolution
shows, however, that the components of the gradient vary linearly as
\( 2x \) and \( 4y \) in the interior of the mesh (i.e., as soon as we are one
element away from the boundary).  The <code>application_test_gradient</code>
function in <code>ft05_poisson_iter.py</code> performs some experiments.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Detour: Manual projection.</b>
Although you will always use <code>project</code> to project a finite element
function, it can be constructive this point in the tutorial to formulate the
projection mathematically and implement its steps manually in FEniCS.

<p>
Looking at the component \( \partial u/\partial x \) of the gradient, we
project the (discrete) derivative \( \sum_jU_j{\partial \phi_j/\partial
x} \) onto a function space with basis \( \phi_1,\phi_2,\ldots \) such that
the derivative in this space is expressed by the standard sum
\( \sum_j\bar U_j \phi_j \), for suitable (new) coefficients \( \bar U_j \).

<p>
The variational problem for \( w \) reads: find  \( w\in \Vg \) such that

$$
\begin{equation}
a(w, v) = L(v)\quad\forall v\in \hat{\Vg},
\tag{4.3}
\end{equation}
$$

where

$$
\begin{align}
a(w, v) &= \int_\Omega w\cdot v \dx,
\tag{4.4}\\ 
L(v) &= \int_\Omega \nabla u\cdot v \dx\tp
\tag{4.5}
\end{align}
$$

The function spaces \( \Vg \) and \( \hat{\Vg} \) (with the superscript g
denoting &quot;gradient&quot;) are vector versions of the function space for
\( u \), with boundary conditions removed (if \( V \) is the space we used for
\( u \), with no restrictions on boundary values, \( \Vg = \hat{\Vg} =
[V]^d \), where \( d \) is the number of space dimensions).  For example, if
we used piecewise linear functions on the mesh to approximate \( u \), the
variational problem for \( w \) corresponds to approximating each
component field of \( w \) by piecewise linear functions.

<p>
The variational problem for the vector field
\( w \), called <code>grad_u</code> in the code, is easy to solve in FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
w <span style="color: #666666">=</span> TrialFunction(V_g)
v <span style="color: #666666">=</span> TestFunction(V_g)

a <span style="color: #666666">=</span> dot(w, v)<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> dot(grad(u), v)<span style="color: #666666">*</span>dx
grad_u <span style="color: #666666">=</span> Function(V_g)
solve(a <span style="color: #666666">==</span> L, grad_u)

plot(grad_u, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;grad(u)&#39;</span>)
</pre></div>
<p>
The boundary condition argument to <code>solve</code> is dropped since there are
no essential boundary conditions in this problem.
The new thing is basically that we work with a <code>VectorFunctionSpace</code>,
since the unknown is now a vector field, instead of the
<code>FunctionSpace</code> object for scalar fields.
</div>


<h2 id="ftut:possion:2D:varcoeff">A variable-coefficient Poisson problem</h2>

<p>
Suppose we have a variable coefficient \( p(x,y) \) in the Laplace operator,
as in the boundary-value problem

$$
\begin{equation} \tag{4.6}
  \begin{split}
    - \nabla\cdot \left\lbrack
p(x,y)\nabla u(x,y)\right\rbrack &= f(x,y) \quad \mbox{in } \Omega,
    \\ 
    u(x,y) &= u_0(x,y) \quad \mbox{on}\  \partial\Omega\tp
  \end{split}
\end{equation}
$$

We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS program.

<h3 id="___sec92">Test problem </h3>

<p>
Let us continue to use our favorite solution \( u(x,y)=1+x^2+2y^2 \) and
then prescribe \( p(x,y)=x+y \). It follows that
\( u_0(x,y) = 1 + x^2 + 2y^2 \) and \( f(x,y)=-8x-10y \).

<h3 id="___sec93">Modifications of the PDE solver </h3>

<p>
What are the modifications we need to do in the previously shown codes
to incorporate the variable coefficient \( p \)?
from the section <a href="#ch:poisson0:verify1">Writing out the discrete solution</a>?

<ul>
  <li> <code>solver</code> must take <code>p</code> as argument,</li>
  <li> <code>f</code> in our test problem
    must be an <code>Expression</code> since it is no longer a constant,</li>
  <li> a new <code>Expression p</code> must be defined for the variable coefficient,</li>
  <li> the formula for \( a(u,v) \) in the variational problem is slightly changed.</li>
</ul>

First we address the modified variational problem. Multiplying
the PDE by a test function \( v \) and
integrating by parts now results
in

$$
\begin{equation*}
\int_\Omega p\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} p{\partial u\over
\partial n}v \ds = \int_\Omega fv \dx\tp
\end{equation*}
$$

The function spaces for \( u \) and \( v \) are the same as in
the section <a href="._ftut004.html#ch:poisson0:varform">Finite element variational formulation</a>, implying that the boundary integral
vanishes since \( v=0 \) on \( \partial\Omega \) where we have Dirichlet conditions.
The weak form \( a(u,v)=L(v) \) then has

$$
\begin{align}
a(u,v) &= \int_\Omega p\nabla u\cdot\nabla v \dx,
\tag{4.7}\\ 
L(v) &= \int_\Omega fv \dx\tp
\tag{4.8}
\end{align}
$$

In the code for solving \( -\nabla^2u=f \) we must replace

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> p<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
to solve \( -\nabla\cdot(p\nabla u)=f \). Moreover,
the definitions of <code>p</code> and <code>f</code> in the test problem read

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
</pre></div>
<p>
No additional modifications are necessary. The file
<code>ft06_poisson_vc.py</code> (variable-coefficient Poisson problem in 2D)
is a copy of <code>ft05_poisson_iter.py</code> with the mentioned changes
incorporated. Observe that \( p=1 \) recovers the original problem in
<code>ft05_poisson_iter.py</code>.

<p>
You can run it and confirm
that it recovers the exact \( u \) at the nodes.

<h3 id="___sec94">Modifications of the flux computations </h3>

<p>
The flux \( -p\nabla u \) may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section <a href="#ch:poisson0:gradu">Computing derivatives</a>,
we normally want the piecewise discontinuous flux or gradient to be
approximated by a continuous vector field, using the same elements as
used for the numerical solution \( u \). The approximation now consists of
solving \( w = -p\nabla u \) by a finite element method: find \( w\in \Vg \)
such that

$$
\begin{equation}
a(w, v) = L(v)\quad\forall v\in \hat{\Vg},
\tag{4.9}
\end{equation}
$$

where

$$
\begin{align}
a(w, v) &= \int_\Omega w\cdot v \dx,
\tag{4.10}\\ 
L(v) &= \int_\Omega (-p \nabla u)\cdot v \dx\tp
\tag{4.11}
\end{align}
$$

This problem is identical to the one in the section <a href="#ch:poisson0:gradu">Computing derivatives</a>,
except that \( p \) enters the integral in \( L \).

<p>
The relevant Python statement for computing the flux field take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>grad(u),
               VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degreee))
</pre></div>
<p>
An appropriate function for computing the flux based on <code>u</code> and <code>p</code> is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">flux</span>(u, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return p*grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    degree <span style="color: #666666">=</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
    V_g <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
    flux_u <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>grad(u), V_g)
    flux_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous flux field&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> flux_u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_test_flux</span>(Nx<span style="color: #666666">=6</span>, Ny<span style="color: #666666">=4</span>):
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    p <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
    u <span style="color: #666666">=</span> solver(p, f, u0, Nx, Ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;solution&#39;</span>)
    flux_u <span style="color: #666666">=</span> flux(u, p)
    <span style="color: #408080; font-style: italic"># Grab each component as a scalar field</span>
    flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    flux_u_x<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)_x&#39;</span>, <span style="color: #BA2121">&#39;x-component of flux(u)&#39;</span>)
    flux_u_y<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)_y&#39;</span>, <span style="color: #BA2121">&#39;y-component of flux(u)&#39;</span>)
    plot(u, title<span style="color: #666666">=</span>u<span style="color: #666666">.</span>label())
    plot(flux_u,   title<span style="color: #666666">=</span>flux_u<span style="color: #666666">.</span>label())
    plot(flux_u_x, title<span style="color: #666666">=</span>flux_u_x<span style="color: #666666">.</span>label())
    plot(flux_u_y, title<span style="color: #666666">=</span>flux_u_y<span style="color: #666666">.</span>label())

    u_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>
    flux_x_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">-</span>(x<span style="color: #666666">+</span>y)<span style="color: #666666">*2*</span>x
    flux_y_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">-</span>(x<span style="color: #666666">+</span>y)<span style="color: #666666">*4*</span>y

    coor <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(coor) <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>:
        <span style="color: #408080; font-style: italic"># Quite large errors for coarse meshes, but the error</span>
        <span style="color: #408080; font-style: italic"># decreases with increasing resolution</span>
        <span style="color: #008000; font-weight: bold">for</span> i, value <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(flux_u_x<span style="color: #666666">.</span>compute_vertex_values()):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, -p*u_x=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (i, <span style="color: #008000">tuple</span>(coor[i]), value,
                   flux_x_exact(<span style="color: #666666">*</span>coor[i]) <span style="color: #666666">-</span> value))
        <span style="color: #008000; font-weight: bold">for</span> i, value <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(flux_u_y<span style="color: #666666">.</span>compute_vertex_values()):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, -p*u_y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (i, <span style="color: #008000">tuple</span>(coor[i]), value,
                   flux_y_exact(<span style="color: #666666">*</span>coor[i]) <span style="color: #666666">-</span> value))
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #408080; font-style: italic"># Compute integrated L2 error of the flux components</span>
        <span style="color: #408080; font-style: italic"># (Will this work for unstructured mesh? Need to think about that)</span>
        xv <span style="color: #666666">=</span> coor<span style="color: #666666">.</span>T[<span style="color: #666666">0</span>]
        yv <span style="color: #666666">=</span> coor<span style="color: #666666">.</span>T[<span style="color: #666666">1</span>]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_errors</span>(u, u_exact):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span style="color: #BA2121; font-style: italic">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Compute error norm (for very small errors, the value can be</span>
    <span style="color: #408080; font-style: italic"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()

    <span style="color: #408080; font-style: italic"># Function - Expression</span>
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_exact)<span style="color: #666666">**2*</span>dx
    E1 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_e onto the same space as u:</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E2 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span style="color: #408080; font-style: italic"># u will also be interpolated to the space Ve before integration</span>
    Ve <span style="color: #666666">=</span> FunctionSpace(V<span style="color: #666666">.</span>mesh(), <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">5</span>)
    u_e <span style="color: #666666">=</span> interpolate(u_exact, Ve)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E3 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># fenics.errornorm interpolates u and u_e to a space with</span>
    <span style="color: #408080; font-style: italic"># given degree, and creates the error field by subtracting</span>
    <span style="color: #408080; font-style: italic"># the degrees of freedom, then the error field is integrated</span>
    <span style="color: #408080; font-style: italic"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span style="color: #408080; font-style: italic">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span style="color: #408080; font-style: italic"># Manual implementation errornorm to get around the bug:</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">errornorm</span>(u_exact, u, Ve):
        u_Ve <span style="color: #666666">=</span> interpolate(u, Ve)
        u_e_Ve <span style="color: #666666">=</span> interpolate(u_exact, Ve)
        e_Ve <span style="color: #666666">=</span> Function(Ve)
        <span style="color: #408080; font-style: italic"># Subtract degrees of freedom for the error field</span>
        e_Ve<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_e_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        <span style="color: #408080; font-style: italic"># More efficient computation (avoids the rhs array result above)</span>
        <span style="color: #408080; font-style: italic">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span style="color: #408080; font-style: italic">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        error <span style="color: #666666">=</span> e_Ve<span style="color: #666666">**2*</span>dx(Ve<span style="color: #666666">.</span>mesh())
        <span style="color: #008000; font-weight: bold">return</span> sqrt(<span style="color: #008000">abs</span>(assemble(error))), e_Ve
    E4, e_Ve <span style="color: #666666">=</span> errornorm(u_exact, u, Ve)

    <span style="color: #408080; font-style: italic"># Infinity norm based on nodal values</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    E5 <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()

    <span style="color: #408080; font-style: italic"># H1 seminorm</span>
    error <span style="color: #666666">=</span> dot(grad(e_Ve), grad(e_Ve))<span style="color: #666666">*</span>dx
    E6 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Collect error measures in a dictionary with self-explanatory keys</span>
    errors <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;u - u_exact&#39;</span>: E1,
              <span style="color: #BA2121">&#39;u - interpolate(u_exact,V)&#39;</span>: E2,
              <span style="color: #BA2121">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span>: E3,
              <span style="color: #BA2121">&#39;errornorm&#39;</span>: E4,
              <span style="color: #BA2121">&#39;infinity norm (of dofs)&#39;</span>: E5,
              <span style="color: #BA2121">&#39;grad(error) H1 seminorm&#39;</span>: E6}

    <span style="color: #008000; font-weight: bold">return</span> errors

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rate</span>(u_exact, f, u0, p, degrees,
                     n<span style="color: #666666">=</span>[<span style="color: #666666">2**</span>(k<span style="color: #666666">+3</span>) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">5</span>)]):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute convergence rates for various error norms for a</span>
<span style="color: #BA2121; font-style: italic">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span style="color: #BA2121; font-style: italic">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span style="color: #BA2121; font-style: italic">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    h <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Discretization parameter, h[degree][experiment]</span>
    E <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Error measure(s), E[degree][experiment][error_type]</span>
    P_degrees <span style="color: #666666">=</span> <span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>
    num_meshes <span style="color: #666666">=</span> <span style="color: #666666">5</span>

    <span style="color: #408080; font-style: italic"># Perform experiments with meshes and element types</span>
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        n <span style="color: #666666">=</span> <span style="color: #666666">4</span>   <span style="color: #408080; font-style: italic"># Coarsest mesh division</span>
        h[degree] <span style="color: #666666">=</span> []
        E[degree] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
            n <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
            h[degree]<span style="color: #666666">.</span>append(<span style="color: #666666">1.0/</span>n)
            u <span style="color: #666666">=</span> solver(p, f, u0, n, n, degree,
                       linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
            errors <span style="color: #666666">=</span> compute_errors(u, u_exact)
            E[degree]<span style="color: #666666">.</span>append(errors)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;2*(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh, </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> unknowns, E1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (n, n, degree, u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
                   errors[<span style="color: #BA2121">&#39;u - u_exact&#39;</span>]))
    <span style="color: #408080; font-style: italic"># Convergence rates</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log <span style="color: #008000; font-weight: bold">as</span> ln  <span style="color: #408080; font-style: italic"># log is a fenics name too</span>
    error_types <span style="color: #666666">=</span> <span style="color: #008000">list</span>(E[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>keys())
    rates <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        rates[degree] <span style="color: #666666">=</span> {}
        <span style="color: #008000; font-weight: bold">for</span> error_type <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(error_types):
            rates[degree][error_type] <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
                Ei   <span style="color: #666666">=</span> E[degree][i][error_type]
                Eim1 <span style="color: #666666">=</span> E[degree][i<span style="color: #666666">-1</span>][error_type]
                r <span style="color: #666666">=</span> ln(Ei<span style="color: #666666">/</span>Eim1)<span style="color: #666666">/</span>ln(h[degree][i]<span style="color: #666666">/</span>h[degree][i<span style="color: #666666">-1</span>])
                rates[degree][error_type]<span style="color: #666666">.</span>append(<span style="color: #008000">round</span>(r,<span style="color: #666666">2</span>))
    <span style="color: #008000; font-weight: bold">return</span> rates

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rate_sin</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute convergence rates for u=sin(x)*sin(y) solution.&quot;&quot;&quot;</span>
    omega <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
    u_exact <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span>,
                         omega<span style="color: #666666">=</span>omega)
    f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>omega<span style="color: #666666">**2*</span>pi<span style="color: #666666">**2*</span>u_exact
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Note: P4 for n&gt;=128 seems to break down</span>
    rates <span style="color: #666666">=</span> convergence_rates(u_exact, f, u0, p, degrees<span style="color: #666666">=4</span>,
                              n<span style="color: #666666">=</span>[<span style="color: #666666">2**</span>(k<span style="color: #666666">+3</span>) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">5</span>)])
    <span style="color: #408080; font-style: italic"># Print rates</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n\n</span><span style="color: #BA2121">&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> error_type <span style="color: #AA22FF; font-weight: bold">in</span> error_types:
        <span style="color: #008000; font-weight: bold">print</span>(error_type)
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (degree, <span style="color: #008000">str</span>(rates[degree][error_type])[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">structured_mesh</span>(u, divisions):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    u2 <span style="color: #666666">=</span> u <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
         interpolate(u, FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
    mesh <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">BoxField</span> <span style="color: #008000; font-weight: bold">import</span> fenics_function2BoxField
    u_box <span style="color: #666666">=</span> fenics_function2BoxField(
        u2, mesh, divisions, uniform_mesh<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u_box

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_structured_mesh</span>(model_problem<span style="color: #666666">=1</span>):
    <span style="color: #008000; font-weight: bold">if</span> model_problem <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
        <span style="color: #408080; font-style: italic"># Numerical solution is exact</span>
        u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
        p <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
        f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
        flux_u_x_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">-</span>(x <span style="color: #666666">+</span> y)<span style="color: #666666">*2*</span>x
        nx <span style="color: #666666">=</span> <span style="color: #666666">6</span>;  ny <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    <span style="color: #008000; font-weight: bold">elif</span> model_problem <span style="color: #666666">==</span> <span style="color: #666666">2</span>:
        <span style="color: #408080; font-style: italic"># Mexican hat solution</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, pi  <span style="color: #408080; font-style: italic"># for use in math formulas</span>
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
        H <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: exp(<span style="color: #666666">-16*</span>(x<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>sin(<span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>x)
        x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0], x[1]&#39;</span>)
        u <span style="color: #666666">=</span> H(x)<span style="color: #666666">*</span>H(y)
        u_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
        <span style="color: #408080; font-style: italic"># &#39;-exp(-16*pow(x - 0.5, 2) - 16*pow(y - 0.5, 2))*&#39;</span>
        <span style="color: #408080; font-style: italic"># &#39;sin(3*M_PI*x)*sin(3*M_PI*y)&#39;</span>
        u_c <span style="color: #666666">=</span> u_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;DOLFIN_PI&#39;</span>)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u in C:&#39;</span>, u_c)
        u0 <span style="color: #666666">=</span> Expression(u_c)

        p <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Don&#39;t use Constant(1) here (!)</span>
        f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">+</span> \ 
            sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
        f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
        f_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
        f_c <span style="color: #666666">=</span> f_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;DOLFIN_PI&#39;</span>)
        f <span style="color: #666666">=</span> Expression(f_c)
        flux_u_x_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y], <span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x),
                                      modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;f in C:&#39;</span>, f_c)
        p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
        nx <span style="color: #666666">=</span> <span style="color: #666666">22</span>;  ny <span style="color: #666666">=</span> <span style="color: #666666">22</span>

    u <span style="color: #666666">=</span> solver(p, f, u0, nx, ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    u_box <span style="color: #666666">=</span> structured_mesh(u, (nx, ny))
    u_ <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>values  <span style="color: #408080; font-style: italic"># numpy array</span>
    X <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  Y <span style="color: #666666">=</span> <span style="color: #666666">1</span>      <span style="color: #408080; font-style: italic"># for indexing in x and y direction</span>

    <span style="color: #408080; font-style: italic"># Iterate over 2D mesh points (i,j)</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_ is defined on a structured mesh with </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span>
          <span style="color: #666666">%</span> <span style="color: #008000">str</span>(u_<span style="color: #666666">.</span>shape))
    <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">100</span>:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=u(</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                      (i, j,
                       u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][i], u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][j],
                       u_[i,j]))

    <span style="color: #408080; font-style: italic"># Make surface plot</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
    fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
    ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
    cv <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coorv  <span style="color: #408080; font-style: italic"># vectorized mesh coordinates</span>
    ax<span style="color: #666666">.</span>plot_surface(cv[X], cv[Y], u_, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                    rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Surface plot of solution&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp0.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp0.pdf&#39;</span>)

    <span style="color: #408080; font-style: italic"># Make contour plot</span>
    fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
    ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca()
    cs <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>contour(cv[X], cv[Y], u_, <span style="color: #666666">7</span>)  <span style="color: #408080; font-style: italic"># 7 levels</span>
    plt<span style="color: #666666">.</span>clabel(cs)  <span style="color: #408080; font-style: italic"># add labels to contour lines</span>
    plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;equal&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Contour plot of solution&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>)

    <span style="color: #408080; font-style: italic"># Plot u along a line y=const and compare with exact solution</span>
    start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
    x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
    u_e_val <span style="color: #666666">=</span> [u0((x_, y_fixed)) <span style="color: #008000; font-weight: bold">for</span> x_ <span style="color: #AA22FF; font-weight: bold">in</span> x]

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(x, u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
    plt<span style="color: #666666">.</span>plot(x, u_e_val, <span style="color: #BA2121">&#39;bo&#39;</span>)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)

    flux_u <span style="color: #666666">=</span> flux(u, p)
    flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)

    <span style="color: #408080; font-style: italic"># Plot the numerical and exact flux along the same line</span>
    flux2_x <span style="color: #666666">=</span> flux_u_x <span style="color: #008000; font-weight: bold">if</span> flux_u_x<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> \ 
              <span style="color: #008000; font-weight: bold">else</span> interpolate(flux_x,
                   FunctionSpace(u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh(),
                                 <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
    flux_u_x_box <span style="color: #666666">=</span> structured_mesh(flux_u_x, (nx,ny))
    x, flux_u_val, y_fixed, snapped <span style="color: #666666">=</span> \ 
       flux_u_x_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
    y <span style="color: #666666">=</span> y_fixed

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(x, flux_u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
    plt<span style="color: #666666">.</span>plot(x, flux_u_x_exact(x, y_fixed), <span style="color: #BA2121">&#39;bo&#39;</span>)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Flux along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)

    plt<span style="color: #666666">.</span>show()

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_linalg</span>(
    p, f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    assembly<span style="color: #666666">=</span><span style="color: #BA2121">&#39;variational&#39;</span>, <span style="color: #408080; font-style: italic"># or &#39;matvec&#39; or &#39;system&#39;</span>
    start_vector<span style="color: #666666">=</span><span style="color: #BA2121">&#39;zero&#39;</span>,    <span style="color: #408080; font-style: italic"># or &#39;random&#39;</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -div(p*grad(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u0 (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
    <span style="color: #008000; font-weight: bold">if</span> initial_guess <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;random&#39;</span>:
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
        np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)  <span style="color: #408080; font-style: italic"># for testing</span>
        U[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">-100</span>, <span style="color: #666666">100</span>, n)

    <span style="color: #008000; font-weight: bold">if</span> assembly <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;variational&#39;</span>:
        <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
            prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
            prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
            prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
            prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
            prm[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
            <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
            set_log_level(log_level)
            <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
                info(parameters, <span style="color: #008000">True</span>)
            solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                                 <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
        <span style="color: #008000; font-weight: bold">else</span>:
            solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

        solve(a <span style="color: #666666">==</span> L, u, bc, solver_parameters<span style="color: #666666">=</span>solver_parameters)
        A <span style="color: #666666">=</span> <span style="color: #008000">None</span> <span style="color: #408080; font-style: italic"># Cannot return cofficient matrix</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">if</span> assembly <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;matvec&#39;</span>:
            A <span style="color: #666666">=</span> assemble(a)
            b <span style="color: #666666">=</span> assemble(L)
            bc<span style="color: #666666">.</span>apply(A, b)
            <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;direct&#39;</span>:
                solve(A, U, b)
            <span style="color: #008000; font-weight: bold">else</span>:
                solver <span style="color: #666666">=</span> KrylovSolver(<span style="color: #BA2121">&#39;gmres&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
                prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters
                prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
                prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
                prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
                prm[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
                solver<span style="color: #666666">.</span>solve(A, U, b)
        <span style="color: #008000; font-weight: bold">elif</span> assembly <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;system&#39;</span>:
            A, b <span style="color: #666666">=</span> assemble_system(a, L, [bc])
            <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;direct&#39;</span>:
                solve(A, U, b)
            <span style="color: #008000; font-weight: bold">else</span>:
                solver <span style="color: #666666">=</span> KrylovSolver(<span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
                prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters
                prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
                prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
                prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
                prm[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
                solver<span style="color: #666666">.</span>solve(A, U, b)
    <span style="color: #008000; font-weight: bold">return</span> u, A

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_linalg</span>():
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    p <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
    meshes <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">8</span>, <span style="color: #666666">32</span>, <span style="color: #666666">128</span>]
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> meshes:
        <span style="color: #008000; font-weight: bold">for</span> assembly <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;variational&#39;</span>, <span style="color: #BA2121">&#39;matvec&#39;</span>, <span style="color: #BA2121">&#39;system&#39;</span>:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;--- </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> assembly ---&#39;</span> <span style="color: #666666">%</span> (n, n, assembly))
            u, A <span style="color: #666666">=</span> solver_linalg(
                p, f, u0, n, n, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>,
                assembly<span style="color: #666666">=</span>assembly)
            <span style="color: #008000; font-weight: bold">if</span> A <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">10</span>:
                <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
                np<span style="color: #666666">.</span>set_printoptions(precision<span style="color: #666666">=2</span>)
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> assembly</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> assembly, A<span style="color: #666666">.</span>array())

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_bc</span>(
    p, f,                   <span style="color: #408080; font-style: italic"># Coefficients in the PDE</span>
    boundary_conditions,    <span style="color: #408080; font-style: italic"># Dict of boundary conditions</span>
    Nx, Ny,                 <span style="color: #408080; font-style: italic"># Cell division of the domain</span>
    degree<span style="color: #666666">=1</span>,               <span style="color: #408080; font-style: italic"># Polynomial degree</span>
    subdomains<span style="color: #666666">=</span>[],          <span style="color: #408080; font-style: italic"># List of SubDomain objects in domain</span>
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    debug<span style="color: #666666">=</span><span style="color: #008000">False</span>,
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -div(p*grad(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and Dirichlet, Neumann, or Robin</span>
<span style="color: #BA2121; font-style: italic">    conditions on the boundary. Piecewise constant p over subdomains</span>
<span style="color: #BA2121; font-style: italic">    are also allowed.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)

    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

    <span style="color: #408080; font-style: italic"># Subdomains in the domain?</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    <span style="color: #008000; font-weight: bold">if</span> subdomains:
        <span style="color: #408080; font-style: italic"># subdomains is list of SubDomain objects,</span>
        <span style="color: #408080; font-style: italic"># p is array of corresponding constant values of p</span>
        <span style="color: #408080; font-style: italic"># in each subdomain</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">isinstance</span>(p, (<span style="color: #008000">list</span>, <span style="color: #008000">tuple</span>, np<span style="color: #666666">.</span>ndarray)):
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">TypeError</span>(
                <span style="color: #BA2121">&#39;p must be array if we have sudomains, not </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span>
                <span style="color: #666666">%</span> <span style="color: #008000">type</span>(p))
        materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
        materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># &quot;the rest&quot;</span>
        <span style="color: #008000; font-weight: bold">for</span> m, subdomain <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(subdomains[<span style="color: #666666">1</span>:], <span style="color: #666666">1</span>):
            subdomain<span style="color: #666666">.</span>mark(materials, m)

        p_values <span style="color: #666666">=</span> p
        V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
        p  <span style="color: #666666">=</span> Function(V0)
        help <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int32)
        p<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>choose(help, p_values)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">isinstance</span>(p, (Expression, Constant)):
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">TypeError</span>(
                <span style="color: #BA2121">&#39;p is type </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, must be Expression or Constant&#39;</span>
                <span style="color: #666666">%</span> <span style="color: #008000">type</span>(p))

    <span style="color: #408080; font-style: italic"># Boundary subdomains</span>
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryY0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryY1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

    <span style="color: #408080; font-style: italic"># Mark boundaries</span>
    boundary_parts <span style="color: #666666">=</span> FacetFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
    boundary_parts<span style="color: #666666">.</span>set_all(<span style="color: #666666">9999</span>)
    bx0 <span style="color: #666666">=</span> BoundaryX0()
    bx1 <span style="color: #666666">=</span> BoundaryX1()
    by0 <span style="color: #666666">=</span> BoundaryY0()
    by1 <span style="color: #666666">=</span> BoundaryY1()
    bx0<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">0</span>)
    bx1<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">1</span>)
    by0<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">2</span>)
    by1<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">3</span>)
    <span style="color: #408080; font-style: italic"># boundary_parts.array() is a numpy array</span>

    ds <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;ds&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>boundary_parts)

    <span style="color: #408080; font-style: italic"># boundary_conditions is a dict of dicts:</span>
    <span style="color: #408080; font-style: italic"># {0: {&#39;Dirichlet&#39;: u0},</span>
    <span style="color: #408080; font-style: italic">#  1: {&#39;Robin&#39;: (r, s)},</span>
    <span style="color: #408080; font-style: italic">#  2: {&#39;Neumann: g}},</span>
    <span style="color: #408080; font-style: italic">#  3: {&#39;Neumann&#39;, 0}}</span>

    bcs <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># List of Dirichlet conditions</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Dirichlet&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
            bcs<span style="color: #666666">.</span>append(
                DirichletBC(V, boundary_conditions[n][<span style="color: #BA2121">&#39;Dirichlet&#39;</span>],
                            boundary_parts, n))

    <span style="color: #008000; font-weight: bold">if</span> debug:
        <span style="color: #408080; font-style: italic"># Print the vertices that are on the boundaries</span>
        coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
        <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> coor:
            <span style="color: #008000; font-weight: bold">if</span> bx0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=0&#39;</span> <span style="color: #666666">%</span> x)
            <span style="color: #008000; font-weight: bold">if</span> bx1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=1&#39;</span> <span style="color: #666666">%</span> x)
            <span style="color: #008000; font-weight: bold">if</span> by0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=0&#39;</span> <span style="color: #666666">%</span> x)
            <span style="color: #008000; font-weight: bold">if</span> by1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=1&#39;</span> <span style="color: #666666">%</span> x)


        <span style="color: #408080; font-style: italic"># Print the Dirichlet conditions</span>
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;No of Dirichlet conditions:&#39;</span>, <span style="color: #008000">len</span>(bcs))
        d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
        <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
            bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
            <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof]))
                <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
                    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;   at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                          (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))

    <span style="color: #408080; font-style: italic"># Collect Neumann integrals</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)

    Neumann_integrals <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Neumann&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
            <span style="color: #008000; font-weight: bold">if</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>] <span style="color: #666666">!=</span> <span style="color: #666666">0</span>:
                g <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>]
                Neumann_integrals<span style="color: #666666">.</span>append(g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))

    <span style="color: #408080; font-style: italic"># Collect Robin integrals</span>
    Robin_a_integrals <span style="color: #666666">=</span> []
    Robin_L_integrals <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
            r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
            Robin_a_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
            Robin_L_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))

    <span style="color: #408080; font-style: italic"># Simpler Robin integrals</span>
    Robin_integrals <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
            r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
            Robin_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>(u<span style="color: #666666">-</span>s)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))

    <span style="color: #408080; font-style: italic"># Define variational problem, solver_bc</span>
    a <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
        <span style="color: #008000">sum</span>(Robin_a_integrals)
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> <span style="color: #008000">sum</span>(Neumann_integrals) <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Robin_L_integrals)

    <span style="color: #408080; font-style: italic"># Simpler variational formulation</span>
    F <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
        <span style="color: #008000">sum</span>(Robin_integrals) <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Neumann_integrals)
    a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solve(a <span style="color: #666666">==</span> L, u, bcs, solver_parameters<span style="color: #666666">=</span>solver_parameters)
    <span style="color: #008000; font-weight: bold">return</span> u, p  <span style="color: #408080; font-style: italic"># Note: p may be modified (Function on V0)</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_bc_test</span>():
    <span style="color: #408080; font-style: italic"># Define manufactured solution in sympy and derive f, g, etc.</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)  <span style="color: #408080; font-style: italic"># UFL needs x[0] for x etc.</span>
    u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x, <span style="color: #666666">2</span>) <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(u, y, <span style="color: #666666">2</span>)  <span style="color: #408080; font-style: italic"># -Laplace(u)</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
    u_00 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># x=0 boundary</span>
    u_01 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary</span>
    g <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, y)<span style="color: #666666">.</span>subs(y, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary, du/dn=-du/dy</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">1000</span> <span style="color: #408080; font-style: italic"># any function can go here</span>
    s <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Turn to C/C++ code for UFL expressions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
    u_00 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_00)
    u_01 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_01)
    g <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(g)
    r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(r)
    s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(s)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Test problem (C/C++):</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">f = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u, f))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_00: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u_01: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">g = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">r = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">s = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
          (u_00, u_01, g, r, s))

    <span style="color: #408080; font-style: italic"># Turn into FEniCS objects</span>
    u_00 <span style="color: #666666">=</span> Expression(u_00)
    u_01 <span style="color: #666666">=</span> Expression(u_01)
    f <span style="color: #666666">=</span> Expression(f)
    g <span style="color: #666666">=</span> Expression(g)
    r <span style="color: #666666">=</span> Expression(r)
    s <span style="color: #666666">=</span> Expression(s)
    u_exact <span style="color: #666666">=</span> Expression(sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u))

    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_00},   <span style="color: #408080; font-style: italic"># x=0</span>
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_01},   <span style="color: #408080; font-style: italic"># x=1</span>
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Robin&#39;</span>: (r, s)},     <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: g}}        <span style="color: #408080; font-style: italic"># y=1</span>

    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    u, p <span style="color: #666666">=</span> solver_bc(
        p, f, boundary_conditions, Nx, Ny, degree<span style="color: #666666">=1</span>,
        linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>,
        debug<span style="color: #666666">=2*</span>Nx<span style="color: #666666">*</span>Ny <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>,  <span style="color: #408080; font-style: italic"># for small problems only</span>
        )

    <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                       u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Max error:&#39;</span>, max_error)

    <span style="color: #408080; font-style: italic"># Print numerical and exact solution at the vertices</span>
    <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>:  <span style="color: #408080; font-style: italic"># (small problems only)</span>
        u_e_at_vertices <span style="color: #666666">=</span> u_e<span style="color: #666666">.</span>compute_vertex_values()
        u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
        coor <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
        <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">): error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> vs </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span>
                  <span style="color: #666666">%</span> (i, x[<span style="color: #666666">0</span>], x[<span style="color: #666666">1</span>],
                     u_e_at_vertices[i] <span style="color: #666666">-</span> u_at_vertices[i],
                     u_e_at_vertices[i], u_at_vertices[i]))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solvers_bc</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to with different solvers.&quot;&quot;&quot;</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">3E-12</span>  <span style="color: #408080; font-style: italic"># Appropriate tolerance for these tests (P2, 20x20 mesh)</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
    u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x, <span style="color: #666666">2</span>) <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(u, y, <span style="color: #666666">2</span>)
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
    u_00 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># x=0 boundary</span>
    u_01 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary</span>
    g <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, y)<span style="color: #666666">.</span>subs(y, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">1000</span> <span style="color: #408080; font-style: italic"># arbitrary function can go here</span>
    s <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Turn to C/C++ code for UFL expressions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
    u_00 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_00)
    u_01 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_01)
    g <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(g)
    r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(r)
    s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(s)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Test problem (C/C++):</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">f = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u, f))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_00: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u_01: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">g = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">r = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">s = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
          (u_00, u_01, g, r, s))

    <span style="color: #408080; font-style: italic"># Turn into FEniCS objects</span>
    u_00 <span style="color: #666666">=</span> Expression(u_00)
    u_01 <span style="color: #666666">=</span> Expression(u_01)
    f <span style="color: #666666">=</span> Expression(f)
    g <span style="color: #666666">=</span> Expression(g)
    r <span style="color: #666666">=</span> Expression(r)
    s <span style="color: #666666">=</span> Expression(s)
    u_exact <span style="color: #666666">=</span> Expression(sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u))

    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_00},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_01},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Robin&#39;</span>: (r, s)},
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: g}}

    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)

    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">3</span>,<span style="color: #666666">5</span>), (<span style="color: #666666">5</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">20</span>,<span style="color: #666666">20</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            <span style="color: #008000; font-weight: bold">for</span> linear_solver <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #BA2121">&#39;direct&#39;</span>]:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x) mesh with P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span>
                      <span style="color: #666666">%</span> (Nx, Ny, degree)),
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39; </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> solver, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> function&#39;</span> <span style="color: #666666">%</span>
                      (linear_solver, solver_func<span style="color: #666666">.</span>__name__))
                u, p <span style="color: #666666">=</span> solver_bc(
                    p, f, boundary_conditions, Nx, Ny, degree,
                linear_solver<span style="color: #666666">=</span>linear_solver,
                    abs_tol<span style="color: #666666">=0.1*</span>tol,
                    rel_tol<span style="color: #666666">=0.1*</span>tol)
                <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u0</span>
                V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
                u_e_Function <span style="color: #666666">=</span> interpolate(u_exact, V)  <span style="color: #408080; font-style: italic"># exact solution</span>
                <span style="color: #408080; font-style: italic"># Check that dof arrays are equal</span>
                u_e_array <span style="color: #666666">=</span> u_e_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
                max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
                msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> for 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh, degree=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,&#39;</span>\ 
                      <span style="color: #BA2121">&#39; </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> solver, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
                      (max_error, Nx, Ny, degree, linear_solver,
                       solver_func<span style="color: #666666">.</span>__name__)
                <span style="color: #008000; font-weight: bold">print</span>(msg)
                <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_bc_test_2mat</span>():
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol

    subdomains <span style="color: #666666">=</span> [Omega0(), Omega1()]
    p_values <span style="color: #666666">=</span> [<span style="color: #666666">2.0</span>, <span style="color: #666666">13.0</span>]

    u_exact <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span style="color: #BA2121">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span>,
        p_0<span style="color: #666666">=</span>p_values[<span style="color: #666666">0</span>], p_1<span style="color: #666666">=</span>p_values[<span style="color: #666666">1</span>])


    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">0</span>)}, <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">1</span>)}, <span style="color: #408080; font-style: italic"># y=1</span>
        }

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    u, p <span style="color: #666666">=</span> solver_bc(
        p_values, f, boundary_conditions, Nx, Ny, degree<span style="color: #666666">=1</span>,
        linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, subdomains<span style="color: #666666">=</span>subdomains,
        debug<span style="color: #666666">=2*</span>Nx<span style="color: #666666">*</span>Ny <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>,  <span style="color: #408080; font-style: italic"># for small problems only</span>
        )

    <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                       u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Max error:&#39;</span>, max_error)

    <span style="color: #408080; font-style: italic"># Print numerical and exact solution at the vertices</span>
    <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim() <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>:  <span style="color: #408080; font-style: italic"># (small problems only)</span>
        u_e_at_vertices <span style="color: #666666">=</span> u_e<span style="color: #666666">.</span>compute_vertex_values()
        u_at_vertices <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
        coor <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()<span style="color: #666666">.</span>coordinates()
        <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coor):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%9g</span><span style="color: #BA2121">): error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> vs </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span>
                  <span style="color: #666666">%</span> (i, x[<span style="color: #666666">0</span>], x[<span style="color: #666666">1</span>],
                     u_e_at_vertices[i] <span style="color: #666666">-</span> u_at_vertices[i],
                     u_e_at_vertices[i], u_at_vertices[i]))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solvers_bc_2mat</span>():
    tol <span style="color: #666666">=</span> <span style="color: #666666">2E-13</span>  <span style="color: #408080; font-style: italic"># Tolerance for comparisons</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol

    subdomains <span style="color: #666666">=</span> [Omega0(), Omega1()]
    p_values <span style="color: #666666">=</span> [<span style="color: #666666">2.0</span>, <span style="color: #666666">13.0</span>]
    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">0</span>)}, <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">1</span>)}, <span style="color: #408080; font-style: italic"># y=1</span>
        }

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_exact <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span style="color: #BA2121">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span>,
        p_0<span style="color: #666666">=</span>p_values[<span style="color: #666666">0</span>], p_1<span style="color: #666666">=</span>p_values[<span style="color: #666666">1</span>])

    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), (<span style="color: #666666">2</span>,<span style="color: #666666">4</span>), (<span style="color: #666666">8</span>,<span style="color: #666666">4</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            u, p <span style="color: #666666">=</span> solver_bc(
                p_values, f, boundary_conditions, Nx, Ny, degree,
                linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, subdomains<span style="color: #666666">=</span>subdomains,
                debug<span style="color: #666666">=</span><span style="color: #008000">False</span>)

            <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
            u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
            <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
            max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                           u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> max_error

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_flow_around_circle</span>(obstacle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;rectangle&#39;</span>):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Circle</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> ((x[<span style="color: #666666">0</span>]<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (x[<span style="color: #666666">1</span>]<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>) <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.2**2</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Rectangle</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.3</span> <span style="color: #666666">&lt;=</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.7</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #666666">0.3</span> <span style="color: #666666">&lt;=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.7</span>

    obstacle <span style="color: #666666">=</span> Circle() <span style="color: #008000; font-weight: bold">if</span> obstacle <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;circle&#39;</span> <span style="color: #008000; font-weight: bold">else</span> Rectangle()
    subdomains <span style="color: #666666">=</span> [<span style="color: #008000">None</span>, obstacle]
    p_values <span style="color: #666666">=</span> [<span style="color: #666666">1.0</span>, <span style="color: #666666">1E-4</span>]

    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">1</span>)}, <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">0</span>)}, <span style="color: #408080; font-style: italic"># y=1</span>
        }

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">50</span>
    u, p <span style="color: #666666">=</span> solver_bc(
        p_values, f, boundary_conditions, Nx, Ny, degree<span style="color: #666666">=1</span>,
        linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, subdomains<span style="color: #666666">=</span>subdomains)

    v <span style="color: #666666">=</span> flux(u, p)
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;porous_media_flow.pvd&#39;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> v
    plot(u)
    plot(v)

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #408080; font-style: italic">#application_test()</span>
    <span style="color: #408080; font-style: italic">#application_test_flux(Nx=20, Ny=20)</span>
    <span style="color: #408080; font-style: italic">#convergence_rate()</span>
    <span style="color: #408080; font-style: italic">#application_structured_mesh(2)</span>
    <span style="color: #408080; font-style: italic">#application_linalg()</span>
    <span style="color: #408080; font-style: italic">#application_bc_test_2mat()</span>
    application_flow_around_circle()
    <span style="color: #408080; font-style: italic">#test_solvers_bc()</span>
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>
<p>
Plotting the flux vector field is naturally as easy as plotting
the gradient (see the section <a href="#ch:poisson0:gradu">Computing derivatives</a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(flux, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;flux field&#39;</span>)

flux_x, flux_y <span style="color: #666666">=</span> flux<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)  <span style="color: #408080; font-style: italic"># extract components</span>
plot(flux_x, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x-component of flux (-p*grad(u))&#39;</span>)
plot(flux_y, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y-component of flux (-p*grad(u))&#39;</span>)
</pre></div>
<p>
For data analysis of the nodal values of the flux field we can
grab the underlying <code>numpy</code> arrays (demands a <code>deepcopy=True</code>
in the split of <code>flux</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_x_array <span style="color: #666666">=</span> flux_x<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
flux_y_array <span style="color: #666666">=</span> flux_y<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
The function <code>application_test_flux</code> in the
program <code>ft06_poisson_vc.py</code> demonstrates the computations described
above.

<h2 id="ch:poisson0:linalg">Creating the linear system explicitly</h2>

<p>
Given \( a(u,v)=L(v) \), the discrete solution \( u \) is computed by
inserting \( u=\sum_{j=1}^N U_j \phi_j \) into \( a(u,v) \) and demanding
\( a(u,v)=L(v) \) to be fulfilled for \( N \) test functions
\( \hat\phi_1,\ldots,\hat\phi_N \). This implies

$$
\begin{equation*}
\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,
\end{equation*}
$$

which is nothing but a linear system,

$$
\begin{equation*}
  AU = b,
\end{equation*}
$$

where the entries in \( A \) and \( b \) are given by

$$
\begin{align*}
  A_{ij} &= a(\phi_j, \hat{\phi}_i), \\ 
  b_i &= L(\hat\phi_i)\tp
\end{align*}
$$

<p>
The examples so far have specified the left- and right-hand side of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it.  An alternative is to explicitly call
functions for assembling the coefficient matrix \( A \) and the right-side
vector \( b \), and then solve the linear system \( AU=b \) with respect to
the \( U \) vector.  Instead of <code>solve(a == L, u, b)</code> we now write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
bc<span style="color: #666666">.</span>apply(A, b)
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
solve(A, U, b)
</pre></div>
<p>
The variables <code>a</code> and <code>L</code> are as before. That is, <code>a</code> refers to the
bilinear form involving a <code>TrialFunction</code> object (e.g., <code>u</code>)
and a <code>TestFunction</code> object (<code>v</code>), and <code>L</code> involves a
<code>TestFunction</code> object (<code>v</code>). From <code>a</code> and <code>L</code>,
the <code>assemble</code> function can
compute \( A \) and \( b \).

<p>
The matrix \( A \) and vector \( b \) are first assembled without incorporating
essential (Dirichlet) boundary conditions. Thereafter, the
call <code>bc.apply(A, b)</code> performs the necessary modifications of
the linear system such that <code>u</code> is guaranteed to equal the prescribed
boundary values.
When we have multiple Dirichlet conditions stored in a list <code>bcs</code>,
as explained in the section <a href="._ftut012.html#ch:poisson0:multiple:Dirichlet">Multiple Dirichlet conditions</a>, we must apply
each condition in <code>bcs</code> to the system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># bcs is a list of DirichletBC objects</span>
<span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc<span style="color: #666666">.</span>apply(A, b)
</pre></div>
<p>
There is an alternative function <code>assemble_system</code>, which can
assemble the system and take boundary conditions into account in one call:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A, b <span style="color: #666666">=</span> assemble_system(a, L, bcs)
</pre></div>
<p>
The <code>assemble_system</code> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.
The conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.
<!-- That is, for each degree of freedom -->
<!-- that is known, the corresponding row and column is zero'ed out and 1 -->
<!-- is placed on the main diagonal, and the right-hand side <code>b</code> is -->
<!-- modified by subtracting the column in <code>A</code> times the value of the -->
<!-- degree of, and then the corresponding entry in <code>b</code> is replaced by the -->
<!-- known value of the degree of freedom. -->
With <code>bc.apply(A, b)</code> the
matrix <code>A</code> is modified in an nonsymmetric way.
<!-- : The row is zero'ed out -->
<!-- and 1 is placed on the main diagonal, and the degree of freedom value -->
<!-- is inserted in <code>b</code>. -->

<p>
Note that the solution <code>u</code> is, as before, a <code>Function</code> object.
The degrees of freedom, \( U=A^{-1}b \), are filled
into <code>u</code>'s <code>Vector</code> object (<code>u.vector()</code>)
by the <code>solve</code> function.

<p>
The object <code>A</code> is of type <code>Matrix</code>, while <code>b</code> and
<code>u.vector()</code> are of type <code>Vector</code>. We may convert the
matrix and vector data to <code>numpy</code> arrays by calling the
<code>array()</code> method as shown before. If you wonder how essential
boundary conditions are incorporated in the linear system, you can
print out <code>A</code> and <code>b</code> before and after the
<code>bc.apply(A, b)</code> call:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>:  <span style="color: #408080; font-style: italic"># print for small meshes only</span>
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
bc<span style="color: #666666">.</span>apply(A, b)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>:
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
</pre></div>
<p>
With access to the elements in <code>A</code> through a <code>numpy</code> array we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code>eig</code> function in <code>numpy.linalg</code>). We can alternatively dump
<code>A.array()</code> and <code>b.array()</code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.io</span>
scipy<span style="color: #666666">.</span>io<span style="color: #666666">.</span>savemat(<span style="color: #BA2121">&#39;Ab.mat&#39;</span>, {<span style="color: #BA2121">&#39;A&#39;</span>: A<span style="color: #666666">.</span>array(), <span style="color: #BA2121">&#39;b&#39;</span>: b<span style="color: #666666">.</span>array()})
</pre></div>
<p>
Writing <code>load Ab.mat</code> in MATLAB or Octave will then make
the array variables <code>A</code> and <code>b</code> available for computations.

<p>
Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code>numpy</code> arrays or matrices in MATLAB
file format are dense matrices. FEniCS also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <code>demo/la/eigenvalue</code> in the FEniCS source code tree
for a demo).

<p>
By default, <code>solve(A, U, b)</code> applies sparse LU decomposition
as solver. Specification of an iterative solver and preconditioner
is done through two optional arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solve(A, U, b, <span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
</pre></div>
<p>
Appropriate names of solvers and preconditioners are found in
the section <a href="._ftut018.html#ftut:app:solver:prec">Linear solvers and preconditioners</a>.

<p>
To control tolerances in the stopping criterion and the maximum
number of iterations, one can explicitly form a <code>KrylovSolver</code> object
and set items in its <code>parameters</code> attribute
(see also the section <a href="#ch:poisson0:solver:problem">Linear variational problem and solver objects</a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solver <span style="color: #666666">=</span> KrylovSolver(<span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
set_log_level(DEBUG)
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
The function <code>solver_linalg</code> in the
program file <code>ft06_poisson_vc.py</code> implements a solver function where
the user can choose between different types of assembly: the variational
(<code>solve(a == L, u, bc)</code>), assembling the matrix and right-hand side separately, and assembling the system such that the coefficient matrix preserves
symmetry.
The function <code>application_linalg</code> runs a test problem on sequence of
meshes and solves the problem with symmetric and non-symmetric modification
of the coefficient matrix. One can monitor the number of Krylov
method iteration and realize that with a symmetric coefficient matrix,
the Conjugate Gradient method requires slightly fewer iterations than
GMRES in the non-symmetric case. Taking into account that the Conjugate
Gradient method has less work per iteration, there is some efficiency to
be gained by using <code>assemble_system</code>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 13</b>: Running <code>application_linalg</code>, the results are strange: Why does the <code>solve(a==L,...)</code> method need many more iterations than <code>solve(A, U, b, ...)</code> when we use the same Krylov parameter settings? Something wrong with the settings?)</font>
<!-- end inline comment -->

<p>
The choice of start vector for the iterations in a linear solver is often
important. With the <code>solver.solve(A, U, b)</code> call the default start vector
is the zero vector. A start vector
with random numbers in the interval \( [-100,100] \) can be computed as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>size
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
U[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">-100</span>, <span style="color: #666666">100</span>, n)
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
Note that we must turn off the default behavior of setting the start
vector (&quot;initial guess&quot;) to zero, and then the provided value of <code>U</code>
is used as start vector.

<p>
Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, \( A \) may
be constant throughout a time-dependent simulation, so we can avoid
recalculating \( A \) at every time level and save a significant amount
of simulation time.
<!-- the sections <a href="._ftut008.html#ftut:timedep:diffusion1:impl">A simple implementation</a> -->
<!-- and <a href="._ftut013.html#ch:diffusion:opt:noassembly">Avoiding all assembly</a> deal with this topic -->
<!-- in detail. -->

<p>
<!-- In other problems, we may divide the variational -->
<!-- problem and linear system into different terms, say \( A=M + {\dt} K \), -->
<!-- where \( M \) is a matrix arising from a term like \( \partial u/\partial t \), -->
<!-- \( K \) is a term corresponding to a Laplace operator, and \( \dt \) is -->
<!-- a time discretization parameter. When \( \dt \) is changed in time, -->
<!-- we can efficiently recompute \( A = M + {\dt} K \) without -->
<!-- reassembling the constant matrices \( M \) and \( K \). This strategy may -->
<!-- speed up simulations significantly. -->

<h2 id="ftut:structviz">Taking advantage of structured mesh data</h2>

<p>
When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.

<p>
A necessary first step is to transform our <code>mesh</code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
second step is to transform the one-dimensional array of nodal values
to a two-dimensional array holding the values at the corners of the
cells in the structured mesh. We want to access a value by its \( i \) and
\( j \) indices, \( i \) counting cells in the \( x \) direction, and \( j \) counting
cells in the \( y \) direction.  This transformation is in principle
straightforward, yet it frequently leads to obscure indexing errors,
so using software tools to ease the work is advantageous.

<p>
In the directory <code>src/modules</code>, associated with this booklet, we have
included a Python module <code>BoxField</code> that can take a finite element
function <code>u</code> computed by a FEniCS software and represent it on a
structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code>[i]</code> in 1D, <code>[i,j]</code> in 2D, and <code>[i,j,k]</code>
in 3D. Given a finite element function <code>u</code>, the following function
returns a <code>BoxField</code> object that represents <code>u</code> on a structured mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">structured_mesh</span>(u, divisions):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    u2 <span style="color: #666666">=</span> u <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
         interpolate(u, FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
    mesh <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">BoxField</span> <span style="color: #008000; font-weight: bold">import</span> fenics_function2BoxField
    u_box <span style="color: #666666">=</span> fenics_function2BoxField(
        u2, mesh, divisions, uniform_mesh<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u_box
</pre></div>
<p>
Note that we can only turn functions on meshes with P1 elements into
<code>BoxField</code> objects, so if <code>u</code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code>divisions</code>).

<p>
The <code>u_box</code> object contains several useful data structures:

<ul>
 <li> <code>u_box.grid</code>: object for the structured mesh</li>
 <li> <code>u_box.grid.coor[X]</code>: grid coordinates in <code>X=0</code> direction</li>
 <li> <code>u_box.grid.coor[Y]</code>: grid coordinates in <code>Y=1</code> direction</li>
 <li> <code>u_box.grid.coor[Z]</code>: grid coordinates in <code>Z=2</code> direction</li>
 <li> <code>u_box.grid.coorv[X]</code>: vectorized version of <code>u_box.grid.coor[X]</code>
   (for vectorized computations or surface plotting)</li>
 <li> <code>u_box.grid.coorv[Y]</code>: vectorized version of <code>u_box.grid.coor[Y]</code></li>
 <li> <code>u_box.grid.coorv[Z]</code>: vectorized version of <code>u_box.grid.coor[Z]</code></li>
 <li> <code>u_box.values</code>: <code>numpy</code> array holding the <code>u</code> values;
   <code>u_box.values[i,j]</code> holds <code>u</code> at the mesh point with coordinates <br />
   <code>(u_box.grid.coor[X], u_box.grid.coor[Y])</code></li>
</ul>

<h3 id="___sec97">Iterating over points and values </h3>

<p>
Let us go back to the <code>solver</code> function in the
<code>ft06_poisson_vc.py</code> code from
the section <a href="#ftut:possion:2D:varcoeff">A variable-coefficient Poisson problem</a>, compute <code>u</code>, map it onto a
<code>BoxField</code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> solver(p, f, u0, nx, ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
u_box <span style="color: #666666">=</span> structured_mesh(u, (nx, ny))
u_ <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>values       <span style="color: #408080; font-style: italic"># numpy array</span>
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  Y <span style="color: #666666">=</span> <span style="color: #666666">1</span>           <span style="color: #408080; font-style: italic"># for indexing in x and y direction</span>

<span style="color: #408080; font-style: italic"># Iterate over 2D mesh points (i,j)</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_ is defined on a structured mesh with </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
      <span style="color: #008000">str</span>(u_<span style="color: #666666">.</span>shape))
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=u(</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (i, j,
               u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][i], u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][j],
               u_[i,j]))
</pre></div>

<h3 id="___sec98">Finite difference approximations </h3>

<p>
Note that with <code>u_</code>, we can easily express finite difference approximation
of derivatives:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X]
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
u_xx <span style="color: #666666">=</span> (u_[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_[i,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">+1</span>,j])<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
</pre></div>

<h3 id="___sec99">Surface plot </h3>

<p>
The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a href="#ftut:structviz:fig1">9</a> (upper left):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
cv <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coorv  <span style="color: #408080; font-style: italic"># vectorized mesh coordinates</span>
ax<span style="color: #666666">.</span>plot_surface(cv[X], cv[Y], u_, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Surface plot of solution&#39;</span>)
</pre></div>
<p>
The key issue is to know that the coordinates needed for the surface
plot is in <code>u_box.grid.coorv</code> and that the values are in <code>u_</code>.

<p>
<center> <!-- figure label: --> <div id="ftut:structviz:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  Various plots of the solution on a structured mesh.  <!-- caption label: ftut:structviz:fig1 --> </p></center>
<p><img src="fig/poisson_vc_structmesh2.png" align="bottom" width=800></p>
</center>

<h3 id="___sec100">Contour plot </h3>

<p>
A contour plot can also be made by Matplotlib:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca()
levels <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">2.0</span>, <span style="color: #666666">2.5</span>, <span style="color: #666666">3.5</span>]
cs <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>contour(cv[X], cv[Y], u_, levels<span style="color: #666666">=</span>levels)
plt<span style="color: #666666">.</span>clabel(cs)  <span style="color: #408080; font-style: italic"># add labels to contour lines</span>
plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;equal&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Contour plot of solution&#39;</span>)
</pre></div>
<p>
The result appears in Figure <a href="#ftut:structviz:fig1">9</a> (upper right).

<h3 id="___sec101">Curve plot through the mesh </h3>

<p>
A handy feature of <code>BoxField</code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot \( u \) along
the line \( y=0.4 \). The mesh points, <code>x</code>, and the \( u \) values
along this line, <code>u_val</code>, are extracted by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
</pre></div>
<p>
The variable <code>snapped</code> is true if the line had to be snapped onto a
gridline and in that case <code>y_fixed</code> holds the snapped
(altered) \( y \) value. To avoid interpolation in the structured mesh,
<code>snapped</code> is in fact <em>always</em> true.

<p>
A comparison of the numerical and exact solution along the line
\( y=0.5 \) (snapped from \( y=0.4 \)) is made by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
u_e_val <span style="color: #666666">=</span> [u0((x_, y_fixed)) <span style="color: #008000; font-weight: bold">for</span> x_ <span style="color: #AA22FF; font-weight: bold">in</span> x]

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, u_e_val, <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
See Figure <a href="#ftut:structviz:fig1">9</a> (lower left) for the resulting curve plot.

<h3 id="___sec102">Curve plot of the flux </h3>

<p>
Let us also compare the numerical and
exact flux \( -p\partial u/\partial x \) along the same line as above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u <span style="color: #666666">=</span> flux(u, p)
flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)

<span style="color: #408080; font-style: italic"># Plot the numerical and exact flux along the same line</span>
flux2_x <span style="color: #666666">=</span> flux_u_x <span style="color: #008000; font-weight: bold">if</span> flux_u_x<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> \ 
          <span style="color: #008000; font-weight: bold">else</span> interpolate(flux_x,
               FunctionSpace(u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh(),
                             <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
flux_u_x_box <span style="color: #666666">=</span> structured_mesh(flux_u_x, (nx,ny))
x, flux_u_val, y_fixed, snapped <span style="color: #666666">=</span> \ 
   flux_u_x_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
y <span style="color: #666666">=</span> y_fixed

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, flux_u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, flux_u_x_exact(x, y_fixed), <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Flux along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
The second <code>plt.plot</code> command
requires a Python function <code>flux_u_x_exact(x,y)</code> to be
available for the exact flux expression.

<p>
Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a href="https://github.com/hplgit/scitools" target="_self">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.

<h3 id="___sec103">Test problem </h3>

<p>
The graphics referred to in Figure <a href="#ftut:structviz:fig1">9</a> correspond to
a test problem with prescribed solution \( \uex = H(x)H(y) \), where

$$ H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x)\tp$$

We just fit a function \( f(x,y) \) in the PDE (can choose \( p=1 \)),
and notice that \( u=0 \) along the
boundary of the unit square. Although it is easy to carry out the
differentiation of \( f \) by hand and hardcode the resulting expressions
in an <code>Expression</code> object, a more reliable habit is to use Python's
symbolic computing engine, SymPy, to perform mathematics and
automatically turn formulas into C++ syntax for <code>Expression</code> objects.
A short introduction was given in the section <a href="._ftut008.html#ftut:nonlinear:Newton:auto">A simple implementation</a>.

<p>
We start out with defining the exact solution in <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, pi  <span style="color: #408080; font-style: italic"># for use in math formulas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
H <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: exp(<span style="color: #666666">-16*</span>(x<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>sin(<span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>x)
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0], x[1]&#39;</span>)
u <span style="color: #666666">=</span> H(x)<span style="color: #666666">*</span>H(y)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to be have valid syntax for
<code>Expression</code> objects, and then \( x \) reads <code>x[0]</code> and \( y \) must be <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expression for <code>u</code> into C or C++ syntax for <code>Expression</code> objects
needs two steps. First we ask for the C code of the expression,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
</pre></div>
<p>
Printing out <code>u_c</code> gives (the output is here manually broken into two
lines):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
<p>
The necessary syntax adjustment is replacing
the symbol <code>M_PI</code> for \( \pi \) in C/C++ by <code>pi</code> (or <code>DOLFIN_PI</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> u_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
u0 <span style="color: #666666">=</span> Expression(u_c)
</pre></div>
<p>
Thereafter, we can progress with the computation of \( f = -\nabla\cdot(p\nabla u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">+</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
f_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
f_c <span style="color: #666666">=</span> f_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
f <span style="color: #666666">=</span> Expression(f_c)
</pre></div>
<p>
We also need a Python function for the exact flux \( -p\partial u/\partial x \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u_x_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y], <span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x),
                              modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
</pre></div>
<p>
It remains to define <code>p = Constant(1)</code> and set <code>nx</code> and <code>ny</code> before calling
<code>solver</code> to compute the finite element solution of this problem.

<p>
<!-- FIGURE: [fig/poisson_vc_structmesh, width=800 frac=1] Various plots of the solution on a structured mesh. <div id="ftut:structviz:fig1a"></div> -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut009.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li><a href="._ftut009.html">10</a></li>
  <li class="active"><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="._ftut015.html">16</a></li>
  <li><a href="._ftut016.html">17</a></li>
  <li><a href="._ftut017.html">18</a></li>
  <li><a href="._ftut018.html">19</a></li>
  <li><a href="._ftut019.html">20</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut021.html">22</a></li>
  <li><a href="._ftut011.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

