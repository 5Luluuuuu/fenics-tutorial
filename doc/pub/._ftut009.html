<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,time-dependent PDEs,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),visualization,plotting,VTK,rotate PDF plots,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,assembly, increasing efficiency,heterogeneous medium,multi-material domain,nonlinear variational problems,Gateaux derivative,automatic differentiation,Jacobian, automatic computation,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,troubleshooting,compilation problems,plotting problems">

<title>Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'tut:pybooks', u'tut:pybooks'),
              (u'The finite element method',
               2,
               u'tut:fembooks',
               u'tut:fembooks'),
              (u'Fundamentals', 0, u'ch:fundamentals', u'ch:fundamentals'),
              (u'The Poisson equation', 1, None, '___sec14'),
              (u'Mathematical problem formulation',
               2,
               u'tut:poisson1:bvp',
               u'tut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'tut:poisson1:abstrat',
               u'tut:poisson1:abstrat'),
              (u'Choosing a test problem',
               2,
               u'tut:poisson1:testproblem',
               u'tut:poisson1:testproblem'),
              (u'FEniCS implementation',
               2,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'Running the program',
               2,
               u'tut:poisson1:impl:run',
               u'tut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'tut:poisson1:impl:dissect',
               u'tut:poisson1:impl:dissect'),
              (u'The important first line', 3, None, '___sec22'),
              (u'Generating simple meshes', 3, None, '___sec23'),
              (u'Defining the finite element function space',
               3,
               None,
               '___sec24'),
              (u'Defining the trial and test functions', 3, None, '___sec25'),
              (u'Defining the boundary and the boundary conditions',
               3,
               None,
               '___sec26'),
              (u'Defining the source term', 3, None, '___sec27'),
              (u'Defining the variational problem', 3, None, '___sec28'),
              (u'Forming and solving the linear system', 3, None, '___sec29'),
              (u'Examining the values of the solution', 3, None, '___sec30'),
              (u'Plotting the solution', 3, None, '___sec31'),
              (u'Deflection of a membrane',
               2,
               u'ftut:poisson:membrane',
               u'ftut:poisson:membrane'),
              (u'Generating the mesh', 3, None, '___sec33'),
              (u'The expression for the load', 3, None, '___sec34'),
              (u'Variational form', 3, None, '___sec35'),
              (u'Visualization', 3, None, '___sec36'),
              (u'The time-dependent diffusion equation',
               1,
               u'tut:timedep',
               u'tut:timedep'),
              (u'Variational formulation',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'A simple implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec40'),
              (u'The code', 3, None, '___sec41'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec42'),
              (u'A nonlinear Poisson equation', 1, None, '___sec43'),
              (u'Variational formulation', 2, None, '___sec44'),
              (u'A simple implementation',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Overview', 3, None, '___sec46'),
              (u'Constructing a test problem with SymPy',
               3,
               None,
               '___sec47'),
              (u'The equations of linear elasticity',
               1,
               u'tut:elast',
               u'tut:elast'),
              (u'Variational formulation',
               2,
               u'tut:elast:varform',
               u'tut:elast:varform'),
              (u'A simple implementation', 2, None, '___sec50'),
              (u'Test problem', 3, None, '___sec51'),
              (u'Code', 3, None, '___sec52'),
              (u'The Navier--Stokes equations', 1, None, '___sec53'),
              (u'Variational formulation', 2, None, '___sec54'),
              (u'A simple implementation', 2, None, '___sec55'),
              (u'The Poisson solver revisited',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'tut:poisson1:impl2',
               u'tut:poisson1:impl2'),
              (u'A general solver function', 2, None, '___sec58'),
              (u'Plotting for the test problem', 3, None, '___sec59'),
              (u'Make a module!', 3, None, '___sec60'),
              (u'Verification and unit tests', 2, None, '___sec61'),
              (u'Exercise 1: Solve a Poisson problem', 2, None, '___sec62'),
              (u'Remarks', 3, None, '___sec63'),
              (u'Useful extensions', 1, None, '___sec64'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec66'),
              (u'Linear algebra backend', 3, None, '___sec67'),
              (u'The `parameters` database', 3, None, '___sec68'),
              (u'An extended solver function', 3, None, '___sec69'),
              (u'Remark regarding unit tests', 3, None, '___sec70'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Generating a hypercube', 3, None, '___sec74'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec77'),
              (u'Modifications of the PDE solver', 3, None, '___sec78'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec79'),
              (u'Creating the linear system explicitly',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Visualization', 1, None, '___sec81'),
              (u'Deflection of a circular membrane',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'The problem', 3, None, '___sec83'),
              (u'Scaling', 3, None, '___sec84'),
              (u'Implementation', 3, None, '___sec85'),
              (u'Test problem', 3, None, '___sec86'),
              (u'Visualization in FEniCS',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'Visualization in ParaView',
               2,
               u'tut:paraview',
               u'tut:paraview'),
              (u'Exercise 2: Visualize a solution in a cube',
               2,
               None,
               '___sec89'),
              (u'Taking advantage of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec91'),
              (u'Finite difference approximations', 3, None, '___sec92'),
              (u'Surface plot', 3, None, '___sec93'),
              (u'Contour plot', 3, None, '___sec94'),
              (u'Curve plot through the mesh', 3, None, '___sec95'),
              (u'Curve plot of the flux', 3, None, '___sec96'),
              (u'Test problem', 3, None, '___sec97'),
              (u'Postprocessing computations', 1, None, '___sec98'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec100'),
              (u'Error functional', 3, None, '___sec101'),
              (u'Flux Functionals', 3, None, '___sec102'),
              (u'Computing convergence rates',
               2,
               u'tut:poisson1:convrates',
               u'tut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec104'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec105'),
              (u'Test problem', 3, None, '___sec106'),
              (u'Experiments', 3, None, '___sec107'),
              (u'Multiple domains and boundaries', 1, None, '___sec108'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'PDE problem', 3, None, '___sec110'),
              (u'Variational formulation', 3, None, '___sec111'),
              (u'Implementation', 3, None, '___sec112'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec114'),
              (u'Working with subdomains',
               2,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec116'),
              (u'Mesh functions', 3, None, '___sec117'),
              (u'C++ strings for subdomain definitions',
               3,
               None,
               '___sec118'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ftut:poisson:exer:eff:expression',
               u'ftut:poisson:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:multi:bc',
               u'tut:poisson:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec121'),
              (u'A general model problem', 3, None, '___sec122'),
              (u'Variational formulation', 3, None, '___sec123'),
              (u'Implementation of boundary conditions',
               3,
               None,
               '___sec124'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec125'),
              (u'Test problem', 3, None, '___sec126'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec127'),
              (u'Implementation of multiple subdomains',
               3,
               None,
               '___sec128'),
              (u'Refactoring of a solver function into solver and problem classes',
               2,
               None,
               '___sec129'),
              (u'The diffusion solver revisited',
               0,
               u'ch:diffusion',
               u'ch:diffusion'),
              (u'Optimization of algorithms and implementations',
               1,
               None,
               '___sec131'),
              (u'Avoiding some assembly', 2, None, '___sec132'),
              (u'Avoiding all assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'Deriving recursive linear systems', 3, None, '___sec134'),
              (u'Implementation', 3, None, '___sec135'),
              (u'Refactored implementation', 1, None, '___sec136'),
              (u'A class-based solver for a general diffusion problem',
               2,
               None,
               '___sec137'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'The nonlinear Poisson solver revisited',
               0,
               u'tut:nonlinear',
               u'tut:nonlinear'),
              (u'Test problem', 3, None, '___sec140'),
              (u'The built-in automated Newton solver',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Computing the Jacobian', 2, None, '___sec142'),
              (u'Setting solver parameters', 2, None, '___sec143'),
              (u'Implementation', 2, None, '___sec144'),
              (u'Manual implementation of solution algorithms',
               1,
               None,
               '___sec145'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'More old stuff', 0, None, '___sec149'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'Coordinate stretching', 3, None, '___sec153'),
              (u'Rectangle to hollow circle mapping', 3, None, '___sec154'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'tut:possion:nD:nmat',
               u'tut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'tut:possion:nD:nmat:PDE',
               u'tut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'tut:possion:nD:nmat:prepro',
               u'tut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'tut:possion:nD:nmat:solve',
               u'tut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec159'),
              (u'Miscellaneous topics', 1, None, '___sec160'),
              (u'Glossary', 2, None, '___sec161'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec162'),
              (u'Mesh', 3, None, '___sec163'),
              (u'Function space', 3, None, '___sec164'),
              (u'Function', 3, None, '___sec165'),
              (u'Overview of objects and functions', 2, None, '___sec166'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Troubleshooting', 0, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 1, None, '___sec170'),
              (u'Problems with the Instant cache', 2, None, '___sec171'),
              (u'Syntax errors in expressions', 2, None, '___sec172'),
              (u'Example', 3, None, '___sec173'),
              (u'Problems in the solve step', 2, None, '___sec174'),
              (u'Unable to convert object to a UFL form',
               2,
               None,
               '___sec175'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               2,
               None,
               '___sec176'),
              (u'All programs fail to compile', 2, None, '___sec177'),
              (u'Problems with Expression Objects', 1, None, '___sec178'),
              (u'There seems to be some bug in an Expression object',
               2,
               None,
               '___sec179'),
              (u'Segmentation fault when using an Expression object',
               2,
               None,
               '___sec180'),
              (u'Other Problems', 1, None, '___sec181'),
              (u'Very strange error message involving a `mesh` variable',
               2,
               None,
               '___sec182'),
              (u'The plot disappears quickly from the screen',
               2,
               None,
               '___sec183'),
              (u'Only parts of the program are executed',
               2,
               None,
               '___sec184'),
              (u'Error in the definition of the boundary',
               2,
               None,
               '___sec185'),
              (u'The solver in a nonlinear problems does not converge',
               2,
               None,
               '___sec186'),
              (u'How To Debug a FEniCS Program?', 1, None, '___sec187'),
              (u'To-do list', 1, None, '___sec188'),
              (u'AL list', 2, None, '___sec189'),
              (u'HPL list', 2, None, '___sec190'),
              (u'HPL questions', 2, None, '___sec191'),
              (u'Iterative linear solvers info', 3, None, '___sec192'),
              (u'Bibliography', 1, None, '___sec193')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">Writing State-of-the-Art Finite Element Solvers in Minutes - The FEniCS Tutorial</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#tut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#tut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#ftut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The expression for the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:timedep" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The time-dependent diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing a test problem with SymPy</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#ch:poisson" style="font-size: 80%;"><b>The Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec58" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec61" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Useful extensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec77" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deflection of a circular membrane</a></li>
     <!-- navigation toc: --> <li><a href="#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#tut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="#tut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="#tut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#ftut:poisson:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:poisson:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refactoring of a solver function into solver and problem classes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#ch:diffusion" style="font-size: 80%;"><b>The diffusion solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of algorithms and implementations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding some assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding all assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving recursive linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A class-based solver for a general diffusion problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:nonlinear" style="font-size: 80%;"><b>The nonlinear Poisson solver revisited</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:poisson:nonlinear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The built-in automated Newton solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Manual implementation of solution algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec149" style="font-size: 80%;"><b>More old stuff</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating more complex domains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#tut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinate stretching</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle to hollow circle mapping</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:possion:nD:nmat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A General \( d \)-Dimensional multi-material test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec159" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More Examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Miscellaneous topics</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec161" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec163" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec165" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec166" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#tut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#tut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#tut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec172" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec176" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec177" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec180" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec182" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Very strange error message involving a <code>mesh</code> variable</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec183" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disappears quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec184" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec185" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec186" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut018.html#___sec187" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;To-do list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec189" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec190" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL list</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec191" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut019.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut020.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0009"></a>
<!-- !split -->

<h1 id="___sec81">Visualization </h1>

<p>
Perhaps you are not particularly amazed by viewing the simple surface
of \( u \) in the test problem used in the previous sections.  However,
solving a real physical problem with a more interesting and amazing
solution on the screen is only a matter of specifying a more exciting
domain, boundary condition, and/or right-hand side \( f \).  The present
chapter starts with the solver for a membrane deflection, where the
geometry is a circle instead of the unit square, and where the
involved functions have more exciting shapes. We then go on with
explaining how the membrane deflection and the pressure load can be
visualized, using both the built-in FEniCS visualization tool and the
powerful application ParaView. Finally, we return to box-shaped
domains with uniform partition and show how the unstructured data in
FEniCS finite element solvers can be transformed to structured mesh
representations like those commonly used for finite difference
methods. The structured mesh representation, whenever possible,
gives greater flexibility
with respect to visualization and data analysis.

<h2 id="tut:poisson:membrane">Deflection of a circular membrane</h2>

<h3 id="___sec83">The problem </h3>

<p>
One possible physical problem regards the deflection \( D(x,y) \) of an
elastic circular membrane with radius \( R \), subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is

$$
\begin{equation}
-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},
\tag{3.12}
\end{equation}
$$

with

$$
\begin{equation}
p(x,y) = {A\over 2\pi\sigma}\exp{\left(
- {1\over2}\left( {x-x_0\over\sigma}\right)^2
- {1\over2}\left( {y-y_0\over\sigma}\right)^2
\right)}\, .
\tag{3.13}
\end{equation}
$$

Here, \( T \) is the tension in the membrane (constant), \( p \) is the external
pressure load,
\( A \) the amplitude of the pressure, \( (x_0,y_0) \) the localization of
the Gaussian pressure function, and \( \sigma \) the &quot;width&quot; of this
function. The boundary of the membrane has no
deflection, implying \( D=0 \) as boundary condition.

<p>
<!-- For scaling and verification it is convenient to simplify the problem -->
<!-- to find an analytical solution. In the limit \( \sigma\rightarrow\infty \), -->
<!-- \( p\rightarrow A/(2\pi\sigma) \) (constant pressure throughout \( \Omega \)), -->
<!-- and we can easily find an analytical solution -->
<!-- of the problem by integrating the Poisson equation in the -->
<!-- radial coordinate: \( r\in [0,R] \). The result becomes -->
<!-- \( D(r)=(r^2-R^2)A/(8\pi\sigma T) \). -->

<h3 id="___sec84">Scaling </h3>

<p>
The localization of the pressure, \( (x_0,y_0) \), is for simplicity
set to \( (0, R_0) \).
There are many physical parameters in this problem, and we can benefit
from grouping them by means of scaling. Let us introduce dimensionless
coordinates \( \bar x = x/R \), \( \bar y = y/R \), and a dimensionless
deflection \( w=D/D_c \), where \( D_c \) is a characteristic size of the
deflection. Introducing \( \bar R_0=R_0/R \), we get

$$ \frac{\partial^2 w}{\partial\bar x^2} +
\frac{\partial^2 w}{\partial\bar y^2}= \alpha
\exp{\left(
- \beta^2(\bar x^2
+ (\bar y-\bar R_0)^2)\right)}\hbox{ for } \bar x^2 + \bar y^2 < 1,$$

where

$$ \alpha = \frac{R^2A}{2\pi T D_c\sigma},\quad\beta = \frac{R}{\sqrt{2}\sigma}\tp$$

With an appropriate scaling, \( \bar w \) and its derivatives are of size
unity, so the left-hand side of the scaled PDE is about unity in size,
while the right-hand side has \( \alpha \) as its characteristic size.
This suggest choosing \( \alpha \) to be unity, or around unit.  We shall
in particular choose \( \alpha=4 \). With this value, the solution is
\( w(\bar x,\bar y) = 1-\bar x^2 - \bar y^2 \).  (One can also find the
analytical solution in scaled coordinates and show that the maximum
deflection \( D(0,0) \) is \( D_c \) if we choose \( \alpha=4 \) to determine
\( D_c \).)  With \( D_c=AR^2/(8\pi\sigma T) \) and dropping the bars we get
the scaled problem

$$
\begin{equation}
\nabla^2w = 4\exp{\left(
- \beta^2(x^2
+ (y-R_0)^2)\right)},
\tag{3.14}
\end{equation}
$$

to be solved over the unit circle with \( w=0 \) on the boundary.  Now
there are only two parameters to vary: the dimensionless extent of the
pressure, \( \beta \), and the localization of the pressure peak, \( R_0\in
[0,1] \).  As \( \beta\rightarrow 0 \), we have a special case with solution
\( w=1-x^2-y^2 \).

<p>
Given a computed \( w \), the physical deflection is given by

$$ D = \frac{AR^2}{8\pi\sigma T}w\tp$$

<h3 id="___sec85">Implementation </h3>

<p>
Very few modifications of the software in <code>ft05_poisson_iter.py</code> are
required. Actually, the <code>solver</code> function can be reused, except that
the domain is now a circle and not a square. We change the <code>solver</code>
function by letting the mesh be an argument <code>mesh</code> (instead of <code>Nx</code>
and <code>Ny</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u0, mesh, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    <span style="color: #666666">...</span>):
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
    <span style="color: #666666">...</span>
</pre></div>
<p>
The final program is found in the file <code>ft07_poisson_membrane.py</code>.  The
key function to simulate membrane deflection is named <code>application</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>(beta, R0, num_elements_radial_dir):
    <span style="color: #408080; font-style: italic"># Scaled pressure function</span>
    p <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
        beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)

    <span style="color: #408080; font-style: italic"># Generate mesh over the unit circle</span>
    domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
    mesh <span style="color: #666666">=</span> generate_mesh(domain, num_elements_radial_dir)

    w <span style="color: #666666">=</span> solver(p, Constant(<span style="color: #666666">0</span>), mesh, degree<span style="color: #666666">=1</span>,
               linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    w<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;w&#39;</span>, <span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># set name and label (description)</span>

    <span style="color: #408080; font-style: italic"># Plot scaled solution, mesh and pressure</span>
    plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Mesh over scaled domain&#39;</span>)
    plot(w, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> w<span style="color: #666666">.</span>label())
    V <span style="color: #666666">=</span> w<span style="color: #666666">.</span>function_space()
    p <span style="color: #666666">=</span> interpolate(p, V)
    p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;p&#39;</span>, <span style="color: #BA2121">&#39;pressure&#39;</span>)
    plot(p, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> p<span style="color: #666666">.</span>label())

    <span style="color: #408080; font-style: italic"># Dump p and w to file in VTK format</span>
    vtkfile1 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_displacement.pvd&#39;</span>)
    vtkfile1 <span style="color: #666666">&lt;&lt;</span> w
    vtkfile2 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_load.pvd&#39;</span>)
    vtkfile2 <span style="color: #666666">&lt;&lt;</span> p
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Clean up compilation files.</b>
Running FEniCS programs usually implies compilation of some generated
C++ code. If you run into compilation errors, the first action to perform
is to clean up compilation files by the command

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Terminal&gt; instant-clean
</pre></div>
<p>
Then recompile, and if the error persist, open the <code>.log</code> file referred
to in the error message, search for the word <em>error</em>, and see
if the error message from the C++ compiler makes sense. As a user,
your compilation errors will in most cases arise from wrong (C++) syntax
in <code>Expression</code> objects.
</div>


<p>
Choosing a very peak-formed pressure with large \( \beta \) (e.g., \( \beta
\geq 20 \)) and a location \( R_0 \) toward the circular boundary (e.g.,
\( R_0=0.5 \)), may produce an exciting visual demonstrations of the very
smoothed elastic response to a peak force (or mathematically, the
smoothing properties of the inverse of the Laplace operator).  One
needs to experiment with the mesh resolution to get a smooth visual
representation of \( p \).  You are strongly encouraged to play around
with the plots and different mesh resolutions:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;import membrane as m; m.application()&#39; \ 
          membrane.py
</pre></div>

<h3 id="___sec86">Test problem </h3>

<p>
We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case \( \beta =0 \).
A unit test, implemented for the pytest or nose frameworks, appears in
the function <code>test_membrane</code>.

<h2 id="tut:quickviz">Visualization in FEniCS</h2>

<p>
As we go along with examples it is fun to play around with
<code>plot</code> commands and visualize what is computed. This section explains
some useful visualization features.

<p>
The <code>plot</code> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.

<p>
We have made a program <code>ft07_poisson_membrane.py</code> for the membrane
deflection problem in the section <a href="#tut:poisson:membrane">Deflection of a circular membrane</a> and added
various demonstrations of plotting capabilities. You are encouraged to
play around with <code>ft07_poisson_membrane.py</code> and modify the code as
you read about various features.

<p>
The <code>plot</code> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Finite element mesh&#39;</span>)
plot(w, wireframe<span style="color: #666666">=</span><span style="color: #008000">True</span>, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Solution&#39;</span>)
</pre></div>
<p>
Axes can be turned on by the <code>axes=True</code> argument, while
<code>interactive=True</code> makes the program hang at the plot command - you have
to type <code>q</code> in the plot window to terminate the plot and continue execution.

<p>
The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <code>Help</code> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,

<ul>
 <li> pressing <code>m</code> turns visualization of the mesh on and off,</li>
 <li> pressing <code>b</code> turns on and off a bounding box,</li>
 <li> pressing <code>p</code> dumps the plot to a PNG file,</li>
 <li> pressing <code>P</code> dumps the plot to a PDF file,</li>
 <li> pressing `Ctrl +' stretches the surface in the \( z \) direction,</li>
 <li> pressing `Ctrl -' shrinks++ the surface in the \( z \) direction,</li>
 <li> pressing `Ctrl w' closes the plot window,</li>
 <li> pressing `Ctrl q' closes all plot windows.</li>
</ul>

The plots created by pressing <code>p</code> or <code>P</code> are stored in files with
names <code>dolfin_plot_X.png</code> or <code>dolfin_plot_X.pdf</code>,
where <code>X</code> is an integer that is increased by one from the last plot
that was made. The file stem <code>dolfin_plot_</code> can be set to something
more suitable through the <code>hardcopy_prefix</code> keyword argument to the
<code>plot</code> function,
for instance, <code>plot(f, hardcopy_prefix='pressure')</code>.

<p>
Plots stored in PDF format need to be rotated 90 degrees before
inclusion in documents. This can be done by the <code>convert -rotate 90</code>
command (from the ImageMagick utility), but the resulting file has
then no more high-resolution PDF vector graphics. A better solution
is therefore to use <code>pdftk</code> to preserve the vector graphics:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; pdftk dolfin_plot_1.pdf cat 1-endnorth output out.pdf
</pre></div>
<p>
For making plots in batch, we can do the following:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">viz_w <span style="color: #666666">=</span> plot(w, interactive<span style="color: #666666">=</span><span style="color: #008000">False</span>)
viz_w<span style="color: #666666">.</span>elevate(<span style="color: #666666">-10</span>)  <span style="color: #408080; font-style: italic"># adjust (lift) camera from the default view</span>
viz_w<span style="color: #666666">.</span>plot(w)       <span style="color: #408080; font-style: italic"># bring new settings into action</span>
viz_w<span style="color: #666666">.</span>write_png(<span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># make deflection.png</span>
viz_w<span style="color: #666666">.</span>write_pdf(<span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># make deflection.pdf</span>
<span style="color: #408080; font-style: italic"># Rotate pdf file (right) from landscape to portrait</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>
os<span style="color: #666666">.</span>system(<span style="color: #BA2121">&#39;pdftk deflection.pdf cat 1-endnorth output w.pdf&#39;</span>)
</pre></div>
<p>
The commands above appear in the <code>application2</code>
function in the <code>ft07_poisson_membrane.py</code> file.

<p>
<center> <!-- figure label: --> <div id="tut:poisson:2D:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 5:  Plot of the deflection of a membrane.  <!-- caption label: tut:poisson:2D:fig1 --> </p></center>
<p><img src="fig/membrane_deflection.png" align="bottom" width=480></p>
</center>

<h2 id="tut:paraview">Visualization in ParaView</h2>

<p>
We strongly recommend FEniCS users to visualize
multi-dimensional  scalar and vector fields with
<a href="http://www.paraview.org" target="_self">ParaView</a>.

<p>
The <code>application</code> function in the <code>ft07_poisson_membrane.py</code> file
writes \( w \) and \( p \), to as finite element functions, to file.
The default filenames are <code>membrane000000.vtu</code> for the first field, \( w \), and
<code>membrane000001.vtu</code> for the second field, \( p \). These files are in VTK
format and their data can be visualized in ParaView.

<ol>
<li> Start the ParaView application.</li>
<li> Open a file with <b>File - Open...</b>. You will see a list of <code>.vtu</code> files,
   more specifically you see <code>mambrane..vtu</code>. Click to the left of that
   name to expand the collection of <code>membrane*.vtu</code> files. Choose the
   first one, <code>membrane000000.vtu</code></li>
<li> Click on <b>Apply</b> to the left (<em>Properties</em> pane) in the GUI, and
   ParaView will visualize the contents of the file, here as a color image.</li>
<li> To get rid of the axis in the lower left corner of the plot area
   and axis cross in the middle of the circle, find the <em>Show Orientation Axis</em> and <em>Show Center</em> buttons to the right in the second row of buttons at the top of the GUI. Click on these buttons to toggle axis information on/off.</li>
<li> If you want a color bar to explain the mapping between \( w \) values and colors,
   go to the <em>Color Map Editor</em> in the right of the GUI and use the
   <em>Show/hide color legend</em> button. Alternatively, find <em>Coloring</em> in the
   lower left part of the GUI, and toggle the <em>Show</em> button.</li>
<li> The color map, by default going from blue (low values) to red (high values),
   can easily be changed. Find the <em>Coloring</em> menu in the left part of the
   GUI, click <em>Edit</em>, then in the <em>Color Map Editor</em> double click at the
   left end of the color spectrum and choose another color, say yellow, then
   double click at the right and of the spectrum and choose pink, scroll
   down to the bottom of the dialog and click <em>Update</em>. The color map now
   goes from yellow to pink.</li>
<li> To save the plot to file, click on <b>File - Export Scene...</b>,
   choose a file type, fill in a filename, and save.
   See Figure <a href="#tut:paraview:figwp">6</a> (middle).</li>
<li> To change the background color of plots, choose
   <b>Edit - Settings...</b>, <b>Color</b> tab, click on <b>Background Color</b>,
   and choose it to be, e.g., white. Then choose <b>Foreground Color</b> to
   be something different.</li>
<li> To plot the mesh with colors reflecting the size of \( w \), find the
   <em>Representation</em> drop down menu in the left part of the GUI, and replace
   <em>Surface</em> by <em>Wireframe</em>.</li>
<li> To overlay a surface plot with a wireframe plot, load \( w \) and plot
   as surface, then load \( w \) again and plot as wireframe. Make sure
   both icons in the <em>Pipeline Browser</em> in the left part of the GUI
   are <em>on</em> for the two <code>membrane000000.vtu</code> files.
   See Figure <a href="#tut:paraview:figwp">6</a> (left).</li>
<li> Redo the surface plot. Then we can add some contour lines.
   Press the semi-sphere icon in the third row of buttons at the top of the
   GUI (the so-called <em>filters</em>). A set of contour values can now be
   specified at in a dialog box in the left part of the GUI. Remove
   the default contour (0.578808) and add 0.01, 0.02, 0.03, 0.04, 0.05.
   Click <em>Apply</em> and see an overlay of white contour lines.
   In the <em>Pipeline Browser</em> you can click on the icons to turn
   a filter on or off.</li>
</ol>

<center> <!-- figure label: --> <div id="tut:paraview:figwp"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 6:  Default visualizations in ParaView: deflection (left, middle) and pressure load (right).  <!-- caption label: tut:paraview:figwp --> </p></center>
<p><img src="fig/paraview_membrane3b.png" align="bottom" width=800></p>
</center>

<p>
A particularly useful feature of ParaView is that you can record GUI clicks
(<b>Tools - Start/Stop Trace</b>) and
get them translated to Python code. This allows you automate the
visualization process. You can also make curve plots along lines through
the domain, etc.

<p>
For more information, we refer to The ParaView Guide <a href="._ftut020.html#Paraview">[22]</a>
(free PDF available) and to the <a href="http://www.paraview.org/Wiki/The_ParaView_Tutorial" target="_self">ParaView tutorial</a>.

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec89">Exercise 2: Visualize a solution in a cube </h2>

<p>
Solve the problem \( -\nabla^2 u = f \) on the unit cube \( [0,1]\times[0,1]\times
[0,1] \) with \( u_0 = 1 + x^2 + 2y^2 - 4z^2 \) on the boundary.
Visualize the solution. Explore both the built-in visualization tool and
ParaView.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
As hinted by the filename in this exercise,
a good starting point is the <code>solver</code> function in
the program <code>ft04_poisson_func.py</code>, which solves the corresponding 2D
problem. Only one line in the body of <code>solver</code> needs to be changed (!):
<code>mesh = ...</code>. Replace this line with

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> UnitCubeMesh(Nx, Ny, Nz)
</pre></div>
<p>
and add <code>Nz</code> as argument to <code>solver</code>. We implement the new \( u_0 \) function
in <code>application_test</code> and realize that the proper \( f(x,y,z) \) function
in this new case is 2.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1] - 4*x[2]*x[2]&#39;</span>)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">2.0</span>)
u <span style="color: #666666">=</span> solver(f, u0, <span style="color: #666666">6</span>, <span style="color: #666666">4</span>, <span style="color: #666666">3</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The numerical solution is without approximation errors so we can
reuse the unit test from 2D, but it needs an extra <code>Nz</code> parameter.

<p>
The variation in \( u \) is only quadratic so a coarse mesh is okay for
visualization. Below is plot from the ParaView (left) and the built-in
visualization tool (right).  The usage is as in 2D, but now one can
use the mouse to rotate the 3D cube.

<p>
<center><p><img src="fig/cube3D_quad_sol.png" align="bottom" width=800></p></center>

<p>
We can in ParaView add a contour filter and define contour surfaces for
\( u=-2,1,0,1,2,3 \), then add a slice filter to get a slice with colors:

<p>
<center><p><img src="fig/cube3D_quad_sol_contours.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>p3D_func</code>.

<p>
<!-- --- end exercise --- -->

<h2 id="tut:structviz">Taking advantage of structured mesh data</h2>

<p>
When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.

<p>
A necessary first step is to transform our <code>mesh</code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
second step is to transform the one-dimensional array of nodal values
to a two-dimensional array holding the values at the corners of the
cells in the structured mesh. We want to access a value by its \( i \) and
\( j \) indices, \( i \) counting cells in the \( x \) direction, and \( j \) counting
cells in the \( y \) direction.  This transformation is in principle
straightforward, yet it frequently leads to obscure indexing errors,
so using software tools to ease the work is advantageous.

<p>
In the directory <code>src/modules</code>, associated with this booklet, we have
included a Python module <code>BoxField</code> that can take a finite element
function <code>u</code> computed by a FEniCS software and represent it on a
structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code>[i]</code> in 1D, <code>[i,j]</code> in 2D, and <code>[i,j,k]</code>
in 3D. Given a finite element function <code>u</code>, the following function
returns a <code>BoxField</code> object that represents <code>u</code> on a structured mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">structured_mesh</span>(u, divisions):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    u2 <span style="color: #666666">=</span> u <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
         interpolate(u, FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
    mesh <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">BoxField</span> <span style="color: #008000; font-weight: bold">import</span> fenics_function2BoxField
    u_box <span style="color: #666666">=</span> fenics_function2BoxField(
        u2, mesh, divisions, uniform_mesh<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u_box
</pre></div>
<p>
Note that we can only turn functions on meshes with P1 elements into
<code>BoxField</code> objects, so if <code>u</code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code>divisions</code>).

<p>
The <code>u_box</code> object contains several useful data structures:

<ul>
 <li> <code>u_box.grid</code>: object for the structured mesh</li>
 <li> <code>u_box.grid.coor[X]</code>: grid coordinates in <code>X=0</code> direction</li>
 <li> <code>u_box.grid.coor[Y]</code>: grid coordinates in <code>Y=1</code> direction</li>
 <li> <code>u_box.grid.coor[Z]</code>: grid coordinates in <code>Z=2</code> direction</li>
 <li> <code>u_box.grid.coorv[X]</code>: vectorized version of <code>u_box.grid.coor[X]</code>
   (for vectorized computations or surface plotting)</li>
 <li> <code>u_box.grid.coorv[Y]</code>: vectorized version of <code>u_box.grid.coor[Y]</code></li>
 <li> <code>u_box.grid.coorv[Z]</code>: vectorized version of <code>u_box.grid.coor[Z]</code></li>
 <li> <code>u_box.values</code>: <code>numpy</code> array holding the <code>u</code> values;
   <code>u_box.values[i,j]</code> holds <code>u</code> at the mesh point with coordinates <br />
   <code>(u_box.grid.coor[X], u_box.grid.coor[Y])</code></li>
</ul>

<h3 id="___sec91">Iterating over points and values </h3>

<p>
Let us go back to the <code>solver</code> function in the
<code>ft06_poisson_vc.py</code> code from
the section <a href="._ftut008.html#tut:possion:2D:varcoeff">A variable-coefficient Poisson problem</a>, compute <code>u</code>, map it onto a
<code>BoxField</code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> solver(p, f, u0, nx, ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
u_box <span style="color: #666666">=</span> structured_mesh(u, (nx, ny))
u_ <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>values       <span style="color: #408080; font-style: italic"># numpy array</span>
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  Y <span style="color: #666666">=</span> <span style="color: #666666">1</span>           <span style="color: #408080; font-style: italic"># for indexing in x and y direction</span>

<span style="color: #408080; font-style: italic"># Iterate over 2D mesh points (i,j)</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_ is defined on a structured mesh with </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
      <span style="color: #008000">str</span>(u_<span style="color: #666666">.</span>shape))
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=u(</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (i, j,
               u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][i], u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][j],
               u_[i,j]))
</pre></div>

<h3 id="___sec92">Finite difference approximations </h3>

<p>
Note that with <code>u_</code>, we can easily express finite difference approximation
of derivatives:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X]
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
u_xx <span style="color: #666666">=</span> (u_[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_[i,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">+1</span>,j])<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
</pre></div>

<h3 id="___sec93">Surface plot </h3>

<p>
The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a href="#tut:structviz:fig1">7</a> (upper left):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
cv <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coorv  <span style="color: #408080; font-style: italic"># vectorized mesh coordinates</span>
ax<span style="color: #666666">.</span>plot_surface(cv[X], cv[Y], u_, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Surface plot of solution&#39;</span>)
</pre></div>
<p>
The key issue is to know that the coordinates needed for the surface
plot is in <code>u_box.grid.coorv</code> and that the values are in <code>u_</code>.

<p>
<center> <!-- figure label: --> <div id="tut:structviz:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 7:  Various plots of the solution on a structured mesh.  <!-- caption label: tut:structviz:fig1 --> </p></center>
<p><img src="fig/poisson_vc_structmesh2.png" align="bottom" width=800></p>
</center>

<h3 id="___sec94">Contour plot </h3>

<p>
A contour plot can also be made by Matplotlib:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca()
levels <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">2.0</span>, <span style="color: #666666">2.5</span>, <span style="color: #666666">3.5</span>]
cs <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>contour(cv[X], cv[Y], u_, levels<span style="color: #666666">=</span>levels)
plt<span style="color: #666666">.</span>clabel(cs)  <span style="color: #408080; font-style: italic"># add labels to contour lines</span>
plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;equal&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Contour plot of solution&#39;</span>)
</pre></div>
<p>
The result appears in Figure <a href="#tut:structviz:fig1">7</a> (upper right).

<h3 id="___sec95">Curve plot through the mesh </h3>

<p>
A handy feature of <code>BoxField</code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot \( u \) along
the line \( y=0.4 \). The mesh points, <code>x</code>, and the \( u \) values
along this line, <code>u_val</code>, are extracted by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
</pre></div>
<p>
The variable <code>snapped</code> is true if the line had to be snapped onto a
gridline and in that case <code>y_fixed</code> holds the snapped
(altered) \( y \) value. To avoid interpolation in the structured mesh,
<code>snapped</code> is in fact <em>always</em> true.

<p>
A comparison of the numerical and exact solution along the line
\( y=0.5 \) (snapped from \( y=0.4 \)) is made by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
u_e_val <span style="color: #666666">=</span> [u0((x_, y_fixed)) <span style="color: #008000; font-weight: bold">for</span> x_ <span style="color: #AA22FF; font-weight: bold">in</span> x]

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, u_e_val, <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
See Figure <a href="#tut:structviz:fig1">7</a> (lower left) for the resulting curve plot.

<h3 id="___sec96">Curve plot of the flux </h3>

<p>
Let us also compare the numerical and
exact flux \( -p\partial u/\partial x \) along the same line as above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u <span style="color: #666666">=</span> flux(u, p)
flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)

<span style="color: #408080; font-style: italic"># Plot the numerical and exact flux along the same line</span>
flux2_x <span style="color: #666666">=</span> flux_u_x <span style="color: #008000; font-weight: bold">if</span> flux_u_x<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> \ 
          <span style="color: #008000; font-weight: bold">else</span> interpolate(flux_x,
               FunctionSpace(u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh(),
                             <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
flux_u_x_box <span style="color: #666666">=</span> structured_mesh(flux_u_x, (nx,ny))
x, flux_u_val, y_fixed, snapped <span style="color: #666666">=</span> \ 
   flux_u_x_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
y <span style="color: #666666">=</span> y_fixed

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, flux_u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, flux_u_x_exact(x, y_fixed), <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Flux along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
The second <code>plt.plot</code> command
requires a Python function <code>flux_u_x_exact(x,y)</code> to be
available for the exact flux expression.

<p>
Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a href="https://github.com/hplgit/scitools" target="_self">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.

<h3 id="___sec97">Test problem </h3>

<p>
The graphics referred to in Figure <a href="#tut:structviz:fig1">7</a> correspond to
a test problem with prescribed solution \( \uex = H(x)H(y) \), where

$$ H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x)\tp$$

We just fit a function \( f(x,y) \) in the PDE (can choose \( p=1 \)),
and notice that \( u=0 \) along the
boundary of the unit square. Although it is easy to carry out the
differentiation of \( f \) by hand and hardcode the resulting expressions
in an <code>Expression</code> object, a more reliable habit is to use Python's
symbolic computing engine, SymPy, to perform mathematics and
automatically turn formulas into C++ syntax for <code>Expression</code> objects.
A short introduction was given in the section <a href="._ftut006.html#tut:nonlinear:Newton:auto">A simple implementation</a>.

<p>
We start out with defining the exact solution in <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, pi  <span style="color: #408080; font-style: italic"># for use in math formulas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
H <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: exp(<span style="color: #666666">-16*</span>(x<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>sin(<span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>x)
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0], x[1]&#39;</span>)
u <span style="color: #666666">=</span> H(x)<span style="color: #666666">*</span>H(y)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to be have valid syntax for
<code>Expression</code> objects, and then \( x \) reads <code>x[0]</code> and \( y \) must be <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expression for <code>u</code> into C or C++ syntax for <code>Expression</code> objects
needs two steps. First we ask for the C code of the expression,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
</pre></div>
<p>
Printing out <code>u_c</code> gives (the output is here manually broken into two
lines):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
<p>
The necessary syntax adjustment is replacing
the symbol <code>M_PI</code> for \( \pi \) in C/C++ by <code>pi</code> (or <code>DOLFIN_PI</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_c <span style="color: #666666">=</span> u_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
u0 <span style="color: #666666">=</span> Expression(u_c)
</pre></div>
<p>
Thereafter, we can progress with the computation of \( f = -\nabla\cdot(p\nabla u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">+</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
f_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
f_c <span style="color: #666666">=</span> f_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
f <span style="color: #666666">=</span> Expression(f_c)
</pre></div>
<p>
We also need a Python function for the exact flux \( -p\partial u/\partial x \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">flux_u_x_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y], <span style="color: #666666">-</span>p<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x),
                              modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
</pre></div>
<p>
It remains to define <code>p = Constant(1)</code> and set <code>nx</code> and <code>ny</code> before calling
<code>solver</code> to compute the finite element solution of this problem.

<p>
<!-- FIGURE: [fig/poisson_vc_structmesh, width=800 frac=1] Various plots of the solution on a structured mesh. <div id="tut:structviz:fig1a"></div> -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut008.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="._ftut001.html">2</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li class="active"><a href="._ftut009.html">10</a></li>
  <li><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="._ftut015.html">16</a></li>
  <li><a href="._ftut016.html">17</a></li>
  <li><a href="._ftut017.html">18</a></li>
  <li><a href="._ftut018.html">19</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut020.html">21</a></li>
  <li><a href="._ftut010.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

