<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Finite Element Programming - The FEniCS Tutorial">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,DOLFIN mesh,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Dirichlet boundary conditions,boundary specification (function),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,unit testing,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),Poisson's equation with variable coefficient,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,time-dependent PDEs,assembly, increasing efficiency,heterogeneous medium,multi-material domain,Picard iteration,successive substitutions,Newton's method (algebraic equations),under-relaxation,Jacobian, manual computation,Newton's method (PDE level),Gateaux derivative,automatic differentiation,Jacobian, automatic computation,nonlinear variational problems,mesh transformations,coordinate stretching,coordinate transformations,FEniCS,DOLFIN,Viper,UFL,class,instance,method (class),attribute (class),down-casting matrices and vectors,PETSc,Trilinos,Epetra,installing FEniCS,troubleshooting,compilation problems,plotting problems">

<title>Introduction to Finite Element Programming - The FEniCS Tutorial</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u'Preface', 1, None, '___sec0'),
              (u'Acknowledgments', 3, None, '___sec1'),
              (u'To-do list', 1, None, '___sec2'),
              (u'HPL questions', 2, None, '___sec3'),
              (u'Iterative linear solvers info', 3, None, '___sec4'),
              (u'Mathematical problem formulation', 1, None, '___sec5'),
              (u'The Poisson equation',
               2,
               u'tut:poisson1:bvp',
               u'tut:poisson1:bvp'),
              (u'Variational formulation',
               2,
               u'tut:poisson1:varform',
               u'tut:poisson1:varform'),
              (u'A basic Poisson solver',
               1,
               u'tut:poisson1:impl',
               u'tut:poisson1:impl'),
              (u'A simple code',
               2,
               u'tut:poisson1:impl:code',
               u'tut:poisson1:impl:code'),
              (u'Running the program',
               2,
               u'tut:poisson1:impl:run',
               u'tut:poisson1:impl:run'),
              (u'Dissection of the program',
               2,
               u'tut:poisson1:impl:dissect',
               u'tut:poisson1:impl:dissect'),
              (u'The key import line', 3, None, '___sec12'),
              (u'Generating simple meshes', 3, None, '___sec13'),
              (u'Defining a function space corresponding to a mesh',
               3,
               None,
               '___sec14'),
              (u'Defining test and trial functions', 3, None, '___sec15'),
              (u'Specifying the boundary and boundary conditions',
               3,
               None,
               '___sec16'),
              (u'Specifying the right-hand side function',
               3,
               None,
               '___sec17'),
              (u'Specifying the variational formulation',
               3,
               None,
               '___sec18'),
              (u'Forming and solving the linear system', 3, None, '___sec19'),
              (u'Examining the values of the solution', 3, None, '___sec20'),
              (u'Plotting the solution', 3, None, '___sec21'),
              (u'Refactored implementation',
               2,
               u'tut:poisson1:impl2',
               u'tut:poisson1:impl2'),
              (u'A general solver function', 3, None, '___sec23'),
              (u'Plotting for the test problem', 3, None, '___sec24'),
              (u'Make a module!', 3, None, '___sec25'),
              (u'Verification', 3, None, '___sec26'),
              (u'Exercise 1: Solve a Poisson problem', 2, None, '___sec27'),
              (u'Remarks', 3, None, '___sec28'),
              (u'Useful extensions', 1, None, '___sec29'),
              (u'Controlling the solution process',
               2,
               u'tut:poisson1:solve:prm',
               u'tut:poisson1:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec31'),
              (u'Linear algebra backend', 3, None, '___sec32'),
              (u'The `parameters` database', 3, None, '___sec33'),
              (u'An extended solver function', 3, None, '___sec34'),
              (u'Remark regarding unit tests', 3, None, '___sec35'),
              (u'Linear variational problem and solver objects',
               2,
               u'tut:poisson1:solver:problem',
               u'tut:poisson1:solver:problem'),
              (u'Writing out the discrete solution',
               2,
               u'tut:poisson1:verify1',
               u'tut:poisson1:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'tut:poisson:nD',
               u'tut:poisson:nD'),
              (u'Generating a hypercube', 3, None, '___sec39'),
              (u'Computing derivatives',
               2,
               u'tut:poisson:gradu',
               u'tut:poisson:gradu'),
              (u'A variable-coefficient Poisson problem',
               2,
               u'tut:possion:2D:varcoeff',
               u'tut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec42'),
              (u'Modifications of the PDE solver', 3, None, '___sec43'),
              (u'Modifications of the flux computations',
               3,
               None,
               '___sec44'),
              (u'Creating the linear system explicitly',
               2,
               u'tut:poisson1:linalg',
               u'tut:poisson1:linalg'),
              (u'Visualization', 1, None, '___sec46'),
              (u'Deflection of a circular membrane',
               2,
               u'tut:poisson:membrane',
               u'tut:poisson:membrane'),
              (u'The problem', 3, None, '___sec48'),
              (u'Scaling', 3, None, '___sec49'),
              (u'Implementation', 3, None, '___sec50'),
              (u'Quick visualization with VTK',
               2,
               u'tut:quickviz',
               u'tut:quickviz'),
              (u'Paraview', 2, None, '___sec52'),
              (u'Taking advantage of structured mesh data',
               2,
               u'tut:structviz',
               u'tut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec54'),
              (u'Finite difference approximations', 3, None, '___sec55'),
              (u'Surface plot', 3, None, '___sec56'),
              (u'Contour plot', 3, None, '___sec57'),
              (u'Curve plot through the mesh', 3, None, '___sec58'),
              (u'Curve plot of the flux', 3, None, '___sec59'),
              (u'Test problem', 3, None, '___sec60'),
              (u'Postprocessing computations', 1, None, '___sec61'),
              (u'Computing functionals',
               2,
               u'tut:poisson1:functionals',
               u'tut:poisson1:functionals'),
              (u'Energy functional', 3, None, '___sec63'),
              (u'Error functional', 3, None, '___sec64'),
              (u'Flux Functionals', 3, None, '___sec65'),
              (u'Computing convergence rates',
               2,
               u'tut:poisson1:convrates',
               u'tut:poisson1:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec67'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec68'),
              (u'Test problem', 3, None, '___sec69'),
              (u'Experiments', 3, None, '___sec70'),
              (u'Multiple domain and boundaries', 1, None, '___sec71'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'tut:poisson1:DN',
               u'tut:poisson1:DN'),
              (u'PDE problem', 3, None, '___sec73'),
              (u'Variational formulation', 3, None, '___sec74'),
              (u'Implementation', 3, None, '___sec75'),
              (u'Multiple Dirichlet conditions',
               2,
               u'tut:poisson:multiple:Dirichlet',
               u'tut:poisson:multiple:Dirichlet'),
              (u'Functions for marking Dirichlet boundaries',
               3,
               None,
               '___sec77'),
              (u'Classes for marking Dirichlet boundaries',
               3,
               None,
               '___sec78'),
              (u'Debugging Dirichlet conditions', 3, None, '___sec79'),
              (u'Working with two subdomains',
               2,
               u'tut:possion:2D:2mat:problem',
               u'tut:possion:2D:2mat:problem'),
              (u'Mathematical problem', 3, None, '___sec81'),
              (u'Implementation',
               3,
               u'tut:possion:2D:2mat:impl',
               u'tut:possion:2D:2mat:impl'),
              (u'Multiple Neumann, Robin, and Dirichlet condition',
               2,
               u'tut:poisson:mat:neumann',
               u'tut:poisson:mat:neumann'),
              (u'Handy methods in key FEniCS objects', 2, None, '___sec84'),
              (u'Mesh', 3, None, '___sec85'),
              (u'Function space', 3, None, '___sec86'),
              (u'Function', 3, None, '___sec87'),
              (u'Time-dependent problems', 1, u'tut:timedep', u'tut:timedep'),
              (u'A diffusion problem and its discretization',
               2,
               u'tut:timedep:diffusion1',
               u'tut:timedep:diffusion1'),
              (u'Implementation',
               2,
               u'tut:timedep:diffusion1:impl',
               u'tut:timedep:diffusion1:impl'),
              (u'Avoiding assembly',
               2,
               u'tut:timedep:diffusion1:noassemble',
               u'tut:timedep:diffusion1:noassemble'),
              (u'A physical example',
               2,
               u'tut:timedep:diffusion2:sin',
               u'tut:timedep:diffusion2:sin'),
              (u'Nonlinear problems',
               1,
               u'tut:poisson:nonlinear',
               u'tut:poisson:nonlinear'),
              (u'Picard iteration',
               2,
               u'tut:nonlinear:Picard',
               u'tut:nonlinear:Picard'),
              (u'A Newton method at the algebraic level',
               2,
               u'tut:nonlinear:Newton:algebraic',
               u'tut:nonlinear:Newton:algebraic'),
              (u'A Newton method at the PDE level',
               2,
               u'tut:nonlinear:Newton:pdelevel',
               u'tut:nonlinear:Newton:pdelevel'),
              (u'Solving the nonlinear variational problem directly',
               2,
               u'tut:nonlinear:Newton:auto',
               u'tut:nonlinear:Newton:auto'),
              (u'Creating more complex domains',
               1,
               u'tut:prepro',
               u'tut:prepro'),
              (u'Built-in mesh generation tools',
               2,
               u'tut:prepro:builtin',
               u'tut:prepro:builtin'),
              (u'Transforming mesh coordinates',
               2,
               u'tut:mesh:transform:cyl',
               u'tut:mesh:transform:cyl'),
              (u'A General $d$-Dimensional multi-material test problem',
               1,
               u'tut:possion:nD:nmat',
               u'tut:possion:nD:nmat'),
              (u'The PDE problem',
               2,
               u'tut:possion:nD:nmat:PDE',
               u'tut:possion:nD:nmat:PDE'),
              (u'Preparing a mesh with subdomains',
               2,
               u'tut:possion:nD:nmat:prepro',
               u'tut:possion:nD:nmat:prepro'),
              (u'Solving the PDE problem',
               2,
               u'tut:possion:nD:nmat:solve',
               u'tut:possion:nD:nmat:solve'),
              (u'More Examples', 1, None, '___sec105'),
              (u'Miscellaneous topics', 1, None, '___sec106'),
              (u'Glossary', 2, None, '___sec107'),
              (u'Overview of objects and functions', 2, None, '___sec108'),
              (u'User-defined functions',
               2,
               u'tut:app:cpp:functions',
               u'tut:app:cpp:functions'),
              (u'Linear solvers and preconditioners',
               2,
               u'tut:app:solver:prec',
               u'tut:app:solver:prec'),
              (u'Using a backend-specific solver',
               2,
               u'tut:Epetra',
               u'tut:Epetra'),
              (u'Installing FEniCS',
               2,
               u'tut:app:install',
               u'tut:app:install'),
              (u'Books on the finite element method',
               2,
               u'tut:appendix:books',
               u'tut:appendix:books'),
              (u'Books on Python',
               2,
               u'tut:appendix:pybooks',
               u'tut:appendix:pybooks'),
              (u'Troubleshooting', 1, u'tut:trouble', u'tut:trouble'),
              (u'Compilation Problems', 2, None, '___sec116'),
              (u'Problems with the Instant cache', 3, None, '___sec117'),
              (u'Syntax errors in expressions', 3, None, '___sec118'),
              (u'Problems in the solve step', 3, None, '___sec119'),
              (u'Unable to convert object to a UFL form',
               3,
               None,
               '___sec120'),
              (u'UFL reports that a numpy array cannot be converted to any UFL type',
               3,
               None,
               '___sec121'),
              (u'All programs fail to compile', 3, None, '___sec122'),
              (u'Plotting Problems', 2, None, '___sec123'),
              (u'The plot disapperas quickly from the screen',
               3,
               None,
               '___sec124'),
              (u'Problems with Expression Objects', 2, None, '___sec125'),
              (u'There seems to be some bug in an Expression object',
               3,
               None,
               '___sec126'),
              (u'I get a segmentation fault when using an Expression object',
               3,
               None,
               '___sec127'),
              (u'Other Problems', 2, None, '___sec128'),
              (u'Only parts of the program are executed',
               3,
               None,
               '___sec129'),
              (u'I get an error in the definition of the boundary',
               3,
               None,
               '___sec130'),
              (u'The solver in a nonlinear problems does not converge',
               3,
               None,
               '___sec131'),
              (u'How To Debug a FEniCS Program?', 2, None, '___sec132'),
              (u'Bibliography', 1, None, '___sec133')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\tp}{\thinspace .}
\newcommand{\dt}{\Delta t}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut.html">Introduction to Finite Element Programming - The FEniCS Tutorial</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut002.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec2" style="font-size: 80%;"><b>To-do list</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;HPL questions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut003.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative linear solvers info</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#___sec5" style="font-size: 80%;"><b>Mathematical problem formulation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut004.html#tut:poisson1:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:impl" style="font-size: 80%;"><b>A basic Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:impl:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A simple code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key import line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining a function space corresponding to a mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the boundary and boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the right-hand side function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifying the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the values of the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#tut:poisson1:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 1: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut005.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec29" style="font-size: 80%;"><b>Useful extensions</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut006.html#tut:poisson1:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec46" style="font-size: 80%;"><b>Visualization</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:poisson:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a circular membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec48" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Quick visualization with VTK</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Paraview</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#tut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec58" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut007.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec61" style="font-size: 80%;"><b>Postprocessing computations</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#tut:poisson1:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="#___sec71" style="font-size: 80%;"><b>Multiple domain and boundaries</b></a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson1:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec77" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classes for marking Dirichlet boundaries</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#tut:possion:2D:2mat:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with two subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="#tut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#tut:poisson:mat:neumann" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet condition</a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Handy methods in key FEniCS objects</a></li>
     <!-- navigation toc: --> <li><a href="#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function space</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep" style="font-size: 80%;"><b>Time-dependent problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A diffusion problem and its discretization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion1:noassemble" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Avoiding assembly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut010.html#tut:timedep:diffusion2:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A physical example</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:poisson:nonlinear" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:algebraic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Newton method at the algebraic level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Newton method at the PDE level</a></li>
     <!-- navigation toc: --> <li><a href="._ftut011.html#tut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving the nonlinear variational problem directly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:prepro" style="font-size: 80%;"><b>Creating more complex domains</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:prepro:builtin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Built-in mesh generation tools</a></li>
     <!-- navigation toc: --> <li><a href="._ftut012.html#tut:mesh:transform:cyl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Transforming mesh coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat" style="font-size: 80%;"><b>A General \( d \)-Dimensional multi-material test problem</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:PDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:prepro" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Preparing a mesh with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut013.html#tut:possion:nD:nmat:solve" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving the PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut014.html#___sec105" style="font-size: 80%;"><b>More Examples</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec106" style="font-size: 80%;"><b>Miscellaneous topics</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Glossary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Overview of objects and functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:app:cpp:functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;User-defined functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:Epetra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Using a backend-specific solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:app:install" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Installing FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:appendix:books" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Books on the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut015.html#tut:appendix:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Books on Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#tut:trouble" style="font-size: 80%;"><b>Troubleshooting</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compilation Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with the Instant cache</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax errors in expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems in the solve step</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec120" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable to convert object to a UFL form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UFL reports that a numpy array cannot be converted to any UFL type</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All programs fail to compile</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Plotting Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The plot disapperas quickly from the screen</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problems with Expression Objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There seems to be some bug in an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I get a segmentation fault when using an Expression object</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other Problems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only parts of the program are executed</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I get an error in the definition of the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver in a nonlinear problems does not converge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut016.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How To Debug a FEniCS Program?</a></li>
     <!-- navigation toc: --> <li><a href="._ftut017.html#___sec133" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0009"></a>
<!-- !split -->

<h1 id="___sec71">Multiple domain and boundaries </h1>

<h2 id="tut:poisson1:DN">Combining Dirichlet and Neumann conditions</h2>

<p>
Let us make a slight extension of our two-dimensional Poisson problem
from the section <a href="._ftut004.html#tut:poisson1:bvp">The Poisson equation</a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition \( u=u_0 \) at the left and right sides, \( x=0 \) and
\( x=1 \), while the Neumann condition

$$
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
$$

is applied to the remaining
sides \( y=0 \) and \( y=1 \).
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).

<h3 id="___sec73">PDE problem </h3>

<p>
Let \( \Gamma_D \) and \( \Gamma_N \) denote the parts of \( \partial\Omega \)
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

$$
\begin{align}
    - \nabla^2 u &= f \mbox{ in } \Omega,  
\tag{31}\\ 
    u &= u_0 \mbox{ on } \Gamma_D,       
\tag{32}\\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N  \tp
\tag{33}
\end{align}
$$

Again we choose \( u=1+x^2 + 2y^2 \) as the exact solution and adjust \( f \), \( g \), and
\( u_0 \) accordingly:

$$
\begin{align*}
f &= -6,\\ 
g &= \left\lbrace\begin{array}{ll}
-4, & y=1\\ 
0,  & y=0
\end{array}\right.\\ 
u_0 &= 1 + x^2 + 2y^2\tp
\end{align*}
$$

For ease of programming we may introduce a \( g \) function defined over the whole
of \( \Omega \) such that \( g \) takes on the right values at \( y=0 \) and
\( y=1 \). One possible extension is

$$
\begin{equation*}
g(x,y) = -4y\tp
\end{equation*}
$$

<h3 id="___sec74">Variational formulation </h3>

<p>
The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
\( v \) is only zero on \( \Gamma_D \). We have

$$
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
$$

and since \( v=0 \) on \( \Gamma_D \),

$$
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v \ds
= \int_{\Gamma_N}gv \ds,
\end{equation*}
$$

by applying the boundary condition on \( \Gamma_N \).
The resulting weak form reads

$$
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx +
\int_{\Gamma_N} gv \ds
= \int_{\Omega} fv \dx\tp
\tag{34}
\end{equation}
$$

Expressing this equation
in the standard notation \( a(u,v)=L(v) \) is straightforward with

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{35}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\Gamma_N} gv \ds\tp  \tag{36}
\end{align}
$$

<h3 id="___sec75">Implementation </h3>

<p>
How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code>p2D_plain.py</code>, from
the section <a href="._ftut005.html#tut:poisson1:impl:code">A simple code</a>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:

<ul>
  <li> The function describing the boundary where Dirichlet conditions
    apply must be modified.</li>
  <li> The new boundary term must be added to the expression in <code>L</code>.</li>
</ul>

The first adjustment can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">if</span> on_boundary:
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
</pre></div>
<p>
A more compact implementation reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Never use <code>==</code> for comparing real numbers!</b>
A list like <code>x[0] == 1</code> should never be used if <code>x[0]</code> is a real number,
because rounding errors in <code>x[0]</code> may make the test fail even when it is
mathematically correct. Consider

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span> <span style="color: #666666">==</span> <span style="color: #666666">0.3</span>
<span style="color: #008000">False</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span>
<span style="color: #666666">0.30000000000000004</span>
</pre></div>
<p>
Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">0.1+0.2</span> <span style="color: #666666">-</span> <span style="color: #666666">0.3</span>)
<span style="color: #666666">5.551115123125783e-17</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1.1+1.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10.1+10.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20.3</span>)
<span style="color: #666666">3.552713678800501e-15</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">100.1+100.2</span> <span style="color: #666666">-</span> <span style="color: #666666">200.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1000.1+1000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2000.3</span>)
<span style="color: #666666">2.2737367544323206e-13</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10000.1+10000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20000.3</span>)
<span style="color: #666666">3.637978807091713e-12</span>
</pre></div>
<p>
For numbers around unity, tolerances as low as \( 3\cdot 10^{-16} \) can be used
(in fact, this tolerance is known as <code>DOLFIN_EPS</code> in the <code>dolfin</code> package),
otherwise an appropriate tolerance must be found.

<p>
Testing for <code>x[0] == 1</code> should therefore be implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol:
    <span style="color: #666666">...</span>
</pre></div>
<p>
</div>


<p>
Here is a new boundary function using tolerances in the test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> \ 
           (<span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol)
</pre></div>
<p>
The second adjustment of our program concerns the definition of <code>L</code>,
where we have to add a boundary integral and a definition of the \( g \)
function to be integrated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-4*x[1]&#39;</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds
</pre></div>
<p>
The <code>ds</code> variable implies a boundary integral, while <code>dx</code>
implies an integral over the domain \( \Omega \).
No more modifications are necessary.

<h2 id="tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</h2>

<p>
The PDE problem from the previous section applies a function \( u_0(x,y) \)
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have \( m \) functions for
setting Dirichlet conditions on \( m \) parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

<p>
Let us return to the case from the section <a href="#tut:poisson1:DN">Combining Dirichlet and Neumann conditions</a> and define
two separate functions for the two Dirichlet conditions:

$$
\begin{align*}
    - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
    u &= u_L \mbox{ on } \Gamma_0, \\ 
    u &= u_R \mbox{ on } \Gamma_1, \\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N \tp
\end{align*}
$$

Here, \( \Gamma_0 \) is the boundary \( x=0 \), while \( \Gamma_1 \) corresponds
to the boundary \( x=1 \).  We have that \( u_L = 1 + 2y^2 \), \( u_R = 2 +
2y^2 \), and \( g=-4y \).

<h3 id="___sec77">Functions for marking Dirichlet boundaries </h3>

<p>
For the left boundary \( \Gamma_0 \) we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code>DirichletBC</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">left_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_0 <span style="color: #666666">=</span> DirichletBC(V, u_L, left_boundary)
</pre></div>
<p>
For the boundary \( x=1 \) we write a similar code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">right_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

Gamma_1 <span style="color: #666666">=</span> DirichletBC(V, u_R, right_boundary)
</pre></div>
<p>
The various essential conditions are then collected in a list
and used in the solution process:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> [Gamma_0, Gamma_1]
<span style="color: #666666">...</span>
solve(a <span style="color: #666666">==</span> L, u, bcs)
<span style="color: #408080; font-style: italic"># or</span>
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bcs)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
In other problems, where the \( u \) values are constant at a part of the
boundary, we may use a simple <code>Constant</code> object instead of an
<code>Expression</code> object.

<h3 id="___sec78">Classes for marking Dirichlet boundaries </h3>

<p>
Instead of using a function like <code>left_boundary(x, on_boundary)</code> to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class <code>SubDomain</code> and has a method <code>inside(self, x, on_boundary)</code> for the code that returns whether the <code>point</code> is on the
boundary in question or not. Our previous <code>left_boundary</code> function
takes this form in its class version:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">LeftBoundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

left_boundary <span style="color: #666666">=</span> LeftBoundary()
Gamma_0 <span style="color: #666666">=</span> DirichletBC(V, u_L, left_boundary)
</pre></div>

<h3 id="___sec79">Debugging Dirichlet conditions </h3>

<p>
Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <code>get_boundary_values</code> method in the <code>DirichletBC</code> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding essential conditions as values. In the present problem
we can write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
<span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
    <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (dof, bc_dict[dof],
	      <span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Lagrange_1st_order <span style="color: #666666">=</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>
<span style="color: #008000; font-weight: bold">if</span> Lagrange_1st_order:
    coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
    d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
    <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
        bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
        <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof])),
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
The output for a mesh made by <code>UnitSquareMesh(3, 2)</code> becomes
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dof  0: u=1 	 at point (0.0, 0.0)
dof  8: u=3 	 at point (0.0, 1.0)
dof  4: u=1.5 	 at point (0.0, 0.5)
dof  3: u=2 	 at point (1.0, 0.0)
dof 11: u=4 	 at point (1.0, 1.0)
dof  7: u=2.5 	 at point (1.0, 0.5)
</pre></div>
<p>
<!-- The file <code>dn2_p2D.py</code> contains a complete program which -->
<!-- demonstrates the constructions above. -->
An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the <em>mesh function</em> concept and is therefore
left to the section <a href="#tut:poisson:mat:neumann">Multiple Neumann, Robin, and Dirichlet condition</a>.

<h2 id="tut:possion:2D:2mat:problem">Working with two subdomains</h2>

<p>
Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent the
various materials. We can thereafter define material properties through
functions, known in FEniCS as <em>mesh functions</em>,
that are piecewise constant in each subdomain.
A simple example with
two materials (subdomains) in 2D will
demonstrate the basic steps in the process.
<!-- Later, a multi-material -->
<!-- problem in \( d \) space dimensions is addressed. -->

<p>
<center> <!-- figure label: --> <div id="tut:possion:2D:2mat:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 5:  Medium with discontinuous material properties.  <!-- caption label: tut:possion:2D:2mat:fig1 --> </p></center>
<p><img src="fig/layered_medium_2.png" align="bottom" width=400></p>
</center>

<h3 id="___sec81">Mathematical problem </h3>

<p>
Suppose we want to solve

$$
\begin{equation} \tag{37}
    \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,
\end{equation}
$$

in a domain \( \Omega \) consisting of two subdomains where \( k \) takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain \( \Omega = [0,1]\times [0,1] \) and divide it into two equal
subdomains,
as depicted in Figure <a href="#tut:possion:2D:2mat:fig1">5</a>,

$$
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
$$

We define \( k(x,y)=k_0 \) in \( \Omega_0 \) and \( k(x,y)=k_1 \) in \( \Omega_1 \),
where \( k_0>0 \) and \( k_1>0 \) are given constants.
As boundary conditions, we choose \( u=0 \) at \( y=0 \), \( u=1 \) at \( y=1 \),
and \( \partial u/\partial n=0 \) at \( x=0 \) and \( x=1 \).
One can show that the exact solution is now given by

$$
\begin{equation}
u(x, y) = \left\lbrace\begin{array}{ll}
{2yk_1\over k_0+k_1}, & y \leq 1/2\\ 
{(2y-1)k_0 + k_1\over k_0+k_1}, & y \geq 1/2
\end{array}\right.
\tag{38}
\end{equation}
$$

As long as the element boundaries coincide with the internal boundary
\( y=1/2 \), this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We use this property to verify
the implementation.

<p>
Physically, the present problem may correspond to heat conduction, where
the heat conduction in \( \Omega_1 \) is ten times more efficient than
in \( \Omega_0 \). An alternative interpretation is flow in porous media
with two geological layers, where the layers' ability to transport
the fluid differs by a factor of 10.

<h3 id="tut:possion:2D:2mat:impl">Implementation</h3>

<p>
The new functionality in this subsection regards how to define the
subdomains \( \Omega_0 \) and \( \Omega_1 \). For this purpose we need to use
subclasses of class <code>SubDomain</code>, not only plain functions as we have
used so far for specifying boundaries. Consider the boundary function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
for defining the boundary \( x=0 \). Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <code>SubDomain</code>,
which implements the <code>inside</code> method as an alternative to the
<code>boundary</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Boundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

boundary <span style="color: #666666">=</span> Boundary()
bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)
</pre></div>
<p>
A word about computer science terminology may be used here:
The term <em>instance</em>
means a Python object of a particular type (such as <code>SubDomain</code>,
<code>Function</code>
<code>FunctionSpace</code>, etc.).
Many use <em>instance</em> and <em>object</em>
as interchangeable terms. In other computer programming languages one may
also use the term <em>variable</em> for the same thing.
We mostly use the well-known  term <em>object</em> in this text.

<p>
A subclass of <code>SubDomain</code> with an <code>inside</code> method offers
functionality for marking parts of the domain or
the boundary. Now we need to define one class for the
subdomain \( \Omega_0 \)
where \( y\leq 1/2 \) and another for the subdomain \( \Omega_1 \) where \( y\geq 1/2 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span> <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">False</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span> <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">False</span>
</pre></div>
<p>
Notice the use of <code>&lt;=</code> and <code>&gt;=</code> in both tests. For a cell to
belong to, e.g., \( \Omega_1 \), the <code>inside</code> method must return
<code>True</code> for all the vertices <code>x</code> of the cell. So to make the
cells at the internal boundary \( y=1/2 \) belong to \( \Omega_1 \), we need
the test <code>x[1] &gt;= 0.5</code>.

<p>
The next task is to use a <code>MeshFunction</code> to mark all
cells in \( \Omega_0 \) with the subdomain number 0 and all cells in \( \Omega_1 \)
with the subdomain number 1.
Our convention is to number subdomains as \( 0,1,2,\ldots \).

<p>
A <code>MeshFunction</code> is a discrete function that can be evaluated at a set
of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <code>MeshFunction</code> over cells is suitable to
represent subdomains (materials), while a <code>MeshFunction</code> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous fields.

<p>
Since we need to define subdomains of \( \Omega \)
in the present example, we must make use
of a <code>MeshFunction</code> over cells. The
<code>MeshFunction</code> constructor is fed with three arguments: 1) the type
of value: <code>'int'</code> for integers, <code>'uint'</code> for positive
(unsigned) integers, <code>'double'</code> for real numbers, and
<code>'bool'</code> for logical values; 2) a <code>Mesh</code> object, and 3)
the topological dimension of the mesh entity in question: cells
have topological dimension equal to the number of space dimensions in
the PDE problem, and facets have one dimension lower.
Alternatively, the constructor can take just a filename
and initialize the <code>MeshFunction</code> from data in a file.

<p>
We start with creating a <code>MeshFunction</code> whose
values are non-negative integers (<code>'uint'</code>)
for numbering the subdomains.
The mesh entities of interest are the cells, which have dimension 2
in a two-dimensional problem (1 in 1D, 3 in 3D). The appropriate code for
defining the <code>MeshFunction</code> for two subdomains then reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">subdomains <span style="color: #666666">=</span> MeshFunction(<span style="color: #BA2121">&#39;uint&#39;</span>, mesh, <span style="color: #666666">2</span>)
<span style="color: #408080; font-style: italic"># Mark subdomains with numbers 0 and 1</span>
subdomain0 <span style="color: #666666">=</span> Omega0()
subdomain0<span style="color: #666666">.</span>mark(subdomains, <span style="color: #666666">0</span>)
subdomain1 <span style="color: #666666">=</span> Omega1()
subdomain1<span style="color: #666666">.</span>mark(subdomains, <span style="color: #666666">1</span>)
</pre></div>
<p>
Calling <code>subdomains.array()</code> returns a <code>numpy</code> array of the
subdomain values. That is, <code>subdomain.array()[i]</code> is
the subdomain value of cell number <code>i</code>. This array is used to
look up the subdomain or material number of a specific element.

<p>
We need a function <code>k</code> that is constant in
each subdomain \( \Omega_0 \) and \( \Omega_1 \). Since we want <code>k</code>
to be a finite element function, it is natural to choose
a space of functions that are constant over each element.
The family of discontinuous Galerkin methods, in FEniCS
denoted by <code>'DG'</code>, is suitable for this purpose. Since we
want functions that are piecewise constant, the value of
the degree parameter is zero:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
k  <span style="color: #666666">=</span> Function(V0)
</pre></div>
<p>
To fill <code>k</code> with the right values in each element, we loop over
all cells (i.e., indices in <code>subdomain.array()</code>),
extract the corresponding subdomain number of a cell,
and assign the corresponding \( k \) value to the <code>k.vector()</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k_values <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">50</span>]  <span style="color: #408080; font-style: italic"># values of k in the two subdomains</span>
<span style="color: #008000; font-weight: bold">for</span> cell_no <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(subdomains<span style="color: #666666">.</span>array())):
    subdomain_no <span style="color: #666666">=</span> subdomains<span style="color: #666666">.</span>array()[cell_no]
    k<span style="color: #666666">.</span>vector()[cell_no] <span style="color: #666666">=</span> k_values[subdomain_no]
</pre></div>
<p>
Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <code>numpy</code> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<code>subdomain.array()</code>, but where the value <code>i</code> of an entry
in <code>subdomain.array()</code> is replaced by <code>k_values[i]</code>.
Such an operation is carried out by the <code>numpy</code> function <code>choose</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">help <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>asarray(subdomains<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>numpy<span style="color: #666666">.</span>int32)
k<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>choose(help, k_values)
</pre></div>
<p>
The <code>help</code> array is required since <code>choose</code> cannot work with
<code>subdomain.array()</code> because this array has elements of
type <code>uint32</code>. We must therefore transform this array to an array
<code>help</code> with standard <code>int32</code> integers.

<p>
Having the <code>k</code> function ready for finite element computations, we
can proceed in the normal manner with defining essential boundary
conditions, as in the section <a href="#tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>,
and the \( a(u,v) \) and \( L(v) \) forms, as in
the section <a href="._ftut006.html#tut:possion:2D:varcoeff">A variable-coefficient Poisson problem</a>.
All the details can be found in the file <code>mat2_p2D.py</code>.

<h2 id="tut:poisson:mat:neumann">Multiple Neumann, Robin, and Dirichlet condition</h2>

<p>
Let us go back to the model problem from
the section <a href="#tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>
where we had both Dirichlet and Neumann conditions.
The term <code>v*g*ds</code> in the expression for <code>L</code> implies a
boundary integral over the complete boundary, or in FEniCS terms,
an integral over all exterior facets.
However, the contributions from the parts of the boundary where we have
Dirichlet conditions are erased when the linear system is modified by
the Dirichlet conditions.
We would like, from an efficiency point of view, to integrate <code>v*g*ds</code>
only over the parts of the boundary where we actually have Neumann conditions.
And more importantly,
in other problems one may have different Neumann conditions or
other conditions like the Robin type condition.
With the mesh function concept we can mark
different parts of the boundary and integrate over specific parts.
The same concept can also be used to treat multiple Dirichlet conditions.
The forthcoming text illustrates how this is done.

<p>
Essentially, we still stick to the model problem from
the section <a href="#tut:poisson:multiple:Dirichlet">Multiple Dirichlet conditions</a>, but replace the
Neumann condition at \( y=0 \) by a <em>Robin condition</em>:

$$
\begin{equation*}
-{\partial u\over\partial n} = p(u-q),
\end{equation*}
$$

where \( p \) and \( q \) are specified functions.
The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law.

<p>
Since we have prescribed a simple solution in our model problem,
\( u=1+x^2+2y^2 \), we adjust \( p \) and \( q \) such that the condition holds
at \( y=0 \). This implies that \( q=1+x^2+2y^2 \) and \( p \) can be arbitrary
(the normal derivative at \( y=0 \): \( \partial u/\partial n = -\partial u/\partial y = -4y=0 \)).

<p>
Now we have four parts of the boundary: \( \Gamma_N \) which corresponds to
the upper side \( y=1 \), \( \Gamma_R \) which corresponds to the lower part
\( y=0 \), \( \Gamma_0 \) which corresponds to the left part \( x=0 \), and
\( \Gamma_1 \) which corresponds to the right part \( x=1 \). The
complete boundary-value problem reads

$$
\begin{align}
    - \nabla^2 u &= -6 \mbox{ in } \Omega, \tag{39}\\ 
    u &= u_L \mbox{ on } \Gamma_0, \tag{40}\\ 
    u &= u_R \mbox{ on } \Gamma_1, \tag{41}\\ 
    - {\partial u\over\partial n} &= p(u-q) \mbox{ on } \Gamma_R,
\tag{42}\\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N\tp
\tag{43}
\end{align}
$$

The involved prescribed functions are \( u_L= 1 + 2y^2 \),
\( u_R = 2 + 2y^2 \), \( q=1+x^2+2y^2 \), \( p \) is arbitrary, and \( g=-4y \).

<p>
Integration by parts of \( -\int_\Omega v\nabla^2 u \dx \) becomes
as usual

$$
\begin{equation*}
 -\int_\Omega v\nabla^2 u \dx
= \int_\Omega\nabla u\cdot \nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds\tp
\end{equation*}
$$

The boundary integral vanishes on \( \Gamma_0\cup\Gamma_1 \), and
we split the parts over \( \Gamma_N \) and \( \Gamma_R \) since we have
different conditions at those parts:

$$
\begin{equation*}
- \int_{\partial\Omega}v{\partial u\over\partial n} \ds
=
-\int_{\Gamma_N}v{\partial u\over\partial n} \ds -
\int_{\Gamma_R}v{\partial u\over\partial n} \ds
= \int_{\Gamma_N}vg \ds +
\int_{\Gamma_R}vp(u-q) \ds\tp
\end{equation*}
$$

The weak form then becomes

$$
\begin{equation*}
\int_{\Omega} \nabla u\cdot \nabla v \dx +
\int_{\Gamma_N} gv \ds + \int_{\Gamma_R}p(u-q)v \ds
= \int_{\Omega} fv \dx,
\end{equation*}
$$

We want to write this weak form in the standard
notation \( a(u,v)=L(v) \), which
requires that we identify all integrals with <em>both</em> \( u \) and \( v \),
and collect these in \( a(u,v) \), while the remaining integrals with
\( v \) and not \( u \) go
into \( L(v) \).
The integral from the Robin condition must of this reason be split in two
parts:

$$
\begin{equation*} \int_{\Gamma_R}p(u-q)v \ds
= \int_{\Gamma_R}puv \ds - \int_{\Gamma_R}pqv \ds\tp
\end{equation*}
$$

We then have

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u\cdot \nabla v \dx
+ \int_{\Gamma_R}puv \ds,
\tag{44}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\Gamma_N} g v \ds + \int_{\Gamma_R}pqv \ds\tp
\tag{45}
\end{align}
$$

<p>
A natural starting point for implementation is the <code>dn2_p2D.py</code>
program in the directory <code>poisson</code>. The new aspects are

<ol>
 <li> definition of a mesh function over the boundary,</li>
 <li> marking each side as a subdomain, using the mesh function,</li>
 <li> splitting a boundary integral into parts.</li>
</ol>

Task 1 makes use of the <code>MeshFunction</code> object, but contrary to
the section <a href="#tut:possion:2D:2mat:impl">Implementation</a>, this is not a function over
cells, but a function over cell facets. The topological dimension of
cell facets is one lower than the cell interiors, so in a two-dimensional
problem the dimension
becomes 1. In general, the facet dimension
is given as <code>mesh.topology().dim()-1</code>,
which we use in the code for ease of direct reuse in other problems.
The construction of a <code>MeshFunction</code> object to mark boundary parts
now reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary_parts <span style="color: #666666">=</span> \ 
  MeshFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh, mesh<span style="color: #666666">.</span>topology()<span style="color: #666666">.</span>dim()<span style="color: #666666">-1</span>)
</pre></div>
<p>
As in the section <a href="#tut:possion:2D:2mat:impl">Implementation</a> we
use a subclass of <code>SubDomain</code> to identify the various parts
of the mesh function. Problems with domains of more complicated geometries may
set the mesh function for marking boundaries as part of the mesh
generation.
In our case, the \( y=0 \) boundary can be marked by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">LowerRobinBoundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">1</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_R <span style="color: #666666">=</span> LowerRobinBoundary()
Gamma_R<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">0</span>)
</pre></div>
<p>
The code for the \( y=1 \) boundary is similar and is seen in
<code>dnr_p2D.py</code>.

<p>
The Dirichlet boundaries are marked similarly, using subdomain number 2 for \( \Gamma_0 \) and 3 for \( \Gamma_1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">LeftBoundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_0 <span style="color: #666666">=</span> LeftBoundary()
Gamma_0<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">2</span>)

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">RightBoundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

Gamma_1 <span style="color: #666666">=</span> RightBoundary()
Gamma_1<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">3</span>)
</pre></div>
<p>
Specifying the <code>DirichletBC</code> objects may now make use of
the mesh function (instead of a <code>SubDomain</code> subclass object)
and an indicator for which subdomain each condition
should be applied to:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)
u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)
bcs <span style="color: #666666">=</span> [DirichletBC(V, u_L, boundary_parts, <span style="color: #666666">2</span>),
       DirichletBC(V, u_R, boundary_parts, <span style="color: #666666">3</span>)]
</pre></div>
<p>
Some functions need to be defined before we can go on with the
<code>a</code> and <code>L</code> of the variational problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-4*x[1]&#39;</span>)
q <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
p <span style="color: #666666">=</span> Constant(<span style="color: #666666">100</span>)  <span style="color: #408080; font-style: italic"># arbitrary function can go here</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
</pre></div>
<p>
The new aspect of the variational problem is the two distinct
boundary integrals.
Having a mesh function over exterior cell facets (our
<code>boundary_parts</code> object), where subdomains (boundary parts) are
numbered as \( 0,1,2,\ldots \), the special symbol <code>ds(0)</code>
implies integration over subdomain (part) 0, <code>ds(1)</code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code>ds</code>-type objects generalizes to volume
integrals too: <code>dx(0)</code>, <code>dx(1)</code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside \( \Omega \).

<p>
The variational problem can be defined as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> p<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(<span style="color: #666666">0</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(<span style="color: #666666">1</span>) <span style="color: #666666">+</span> p<span style="color: #666666">*</span>q<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(<span style="color: #666666">0</span>)
</pre></div>
<p>
For the <code>ds(0)</code> and <code>ds(1)</code> symbols to work we must obviously
connect them (or <code>a</code> and <code>L</code>) to the mesh function marking
parts of the boundary. This is done by a certain keyword argument
to the <code>assemble</code> function:

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Warning.</b>
The old code looked like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a, exterior_facet_domains<span style="color: #666666">=</span>boundary_parts)
b <span style="color: #666666">=</span> assemble(L, exterior_facet_domains<span style="color: #666666">=</span>boundary_parts)
</pre></div>
<p>
but the <code>exterior_facet_domain</code> argument is no longer legal.
The text must be updated! The associated code gives wrong results.
</div>


<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
</pre></div>
<p>
Then essential boundary conditions are enforced, and the system can
be solved in the usual way:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc<span style="color: #666666">.</span>apply(A, b)
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
solve(A, U, b)
</pre></div>
<p>
The complete code is in the <code>dnr_p2D.py</code> file in the
<code>poisson</code> directory.

<h2 id="___sec84">Handy methods in key FEniCS objects </h2>

<p>
In general,
<code>pydoc dolfin.X</code> shows the documentation of any DOLFIN name <code>X</code>
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.

<h3 id="___sec85">Mesh </h3>

<p>
Let <code>mesh</code> be a <code>Mesh</code> object.

<ul>
  <li> <code>mesh.coordinates()</code> returns an array of the coordinates of
     the vertices in the mesh.</li>
  <li> <code>mesh.num_cells()</code> returns the number of cells (triangles)
    in the mesh,</li>
  <li> <code>mesh.num_vertices()</code> returns the number of vertices in
    the mesh (with our choice of linear Lagrange elements this equals the
    number of nodes, <code>len(u_array)</code>, or dimension of the space <code>V.dim()</code>),</li>
  <li> <code>mesh.cells()</code> returns the vertex numbers of the vertices in
    each cell as a <code>numpy</code> array with shape
    (<em>number of cells</em>, <em>number of vertices in a cell</em>),</li>
  <li> <code>mesh.hmin()</code> returns the minimum cell diameter (&quot;smallest cell&quot;),</li>
  <li> <code>mesh.hmax()</code> returns the maximum cell diameter (&quot;largest cell&quot;).</li>
</ul>

Writing <code>print(mesh)</code> dumps a short, pretty-print description
of the mesh (<code>print(mesh)</code> actually displays the result of <code>str(mesh)</code>,
which defines the pretty print):

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>

<h3 id="___sec86">Function space </h3>

<p>
Let <code>V</code> be a <code>FunctionSpace</code> object.

<ul>
 <li> <code>V.mesh()</code> returns the associated mesh.</li>
 <li> <code>V.dim()</code> returns the dimension (number of degrees of freedom).</li>
 <li> <code>V.ufl_element()</code> returns the associated finite element.</li>
</ul>

<h3 id="___sec87">Function </h3>

<p>
Let <code>u</code> be a <code>Function</code> object.

<ul>
 <li> <code>u.function_space()</code> returns the associated function space.</li>
 <li> <code>u.vector()</code> returns the DOLFIN vector of degrees of freedom.</li>
 <li> <code>u.vector().array()</code> returns a copy of the degrees of freedom
   in a <code>numpy</code> array.</li>
</ul>

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut008.html">&laquo;</a></li>
  <li><a href="._ftut000.html">1</a></li>
  <li><a href="._ftut001.html">2</a></li>
  <li><a href="._ftut002.html">3</a></li>
  <li><a href="._ftut003.html">4</a></li>
  <li><a href="._ftut004.html">5</a></li>
  <li><a href="._ftut005.html">6</a></li>
  <li><a href="._ftut006.html">7</a></li>
  <li><a href="._ftut007.html">8</a></li>
  <li><a href="._ftut008.html">9</a></li>
  <li class="active"><a href="._ftut009.html">10</a></li>
  <li><a href="._ftut010.html">11</a></li>
  <li><a href="._ftut011.html">12</a></li>
  <li><a href="._ftut012.html">13</a></li>
  <li><a href="._ftut013.html">14</a></li>
  <li><a href="._ftut014.html">15</a></li>
  <li><a href="._ftut015.html">16</a></li>
  <li><a href="._ftut016.html">17</a></li>
  <li><a href="._ftut017.html">18</a></li>
  <li><a href="._ftut010.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

