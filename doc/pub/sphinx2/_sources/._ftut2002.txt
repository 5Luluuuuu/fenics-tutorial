.. !split

.. _ch:classes:

PDE solver design and coding practices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


..

    In the very beginning of this tutorial [Ref1]_ we focused on how
    to quickly put together solvers for a number of different PDEs. FEniCS
    makes it simple and straightforward to write the commands needed to
    set up a variational problem, define domains and boundary
    conditions. In the last chapter of [Ref1]_ and the first of the
    present volume, we wrapped such flat programs in functions for
    increased flexibility and easy testing.  However, for a real
    application you will likely want to be able to reuse the code you
    write for a particular PDE to solve multiple different problems with
    different domains, boundary conditions and other parameters. In this
    chapter, we look at how to structure FEniCS Python code to create
    flexible, reusable, and efficient PDE solvers. The key concept is to
    use Python classes and develop effective an Application Programming
    Interface (API) in terms of class methods (functions) and their arguments.



.. _ch:poisson0:refactor:class:

Refactoring a Poisson solver in terms of classes
================================================

A FEniCS solver for a PDE can be implemented in a general way, but the
problem-dependent data, like boundary conditions, must be specified in
each case by the user. For example, the implementation in in [Ref1]_ requires
the user to supply a ``boundary_conditions`` dictionary with
specifications of the boundary condition on each of the four sides of
the unit square. If we, e.g., want two Dirichlet conditions at one
side, this is not possible without modifying the solver function. What
do to with a general mesh is an open question. To avoid changing the
code in what is meant to be a general PDE solver for a wide class of
problems, we need a different software design.

Such a different design is to introduce a problem class and
methods, supplied by the user from case to case, where boundary
conditions and other input data are defined. Such a design is used in
a lot of more advanced FEniCS application codes, and it is time to
exemplify it here.  As a counterpart to the solver function, we
introduce a solver class, but all the arguments for various input data
are instead method calls to an instance of a *problem class*. This
puts a somewhat greater burden on the programmer, but it allows for
more flexibility, and the code for, e.g., boundary conditions can be
more tailored to the problem at hand than the code we introduced in
the ``solver`` function in in [Ref1]_.

.. _ch:poisson0:refactor:class:solver:

The solver class          (1)
-----------------------------

The solver class will need problem information and for this purpose
call up the methods in a problem class. For example, the solver gets
the :math:`f` and :math:`\kappa` functions in the PDE problem by calling
the class methods
``problem.f_rhs()`` and ``problem.kappa_coeff()``. The mesh object and the
polynomial degree of the elements are supposed to be returned from
``problem.mesh_degree()``. Furthermore, the problem class defines the
boundary conditions in the problem as lists of minimal information
from which the solver can build proper data structures.

The solver class is a wrapping of the previous ``solver_bc`` and ``flux``
functions as methods in a class, but some of the code for handling
boundary conditions, previously inside the solver,
is now delegated to the user in the problem class.

.. code-block:: python

    from fenics import *
    import numpy as np
    
    class PoissonSolver(object):
        def __init__(self, problem, debug=False):
            self.problem = problem
            self.debug = debug
    
        def solve(self, linear_solver='direct'):
            Dirichlet_cond = self.problem.Dirichlet_conditions()
            self.mesh, degree = self.problem.mesh_degree()
            self.V = V = FunctionSpace(self.mesh, 'P', degree)
            if isinstance(Dirichlet_cond, (Expression)):
                # Just one Expression for Dirichlet conditions on
                # the entire boundary
                self.bcs = [DirichletBC(
                    V, Dirichlet_cond,
                    lambda x, on_boundary: on_boundary)]
            else:
                # Boundary SubDomain markers
                self.bcs = [
                    DirichletBC(V, value, boundaries, index)
                    for value, boundaries, index
                    in Dirichlet_cond]
    
            if self.debug:
                # Print the Dirichlet conditions
                print('No of Dirichlet conditions:', len(self.bcs))
                coor = self.mesh.coordinates()
                d2v = dof_to_vertex_map(V)
                for bc in self.bcs:
                    bc_dict = bc.get_boundary_values()
                    for dof in bc_dict:
                        print('dof %2d: u=%g' % (dof, bc_dict[dof]))
                        if V.ufl_element().degree() == 1:
                            print('   at point %s' %
                                  (str(tuple(coor[d2v[dof]].tolist()))))
            # Compute solution
            self.u = Function(self.V)
    
            if linear_solver == 'Krylov':
                solver_parameters = {'linear_solver': 'gmres',
                                     'preconditioner': 'ilu'}
            else:
                solver_parameters = {'linear_solver': 'lu'}
    
            self.define_variational_problem()
            solve(self.a == self.L, self.u, self.bcs,
                  solver_parameters=solver_parameters)
            return self.u
    
        def define_variational_problem(self):
            V = self.V
            u = TrialFunction(V)
            v = TestFunction(V)
            kappa = self.problem.kappa_coeff()
            f = self.problem.f_rhs()
            F = dot(kappa*grad(u), grad(v))*dx
            F -= f*v*dx
            F -= sum([g*v*ds_
                      for g, ds_ in self.problem.Neumann_conditions()])
            F += sum([r*(u-s)*ds_
                      for r, s, ds_ in self.problem.Robin_conditions()])
            self.a, self.L = lhs(F), rhs(F)
    
            if self.debug and V.dim() < 50:
                A = assemble(self.a)
                print('A:\n', A.array())
                b = assemble(self.L)
                print('b:\n', b.array())
    
        def flux(self):
            """Compute and return flux -kappa*grad(u)."""
            mesh = self.u.function_space().mesh()
            degree = self.u.ufl_element().degree()
            V_g = VectorFunctionSpace(mesh, 'P', degree)
            kappa = self.problem.kappa_coeff()
            self.flux_u = project(-kappa*grad(self.u), V_g)
            self.flux_u.rename('flux(u)', 'continuous flux field')
            return self.flux_u
    
    class PoissonProblem(object):
        """Abstract base class for problems."""
        def solve(self, linear_solver='direct',
                  abs_tol=1E-6, rel_tol=1E-5, max_iter=1000):
            self.solver = PoissonSolver(self)
            prm = parameters['krylov_solver'] # short form
            prm['absolute_tolerance'] = abs_tol
            prm['relative_tolerance'] = rel_tol
            prm['maximum_iterations'] = max_iter
            return self.solver.solve(linear_solver)
    
        def solution(self):
            return self.solver.u
    
        def mesh_degree(self):
            """Return mesh, degree."""
            raise NotImplementedError('Must implement mesh!')
    
        def kappa_coeff(self):
            return Constant(1.0)
    
        def f_rhs(self):
            return Constant(0.0)
    
        def Dirichlet_conditions(self):
            """Return list of (value,boundary_parts,index) triplets,
            or an Expression (if Dirichlet values only)."""
            return []
    
        def Neumann_conditions(self):
            """Return list of (g,ds(n)) pairs."""
            return []
    
        def Robin_conditions(self):
            """Return list of (r,u,ds(n)) triplets."""
            return []

Note that this is a general Poisson solver that works in any number
of space dimensions and with any mesh and composition of boundary conditions!


.. admonition:: Tip: Be careful with the ``mesh`` variable

   In classes, one often stores the mesh in ``self.mesh``. When you need
   the mesh, it is easy to write just ``mesh``, but this gives rise to
   peculiar error messages, since ``mesh`` is a Python module imported
   by ``from fenics import *`` and already available as a name in your file.
   When encountering strange error messages in statements containing a
   variable ``mesh``, make sure you use ``self.mesh``.
   
   Many will instead recommend to avoid the ``from fenics import *``
   statement and instead do ``import fenics`` and prefix all FEniCS
   objects by ``fenics``. This is the good programming habit in a
   Python library that employs the ``fenics`` package.




.. _ch:poisson0:refactor:class:problem0:

A problem class
---------------

Let us start with a relatively simple problem class for our favorite
test problem where we manufacture a solution :math:`u_{_\mathrm{D}}=1+x^2 + 2y^2` and
solve :math:`-\nabla^2 u = f` with :math:`f=6` and :math:`u=u_{_\mathrm{D}}` at the entire boundary.

.. code-block:: python

    class TestProblemExact(PoissonProblem):
        def __init__(self, Nx, Ny):
            """Initialize mesh, boundary parts, and p."""
            self.mesh = UnitSquareMesh(Nx, Ny)
            self.u_D = Expression('1 + x[0]*x[0] + 2*x[1]*x[1]')
    
        def mesh_degree(self):
            return self.mesh, 1
    
        def f_rhs(self):
            return Constant(-6.0)
    
        def Dirichlet_conditions(self):
            return self.u_D

We can then make a simple unit test for the problem and solver class:

.. code-block:: python

    def test_PoissonSolver():
        """Recover numerial solution to "machine precision"."""
        problem = TestProblemExact(Nx=2, Ny=2)
        problem.solve(linear_solver='direct')
        u = problem.solution()
        u_e = interpolate(problem.u_D, u.function_space())
        max_error = np.abs(u_e.vector().array() -
                           u.vector().array()).max()
        tol = 1E-14
        assert max_error < tol, 'max error: %g' % max_error

.. _ch:poisson0:refactor:class:problem1:

A more complicated problem class
--------------------------------

Below is the specific problem class for solving a scaled 2D Poisson
problem.  We have a two-material domain where a rectangle
:math:`[0.3,0.7]\times [0.3,0.7]` is embedded in the unit square and where
:math:`p` has a constant value inside the rectangle and another value
outside. On :math:`x=0` and :math:`x=1` we have homogeneous Neumann conditions,
and on :math:`y=0` and :math:`y=1` we have the Dirichlet conditions :math:`u=1` and
:math:`u=0`, respectively.

.. code-block:: python

    class Problem1(PoissonProblem):
        """
        -div(kappa*grad(u)=f on the unit square.
        General Dirichlet, Neumann, or Robin condition along each
        side. Can have multiple subdomains with kappa constant in
        each subdomain.
        """
        def __init__(self, Nx, Ny):
            """Initialize mesh, boundary parts, and kappa."""
            self.mesh = UnitSquareMesh(Nx, Ny)
    
            tol = 1E-14
    
            class BoundaryX0(SubDomain):
                def inside(self, x, on_boundary):
                    return on_boundary and abs(x[0]) < tol
    
            class BoundaryX1(SubDomain):
                def inside(self, x, on_boundary):
                    return on_boundary and abs(x[0] - 1) < tol
    
            class BoundaryY0(SubDomain):
                def inside(self, x, on_boundary):
                    return on_boundary and abs(x[1]) < tol
    
            class BoundaryY1(SubDomain):
                def inside(self, x, on_boundary):
                    return on_boundary and abs(x[1] - 1) < tol
    
            # Mark boundaries
            #self.boundary_parts = FacetFunction('size_t', mesh)
            self.boundary_parts = FacetFunction('uint', self.mesh)
            self.boundary_parts.set_all(9999)
            self.bx0 = BoundaryX0()
            self.bx1 = BoundaryX1()
            self.by0 = BoundaryY0()
            self.by1 = BoundaryY1()
            self.bx0.mark(self.boundary_parts, 0)
            self.bx1.mark(self.boundary_parts, 1)
            self.by0.mark(self.boundary_parts, 2)
            self.by1.mark(self.boundary_parts, 3)
            self.ds =  Measure(
                'ds', domain=self.mesh,
                subdomain_data=self.boundary_parts)
    
            # The domain is the unit square with an embedded rectangle
            class Rectangle(SubDomain):
                def inside(self, x, on_boundary):
                    return 0.3 <= x[0] <= 0.7 and 0.3 <= x[1] <= 0.7
    
            self.materials = CellFunction('size_t', self.mesh)
            self.materials.set_all(0)  # "the rest"
            subdomain = Rectangle()
            subdomain.mark(self.materials, 1)
            self.V0 = FunctionSpace(self.mesh, 'DG', 0)
            self.kappa = Function(self.V0)
            # Vectorized computations of dofs for kappa
            help = np.asarray(self.materials.array(), dtype=np.int32)
            kappa_values = [1, 1E-3]
            self.kappa.vector()[:] = np.choose(help, kappa_values)
    
        def mesh_degree(self):
            return self.mesh, 2
    
        def kappa_coeff(self):
            return self.kappa
    
        def f_rhs(self):
            return Constant(0)
    
        def Dirichlet_conditions(self):
            """Return list of (value,boundary) pairs."""
            return [(1.0, self.boundary_parts, 2),
                    (0.0, self.boundary_parts, 3)]
    
        def Neumann_conditions(self):
            """Return list of g*ds(n) values."""
            return [(0, self.ds(0)), (0, self.ds(1))]

A specific problem can be solved by

.. code-block:: python

    def demo():
        problem = PoissonProblem1(Nx=20, Ny=20)
        problem.solve(linear_solver='direct')
        u = problem.solution()
        u.rename('u', 'potential')  # name 'u' is used in plot
        plot(u)
        flux_u = problem.solver.flux()
        plot(flux_u)
        vtkfile = File('poisson.pvd')
        vtkfile << u
        interactive()

The complete code is found in the file ``ft10_poisson_class.py``.


.. admonition:: Pros and cons of solver/problem classes vs solver function

   What are the advantages of class ``Solver`` and ``Problem`` over the
   function implementation treated previously?
   The primary advantage is that
   the class version works for any mesh and any composition of
   boundary conditions, while the solver function is tied to a mesh
   over the unit square, only one type of boundary condition on a
   each side, and a piecewise constant :math:`p` function. The programmer has
   to supply more code in the class version, but gets greater flexibility.
   The disadvantage of the class version is that it applies the class
   concept so one needs experience with Python class programming.
   
   If you solve a specific PDE problem by FEniCS and want to make your
   code available on the Internet, you are most likely better off with
   offering a class-based solution, since that code can be used with any
   mesh and is easier adapted to the user's requirements.




.. _ch:diffusion:refactor:

Refactoring a heat equation solver
==================================

The flat program for the diffusion solver in ``ft03_heat.py`` and
``ft11_heat2.py`` was refactored in ``ft12_heat_func.py`` in
terms of a ``solver`` function with the general code for solving the PDE
problem, a callback function for processing the solution at each time
step, and an application function defining the callback function and
calling the solver to solve a specific problem. However, for
time-dependent problems a solver function that gets all its input
through a set of arguments is less flexible than a solver class, which
can demand its input both through arguments and through functions (in
subclasses) provided by the user. The following text employs the ideas
of a problem and solver class from the section :ref:`ch:poisson0:refactor:class`, but now generalized to a
time-dependent problem, which brings in some more advanced aspects.

.. When we work with a PDE project, we often want to explore a range of

.. similar problems where the PDE model basically stays the same, but

.. coefficients in the PDE, boundary and initial conditions, as well as

.. domains change.  This means that some of our code related to solving

.. the PDE is always the same, while some of our code is strongly

.. dependent upon a particular application. To avoid copying code (which

.. is considered evil in computer programming), we need to collect the

.. common code for all problems of this type in one place and then create

.. an API (application programming interface) to the code that will be

.. different from application to application. To this end, we introduce a

.. *solver class* that applies FEniCS to solve the PDE. It requires

.. access to a *problem class* where all the application-specific details

.. are defined. This problem class defines an API that the solver class

.. applies for communication.

The solver class will usually have a function to set up data
structures for the variational formulation, a ``step`` function to
advance the solution one time step, and a ``solve`` function to run the
time loop. Every time the solver class needs problem-specific
information, it gets that information from the problem class, either
in terms of attributes (variables) in the problem class or in terms of
method (function) calls. The forthcoming examples are tied to the
diffusion equation, but should be sufficiently general to be reused
for most time-dependent FEniCS applications.

.. --- begin exercise ---

Problem 1: Find error in implementation
---------------------------------------

For those who are familiar with object-oriented programming, this is
seemingly a very simple exercise, but it makes sure you understand
class hierarchies and the associated program flow, so that you
are prepared to read the forthcoming text on solver and problem
classes.  The exercise also points out a very common bug in that
context. If you have problems with this exercise, we advise you to
read more about classes in Python (e.g., Chapter 7 and 9 in
[Ref4]_), before you continue reading with the present book.

Somebody has made a class ``Line`` for straight lines :math:`y=ax+b`
where :math:`a` and :math:`b` are meant to be defined in subclasses by the
methods ``constant`` and ``steepness_factor``, respectively.

.. code-block:: python

    class Line(object):
        def __call__(self, x):
            return self.constant() + self.steepness_factor()*x
    
        def constant(self):
            return 1.0
    
        def steepness_factor(self):
            return 1.0
    
    class MyLine(Line):
        def steepness_factor(self):
            return -0.2
    
    line = MyLine()
    x = 2
    print('x=%g, y=%g' % (x, line(x)))

**a)**
Simulate the program above by hand. Make sure you understand the program
flow.

.. --- begin solution of exercise ---

**Solution.**

.. index:: Online Python Tutor

A nice tool to follow the program flow in simple programs is the
`Online Python Tutor <http://pythontutor.com/visualize.html#mode=edit>`__.

.. raw:: html

    <iframe width="950" height="500" frameborder="0"
            src="http://pythontutor.com/iframe-embed.html#code=from+__future__+import+print_function%0A%0Aclass+Line%28object%29%3A%0A++++def+__call__%28self%2C+x%29%3A%0A++++++++return+self.constant%28%29+%2B+self.steepness_factor%28%29%2Ax%0A%0A++++def+constant%28self%29%3A%0A++++++++return+1.0%0A%0A++++def+steepness_factor%28self%29%3A%0A++++++++return+1.0%0A%0Aclass+MyLine%28Line%29%3A%0A++++def+steepness_factor%28self%29%3A%0A++++++++return+-0.2%0A%0Aline+%3D+MyLine%28%29%0Ax+%3D+2%0Aprint%28%27x%3D%25g%2C+y%3D%25g%27+%25+%28x%2C+line%28x%29%29%29&curInstr=0&py=2&cumulative=false">
    </iframe>

The Online Python Tutor is fine for simple test programs, but one cannot
use third-party Python modules. If that is required,
a debugger must be used. It is
visually less pleasant for following program flow, but will always
be applicable.

The program flow begins at the top of the file and goes down line by
line. First is the definition of the two classes. Then we have the
first line in the main program: ``line = MyLine()``.  There is no
constructor in class ``MyLine``, but it could be inherited from the
parent class ``Line``. However, there is neither any constructor in
``Line``.  In such cases, Python equips the ``Line`` class with an empty
constructor as we had made an ``__init__(self)`` method with just ``pass``
as body. This constructor is called by ``MyLine()``.  It makes ``line``
refer to an instance of class ``MyLine``.

In the print statement, one needs to fill the string with
numbers, and after ``x`` is inserted, the call ``line(x)`` is performed.
Since ``line`` is an object of type ``MyLine``, a function call
like ``line(x)`` is legal if the class has a special method
``__call__``. This is the case, since class ``MyLine`` inherits
``__call__`` from the parent class ``Line``.
The program flow moves to ``Line.__call__`` where we first call
``self.constant()``. Since the ``self`` object is of type ``MyLine``,
this means we call ``MyLine.constant``, but there is no ``constant``
method in ``MyLine``, meaning that it just inherits the ``constant``
method from ``Line``. Consequently, ``Line.constant`` is called and
returns 1.0. The next call is to ``MyLine.steepness_factor``, and
this method is implemented in class ``MyLine`` and returns -0.2.
In ``Line.__call__`` we then evaluate ``1.0 + (-0.2)*x``, which
results in 0.4 when ``x`` is 2.

.. --- end solution of exercise ---

**b)**
Somebody makes another subclass:

.. code-block:: python

    class YourLine(MyLine):
        def steepnes_factor(self):
            return 2
    
    line = YourLine()
    x = 2
    print('x=%g, y=%g' % (x, line(x)))

However, this time the printout is ``x=2, y=0.4``, while it should be
``x=2, y=5``. Where is the error?

.. --- begin solution of exercise ---

**Solution.**
Doing this by hand might not be successful due to the nature of the error.
It is probably better to use the Online Python Tutor or a debugger.

.. raw:: html

    <iframe width="950" height="500" frameborder="0"
            src="http://pythontutor.com/iframe-embed.html#code=from+__future__+import+print_function%0A%0Aclass+Line%28object%29%3A%0A++++def+__call__%28self%2C+x%29%3A%0A++++++++return+self.constant%28%29+%2B+self.steepness_factor%28%29%2Ax%0A%0A++++def+constant%28self%29%3A%0A++++++++return+1.0%0A%0A++++def+steepness_factor%28self%29%3A%0A++++++++return+1.0%0A%0Aclass+MyLine%28Line%29%3A%0A++++def+steepness_factor%28self%29%3A%0A++++++++return+-0.2%0A%0Aclass+YourLine%28MyLine%29%3A%0A++++def+steepnes_factor%28self%29%3A%0A++++++++return+2%0A%0Aline+%3D+YourLine%28%29%0Ax+%3D+2%0Aprint%28%27x%3D%25g%2C+y%3D%25g%27+%25+%28x%2C+line%28x%29%29%29&curInstr=0&py=2&cumulative=false">
    </iframe>

The problem is that when the method ``Line.__call__`` tries to call
the method ``YourLine.steepness_factor``, it cannot find such a method in
``YourLine``, and instead if uses the inherited method ``Line.steepness_factor``,
which returns -0.2. The problem is that there is a misspelling: a
missing s in class ``YourLine``. This is a very common error that can be
hard to track down.

.. --- end solution of exercise ---

.. --- end exercise ---

.. _ch:diffusion:refactor:math:

Mathematical problem
--------------------

We address a variable-coefficient diffusion equation with Dirichlet,
Neumann, and Robin conditions:

.. _Eq:_auto3:

.. math::

    \tag{7}
    \varrho c{\partial u\over\partial t} = \nabla\cdot\left( \kappa\nabla u\right)
        + f(\boldsymbol{x},t)\hbox{ in }\Omega\times (0,T],
        
        

.. _Eq:_auto4:

.. math::

    \tag{8}
    u(\boldsymbol{x},0) = I\hbox{ on }\Omega,
        
        

.. _Eq:_auto5:

.. math::

    \tag{9}
    u = u_{_\mathrm{D}}(t)\hbox{ on }\Gamma_D,
        
        

.. _Eq:_auto6:

.. math::

    \tag{10}
    -\kappa{\partial u\over\partial n} = g\hbox{ on }\Gamma_N,
        
        

.. _Eq:_auto7:

.. math::

    \tag{11}
    -\kappa{\partial u\over\partial n} = r(u-U_s)\hbox{ on }\Gamma_R{\thinspace .}
        
        

The spatial domain :math:`\Omega` has boundary :math:`\partial\Omega = \Gamma_D\cup
\Gamma_N\cup\Gamma_R`. We shall assume that all coefficients :math:`\varrho`,
:math:`c`, :math:`\kappa` may vary in space, while :math:`f` and :math:`g` may vary in time too.
The coefficients :math:`r` and :math:`U_s` are assumed to depend on time only.

We discretize in time by the general :math:`\theta`-rule.  For an evolution
equation :math:`\partial P/\partial t=Q(t)`, this rule reads

.. math::
        
        {P^{n+1} - P^{n}\over{{\Delta t}}} = \theta Q^{n+1} + (1-\theta )Q^{n},
        

where :math:`\theta\in[0,1]` is a weighting factor. The attractive property
of this scheme is that :math:`\theta =1` corresponds
to the Backward Euler scheme, :math:`\theta =1/2` to the Crank-Nicolson
scheme, and :math:`\theta =0` to the Forward Euler scheme.

Introducing the :math:`\theta`-rule in our PDE results in

.. _Eq:ch:diffusion:refactor:math:problem:

.. math::

    \tag{12}
    \varrho c\frac{u^{n+1}-u^n}{{\Delta t}}
        = \theta(\nabla\cdot\left( \kappa\nabla u^{n+1}\right) + f(\boldsymbol{x},t_{n+1})) +
        (1-\theta)(\nabla\cdot\left( \kappa\nabla u^{n}\right) + f(\boldsymbol{x},t_{n})){\thinspace .}
        
        

A Galerkin method for this initial-boundary value problem consists
of multiplying :ref:`(12) <Eq:ch:diffusion:refactor:math:problem>` by
a test function :math:`v\in V`, integrate over :math:`\Omega`, and
perform integration by parts on the second-order derivative term
:math:`\nabla\cdot\left( \kappa\nabla u\right)`:

.. math::
        \begin{align*}
        \int\limits_\Omega \bigl(
        v\varrho c\frac{u^{n+1}-u^n}{{\Delta t}}{\, \mathrm{d}x}
        & + \theta \kappa\nabla u^{n+1}\cdot\nabla v - v\theta f(\boldsymbol{x},t_{n+1} \\ 
        & + (1-\theta) \kappa\nabla u^{n}\cdot\nabla v -
        v(1-\theta)f(\boldsymbol{x},t_{n}\bigr){\, \mathrm{d}x}\\ 
        & - \int\limits_{\Gamma_N\cup\Gamma_R}
        \bigl(\theta \kappa\frac{\partial u^{n+1}}{\partial n}v
        + (1-\theta) \kappa\frac{\partial u^{n}}{\partial n}v\bigr){\, \mathrm{d}s} = 0
        {\thinspace .}
        \end{align*}

Inserting the boundary conditions at :math:`\Gamma_N` and :math:`\Gamma_R`  gives
us

.. math::
        
        F(u;v) = \int\limits_\Omega \bigl(
        v\varrho c\frac{u^{n+1}-u^n}{{\Delta t}}{\, \mathrm{d}x}
        + \theta \kappa\nabla u^{n+1}\cdot\nabla v - v\theta f(\boldsymbol{x},t_{n+1}) \nonumber
        

.. math::
          
        \quad - (1-\theta) \kappa\nabla u^{n}\cdot\nabla v +
        v(1-\theta)f(\boldsymbol{x},t_{n}\bigr){\, \mathrm{d}x}\nonumber
        

.. math::
          
        \quad + \int\limits_{\Gamma_N}
        \bigl(\theta g(\boldsymbol{x},t_{n+1})v
        + (1-\theta) g(\boldsymbol{x},t_n)v\bigr){\, \mathrm{d}s}\nonumber
        

.. _Eq:ch:diffusion:refactor:math:varform0:

.. math::

    \tag{13}
    \quad + \int\limits_{\Gamma_R}
        \bigl(\theta r(u^{n+1} - U_s(t_{n+1}))v
        + (1-\theta) r(u^{n} - U_s(t_{n}))v\bigr){\, \mathrm{d}s}
        = 0{\thinspace .}
        
        

Since we use ``u`` for the unknown :math:`u^{n+1}` in the code, and ``u_n``
for :math:`u^n`, we introduce the same notation in the mathematics too:
:math:`u` for :math:`u^{n+1}` and :math:`u^n` for :math:`u^n`,

.. math::
        
        F(u;v) = \int\limits_\Omega \bigl(
        v\varrho c\frac{u-u^n}{{\Delta t}}{\, \mathrm{d}x}
        + \theta \kappa\nabla u\cdot\nabla v - v\theta f(\boldsymbol{x},t_{n+1}) \nonumber
        

.. math::
          
        \quad - (1-\theta) \kappa\nabla u^n\cdot\nabla v +
        v(1-\theta)f(\boldsymbol{x},t_{n}\bigr){\, \mathrm{d}x}\nonumber
        

.. math::
          
        \quad + \int\limits_{\Gamma_N}
        \bigl(\theta g(\boldsymbol{x},t_{n+1})v
        + (1-\theta) g(\boldsymbol{x},t_n)v\bigr){\, \mathrm{d}s}\nonumber
        

.. _Eq:ch:diffusion:refactor:math:varform:

.. math::

    \tag{14}
    \quad + \int\limits_{\Gamma_R}
        \bigl(\theta r(u - U_s(t_{n+1}))v
        + (1-\theta) r(u^n - U_s(t_{n}))v\bigr){\, \mathrm{d}s}
        = 0{\thinspace .}
        
        

The variational formulation is then: at each time level, find :math:`u\in V`
such that :math:`F(u;v)=0\ \forall v\in V`.  We do not need to identify
the bilinear and linear terms in the expression :math:`F` since we can use
the ``lhs`` and ``rhs`` functions for this purpose in the code.  However,
we should be very convinced that we have a *linear* variational
problem at hand and not a nonlinear one.

.. _ch:diffusion:refactor:class_solver:

Superclass for problems
-----------------------

The solver class contains the data structures
and actions from previous programs, but needs to ask the problem class
about the mesh, boundary conditions, the time step, and so forth. We
therefore need to define the API of the problem class first so we know
how the solver class can ask for the mesh, for instance.

Here is an abstract problem class:

.. code-block:: python

    class DiffusionProblem(object):
        """Abstract base class for specific diffusion applications."""
    
        def solve(self, solver_class=DiffusionSolver,
                  theta=0.5, linear_solver='direct',
                  abs_tol=1E-6, rel_tol=1E-5, max_iter=1000):
            """Solve the PDE problem for the primary unknown."""
            self.solver = solver_class(self, theta)
            iterative_solver = KrylovSolver('gmres', 'ilu')
            prm = iterative_solver.parameters
            prm['absolute_tolerance'] = abs_tol
            prm['relative_tolerance'] = rel_tol
            prm['maximum_iterations'] = max_iter
            prm['nonzero_initial_guess'] = True  # Use u (last sol.)
            return self.solver.solve()
    
        def flux(self):
            """Compute and return flux -p*grad(u)."""
            degree = self.solution().ufl_element().degree()
            V_g = VectorFunctionSpace(self.mesh, 'P', degree)
            flux_u = -self.heat_conduction()*grad(self.solution())
            self.flux_u = project(flux_u, V_g)
            self.flux_u.rename('flux(u)', 'continuous flux field')
            return self.flux_u
    
        def mesh_degree(self):
            """Return mesh, degree."""
            raise NotImplementedError('Must implement mesh')
    
        def I(self):
            """Return initial condition."""
            return Constant(0.0)
    
        def heat_conduction(self):  # kappa
            return Constant(1.0)
    
        def density(self):          # rho
            return Constant(1.0)
    
        def heat_capacity(self):    # c
            return Constant(1.0)
    
        def heat_source(self, t):   # f
            return Constant(0.0)
    
        def time_step(self, t):
            raise NotImplentedError('Must implement time_step')
    
        def end_time(self):
            raise NotImplentedError('Must implement end_time')
    
        def solution(self):
            return self.solver.u
    
        def user_action(self, t, u):
            """Post process solution u at time t."""
            pass
    
        def Dirichlet_conditions(self, t):
            """Return either an Expression (for the entire boundary) or
            a list of (value,boundary_parts,index) triplets."""
            return []
    
        def Neumann_conditions(self, t):
            """Return list of (g,ds(n)) pairs."""
            return []
    
        def Robin_conditions(self, t):
            """Return list of (r,s,ds(n)) triplets."""
            return []

The meaning of the different methods in this class will be evident as
we present specific examples on implementations.

The idea now is that different problems are implemented as different
subclasses of ``DiffusionProblem``. The ``solve`` and ``flux`` methods are
general and can be inherited, while the rest of the methods must be
implemented in the subclass for the particular problem at hand.

A specific problem class
------------------------

As a simple example, consider the test problem where we have a
manufactured solution :math:`u=1+x^2 + \alpha y^2 + \beta t` on
a uniform mesh over the unit square or cube, with Dirichlet conditions
on the entire boundary. Suppose we have :math:`{\Delta t}=0.3` and
want to simulate for :math:`t\in [0,0.9]`. A problem class is then

.. code-block:: python

    class TestProblemExact(DiffusionProblem):
        def __init__(self, Nx, Ny, Nz=None, degree=1, num_time_steps=3):
            if Nz is None:
                self.mesh = UnitSquareMesh(Nx, Ny)
            else:
                self.mesh = UnitCubeMesh(Nx, Ny, Nz)
            self.degree = degree
            self.num_time_steps = num_time_steps
    
            alpha = 3; beta = 1.2
            self.u0 = Expression(
                '1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                alpha=alpha, beta=beta, t=0)
            self.f = Constant(beta - 2 - 2*alpha)
    
        def time_step(self, t):
            return 0.3
    
        def end_time(self):
            return self.num_time_steps*self.time_step(0)
    
        def mesh_degree(self):
            return self.mesh, self.degree
    
        def I(self):
            """Return initial condition."""
            return self.u0
    
        def heat_source(self, t):
            return self.f
    
        def Dirichlet_conditions(self, t):
            self.u0.t = t
            return self.u0
    
        def user_action(self, t, u, timestep):
            """Post process solution u at time t."""
            u_e = interpolate(self.u0, u.function_space())
            error = np.abs(u_e.vector().array() -
                           u.vector().array()).max()
            print('error at %g: %g' % (t, error))
            tol = 2E-11
            assert error < tol, 'max_error: %g' % error

Remember that we can inherit all methods from the parent class that are
appropriate for the problem at hand.

Our test problem can now be solved in (e.g.) a unit test like

.. code-block:: python

    def test_DiffusionSolver():
        problem = TestProblemExact(Nx=2, Ny=2)
        problem.solve(theta=1, linear_solver='direct')
        u = problem.solution()

The solver class will call the ``user_action`` function at every time level,
and this function will assert that we recover the solution to machine precision.

The solver class          (2)
-----------------------------

The solver class, here based on the :math:`\theta`-rule and the
variational formulation from the previous section, can be coded as
follows:

.. code-block:: python

    class DiffusionSolver(object):
        """Solve a heat conduction problem by the theta-rule."""
        def __init__(self, problem, theta=0.5):
            self.problem = problem
            self.theta = theta
    
        def solve(self):
            """Run time loop."""
            tol = 1E-14
            T = self.problem.end_time()
            t = self.problem.time_step(0)
            self.initial_condition()
            timestep = 1
    
            while t <= T+tol:
                self.step(t)
                self.problem.user_action(t, self.u, timestep)
    
                # Updates
                self.dt = self.problem.time_step(
                    t+self.problem.time_step(t))
                t += self.dt
                timestep += 1
                self.u_1.assign(self.u)
    
        def initial_condition(self):
            self.mesh, degree = self.problem.mesh_degree()
            self.V = V = FunctionSpace(self.mesh, 'P', degree)
    
            if hasattr(self.problem, 'I_project'):
                I_project = getattr(self.problem, 'I_project')
            else:
                I_project = False
            self.u_1 = project(self.problem.I(), V) if I_project \ 
                       else interpolate(self.problem.I(), V)
            self.u_1.rename('u', 'initial condition')
            self.u = self.u_1 # needed if flux is computed in the next step
            self.problem.user_action(0, self.u_1, 0)
    
        def step(self, t, linear_solver='direct',
                 abs_tol=1E-6, rel_tol=1E-5, max_iter=1000):
            """Advance solution one time step."""
            # Find new Dirichlet conditions at this time step
            Dirichlet_cond = self.problem.Dirichlet_conditions(t)
            if isinstance(Dirichlet_cond, Expression):
                # Just one Expression for Dirichlet conditions on
                # the entire boundary
                self.bcs = [DirichletBC(
                    self.V, Dirichlet_cond,
                    lambda x, on_boundary: on_boundary)]
            else:
                # Boundary SubDomain markers
                self.bcs = [
                    DirichletBC(self.V, value, boundaries, index)
                    for value, boundaries, index
                    in Dirichlet_cond]
    
            #debug_Dirichlet_conditions(self.bcs, self.mesh, self.V)
    
            self.define_variational_problem(t)
            a, L = lhs(self.F), rhs(self.F)
            A = assemble(a)
            b = assemble(L)
    
            [bc.apply(A, b) for bc in self.bcs]
            if self.V.dim() < 50:
                print('A:\n', A.array(), '\nb:\n', b.array())
    
            # Solve linear system
            if linear_solver == 'direct':
                solve(A, self.u.vector(), b)
            else:
                solver = KrylovSolver('gmres', 'ilu')
                solver.solve(A, self.u.vector(), b)
    
        def define_variational_problem(self, t):
            """Set up variational problem at time t."""
            u = TrialFunction(self.V)
            v = TestFunction(self.V)
    
            dt     = self.problem.time_step(t)
            kappa  = self.problem.heat_conduction()
            varrho = self.problem.density()
            c      = self.problem.heat_capacity()
            f      = self.problem.heat_source(t)
            f_1    = self.problem.heat_source(t-dt)
    
            theta = Constant(self.theta)
            u_n = self.u_1  # first computed in initial_condition
    
            F = varrho*c*(u - u_n)/dt*v
            F += theta    *dot(kappa*grad(u),   grad(v))
            F += (1-theta)*dot(kappa*grad(u_n), grad(v))
            F -= theta*f*v + (1-theta)*f_1*v
            F = F*dx
            F += theta*sum(
                [g*v*ds_
                 for g, ds_ in self.problem.Neumann_conditions(t)])
            F += (1-theta)*sum(
                [g*v*ds_
                 for g, ds_ in self.problem.Neumann_conditions(t-dt)])
            F += theta*sum(
                [r*(u - U_s)*v*ds_
                 for r, U_s, ds_ in self.problem.Robin_conditions(t)])
            F += (1-theta)*sum(
                [r*(u - U_s)*v*ds_
                 for r, U_s, ds_ in self.problem.Robin_conditions(t-dt)])
            self.F = F
    
            self.u = Function(self.V)
            self.u.rename('u', 'solution')

Applications to heat conduction
===============================

We shall now through some real physical examples show how the problem
classes can be constructed for various types of applications.
The goal is to achieve PDE solvers that are flexible and convenient for
performing scientific investigations.

Thermal boundary layer
----------------------

Assume we have some medium at temperature :math:`U_s` and then we suddenly
heat one end so the temperature here stays constant at :math:`U_1`. At the
other end we have some equipment to keep the temperature constant at
:math:`U_s`. The other boundaries are insulated so heat cannot escape.
There are no heat sources.  How is the temperature development
in the material due to such sudden heating of one end?
Figure :ref:`ch:diffusion:refactor:class_solver:fig4` sketches the
situation (with a scaled variable :math:`u` that jumps from 0 to 1).

.. Program for the sketch below: fig/thermal_layer1.py

.. _ch:diffusion:refactor:class_solver:fig4:

.. figure:: thermal_layer1_sketch.png
   :width: 500

   *Domain with (scaled) boundary conditions: sudden jump in :math:`u` at the left boundary*

Mathematics
~~~~~~~~~~~

The problem is mathematically one-dimensional, so it means that if we
create a 2D or 3D domain, the boundaries in :math:`y` and :math:`z` directions are
insulated (requiring :math:`\partial u/\partial n=0` as boundary condition
on :math:`y=\mathrm{const}` and :math:`z=\mathrm{const}`).
The heating is applied to :math:`x=0` and :math:`x=L`.

It is natural to scale the problem by introducing dimensionless
independent and dependent variables:

.. math::
         \bar x = \frac{x}{L},\quad \bar y = \frac{y}{L},\quad
        \bar u = \frac{u-U_s}{U_1-U_s},\quad \bar t = \frac{t}{t_c}{\thinspace .}

The suggested scaling for :math:`u` makes a simple boundary condition at :math:`x=0`:
:math:`\bar u = 1`. This scaling also results in :math:`\bar u \in [0,1]` as is
always desired.

After inserting the dimensionless variables in the PDE, we demand the
time-derivative term and the heat conduction term to balance, and
find :math:`t_c` from that condition: :math:`t_c = \varrho c L^2/p`.

The spatial domain is the unit square. We introduce the boundaries
:math:`\Gamma_{D_1}` as the side :math:`x=0`, :math:`\Gamma_{D_2}` as the side :math:`x=1`,
and :math:`\Gamma_N` as the rest of the boundary.
The scaled initial-boundary problem can be written as

.. _Eq:_auto8:

.. math::

    \tag{15}
    \frac{\partial\bar u}{\partial\bar t} = \bar\nabla^2\bar u\hbox{ in }
        \Omega = (0,1)\times (0,1)\times (0,T],
        
        

.. _Eq:_auto9:

.. math::

    \tag{16}
    \bar u(\boldsymbol{x}, 0) = 0\hbox{ in }\Omega,
        
        

.. _Eq:_auto10:

.. math::

    \tag{17}
    \bar u = 1\hbox{ at } \Gamma_{D_1},
        
        

.. _Eq:_auto11:

.. math::

    \tag{18}
    \bar u = 0\hbox{ at } \Gamma_{D_2},
        
        

.. _Eq:_auto12:

.. math::

    \tag{19}
    \frac{\partial\bar u}{\partial\bar n} = 0\hbox{ at }\Gamma_N{\thinspace .}
        
        

FEniCS implementation          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can solve our problem with the general problem and solver
classes by setting :math:`\varrho = c= p = 1`,
and :math:`I=0`. The most labor-intensive part of the problem class is
the visualization. We can create a helper class, ``ProcessSolution``,
which applies ``cbcpost`` to store the solution and perform animation
via the ``fenics.plot`` tool:

.. code-block:: python

    import cbcpost as post
    class ProcessSolution(object):
        """user_action function for storing the solution and flux."""
        def __init__(self, problem, u_min=0, u_max=1):
            """Define fields to be stored/plotted."""
            self.problem = problem  # this user_action belongs to problem
            self.pp = post.PostProcessor(
                dict(casedir='Results', clean_casedir=True))
    
            self.pp.add_field(
                post.SolutionField(
                    'Solution',
                    dict(save=True,
                         save_as=['hdf5', 'xdmf'],  # format
                         plot=True,
                         plot_args=
                         dict(range_min=float(u_min),
                              range_max=float(u_max))
                         )))
    
            self.pp.add_field(
                post.SolutionField(
                    "Flux",
                    dict(save=True,
                         save_as=["hdf5", "xdmf"],  # format
                         )))
    
        def __call__(self, t, u, timestep):
            """Store u and its flux to file."""
            u.rename('u', 'Solution')
            self.pp.update_all(
                {'Solution': lambda: u,
                 'Flux': lambda: self.problem.flux()},
                t, timestep)
            info('saving results at time %g, max u: %g' %
                 (t, u.vector().array().max()))

In the ``user_action``
method, we use this tool to store the solution, but we also add
statements for plotting :math:`u` along a line from :math:`x=0` to :math:`x=1`
through the medium (:math:`y=0.5`). This gives an animation of
the temperature profile, but results in somewhat lengthy code.

To mark the boundaries, so we can set :math:`u=1` at :math:`x=0`, we can make a
function like ``mark_boundaries_in_hypercube`` as shown in
the section :ref:`ch:diffusion:opt:markboundary`.
Eventually, we are in a position to show the complete problem class:

.. code-block:: python

    class Problem1(DiffusionProblem):
        """Evolving boundary layer, I=0, but u=1 at x=0."""
        def __init__(self, Nx, Ny):
            self.make_mesh(self, Nx, Ny)
            # Storage and visualization
            self.user_action_object = \ 
                       ProcessSolution(self, u_min=0, u_max=1)
            # Compare u(x,t) as curve plots for the following times
            self.times4curveplots = [
                self.time_step(0), 4*self.time_step(0),
                8*self.time_step(0), 12*self.time_step(0),
                16*self.time_step(0), 0.02, 0.1, 0.2, 0.3]
            plt.ion()  # for animation
    
        def make_mesh(self, Nx, Ny):
            """Initialize mesh, boundary parts, and p."""
            print('XXX in Problem1.make_mesh')
            self.mesh = UnitSquareMesh(Nx, Ny)
            self.divisions = (Nx, Ny)
    
            self.boundary_parts = \ 
                 mark_boundaries_in_hypercube(self.mesh, d=2)
            self.ds =  Measure(
                'ds', domain=self.mesh,
                subdomain_data=self.boundary_parts)
    
        def time_step(self, t):
            # Small time steps in the beginning when the boundary
            # layer develops
            if t < 0.02:
                return 0.0005
            else:
                return 0.025
    
        def end_time(self):
            return 0.3
    
        def mesh_degree(self):
            return self.mesh, 1
    
        def Dirichlet_conditions(self, t):
            """Return list of (value,boundary) pairs."""
            return [(1.0, self.boundary_parts, 0),
                    (0.0, self.boundary_parts, 1)]
    
        def user_action(self, t, u, timestep):
            """Post process solution u at time t."""
            tol = 1E-14
            self.user_action_object(t, u, timestep)
            # Also plot u along line y=1/2
            x_coor = np.linspace(tol, 1-tol, 101)
            x = [(x_,0.5) for x_ in x_coor]
            u = self.solution()
            u_line = [u(x_) for x_ in x]
            # Animation in figure(1)
            plt.figure(1)
            if timestep == 0:
                self.lines = plt.plot(x_coor, u_line, 'b-')
                plt.legend(['u, t=%.4f' % t])
                plt.title('Solution along y=1/2, time step: %g' %
                          self.time_step(t))
                plt.xlabel('x'), plt.ylabel('u')
                plt.axis([0, 1, 0, 1])
                plt.savefig('tmp_%04d.png' % timestep)
            else:
                self.lines[0].set_ydata(u_line)
                plt.title('Solution along y=1/2, time step: %g' %
                          self.time_step(t))
                plt.draw()
                plt.savefig('tmp_%04d.png' % timestep)
            # Accumulated selected curves in one plot in figure(2)
            plt.figure(2)
            for t_ in self.times4curveplots:
                if abs(t - t_) < 0.5*self.time_step(t):
                    plt.plot(x_coor, u_line, '-')
                    plt.legend(['u, t=%.4f' % t])
                    plt.xlabel('x'); plt.ylabel('u')
                    plt.axis([0, 1, 0, 1])
                    plt.hold('on')

Notice our definition of the time step: because the growth of the
thin boundary layer close to :math:`x=0`
is very rapid for small times, we need to start with a small time
step. Nevertheless, the speed of the heat transfer slows down with time,
so we decide to use a longer time step after :math:`t=0.02`. The animation
would otherwise also be boring to watch, but be aware of the fact that
the apparent speed of the physical process is dramatically increased in the
animation at :math:`t=0.02`.

The problem is solved by

.. code-block:: python

    def demo_Problem1():
        problem = Problem1(Nx=20, Ny=5)
        problem.solve(theta=1, linear_solver='direct')
        plt.figure(2)
        plt.savefig('tmp1.png'); plt.savefig('tmp1.pdf')

Results          (1)
~~~~~~~~~~~~~~~~~~~~

Figure :ref:`ch:diffusion:refactor:class_solver:fig1` shows accumulated
curves (from ``plt.figure(2)``). The problem is a primary example on a
*thermal boundary layer*: the sudden rise in temperature at :math:`x=0` at
:math:`t=0` gives rise to a very steep function, and a thin boundary layer
that grows with time as heat is transported from the boundary into the
domain. The jump in the temperature profile at :math:`x=0` makes demands to
the numerical methods. Quite typically, a Crank-Nicolson scheme may
show oscillations (as we can see in the first curve) because of
inaccurate treatment of the shortest spatial waves in the Fourier
representation of the discrete solution.  The oscillations are removed
by doubling the spatial resolution from 20 to 40 elements in the :math:`x`
direction.  With :math:`\theta=1`, we never experience any oscillations, but
the boundary layer gets thicker and less accurate (smaller :math:`{\Delta t}` is
needed to compensate).  However, in this problem, we see from Figure
:ref:`ch:diffusion:refactor:class_solver:fig1` that the inaccuracy is
only visible for the very first time steps as the boundary layer is
thin.

.. _ch:diffusion:refactor:class_solver:fig1:

.. figure:: thermal_layer1.png
   :width: 800

   *Development of thermal boundary layer: Crank-Nicolson (left) and Backward Euler (right) schemes*

From all the plot frames with filenames ``tmp_%04d.png`` we may create
video files by

.. code-block:: text

    Terminal> ffmpeg -i tmp_%04d.png -r 25 -vcodec libx264   movie.mp4
    Terminal> ffmpeg -i tmp_%04d.png -r 25 -vcodec libtheora movie.ogg

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/thermal_layer1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            <source src='mov/thermal_layer1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
            <source src='mov/thermal_layer1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Developing thermal boundary layer (notice the jump in speed, i.e., time step!)</em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        

Extension to a heterogeneous medium
-----------------------------------

Suppose we now place another material inside the domain with other
values material properties (i.e., values of :math:`\varrho`, :math:`c`, and
:math:`p`).  The new material occupies the rectangle :math:`[0.3,0.7]\times
[0.3,0.7]` inside the scaled domain.  We also change the boundary
condition at :math:`x=1` to be "no change", i.e., :math:`\partial u/\partial
n=0`. Figure :ref:`ch:diffusion:refactor:class_solver:fig5` depicts the
problem.

.. Program for the sketch below: fig/thermal_layer1.py

.. _ch:diffusion:refactor:class_solver:fig5:

.. figure:: thermal_layer2_sketch.png
   :width: 500

   *Domain with internal subdomain and (scaled) boundary conditions*

Updated scaling
~~~~~~~~~~~~~~~

The former scaling is not completely valid as it was based on constant
:math:`\varrho`, :math:`c`, and :math:`p`. We now introduce

.. math::
         \bar\varrho = \frac{\varrho}{\varrho_0},\quad
        \bar c = \frac{c}{c_0},\quad \bar p = \frac{p}{p_0},

where :math:`\varrho_0` is the value of :math:`\varrho` in the outer material,
now to be known as subdomain 0.
A similar parameter :math:`\varrho_1` is the value of :math:`\varrho` inside
the new material, called subdomain 1.
The constants :math:`c_0`, :math:`p_0`, :math:`c_1`, and :math:`p_1` are
defined similarly. In subdomain 0, :math:`\bar\varrho = 1`, and in subdomain 1,
:math:`\bar\varrho = \varrho_1/\varrho_0`, with similar values for
:math:`\bar c` and :math:`\bar p`. The scaled PDE becomes

.. math::
         \bar\varrho\bar c\frac{\partial\bar u}{\partial\bar t}
         = \bar\nabla\cdot(\bar p\bar\nabla\bar u) + \bar f{\thinspace .}

We can call up the solver for the problem with dimensions as long
as we remember to set :math:`p = \varrho = c =1` in subdomain 0.
In subdomain 1, we divide by :math:`\bar\varrho = \varrho_1/\varrho_0`
and :math:`\bar c = c_1/c_0`, which results in a coefficient

.. math::
         \alpha = \frac{\varrho_0c_0p_1}{\varrho_1 c_1p_0} 

on the right-hand side. This means that we can let ``density`` and
``heat_capacity`` be of unit value and only operate with a spatially
varying :math:`p`, which takes on the values 1 in subdomain 0 and
:math:`\alpha` in subdomain 1. For simplicity, we just name this parameter
``kappa_values`` in the code.

[**hpl 3**: Is this trick too tricky? Would it be clearer to let all three parameters vary?]

The problem class          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The problem class is very similar to ``Problem1`` above, except for the
fact that we need to define the inner subdomain, we need to allow for
:math:`p` values in subdomain 0 and 1, the time points
for plots and time steps are a bit different, and the Dirichlet condition
only applies to :math:`x=0` (no need to implement the Neumann condition as
long as it is zero).

.. code-block:: python

    class Problem2(Problem1):
        """As Problem 1, but du/dn at x=1 and varying kappa."""
        def __init__(self, Nx, Ny, kappa_values, subdomain_corners):
            """
            Nx x Ny mesh. kappa_values=[1,a],
            subdomain_corners=[(0.3,0.3), (0.7,0.9)]
            """
            self.make_mesh(Nx, Ny, kappa_values, subdomain_corners)
            self.user_action_object = \ 
                       ProcessSolution(self, u_min=0, u_max=1)
            # Compare u(x,t) as curve plots for the following times
            self.times4curveplots = [
                12*self.time_step(0),
                0.02, 0.1, 0.3, 0.5]
            plt.ion()  # for animation
    
    
        def make_mesh(self, Nx, Ny, kappa_values, subdomain_corners):
            """Initialize mesh, boundary parts, and p."""
            self.mesh = UnitSquareMesh(Nx, Ny)
            self.divisions = (Nx, Ny)
    
            self.boundary_parts = \ 
                 mark_boundaries_in_hypercube(self.mesh, d=2)
            self.ds =  Measure(
                'ds', domain=self.mesh,
                subdomain_data=self.boundary_parts)
    
            # The domain is the unit square with an embedded rectangle
            class Rectangle(SubDomain):
                def __init__(self, subdomain_def):
                    self.subdomain_def = subdomain_def
                    SubDomain.__init__(self)
    
                def inside(self, x, on_boundary):
                    # subdomain_def:
                    # 0.3 <= x[0] <= 0.7 && 0.5 <= x[1] <= 0.9
                    return eval(self.subdomain_def)
    
            self.materials = CellFunction('size_t', self.mesh)
            self.materials.set_all(0)  # "the rest"
            # Give subdomain_corners as (c,c),(b,b)
            c = subdomain_corners
            subdomain_str = '%g <= x[0] <= %g and %g <= x[1] <= %g' % \ 
                            (c[0][0], c[1][0], c[0][1], c[1][1])
            #subdomain = CompiledSubDomain(subdomain_str.replace('and', '&&'))
            subdomain = Rectangle(subdomain_str)
            subdomain.mark(self.materials, 1)
            self.V0 = FunctionSpace(self.mesh, 'DG', 0)
            self.kappa = Function(self.V0)
            help = np.asarray(self.materials.array(), dtype=np.int32)
            self.kappa.vector()[:] = np.choose(help, kappa_values)
            plot(self.materials, title='Subdomain', interactive=True)
    
        def time_step(self, t):
            if t < 0.04:
                return 0.0005
            else:
                return 0.025
    
        def end_time(self):
            return 0.5
    
        def heat_conduction(self):
            return self.kappa
    
        def Dirichlet_conditions(self, t):
            """Return list of (value,boundary) pairs."""
            return [(1.0, self.boundary_parts, 0)]

Results          (2)
~~~~~~~~~~~~~~~~~~~~

We run a case where :math:`\alpha=1000`:

.. code-block:: python

    def demo_Problem2():
        problem = Problem2(Nx=20, Ny=5, kappa_values=[1,1000],
                  subdomain_corners=[(0.3,0.3), (0.7,0.7)])
        problem.solve(theta=0.5, linear_solver='direct')
        plt.figure(2)
        plt.savefig('tmp1.png'); plt.savefig('tmp1.pdf')

As shown in Figure :ref:`ch:diffusion:refactor:class_solver:fig2`,
the highly conductive inner material leads to a flat temperature profile
in this region. The start of the process is as before, but
with an insulated boundary at :math:`x=1`, heat builds up with time.
The limiting steady state is :math:`u=1` as :math:`t\rightarrow\infty`.

.. _ch:diffusion:refactor:class_solver:fig2:

.. figure:: thermal_layer2_CN20.png
   :width: 500

   *Development of thermal boundary layer in heterogeneous medium*

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/thermal_layer2/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            <source src='mov/thermal_layer2/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
            <source src='mov/thermal_layer2/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Developing thermal boundary layer in heterogeneous medium (notice the jump in speed, i.e., time step!)</em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        

Oscillating boundary temperature
--------------------------------

The next example concerns the question: How is the temperature in the
ground affected by day and night variations at the earth's surface?
We consider a rectangular domain with an embedded subdomain as in the
previous example. At the side :math:`y=1` (representing the earth's
surface), we have an oscillating temperature:

.. math::
         u_B(t) = U_s + A\sin(w t),

where :math:`U_s` is the mean temperature, :math:`[-A,A]` is the temperature variation,
and :math:`w` is the frequency, here equal to :math:`w=2\pi/P`, where :math:`P` is the
period of 24 h.

At the other boundaries we assume symmetry or "no change", which implies
:math:`\partial u/\partial n = 0`. The initial condition is taken as
:math:`u=U_s`, but any value will be lost in long time simulations as a
steady state oscillatory condition is established.
Figure :ref:`ch:diffusion:refactor:class_solver:fig6` shows the domain and
boundary conditions.

.. Program for the sketch below: fig/thermal_layer3.py

.. _ch:diffusion:refactor:class_solver:fig6:

.. figure:: thermal_layer3_scaling_sketch.png
   :width: 800

   *Domain with oscillating temperature at the boundary: unscaled (left) and scaled (left)*

Scaling
~~~~~~~

Now we expect :math:`u` to oscillate around :math:`U_s` with amplitude :math:`A`, so to
have :math:`\bar u\in [-1,1]`, we set

.. math::
         \bar u = \frac{u-U_s}{A}{\thinspace .}

The scaled boundary condition is then

.. math::
         \bar u_B(\bar t) = \sin(wt_c\bar t){\thinspace .}

We use a time scale based on :math:`w`, i.e., :math:`t_c=1/w`.
Chapter 3.2.4 in [Ref3]_ (see `ebook <http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book008.html#___sec142>`__)
has an in-depth
coverage of the scaling of this problem. The challenge is that
the temperature will oscillate close to :math:`y=1`, but the oscillations
will decay as we move downwards. One can for special set of parameters
get very thin oscillating boundary layers, which make great demands to
the numerical methods, or one may not achieve substantial decay
so the boundary condition on :math:`y=0` becomes wrong. To zoom in on the
solution in the right way,
it turns out that the right spatial length scale is
:math:`\sqrt{2p/(wc\varrho)}`. With this length scale, a typical
length of the domain in :math:`y` direction is 4.
The most appealing time scale is :math:`t_c=2/w`.

We end up with the same scaled problem as in the previous section,
except that at :math:`y=1` we have

.. math::
         \bar u_B(\bar t) = \sin(2\bar t){\thinspace .}

The problem class          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We need a different reasoning about the time steps size since this is an
oscillatory problem. We also need to stretch the unit square so it becomes
:math:`[0,4]\times [0,4]` as desired. In addition, we need to change the Dirichlet
condition. And finally, we need to adjust the curve plotting
as it now takes place in :math:`y` direction, and the axes are different.
Much of class ``Problem2`` can be reused, so it makes sense to make
a subclass and override the methods that do not fit.

.. code-block:: python

    class Problem3(Problem2):
        """Oscillating surface temperature."""
        def __init__(self, Nx, Ny, kappa_values, subdomain_corners):
            # Oscillating temperature at x=0:
            self.surface_temp = lambda t: sin(2*t)
            w = 2.0
            period = 2*np.pi/w
            self.dt = period/30  # need this before Problem2.__init__
            self.T = 4*period
    
            Problem2.__init__(
                self, Nx, Ny, kappa_values, subdomain_corners)
            # Stretch the mesh in y direction so we get [0,4]x[0,4]
            self.mesh.coordinates()[:] *= 4
    
            self.user_action_object = \ 
                       ProcessSolution(self, u_min=-1, u_max=1)
            # Compare u(x,t) as curve plots for the following times
            self.times4curveplots = [
                period/4, 4*period/8, 3*period/4, 3*period]
    
        def time_step(self, t):
            return self.dt
    
        def end_time(self):
            return self.T
    
        def Dirichlet_conditions(self, t):
            """Return list of (value,boundary) pairs."""
            return [(self.surface_temp(t), self.boundary_parts, 3)]
    
        def user_action(self, t, u, timestep):
            """Post process solution u at time t."""
            tol = 1E-14
            self.user_action_object(t, u, timestep)
            # Also plot u along line x=2
            y_coor = np.linspace(tol, 4-tol, 101)
            y = [(2, y_) for y_ in y_coor]
            u = self.solution()
            u_line = [u(y_) for y_ in y]
            # Animation in figure(1)
            plt.figure(1)
            if timestep == 0:
                self.lines = plt.plot(y_coor, u_line, 'b-')
                plt.legend(['u, t=%.4f' % t])
                plt.title('Solution along x=2, time step: %g' %
                          self.time_step(t))
                plt.xlabel('y'); plt.ylabel('u')
                plt.axis([0, 4, -1.2, 1.2])
                plt.savefig('tmp_%04d.png' % timestep)
            else:
                self.lines[0].set_ydata(u_line)
                plt.title('Solution along x=2, time step: %g' %
                          self.time_step(t))
                plt.draw()
                plt.savefig('tmp_%04d.png' % timestep)
    
            # Accumulated selected curves in one plot in figure(2)
            plt.figure(2)
            for t_ in self.times4curveplots:
                if abs(t - t_) < 0.5*self.time_step(t):
                    plt.plot(y_coor, u_line, '-')
                    plt.legend(['u, t=%.4f' % t])
                    plt.xlabel('y'); plt.ylabel('u')
                    plt.axis([0, 4, -1.2, 1.2])
                    plt.hold('on')

The problem is solved by

.. code-block:: python

    def demo_Problem3():
        problem = Problem3(Nx=5, Ny=20, kappa_values=[1, 1000],
                  subdomain_corners=[(0.3,0.4), (0.7,0.8)])
        problem.solve(theta=0.5, linear_solver='direct')
        plt.figure(2)
        plt.savefig('tmp1.png'); plt.savefig('tmp1.pdf')

Results          (3)
~~~~~~~~~~~~~~~~~~~~

We have made runs with a homogeneous medium and with a heterogeneous medium
(using :math:`\alpha=1000` as in the previous section). Animation in ParaView
meets the problem that :math:`u=\hbox{const}` initially so we must manually set a
range for the data. Bring up the Color Map Editor (click on **Edit** in
the *Coloring* section in the left part of the GUI), click on the second
icon from the top, to "rescale the custom range", give -1 and 1
as the data range, and click **Update** to bring this range into action.

.. _ch:diffusion:refactor:class_solver:fig3:

.. figure:: thermal_layer4.png
   :width: 800

   *Oscillating boundary temperature: homogeneous (left) and heterogeneous (right) medium*

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/thermal_layer3/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            <source src='mov/thermal_layer3/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
            <source src='mov/thermal_layer3/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Oscillating boundary temperature and homogeneous medium.</em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/thermal_layer4/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            <source src='mov/thermal_layer4/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
            <source src='mov/thermal_layer4/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Oscillating boundary temperature and heterogeneous medium.</em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/thermal_layer3/paraview.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Scalar field animation (homogeneous medium).</em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        


.. admonition:: Tip: Let related problem classes utilize inheritance

   The last three examples regard quite related problems, yet they have
   substantial differences. The typical approach to making FEniCS software
   to these applications would be to have three flat programs, each containing
   a full solver of the PDE, but with details adapted to the problem at
   hand. The class approach, on the other hand,
   shows how all applications share the same
   numerical implementation. The different problem classes can also share
   a lot of code so inheritance is a way to save writing.
   However, such class programming requires some experience as it is easy
   to make mistakes and inherit functionality that is wrong.




.. --- begin exercise ---

Exercise 2: Implement second-order schemes in time
--------------------------------------------------

A backward difference of accuracy :math:`\mathcal{O}({\Delta t}^2)` involves
three time levels:

.. math::
         \frac{\partial}{\partial t}u(x, y, t_{n+1}) \approx
        \frac{u^{n+1} - 4u^n + u^{n-1}}{2{\Delta t}}{\thinspace .}

Make a solver based on this scheme. For the first time step, use the
two-level
Backward Euler method. The implementation should also offer the Backward Euler
method. In addition, implement the Crank-Nicolson method where you solve

.. math::
         \frac{\partial u}{\partial t} = G(u)

by

.. math::
         \frac{u^{n+1}-u^n}{{\Delta t}} = \frac{1}{2}(G(u^{n+1}) + G(u^n)){\thinspace .}

This method also has a truncation error of order :math:`{\Delta t}^2`.
[**hpl 4**: Find some good test problems for comparing the performance of the schemes. What about starting Couette flow in 1D and a 2D tube with non-trivial cross section, and some adaptive strategy in time? Can find appropriate :math:`\Delta t` for visualization in different time intervals, then refine for numerical computations and then smoooth through the piecewise constant values.]

.. --- end exercise ---

