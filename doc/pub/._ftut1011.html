<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="The FEniCS Tutorial - <br> Writing State-of-the-Art Finite Element Solvers in Minutes">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,unit testing,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),Poisson's equation with variable coefficient,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional">

<title>The FEniCS Tutorial - <br> Writing State-of-the-Art Finite Element Solvers in Minutes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'New feature: vector function space', 3, None, '___sec70'),
              (u'New feature: constant vectors', 3, None, '___sec71'),
              (u'New feature: `nabla_grad`', 3, None, '___sec72'),
              (u'New feature: stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec78'),
              (u'Test problem 1', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Flow past a cylinder', 2, None, '___sec81'),
              (u'FEniCS implementation', 3, None, '___sec82'),
              (u'Mesh generation, subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Multiple domains and boundaries', 1, None, '___sec84'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 3, None, '___sec86'),
              (u'Variational formulation', 3, None, '___sec87'),
              (u'FEniCS implementation', 3, None, '___sec88'),
              (u'Multiple Dirichlet conditions',
               2,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Working with subdomains',
               2,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec91'),
              (u'Mesh functions', 3, None, '___sec92'),
              (u'C++ strings for subdomain definitions', 3, None, '___sec93'),
              (u'Exercise 2: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet conditions',
               2,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec96'),
              (u'A general model problem', 3, None, '___sec97'),
              (u'Variational formulation', 3, None, '___sec98'),
              (u'FEniCS implementation of boundary conditions',
               2,
               None,
               '___sec99'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec100'),
              (u'Test problem', 3, None, '___sec101'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec102'),
              (u'FEniCS implementation of multiple subdomains',
               2,
               None,
               '___sec103'),
              (u'Heat loss in a pipe', 1, None, '___sec104'),
              (u'Mathematical problem formulation', 1, None, '___sec105'),
              (u'Scaling the equation', 1, None, '___sec106'),
              (u'Finite element variational formulation',
               1,
               None,
               '___sec107'),
              (u'Mesh generation', 1, None, '___sec108'),
              (u'Subdomain markers', 1, None, '___sec109'),
              (u'The complete program', 1, None, '___sec110'),
              (u'Common extensions in PDE solvers',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Plotting for the test problem', 3, None, '___sec114'),
              (u'Make a module!', 3, None, '___sec115'),
              (u'Verification and unit tests', 2, None, '___sec116'),
              (u'Writing out the discrete solution',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Generating a hypercube', 3, None, '___sec119'),
              (u'Exercise 3: Solve a Poisson problem', 2, None, '___sec120'),
              (u'Remarks', 3, None, '___sec121'),
              (u'Exercise 4: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec123'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec125'),
              (u'Linear algebra backend', 3, None, '___sec126'),
              (u'The `parameters` database', 3, None, '___sec127'),
              (u'An extended solver function', 3, None, '___sec128'),
              (u'Remark regarding unit tests', 3, None, '___sec129'),
              (u'Linear solvers and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Creating the linear system explicitly',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'A variable-coefficient Poisson problem',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec134'),
              (u'Modifications of the PDE solver', 2, None, '___sec135'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec138'),
              (u'Finite difference approximations', 3, None, '___sec139'),
              (u'Surface plot', 3, None, '___sec140'),
              (u'Contour plot', 3, None, '___sec141'),
              (u'Curve plot through the mesh', 3, None, '___sec142'),
              (u'Curve plot of the flux', 3, None, '___sec143'),
              (u'Test problem', 3, None, '___sec144'),
              (u'Postprocessing computations', 1, None, '___sec145'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec147'),
              (u'Error functional', 3, None, '___sec148'),
              (u'Flux Functionals', 3, None, '___sec149'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec151'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec152'),
              (u'Test problem', 3, None, '___sec153'),
              (u'Experiments', 3, None, '___sec154'),
              (u'Bibliography', 1, None, '___sec155')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\dr}{\, \mathrm{d}r}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\ub}{u_{\mathrm{b}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
\newcommand{\WmK}{\mathrm{W}\cdot\mathrm{m}^{-1}\cdot\mathrm{K}^{-1}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">The FEniCS Tutorial - <br> Writing State-of-the-Art Finite Element Solvers in Minutes</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: vector function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: <code>nabla_grad</code></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: stress computation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem 1</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:subdomains" style="font-size: 80%;"><b>Mesh generation, subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Heat loss in a pipe</a></li>
     <!-- navigation toc: --> <li><a href="#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Scaling the equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mesh generation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Subdomain markers</a></li>
     <!-- navigation toc: --> <li><a href="#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson" style="font-size: 80%;"><b>Common extensions in PDE solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec120" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1015.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0011"></a>
<!-- !split -->

<h1 id="___sec84">Multiple domains and boundaries </h1>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 28</b>: Need a little intro.)</font>
<!-- end inline comment -->

<h2 id="ch:poisson0:DN">Combining Dirichlet and Neumann conditions</h2>

<p>
Let us make a slight extension of our two-dimensional Poisson problem
with Dirichlet conditions on the entire boundary and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition \( u=\ub \) at the left and right sides, \( x=0 \) and
\( x=1 \), while the Neumann condition

$$
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
$$

is applied to the remaining
sides \( y=0 \) and \( y=1 \).
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).

<h3 id="___sec86">PDE problem </h3>

<p>
Let \( \Gamma_D \) and \( \Gamma_N \) denote the parts of \( \partial\Omega \)
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

$$
\begin{align}
    - \nabla^2 u &= f \mbox{ in } \Omega,  
\tag{4.1}\\ 
    u &= \ub \mbox{ on } \Gamma_D,       
\tag{4.2}\\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N  \tp
\tag{4.3}
\end{align}
$$

Again we choose \( u=1+x^2 + 2y^2 \) as the exact solution and adjust \( f \), \( g \), and
\( \ub \) accordingly:

$$
\begin{align*}
f &= -6,\\ 
g &= \left\lbrace\begin{array}{ll}
-4, & y=1\\ 
0,  & y=0
\end{array}\right.\\ 
\ub &= 1 + x^2 + 2y^2\tp
\end{align*}
$$

For ease of programming we may introduce a \( g \) function defined over the whole
of \( \Omega \) such that \( g \) takes on the right values at \( y=0 \) and
\( y=1 \). One possible extension is

$$
\begin{equation*}
g(x,y) = -4y\tp
\end{equation*}
$$

<h3 id="___sec87">Variational formulation </h3>

<p>
The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
\( v \) is only zero on \( \Gamma_D \). We have

$$
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
$$

and since \( v=0 \) on \( \Gamma_D \),

$$
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v \ds
= \int_{\Gamma_N}gv \ds,
\end{equation*}
$$

by applying the boundary condition on \( \Gamma_N \).
The resulting weak form reads

$$
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx +
\int_{\Gamma_N} gv \ds
= \int_{\Omega} fv \dx\tp
\tag{4.4}
\end{equation}
$$

Expressing this equation
in the standard notation \( a(u,v)=L(v) \) is straightforward with

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{4.5}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\Gamma_N} gv \ds\tp  \tag{4.6}
\end{align}
$$

<h3 id="___sec88">FEniCS implementation </h3>

<p>
How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code>ft01_poisson.py</code>, from
the section <a href="._ftut1006.html#ch:poisson0:impl:code">ch:poisson0:impl:code</a>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:

<ul>
  <li> The function describing the boundary where Dirichlet conditions
    apply must be modified.</li>
  <li> The new boundary term must be added to the expression in <code>L</code>.</li>
</ul>

The first adjustment can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">if</span> on_boundary:
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
</pre></div>
<p>
A more compact implementation reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> <span style="color: #666666">1</span>)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Never use <code>==</code> for comparing real numbers!</b>
A list like <code>x[0] == 1</code> should never be used if <code>x[0]</code> is a real number,
because rounding errors in <code>x[0]</code> may make the test fail even when it is
mathematically correct. Consider

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span> <span style="color: #666666">==</span> <span style="color: #666666">0.3</span>
<span style="color: #008000">False</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span>
<span style="color: #666666">0.30000000000000004</span>
</pre></div>
<p>
Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">0.1+0.2</span> <span style="color: #666666">-</span> <span style="color: #666666">0.3</span>)
<span style="color: #666666">5.551115123125783e-17</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1.1+1.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10.1+10.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20.3</span>)
<span style="color: #666666">3.552713678800501e-15</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">100.1+100.2</span> <span style="color: #666666">-</span> <span style="color: #666666">200.3</span>)
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">1000.1+1000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">2000.3</span>)
<span style="color: #666666">2.2737367544323206e-13</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">abs</span>(<span style="color: #666666">10000.1+10000.2</span> <span style="color: #666666">-</span> <span style="color: #666666">20000.3</span>)
<span style="color: #666666">3.637978807091713e-12</span>
</pre></div>
<p>
For numbers around unity, tolerances as low as \( 3\cdot 10^{-16} \) can be used
(in fact, this tolerance is known as the constant <code>DOLFIN_EPS</code> in FEniCS),
otherwise an appropriate tolerance must be found.

<p>
Testing for <code>x[0] == 1</code> should therefore be implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol:
    <span style="color: #666666">...</span>
</pre></div>
<p>
</div>


<p>
Here is a new boundary function using tolerances in the test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> \ 
           (<span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol)
</pre></div>
<p>
This function can be written a bit more elegantly using the <code>near</code>
function in FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Dirichlet_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> \ 
           (near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol) <span style="color: #AA22FF; font-weight: bold">or</span> near(x[<span style="color: #666666">1</span>], <span style="color: #666666">1</span>, tol))
</pre></div>
<p>
The second adjustment of our program concerns the definition of <code>L</code>,
where we have to add a boundary integral and a definition of the \( g \)
function to be integrated:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-4*x[1]&#39;</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds
</pre></div>
<p>
The <code>ds</code> variable implies a boundary integral, while <code>dx</code>
implies an integral over the domain \( \Omega \).
No more modifications are necessary.

<h2 id="ch:poisson0:multiple:Dirichlet">Multiple Dirichlet conditions</h2>

<p>
The PDE problem from the previous section applies a function \( \ub(x,y) \)
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have \( m \) functions for
setting Dirichlet conditions on \( m \) parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

<p>
Let us return to the case from the section <a href="#ch:poisson0:DN">Combining Dirichlet and Neumann conditions</a> and define
two separate functions for the two Dirichlet conditions:

$$
\begin{align*}
    - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
    u &= u_L \mbox{ on } \Gamma_{D,0}, \\ 
    u &= u_R \mbox{ on } \Gamma_{D,1}, \\ 
    - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N \tp
\end{align*}
$$

Here, \( \Gamma_{D,0} \) is the boundary \( x=0 \), while \( \Gamma_{D,1} \) corresponds
to the boundary \( x=1 \).  We have that \( u_L = 1 + 2y^2 \), \( u_R = 2 +
2y^2 \), and \( g=-4y \).

<p>
For the left boundary \( \Gamma_0 \) we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code>DirichletBC</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">left_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

Gamma_0 <span style="color: #666666">=</span> DirichletBC(V, u_L, left_boundary)
</pre></div>
<p>
For the boundary \( x=1 \) we write a similar code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">right_boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>   <span style="color: #408080; font-style: italic"># tolerance for coordinate comparisons</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">1</span>) <span style="color: #666666">&lt;</span> tol

Gamma_1 <span style="color: #666666">=</span> DirichletBC(V, u_R, right_boundary)
</pre></div>
<p>
The various essential conditions are then collected in a list
and used in the solution process:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> [Gamma_0, Gamma_1]
<span style="color: #666666">...</span>
solve(a <span style="color: #666666">==</span> L, u, bcs)
<span style="color: #408080; font-style: italic"># or</span>
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bcs)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
In other problems, where the \( u \) values are constant at a part of the
boundary, we may use a simple <code>Constant</code> object instead of an
<code>Expression</code> object.

<h2 id="ftut:possion:2D:2mat:impl">Working with subdomains</h2>

<p>
Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent
the various materials. We can thereafter define material properties
through functions, known in FEniCS as <em>mesh functions</em>, that are
piecewise constant in each subdomain.  A simple example with two
materials (subdomains) in 2D will demonstrate the basic steps in the
process.

<p>
<center> <!-- figure label: --> <div id="ftut:possion:2D:2mat:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  Medium with discontinuous material properties.  <!-- caption label: ftut:possion:2D:2mat:fig1 --> </p></center>
<p><img src="fig/layered_medium_2.png" align="bottom" width=400></p>
</center>

<p>
Suppose we want to solve

$$
\begin{equation} \tag{4.7}
    \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,
\end{equation}
$$

in a domain \( \Omega \) consisting of two subdomains where \( k \) takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain \( \Omega = [0,1]\times [0,1] \) and divide it into two equal
subdomains,
as depicted in Figure <a href="#ftut:possion:2D:2mat:fig1">13</a>,

$$
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
$$

We define \( k(x,y)=k_0 \) in \( \Omega_0 \) and \( k(x,y)=k_1 \) in \( \Omega_1 \),
where \( k_0>0 \) and \( k_1>0 \) are given constants.

<p>
Physically, the present problem may correspond to heat conduction, where
the heat conduction in \( \Omega_1 \) is more efficient than
in \( \Omega_0 \). An alternative interpretation is flow in porous media
with two geological layers, where the layers' ability to transport
the fluid differ.

<h3 id="___sec91">Expression objects with if test </h3>

<p>
The simplest way of implementing a variable \( k \) is to define an
<code>Expression</code> object where we return the appropriate \( k \) value
depending on the position in space.  Since we need some testing on the
coordinates, the most straightforward approach is to define a subclass
of <code>Expression</code>, where we can use a full Python method instead of just
a C++ string formula for specifying a function.  The method that
defines the function is called <code>eval</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">K</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_k_values</span>(<span style="color: #008000">self</span>, k0, k1):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k0, <span style="color: #008000">self</span><span style="color: #666666">.</span>k1 <span style="color: #666666">=</span> k0, k1

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
	<span style="color: #408080; font-style: italic"># Fill in-place value[0] for scalar function,</span>
	<span style="color: #408080; font-style: italic"># value[:] for vector function (no return)</span>

	tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol:
	    value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k0
	<span style="color: #008000; font-weight: bold">else</span>:
	    value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k1

<span style="color: #408080; font-style: italic"># Initialize</span>
k <span style="color: #666666">=</span> K()
k<span style="color: #666666">.</span>set_k_values(<span style="color: #666666">1</span>, <span style="color: #666666">0.01</span>)
</pre></div>
<p>
The <code>eval</code> method gives great flexibility in defining functions, but a
downside is that C++ calls up <code>eval</code> in Python for each point <code>x</code>,
which is a slow process, and the number of calls is proportional to
the number of numerical integration points in the mesh (about the
number of degrees of freedom).  Function expressions in terms of
strings are compiled to efficient C++ functions, being called from
C++, so we should try to express functions as string expressions if
possible. (The <code>eval</code> method can also be defined through C++ code, but
this is much more complicated and not covered here.)  The idea is to
use inline if tests in C++:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
k0 <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
k1 <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
k <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[1] &lt;= 0.5+tol? k0 : k1&#39;</span>,
               tol<span style="color: #666666">=</span>tol, k0<span style="color: #666666">=</span>k0, k1<span style="color: #666666">=</span>k1)
</pre></div>
<p>
The method with if tests on the location is feasible when the
subdomains have very simple shapes. A completely general method,
utilizing <em>mesh functions</em>, is described next.

<h3 id="___sec92">Mesh functions </h3>

<p>
We now address how to specify the subdomains \( \Omega_0 \) and \( \Omega_1 \)
so that the method also works for subdomains of any shape. For this
purpose we need to use subclasses of class <code>SubDomain</code>, not only plain
functions as we have used so far for specifying boundaries. Consider
the boundary function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
for defining the boundary \( x=0 \). Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <code>SubDomain</code>,
which implements the <code>inside</code> method as an alternative to the
<code>boundary</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Boundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

boundary <span style="color: #666666">=</span> Boundary()
bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)
</pre></div>
<p>
A word about computer science terminology may be used here: The term
<em>instance</em> means a Python object of a particular type (such as
<code>SubDomain</code>, <code>Function</code>, <code>FunctionSpace</code>, etc.).  Many use <em>instance</em>
and <em>object</em> as interchangeable terms. In other computer programming
languages one may also use the term <em>variable</em> for the same thing.  We
mostly use the well-known term <em>object</em> in this text.

<p>
A subclass of <code>SubDomain</code> with an <code>inside</code> method offers functionality
for marking parts of the domain or the boundary. Now we need to define
one class for the subdomain \( \Omega_0 \) where \( y\leq 1/2 \) and another
for the subdomain \( \Omega_1 \) where \( y\geq 1/2 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol
</pre></div>
<p>
Notice the use of <code>&lt;=</code> and <code>&gt;=</code> in both tests. For a cell to belong
to, e.g., \( \Omega_1 \), the <code>inside</code> method must return <code>True</code> for all
the vertices <code>x</code> of the cell. So to make the cells at the internal
boundary \( y=1/2 \) belong to \( \Omega_1 \), we need the test <code>x[1] &gt;=
0.5</code>. However, because of potential rounding errors in the coordinates
<code>x[1]</code>, we use a tolerance in the comparisons: <code>x[1] &gt;= 0.5-tol</code>.

<p>
The next task is to use a <em>mesh function</em> to mark all cells in
\( \Omega_0 \) with the subdomain number 0 and all cells in \( \Omega_1 \)
with the subdomain number 1.  Our convention is to number subdomains
as \( 0,1,2,\ldots \).

<p>
A <code>MeshFunction</code> object is a discrete function that can be evaluated
at a set of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <code>MeshFunction</code> over cells is suitable
to represent subdomains (materials), while a <code>MeshFunction</code> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous
fields.  The specialized classes <code>CellFunction</code> and <code>FacetFunction</code>
are used to construct mesh functions of cells and facets,
respectively.

<p>
Since we need to define subdomains of \( \Omega \) in the present example,
we make use of a <code>CellFunction</code>. The constructor
is fed with two arguments: 1) the type of value: <code>'int'</code> for integers,
<code>'uint'</code> for positive (unsigned) integers, <code>'double'</code> for real
numbers, and <code>'bool'</code> for logical values; 2) a <code>Mesh</code> object.
Alternatively, the constructor can take just a filename and initialize
the <code>CellFunction</code> from data in a file.

<p>
We start with creating a <code>CellFunction</code> whose values are non-negative
integers (<code>'uint'</code>) for numbering the subdomains.
The appropriate code for two subdomains then reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
<span style="color: #408080; font-style: italic"># Mark subdomains with numbers 0 and 1</span>
subdomain0 <span style="color: #666666">=</span> Omega0()
subdomain0<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">0</span>)
subdomain1 <span style="color: #666666">=</span> Omega1()
subdomain1<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Alternative</span>
materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)
subdomain1<span style="color: #666666">.</span>mark(materials, <span style="color: #666666">1</span>)
</pre></div>
<p>
Calling <code>materials.array()</code> returns a <code>numpy</code> array of the
subdomain values. That is, <code>materials.array()[i]</code> is
the subdomain value of cell number <code>i</code>. This array is used to
look up the subdomain or material number of a specific element.

<p>
We need a function <code>k</code> that is constant in each subdomain \( \Omega_0 \)
and \( \Omega_1 \). Since we want <code>k</code> to be a finite element function, it
is natural to choose a space of functions that is constant over each
element.  The family of discontinuous Galerkin methods, in FEniCS
denoted by <code>'DG'</code>, is suitable for this purpose. Since we want
functions that are piecewise constant, the value of the degree
parameter is zero:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
k  <span style="color: #666666">=</span> Function(V0)
</pre></div>
<p>
To fill <code>k</code> with the right values in each element, we loop over
all cells (i.e., indices in <code>materials.array()</code>),
extract the corresponding subdomain number of a cell,
and assign the corresponding \( k \) value to the <code>k.vector()</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k_values <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">50</span>]  <span style="color: #408080; font-style: italic"># values of k in the two subdomains</span>
<span style="color: #008000; font-weight: bold">for</span> cell_no <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(materials<span style="color: #666666">.</span>array())):
    material_no <span style="color: #666666">=</span> materials<span style="color: #666666">.</span>array()[cell_no]
    k<span style="color: #666666">.</span>vector()[cell_no] <span style="color: #666666">=</span> k_values[material_no]
</pre></div>
<p>
Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <code>numpy</code> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<code>materials.array()</code>, but where the value <code>i</code> of an entry
in <code>materials.array()</code> is replaced by <code>k_values[i]</code>.
Such an operation is carried out by the <code>numpy</code> function <code>choose</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">help <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>numpy<span style="color: #666666">.</span>int32)
k<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>choose(help, k_values)
</pre></div>
<p>
The <code>help</code> array is required since <code>choose</code> cannot work with
<code>materials.array()</code> because this array has elements of
type <code>uint32</code>. We must therefore transform this array to an array
<code>help</code> with standard <code>int32</code> integers.

<p>
The next section exemplifies a complete solver with a piecewise
constant coefficient, like \( k \), defined through <code>SubDomain</code> objects,
combined with different types of boundary conditions.

<h3 id="___sec93">C++ strings for subdomain definitions </h3>

<p>
The <code>SubDomain</code> class in Python is convenient, but leads to lots of
function calls from C++ to Python, which are slow. In large problems,
the subdomains should be defined through C++ code. This is easy to achieve
using the <code>CompiledSubDomain</code> object. Consider the definition of
classes <code>Omega0</code> and <code>Omega1</code> above in Python.
The key strings that define these subdomain can be expressed in
C++ syntax and fed to <code>CompiledSubDomain</code> as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># Tolerance for coordinate comparisons</span>

subdomain0 <span style="color: #666666">=</span> CompiledSubDomain(
                <span style="color: #BA2121">&#39;x[1] &lt;= boundary+tol&#39;</span>, tol<span style="color: #666666">=1E-14</span>, boundary<span style="color: #666666">=0.5</span>)
subdomain1 <span style="color: #666666">=</span> CompiledSubDomain(
                <span style="color: #BA2121">&#39;x[1] &gt;= boundary-tol&#39;</span>, tol<span style="color: #666666">=1E-14</span>, boundary<span style="color: #666666">=0.5</span>)
</pre></div>
<p>
As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, <code>subdomain0</code> and <code>subdomain1</code>, can be used
as ordinary <code>SubDomain</code> objects.

<p>
Compiled subdomain strings can be applied for specifying boundaries as
well, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">y_R <span style="color: #666666">=</span> CompiledSubDomain(<span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[1], R, eps=tol)&#39;</span>,
                        tol<span style="color: #666666">=1E-14</span>, R<span style="color: #666666">=2</span>)   <span style="color: #408080; font-style: italic"># y=2</span>
</pre></div>
<p>
It is possible to feed the C++ string (without parameters) directly as
the third argument to <code>DirichletBC</code> without explicitly constructing a
<code>CompiledSubDomain</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bc1 <span style="color: #666666">=</span> DirichletBC(V, value, <span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[1], 2, 1E-14)&#39;</span>)
</pre></div>
<p>
<!-- --- begin exercise --- -->

<h2 id="ch:poisson0:exer:eff:expression">Exercise 2: Efficiency of Python vs C++ expressions</h2>

<p>
Consider a cube mesh with \( N \) cells in each spatial direction.
We want to define a <code>Function</code> on this mesh where the
values are given by the mathematical function \( f(x,y,z)=a\sin(bxyz) \),
where \( a \) and \( b \) are two parameters. Write a <code>class SineXYZ</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])
</pre></div>
<p>
Create an alternative <code>Expression</code> based on giving the formula for \( f(x,y,z) \)
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using <code>time.clock()</code> to measure the CPU time).

<p>
The <code>sin</code> function used in class <code>SineXYZ.eval</code> can mean many things.
This is an advanced FEniCS function if imported from <code>fenics</code>.
Much more efficient versions for sin of numbers are found in <code>math.sin</code>
and <code>numpy.sin</code>. Compare the use <code>sin</code> from <code>fenics</code>, <code>math</code>, <code>numpy</code>, and
<code>sympy</code> (note that <code>sin</code> from <code>sympy</code> is very slow).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
Here is an appropriate program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">make_sine_Function</span>(N, method):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Fill a Function with sin(x*y*z) values.&quot;&quot;&quot;</span>
    mesh <span style="color: #666666">=</span> UnitCubeMesh(N, N, N)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">2</span>)

    <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&#39;Python&#39;</span>):
        <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;fenics.sin&#39;</span>):
            <span style="color: #408080; font-style: italic"># Need sin as local variable in this function</span>
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;math.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;numpy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;sympy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">NotImplementedError</span>(<span style="color: #BA2121">&#39;method=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> method)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;sin:&#39;</span>, sin, <span style="color: #008000">type</span>(sin))

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b):
                <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
                value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])

        expr <span style="color: #666666">=</span> SineXYZ(a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    <span style="color: #008000; font-weight: bold">elif</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;C++&#39;</span>:
        expr <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;a*sin(b*x[0]*x[1]*x[2])&#39;</span>, a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    u <span style="color: #666666">=</span> interpolate(expr, V)
    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> u, t1<span style="color: #666666">-</span>t0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(N):
    u, cpu_py_fenics  <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-fenics.sin&#39;</span>)
    u, cpu_py_math    <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-math.sin&#39;</span>)
    u, cpu_py_numpy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-numpy.sin&#39;</span>)
    u, cpu_py_sympy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-sympy.sin&#39;</span>)
    u, cpu_cpp <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;C++&#39;</span>)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;&quot;&quot;DOFs: </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Python:</span>
<span style="color: #BA2121">fenics.sin: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">math.sin:   </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">numpy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">sympy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">C++:        </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Speed-up:   math: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">  sympy: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&quot;&quot;&quot;</span> <span style="color: #666666">%</span>
          (u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
           cpu_py_fenics, cpu_py_math,
           cpu_py_numpy, cpu_py_sympy,
           cpu_cpp,
           cpu_py_math<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp),
           cpu_py_sympy<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp)))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">profile</span>():
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">cProfile</span>
    prof <span style="color: #666666">=</span> cProfile<span style="color: #666666">.</span>Profile()
    prof<span style="color: #666666">.</span>runcall(main)
    prof<span style="color: #666666">.</span>dump_stats(<span style="color: #BA2121">&quot;tmp.profile&quot;</span>)
    <span style="color: #408080; font-style: italic"># http://docs.python.org/2/library/profile.html</span>

main(<span style="color: #666666">20</span>)
<span style="color: #408080; font-style: italic">#profile()</span>
</pre></div>
<p>
Running the program shows that <code>sin</code> from <code>math</code> is the most efficient choice,
but a string C++ runs 40 times faster. Note that <code>fenics.sin</code>, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the <code>sin</code>
functions for numbers in <code>math</code> and <code>numpy</code>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>Expression_efficiency</code>.

<p>
<!-- --- end exercise --- -->

<h2 id="ch:poisson0:multi:bc">Multiple Neumann, Robin, and Dirichlet conditions</h2>

<p>
Consider the model problem from the section <a href="#ch:poisson0:multiple:Dirichlet">Multiple Dirichlet conditions</a> where we had both Dirichlet and
Neumann conditions.  The term <code>v*g*ds</code> in the expression for <code>L</code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate <code>v*g*ds</code> only over the parts of the boundary where
we actually have Neumann conditions.  And more importantly, in other
problems one may have different Neumann conditions or other conditions
like the Robin type condition.  With the mesh function concept we can
mark different parts of the boundary and integrate over specific
parts.  The same concept can also be used to treat multiple Dirichlet
conditions.  The forthcoming text illustrates how this is done.

<h3 id="___sec96">Three types of boundary conditions </h3>

<p>
We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin.  Dirichlet conditions apply to some
parts \( \Gamma_{D,0} \), \( \Gamma_{D,1} \), \( ... \), of the boundary:

$$ u_{0,0}\hbox{ on }\Gamma_{D,0},\quad
u_{0,1}\hbox{ on }\Gamma_{D,1}, \ldots$$

where \( u_{0,i} \) are prescribed functions, \( i=0,1,\ldots \)
On other parts, \( \Gamma_{N,0} \), \( \Gamma_{N,1} \), and so on, we have
Neumann conditions

$$ -p{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{N,0},\quad
-p{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{N,1},\quad \ldots
$$

Finally, we have <em>Robin conditions</em>

$$
\begin{equation*}
-p{\partial u\over\partial n} = r(u-s),
\tag{4.8}
\end{equation*}
$$

where \( r \) and \( s \) are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, \( r \) is a heat
transfer coefficient, and \( s \) is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts \( \Gamma_{R,0} \), \( \Gamma_{R,1} \), and so forth:

$$ -p{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\Gamma_{R,0},\quad
-p{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\Gamma_{R,1},\quad \ldots
$$

<h3 id="___sec97">A general model problem </h3>

<p>
With the notation above,
the model problem to be solved with multiple Dirichlet, Neumann, and
Robin conditions can formally be defined as

$$
\begin{align}
-\nabla\cdot(p\nabla u) &= -f, \mbox{ in } \Omega, \tag{4.9}\\ 
u &= u_{0,i} \mbox{ on } \Gamma_{D,i},\quad i=0,1,\ldots
\tag{4.10}\\ 
-p{\partial u\over\partial n} &= g_i \mbox{ on } \Gamma_{N,i},\quad
i=0,1,\ldots
\tag{4.11}\\ 
-p{\partial u\over\partial n} &= r_i(u-s_i) \mbox{ on } \Gamma_{R,i},\quad
i=0,1,\ldots
\tag{4.12}
\end{align}
$$

<h3 id="___sec98">Variational formulation </h3>

<p>
Integration by parts of \( -\int_\Omega v\nabla\cdot(p\nabla u) \dx \) becomes
as usual

$$
\begin{equation*}
 -\int_\Omega v\nabla\cdot(p\nabla u) \dx
= \int_\Omega p\nabla u\cdot \nabla v \dx -
\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds\tp
\end{equation*}
$$

The boundary integral does not apply to the parts of
the boundary where we have Dirichlet conditions (\( \Gamma_{D,i} \)).
Moreover, on the remaining parts, we must split the boundary integral
into the parts where we have Neumann and Robin conditions such that we
insert the right conditions as integrands.
Specifically, we have

$$
\begin{align*}
-\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds
&=
-\sum_i\int_{\Gamma_{N,i}}p\frac{\partial u}{\partial n} \ds
-\sum_i\int_{\Gamma_{R,i}}p\frac{\partial u}{\partial n} \ds\\ 
&=
\sum_i\int_{\Gamma_{N,i}}g_i \ds +
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i) \ds\tp
\end{align*}
$$

The variational formulation then becomes

$$
\begin{equation}
F = \int_{\Omega} p\nabla u\cdot \nabla v \dx +
\sum_i\int_{\Gamma_{N,i}} g_iv \ds +
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i)v \ds
- \int_{\Omega} fv \dx =0\tp
\tag{4.13}
\end{equation}
$$

<p>
We have been used to writing
this variational formulation in the standard notation
\( a(u,v)=L(v) \), which requires that we identify all integrals with
<em>both</em> \( u \) and \( v \), and collect these in \( a(u,v) \), while the remaining
integrals with \( v \) and not \( u \) go into \( L(v) \).  The integral from the
Robin condition must of this reason be split in two parts:

$$
\begin{equation*}
\int_{\Gamma_{R,i}}r_i(u-s_i)v \ds
= \int_{\Gamma_{R,i}} r_iuv \ds - \int_{\Gamma_{R,i}}r_is_iv \ds\tp
\end{equation*}
$$

We then have

$$
\begin{align}
a(u, v) &= \int_{\Omega} p\nabla u\cdot \nabla v \dx
+ \sum_i\int_{\Gamma_{R,i}}r_iuv \ds,
\tag{4.14}\\ 
L(v) &= \int_{\Omega} fv \dx -
\sum_i\int_{\Gamma_{N,i}} g_i v \ds + \sum_i\int_{\Gamma_{R,i}}r_is_iv \ds\tp
\tag{4.15}
\end{align}
$$

<h2 id="___sec99">FEniCS implementation of boundary conditions </h2>

<p>
Looking at our previous <code>solver</code> functions for solving the 2D Poisson equation,
the following new aspects must be taken care of:

<ol>
 <li> definition of a mesh function over the boundary,</li>
 <li> marking each side as a subdomain, using the mesh function,</li>
 <li> splitting a boundary integral into parts.</li>
</ol>

A general approach to the first task is to mark each of the desired
boundaries with markers 0, 1, 2, and so forth. Here we aim at
the four sides of the unit square, marked with
0 (\( x=0 \)), 1 (\( x=1 \)), 2 (\( y=0 \)), and 3 (\( y=1 \)).
The marking of boundaries makes use of a mesh function object, but contrary to
the section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a>, this is not a function over
cells, but a function over cell facets. We apply the <code>FacetFunction</code>
for this purpose:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary_parts <span style="color: #666666">=</span> FacetFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
</pre></div>
<p>
As in the section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a> we use a subclass of
<code>SubDomain</code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the \( x=0 \) boundary can be marked by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">abs</span>(x[<span style="color: #666666">0</span>]) <span style="color: #666666">&lt;</span> tol

bx0 <span style="color: #666666">=</span> BoundaryX0()
bx0<span style="color: #666666">.</span>mark(boundary_parts, <span style="color: #666666">0</span>)
</pre></div>
<p>
Similarly, we make the classes <code>BoundaryX1</code> for the \( x=1 \) boundary,
<code>BoundaryY0</code> for the \( y=0 \) boundary, and <code>BoundaryY1</code> for the \( y=1 \)
boundary, and mark these as subdomains 1, 2, and 3, respectively.

<p>
For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary_conditions = {
  0: {&#39;Dirichlet&#39;: u_b},
  1: {&#39;Robin&#39;: (r, s)},
  2: {&#39;Neumann: g}},
  3: {&#39;Neumann&#39;, 0}}
</pre></div>
<p>
specifies

<ul>
 <li> a Dirichlet condition, with values implemented by an <code>Expression</code>
   or <code>Constant</code> object
   <code>u_b</code>, on subdomain 0, i.e., the \( x=1 \) boundary;</li>
 <li> a Robin condition <a href="#mjx-eqn-4.8">(4.8)</a>
   on subdomain 1, \( x=1 \), with <code>Expression</code> or <code>Constant</code> objects
   <code>r</code> and <code>s</code> specifying \( r \) and \( s \);</li>
 <li> a Neumann condition \( \partial u/\partial n=g \) on subdomain 2, \( y=0 \),
   where an <code>Expression</code> or <code>Constant</code> object <code>g</code> implements the value \( g \);</li>
 <li> a homogeneous Neumann condition \( \partial u/\partial n=0 \) on
   subdomain 3, \( y=1 \).</li>
</ul>

As explained in the section <a href="#ch:poisson0:multiple:Dirichlet">Multiple Dirichlet conditions</a>,
multiple Dirichlet conditions must be collected in a list of
<code>DirichletBC</code> objects. Based on the <code>boundary_conditions</code> data
structure above, we can construct this list by the following snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bcs <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># List of Dirichlet conditions</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Dirichlet&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        bcs<span style="color: #666666">.</span>append(
            DirichletBC(V, boundary_conditions[n][<span style="color: #BA2121">&#39;Dirichlet&#39;</span>],
                        boundary_parts, n))
</pre></div>
<p>
The new aspect of the variational problem is the two distinct
boundary integrals over \( \Gamma_{N,i} \) and \( \Gamma_{R,i} \).
Having a mesh function over exterior cell facets (our
<code>boundary_parts</code> object), where subdomains (boundary parts) are
numbered as \( 0,1,2,\ldots \), the special symbol <code>ds(0)</code>
implies integration over subdomain (part) 0, <code>ds(1)</code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code>ds</code>-type objects generalizes to volume
integrals too: <code>dx(0)</code>, <code>dx(1)</code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside \( \Omega \).

<p>
Before we have <code>ds(n)</code> for integers <code>n</code> defined, we must do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">ds <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;ds&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>boundaries_parts)
</pre></div>
<p>
Similarly, if we want integration of different parts of the domain,
we redefine <code>dx</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dx <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;dx&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>domains)
</pre></div>
<p>
where <code>domains</code> is a <code>CellFunction</code> defining subdomains in \( \Omega \).

<p>
Suppose we have a Robin condition with values <code>r</code> and <code>s</code> on subdomain
<code>R</code>, a Neumann condition with value <code>g</code> on subdomain <code>N</code>, the
variational form can be written

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(N) <span style="color: #666666">+</span> r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
</pre></div>
<p>
In our case things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code>boundary_conditions</code> data structure. We can collect
all Neumann conditions by the code

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
Neumann_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Neumann&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        <span style="color: #008000; font-weight: bold">if</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>] <span style="color: #666666">!=</span> <span style="color: #666666">0</span>:
            g <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Neumann&#39;</span>]
            Neumann_integrals<span style="color: #666666">.</span>append(g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
Applying <code>sum(Nemann_integrals)</code> will apply the <code>+</code> operator to
the variational forms in the <code>Numeann_integrals</code> list and result
in the integrals we need for the right-hand side <code>L</code> of the
variational form.

<p>
The integrals in the Robin condition can similarly be collected
in lists:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Robin_a_integrals <span style="color: #666666">=</span> []
Robin_L_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        Robin_a_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
        Robin_L_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
We are now in a position to define the <code>a</code> and <code>L</code> expressions
in the variational formulation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
    <span style="color: #008000">sum</span>(Robin_a_integrals)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> <span style="color: #008000">sum</span>(Neumann_integrals) <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Robin_L_integrals)
</pre></div>

<h3 id="___sec100">Simplified handling of the variational formulation </h3>

<p>
We carefully ordered the terms in the variational formulation above
into the \( a \) and \( L \) parts. This requires a splitting of the Robin
condition and makes the <code>a</code> and <code>L</code> expressions less readable (still we
think understanding this splitting is key for any finite element programmer!).
Fortunately, UFL allows us to specify the complete variational form
<a href="#mjx-eqn-4.13">(4.13)</a> as one expression and offer tools to
extract what goes into the bilinear form \( a(u,v) \) and the linear form
\( L(v) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">F <span style="color: #666666">=</span> dot(p<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
    <span style="color: #008000">sum</span>(Robin_integrals) <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(Neumann_integrals)
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
This time we can more naturally define the integrals from the
Robin condition as <code>r*(u-s)*v*ds(n)</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Robin_integrals <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[n]:
        r, s <span style="color: #666666">=</span> boundary_conditions[n][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        Robin_integrals<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>(u<span style="color: #666666">-</span>s)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(n))
</pre></div>
<p>
The complete code is in the <code>solver_bc</code> function in the
<code>ft08_poisson_vc.py</code> file.

<h3 id="___sec101">Test problem </h3>

<p>
Let us continue to use \( \uex=1+x^2+2y^2 \) as the exact solution, and
set \( p=1 \) and \( f=-6 \) in the PDE.  Our domain is the unit square, and
we assign Dirichlet conditions at \( x=0 \) and \( x=1 \), a Neumann condition
at \( y=1 \), and a Robin condition at \( y=0 \). With the given \( \uex \), we
realize that the Neumann condition is \( -4y \) (which means \( -4 \) at
\( y=1 \)), while the Robin
condition can be selected in many ways. Since \( \partial u/\partial
n=-\partial u/\partial y=0 \) at \( y=0 \), we can select \( s=u \) and have \( r \)
arbitrary in the Robin condition.

<p>
The boundary parts are \( \Gamma_{D,0} \): \( x=0 \), \( \Gamma_{D,1} \): \( x=1 \),
\( \Gamma_{R,0} \): \( y=0 \), and \( \Gamma_{N,0} \): \( y=1 \).

<p>
When implementing this test problem (and especially other test
problems with more complicated expressions), it is advantageous to use
symbolic computing. Below we define the exact solution as a <code>sympy</code>
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can be fed into <code>Expression</code> objects.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_bc_test</span>():
    <span style="color: #408080; font-style: italic"># Define manufactured solution in sympy and derive f, g, etc.</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)  <span style="color: #408080; font-style: italic"># UFL needs x[0] for x etc.</span>
    u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x, <span style="color: #666666">2</span>) <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(u, y, <span style="color: #666666">2</span>)  <span style="color: #408080; font-style: italic"># -Laplace(u)</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
    u_00 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># x=0 boundary</span>
    u_01 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary</span>
    g <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, y)<span style="color: #666666">.</span>subs(y, <span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># x=1 boundary, du/dn=-du/dy</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">1000</span> <span style="color: #408080; font-style: italic"># any function can go here</span>
    s <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Turn to C/C++ code for UFL expressions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
    u_00 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_00)
    u_01 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u_01)
    g <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(g)
    r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(r)
    s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(s)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Test problem (C/C++):</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">f = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u, f))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_00: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">u_01: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">g = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">r = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">s = </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
          (u_00, u_01, g, r, s))

    <span style="color: #408080; font-style: italic"># Turn into FEniCS objects</span>
    u_00 <span style="color: #666666">=</span> Expression(u_00)
    u_01 <span style="color: #666666">=</span> Expression(u_01)
    f <span style="color: #666666">=</span> Expression(f)
    g <span style="color: #666666">=</span> Expression(g)
    r <span style="color: #666666">=</span> Expression(r)
    s <span style="color: #666666">=</span> Expression(s)
    u_exact <span style="color: #666666">=</span> Expression(sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u))

    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_00},   <span style="color: #408080; font-style: italic"># x=0</span>
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_01},   <span style="color: #408080; font-style: italic"># x=1</span>
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Robin&#39;</span>: (r, s)},     <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: g}}        <span style="color: #408080; font-style: italic"># y=1</span>

    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    u, p <span style="color: #666666">=</span> solver_bc(
        p, f, boundary_conditions, Nx, Ny, degree<span style="color: #666666">=1</span>,
        linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>,
        debug<span style="color: #666666">=2*</span>Nx<span style="color: #666666">*</span>Ny <span style="color: #666666">&lt;</span> <span style="color: #666666">50</span>,  <span style="color: #408080; font-style: italic"># for small problems only</span>
        )
</pre></div>
<p>
This simple test problem is turned into a real unit test for different
function spaces in the function <code>test_solver_bc</code>.

<h3 id="___sec102">Debugging the setting of boundary conditions </h3>

<p>
It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code>SubDomain.inside</code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the output.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> debug:
    <span style="color: #408080; font-style: italic"># Print the vertices that are on the boundaries</span>
    coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> coor:
        <span style="color: #008000; font-weight: bold">if</span> bx0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> bx1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x=1&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y=1&#39;</span> <span style="color: #666666">%</span> x)
    <span style="color: #408080; font-style: italic"># Print the Dirichlet conditions</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;No of Dirichlet conditions:&#39;</span>, <span style="color: #008000">len</span>(bcs))
    d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
    <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
        bc_dict <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
        <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> bc_dict:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, bc_dict[dof]))
            <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;   at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                      (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>
<p>
In addition, it is helpful to print the exact and the numerical solution
at all the vertices as shown in the section <a href="._ftut1012.html#ch:poisson0:verify1">Writing out the discrete solution</a>.

<h2 id="___sec103">FEniCS implementation of multiple subdomains </h2>

<p>
The section <a href="#ftut:possion:2D:2mat:impl">Working with subdomains</a> explains how to deal with
multiple subdomains of \( \Omega \) and a piecewise constant coefficient
function \( p \) that takes on different constant values in the different
subdomains. We can easily add this type of \( p \) coefficient to the
<code>solver_bc</code> function. The signature of the function is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_bc</span>(
    p, f,                   <span style="color: #408080; font-style: italic"># Coefficients in the PDE</span>
    boundary_conditions,    <span style="color: #408080; font-style: italic"># Dict of boundary conditions</span>
    Nx, Ny,                 <span style="color: #408080; font-style: italic"># Cell division of the domain</span>
    degree<span style="color: #666666">=1</span>,               <span style="color: #408080; font-style: italic"># Polynomial degree</span>
    subdomains<span style="color: #666666">=</span>[],          <span style="color: #408080; font-style: italic"># List of SubDomain objects in domain</span>
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max no of iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    dump_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>,  <span style="color: #408080; font-style: italic"># Write out parameter database?</span>
    debug<span style="color: #666666">=</span><span style="color: #008000">False</span>,
    ):
<span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">return</span> u, p   <span style="color: #408080; font-style: italic"># p may be modified</span>
</pre></div>
<p>
If <code>subdomain</code> is an empty list, we assume there are no subdomains, and
\( p \) is an <code>Expression</code> or <code>Constant</code> object specifying a formula for
\( p \). If not, <code>subdomain</code> is a list of <code>SubDomain</code> objects, defining
different parts of the domain. The first element is a dummy object,
defining &quot;the rest&quot; of the domain. The next elements define specific
geometries in the <code>inside</code> methods. We start by marking all elements
with subdomain number 0, this will then be &quot;the rest&quot; after marking
subdomains 1, 2, and so on. The next step is to define <code>p</code> as a
piecewise constant function over cells and fill it with values.
We assume that the user-argument <code>p</code> is an array (or list) holding
the values of \( p \) in the different parts corresponding to <code>subdomains</code>.
The returned <code>p</code> is needed for flux computations. If there are no
subdomains, the returned <code>p</code> is just the original <code>p</code> argument.

<p>
The appropriate code for computing <code>p</code> becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">if</span> subdomains:
    <span style="color: #408080; font-style: italic"># subdomains is list of SubDomain objects,</span>
    <span style="color: #408080; font-style: italic"># p is array of corresponding constant values of p</span>
    <span style="color: #408080; font-style: italic"># in each subdomain</span>
    materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
    materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># &quot;the rest&quot;</span>
    <span style="color: #008000; font-weight: bold">for</span> m, subdomain <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(subdomains[<span style="color: #666666">1</span>:], <span style="color: #666666">1</span>):
        subdomain<span style="color: #666666">.</span>mark(materials, m)

    p_values <span style="color: #666666">=</span> p
    V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
    p  <span style="color: #666666">=</span> Function(V0)
    help <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int32)
    p<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>choose(help, p_values)
</pre></div>
<p>
We define \( p(x,y)=p_0 \) in \( \Omega_0 \) and \( k(x,y)=p_1 \) in \( \Omega_1 \),
where \( p_0>0 \) and \( p_1>0 \) are given constants.
As boundary conditions, we choose \( u=0 \) at \( y=0 \), \( u=1 \) at \( y=1 \),
and \( \partial u/\partial n=0 \) at \( x=0 \) and \( x=1 \).
One can show that the exact solution is now given by

$$
\begin{equation}
u(x, y) = \left\lbrace\begin{array}{ll}
{2yp_1\over p_0+p_1}, & y \leq 1/2\\ 
{(2y-1)p_0 + p_1\over p_0+p_1}, & y \geq 1/2
\end{array}\right.
\tag{4.16}
\end{equation}
$$

As long as the element boundaries coincide with the internal boundary
\( y=1/2 \), this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We can use this property to verify
the implementation and make a unit test for a series of function
spaces:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solvers_bc_2mat</span>():
    tol <span style="color: #666666">=</span> <span style="color: #666666">2E-13</span>  <span style="color: #408080; font-style: italic"># Tolerance for comparisons</span>

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega0</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5+</span>tol

    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega1</span>(SubDomain):
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
            <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5-</span>tol

    subdomains <span style="color: #666666">=</span> [Omega0(), Omega1()]
    p_values <span style="color: #666666">=</span> [<span style="color: #666666">2.0</span>, <span style="color: #666666">13.0</span>]
    boundary_conditions <span style="color: #666666">=</span> {
        <span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>: <span style="color: #666666">0</span>},
        <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">0</span>)}, <span style="color: #408080; font-style: italic"># y=0</span>
        <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: Constant(<span style="color: #666666">1</span>)}, <span style="color: #408080; font-style: italic"># y=1</span>
        }

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_exact <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span style="color: #BA2121">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span>,
        p_0<span style="color: #666666">=</span>p_values[<span style="color: #666666">0</span>], p_1<span style="color: #666666">=</span>p_values[<span style="color: #666666">1</span>])

    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), (<span style="color: #666666">2</span>,<span style="color: #666666">4</span>), (<span style="color: #666666">8</span>,<span style="color: #666666">4</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            u, p <span style="color: #666666">=</span> solver_bc(
                p_values, f, boundary_conditions, Nx, Ny, degree,
                linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, subdomains<span style="color: #666666">=</span>subdomains,
                debug<span style="color: #666666">=</span><span style="color: #008000">False</span>)

            <span style="color: #408080; font-style: italic"># Compute max error in infinity norm</span>
            u_e <span style="color: #666666">=</span> interpolate(u_exact, u<span style="color: #666666">.</span>function_space())
            <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
            max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                           u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max error: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> max_error
</pre></div>

<h1 id="___sec104">Heat loss in a pipe </h1>

<p>
<!-- ===== Physical problem formulation ===== -->

<p>
We will simulate the transport of heat in a non-perfectly insulated
pipe via both diffusion and convection (transport). The inner diameter
of the pipe is \( 4\,\mathrm{cm} \), its thickness is 4mm, the thickness
of the surrounding insulation is \( 10\,\mathrm{mm} \), and its length is
\( 50\,\mathrm{cm} \). We assume that the temperature of the water at the
inlet is 42 degrees centigrade and the temperature of the surrounding
air is 22 degrees centigrade. We also assume that the pipe transmits
0.1 liters of water per second. A sketch of the pipe is given in
Figure X.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 29</b>: Add nice 3D graphics here...)</font>
<!-- end inline comment -->

<p>
To compute the temperature distribution in the pipe, we need to set
boundary conditions, both at the inflow and outflow, as well as on the
boundary of the insulating layer which is exposed to the surrounding
air. We do this by assuming that the temperature at the inlet is 42
degrees, for the water as well as for the pipe and the insulating
layer. We similarly assume the temperature to be 22 degrees in all
three layers at the outflow. The boundary of the insulating layer is
also assumed to have the temperature 22 degrees.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 30</b>: How to you realize this setup in practice? One big water reservoir at 42 C, and then a long pipe from that reservoir surrounded by free air? Convection is very efficient compared to diffusion, so the pipe has to be very long for the water to lose heat. At the outlet out the pipe, I don't think you can assume 22 C in the water; it will flow out with little heat loss - 40 C, e.g. A possible boundary condition for the water is to say &quot;hardly no change&quot; in the temperature, i.e., \( \partial u/\partial n=0 \). That will pick up heat loss along the pipe and be an okay approximation.)</font>
<!-- end inline comment -->

<p>
To compute the temperature distribution, we also need to know the
value of the thermal conductivity \( \lambda \) $[\WmK]$ for water, pipe,
and insulation. From a book of physical tables or from the internet,
we find the following values that we will use for our simulation:
\( \lambda_{\textrm{water}} = 0.6\,\WmK \), \( \lambda_{\textrm{pipe}} = 18\,\WmK \) (stainless steel), and \( \lambda_{\textrm{insul}} = 0.035\,\WmK \)
(styrofoam). We will also need to know the density and specific heat
of water, which we set to \( \rho = 1\,\mathrm{kg}/\mathrm{dm}^3 \) and \( c
= 4.184\,\mathrm{kJ} / (\mathrm{kg} \cdot \mathrm{K}) \) (one
\( \mathrm{kcal} \) per \( \mathrm{kg} \cdot \mathrm{K} \)), respectively.

<!-- begin inline comment -->
<font color="red">(<b>hpl 31</b>: You also need \( c\varrho \) for steel and the other material. The idea with scaling is that you don't need to find 3 parameters per material, all you have to do is to find the fractions. Of course, if you now you have steel and styrofoam, then that fraction requires you to look up the values.)</font>
<!-- end inline comment -->

<p>
Finally, we need to know the velocity field for the water flowing
through the pipe. We know the total flow rate of water (0.1 liters per
second). If the flow is laminar (Poiseuille flow), we know that the
velocity profile is a quadratic function in the radius with its
maximum at the center and zero velocity on the boundary. We may thus
compute the velocity profile from the dimensions of the pipe. In
particular, we know that the velocity profile takes the form
$$ \beta(x) = (0, 0, C (a - r)^2), $$

where \( r = \sqrt{x^2 + y^2} \). The flow rate is then
$$ Q = \int_0^a C (a - r)^2 \, 2\pi r \dr
     = 2 \pi Ca^4 \int_0^1 s (1 - s)^2 \ds
     = \pi Ca^4 / 6 $$

Knowing that \( Q = 0.1\,\mathrm{dm}^3 / \mathrm{s} \), we can solve for \( C \) and
find \( C = 0.6\,\mathrm{dm}^3 / (\pi a^4) \).

<h1 id="___sec105">Mathematical problem formulation </h1>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 32</b>: I think you should start with the incompressible version. I don't remember the compressible version of the heat equation - it has more terms than you include here (e.g., pressure work \( p\nabla\cdot u \)). In the incompressible case, which we deal with anyway, \( c\varrho \) is outside of the derivative even with \( c\varrho \) vary. Remember that they vary here between all the materials. I would also drop the \( f \) term as the scaling with and without \( f \) will often be different.)</font>
<!-- end inline comment -->

<p>
We will model the conduction of heat in the pipe using the standard
convection-diffusion equation:

$$
\begin{equation} \tag{4.17}
    -\nabla \cdot (\lambda\nabla u) + \nabla \cdot (c\rho\beta u) = f.
\end{equation}
$$

Here, \( u \) denotes the temperature, \( \lambda \) is the thermal
conductivity, \( c \) is the specific heat, \( \rho \) is the density, \( \beta \)
is the velocity field, and \( f \) is the source term. Since our problem
does not have a source term, we will set \( f = 0 \).

<p>
The convection-diffusion equation is often stated in the following slightly modified form:
$$
    -\nabla \cdot (\lambda\nabla u) + c\rho\beta \cdot \nabla u = f.
$$

This formulation is equivalent to <a href="#mjx-eqn-4.17">(4.17)</a> if the velocity
field \( \beta \) is divergence free; that is, if \( \nabla \cdot \beta = 0 \):
\( \nabla \cdot (\beta u) = (\nabla \cdot \beta) u + \beta \cdot \nabla
u = \beta \cdot \nabla u \).

<h1 id="___sec106">Scaling the equation </h1>

<p>
Before we can solve the PDE, we must first introduce dimensionless
quantities since, strictly speaking, our program can not work with
units, only with numbers. We let \( L \) be a reference length, let \( T \) be
a reference time length, let \( U \) be a reference temperature, and let
\( P \) be a reference power (energy per unit time). We then introduce the
following dimensionless quantities:

$$
\bar x = \frac{x}{L},\ 
\bar y = \frac{y}{L},\ 
\bar z = \frac{z}{L},\ 
\bar u = \frac{u}{U},\ 
\bar\beta = \frac{\beta}{LT^{-1}},
\bar f = \frac{f}{PL^{-3}}.
$$


<!-- begin inline comment -->
<font color="red">(<b>hpl 33</b>: You will scale \( \beta \) by some characteristic velocity \( V \) and avoid introducing any time here as the problem is stationary. You need to scale \( \varrho \), \( c \), and \( \lambda \) too as they vary in space. These are piecewise constant functions, so you can scale with the value in one of the materials.)</font>
<!-- end inline comment -->

<p>
The dimensionless coordinates \( \bar x \), \( \bar y \) and \( \bar z \)
also lead to dimensionless derivatives:
\( \bar\nabla =
(\partial / \partial \bar x,
 \partial / \partial \bar y,
 \partial / \partial \bar z)
 = L \nabla \).
Inserting \( u = U\bar u \), \( \beta = L^{-1}T\bar\beta \), and \( f = L^{-3}P\bar f \) into the convection-diffusion equation <a href="#mjx-eqn-4.17">(4.17)</a> and using \( \nabla = L^{-1}\bar\nabla \), we obtain
$$
  -L^{-1}\bar\nabla \cdot
  (\lambda L^{-1}\bar\nabla(U\bar u))
  +L^{-1}\bar\nabla \cdot (c\rho LT^{-1}\bar\beta U\bar u)
  = L^{-3}P \bar f.
$$

Rearranging the factors \( L, U, T, P \), we obtain
$$
  -\bar\nabla \cdot
  (LUP^{-1}\lambda \bar\nabla \bar u)
  +\bar\nabla \cdot \left(L^3UT^{-1}P^{-1}c\rho\bar\beta \bar u\right) = \bar f.
$$

Finally, we identify the two dimensionless parameters \( \bar\lambda \) and
\( \bar c \) given by
$$
  \bar\lambda = LUP^{-1}\lambda, \quad
  \bar c = L^3UT^{-1}P^{-1}c\rho.
$$


<!-- begin inline comment -->
<font color="red">(<b>hpl 34</b>: You will typically get some Peclet number here as the only dimensionless parameter, and then you will have scaled \( \varrho \), \( c \), and \( \lambda \) with fractions of material parameters in different materials. I can do this :-))</font>
<!-- end inline comment -->

<p>
Let's double-check that these are indeed dimensionless quantities. We have
$$
  \begin{split}
  [\bar\lambda]
  &= [LUP^{-1}\lambda]
  = [LUP^{-1}] \cdot [\lambda]
  = [LUP^{-1}] \cdot [\WmK] \\ 
  &= [LUP^{-1}] \cdot [L^{-1}U^{-1}P]
  = [LUP^{-1} \cdot L^{-1}U^{-1}P] = [1].
  \end{split}
$$

Similarly, we have
$$
  \begin{split}
  [L^3UT^{-1}P^{-1}c\rho]
  &= [L^3UT^{-1}P^{-1}] \cdot [c] \cdot [\rho] \\ 
  &= [L^3UT^{-1}P^{-1}] \cdot
    [\mathrm{kJ} / (\mathrm{kg} \cdot \mathrm{K})] \cdot
    [\mathrm{kg} / \mathrm{dm}^3] \\ 
  &= [L^3UT^{-1}P^{-1}] \cdot [PTU^{-1} \cdot L^{-3}]
  = [1].
  \end{split}
$$

We thus obtain the dimensionless and fully scaled convection-diffusion equation
\[
  -\bar\nabla \cdot
  (\bar\lambda \bar\nabla \bar u)
  +\bar\nabla \cdot \left(c\bar\beta \bar u\right) = \bar f.
\]
The reference quantities \( L \), \( T \), \( U \) and \( P \) may be chosen arbitrarily.

<!-- begin inline comment -->
<font color="red">(<b>hpl 35</b>: Normally, these are implied by the problem setting and the desire to have all variables of unit size. \( L \) can be the length of the pipe or the diameter (I would choose the diameter). \( U \) is given from the boundary conditions (here 42 C is natural), \( V \) is given by \( Q \).)</font>
<!-- end inline comment -->

If working with very large or very small quantities, one may want to choose for example \( L \) to obtain a domain of unit size. However, for our problem this is not necessary. We will therefore make the most straightforward choice which is to use standard SI units. We thus take
\( L = 1\,\mathrm{m} \),
\( T = 1\,\mathrm{s} \),
\( U = 1\,\mathrm{K} \), and
\( P = 1\,\mathrm{W} \). The scaled variables and parameters \( \bar u \), \( \bar\beta \), \( \bar \lambda \) and so on may then be easily computed by expressing everything in standard SI units and then simply dropping the units.

<p>
In the following we will simply write \( u \) in place of \( \bar{u} \) but remember that the \( u \) we compute is actually \( \bar u \) and the actual temperature will be \( u\,\mathrm{K} \):
$$
\begin{equation} \tag{4.18}
  -\nabla \cdot (\lambda \nabla  u)
  +\nabla \cdot \left(c\beta u\right) = f.
\end{equation}
$$


<!-- begin inline comment -->
<font color="red">(<b>hpl 36</b>: I would use the incompressible version of the heat equation everywhere; then we know it is correct.)</font>
<!-- end inline comment -->

Furthermore, since only derivatives of \( u \) appear in the equation, adding a constant offset to \( u \) does not change the equation. We may therefore work in Kelvin (\( \mathrm{K} \)) as well as in degrees centigrade without needing to rescale the equation.

<h1 id="___sec107">Finite element variational formulation </h1>

<p>
The finite element variational formulation of the convection diffusion
equation is obtained in the same way as for the Poisson equation in
the previous chapter, by multiplying the equation with a test function
\( v \), integrating over the domain \( \Omega \), and integrating terms with
second-derivatives by parts. For the (scaled) convection-diffusion
equation <a href="#mjx-eqn-4.18">(4.18)</a>, we have one such term, namely
\( -\nabla \cdot (\lambda u) \). For this term, integration by parts gives
$$
  -\int_{\Omega} (\nabla \cdot (\lambda \nabla u)) \, v \dx
  = \int_{\Omega} \lambda \nabla u \cdot \nabla v \dx
    - \int_{\partial\Omega} \lambda \nabla u \cdot n \, v \ds.
$$

Since we assume Dirichlet boundary conditions on the entire boundary, we take the test function \( v \) to be zero on \( \partial\Omega \) and thus obtain the following variational problem: find \( u \in V \) such that
$$
  \int_{\Omega} \lambda \nabla u \cdot \nabla v \dx
  + \int_{\Omega} \nabla \cdot (c\beta u)\,v \dx
  = \int_{\Omega} fv \dx,
$$

for all test functions \( v \in V \).

<p>
The variational problem can be stated in FEniCS as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> lmdba<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> div(c<span style="color: #666666">*</span>beta<span style="color: #666666">*</span>u)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
</pre></div>
<p>
Note the intentional misspelling of <code>lmbda</code> to avoid a name clash with the built-in Python keyword <code>lmbda</code>.

<h1 id="___sec108">Mesh generation </h1>

<h1 id="___sec109">Subdomain markers </h1>

<h1 id="___sec110">The complete program </h1>

<p>
Here is the code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Parameters for geometry</span>
a <span style="color: #666666">=</span> <span style="color: #666666">0.04</span>
b <span style="color: #666666">=</span> a <span style="color: #666666">+</span> <span style="color: #666666">0.004</span>
c <span style="color: #666666">=</span> a <span style="color: #666666">+</span> <span style="color: #666666">0.01</span>
L <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>

<span style="color: #408080; font-style: italic"># Define cylinders</span>
cylinder_a <span style="color: #666666">=</span> Cylinder(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, L), a, a)
cylinder_b <span style="color: #666666">=</span> Cylinder(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, L), b, b)
cylinder_c <span style="color: #666666">=</span> Cylinder(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, L), c, c)

<span style="color: #408080; font-style: italic"># Define domain and set subdomains</span>
domain <span style="color: #666666">=</span> cylinder_c
domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">1</span>, cylinder_b)
domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">2</span>, cylinder_a)

<span style="color: #408080; font-style: italic"># Generate mesh</span>
mesh <span style="color: #666666">=</span> generate_mesh(domain, <span style="color: #666666">16</span>)

xmlfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;pipe.xml&#39;</span>)
xmlfile <span style="color: #666666">&lt;&lt;</span> mesh

vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;pipe.pvd&#39;</span>)
vtkfile <span style="color: #666666">&lt;&lt;</span> mesh
</pre></div>
<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1010.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut1003.html">4</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li><a href="._ftut1010.html">11</a></li>
  <li class="active"><a href="._ftut1011.html">12</a></li>
  <li><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1014.html">15</a></li>
  <li><a href="._ftut1015.html">16</a></li>
  <li><a href="._ftut1012.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

