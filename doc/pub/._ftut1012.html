<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,unit testing,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,linear algebra backend,PETSc,Eigen,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,KrylovSolver,random start vector (linear systems),SLEPc,Poisson's equation with variable coefficient,Postprocessing,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional">

<title>Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'New feature: vector function space', 3, None, '___sec70'),
              (u'New feature: constant vectors', 3, None, '___sec71'),
              (u'New feature: `nabla_grad`', 3, None, '___sec72'),
              (u'New feature: stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec78'),
              (u'Test problem 1', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Exercise 2: Simulate channel flow in a 3D geometry',
               2,
               None,
               '___sec81'),
              (u'Flow past a cylinder', 2, None, '___sec82'),
              (u'FEniCS implementation', 3, None, '___sec83'),
              (u'A system of advection--diffusion--reaction equations',
               1,
               u'ftut1:reactionsystem',
               u'ftut1:reactionsystem'),
              (u'PDE problem', 2, None, '___sec85'),
              (u'Variational formulation', 2, None, '___sec86'),
              (u'A simple FEniCS implementation', 2, None, '___sec87'),
              (u'Setting initial conditions for mixed systems',
               2,
               None,
               '___sec88'),
              (u'Setting boundary conditions for mixed systems',
               2,
               None,
               '___sec89'),
              (u'Accessing components of mixed systems', 2, None, '___sec90'),
              (u'Subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Multiple domains and boundaries', 0, None, '___sec92'),
              (u'Combining Dirichlet and Neumann conditions',
               1,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 2, None, '___sec94'),
              (u'Variational formulation', 2, None, '___sec95'),
              (u'FEniCS implementation', 2, None, '___sec96'),
              (u'Setting multiple Dirichlet conditions',
               1,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Working with subdomains',
               1,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 2, None, '___sec99'),
              (u'Mesh functions', 2, None, '___sec100'),
              (u'C++ strings for subdomain definitions',
               2,
               None,
               '___sec101'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Setting multiple Neumann, Robin, and Dirichlet conditions',
               1,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 2, None, '___sec104'),
              (u'PDE problem', 2, None, '___sec105'),
              (u'Variational formulation', 2, None, '___sec106'),
              (u'FEniCS implementation', 2, None, '___sec107'),
              (u'Test problem', 2, None, '___sec108'),
              (u'Debugging boundary conditions', 2, None, '___sec109'),
              (u'Generating meshes with subdomains', 1, None, '___sec110'),
              (u'PDE problem', 2, None, '___sec111'),
              (u'Variational formulation', 2, None, '___sec112'),
              (u'FEniCS implementation', 2, None, '___sec113'),
              (u'Extensions: Improving the Poisson solver',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactoring the Poisson solver',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Writing the solver as a Python module',
               2,
               None,
               '___sec117'),
              (u'Verification and unit tests', 2, None, '___sec118'),
              (u'Examining the degrees of freedom',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Exercise 4: Solve a Poisson problem', 2, None, '___sec121'),
              (u'Remarks', 3, None, '___sec122'),
              (u'Exercise 5: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec124'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Choosing a linear solver and preconditioner',
               3,
               None,
               '___sec126'),
              (u'Choosing a linear algebra backend', 3, None, '___sec127'),
              (u'Setting solver parameters', 3, None, '___sec128'),
              (u'An extended solver function', 3, None, '___sec129'),
              (u'A remark regarding unit tests', 3, None, '___sec130'),
              (u'List of linear solver methods and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Explicit assembly and solve',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'Examining matrix and vector values', 2, None, '___sec134'),
              (u'Postprocessing computations',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'A variable-coefficient Poisson problem',
               2,
               None,
               '___sec136'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec139'),
              (u'Finite difference approximations', 3, None, '___sec140'),
              (u'Surface plot', 3, None, '___sec141'),
              (u'Contour plot', 3, None, '___sec142'),
              (u'Curve plot through the mesh', 3, None, '___sec143'),
              (u'Curve plot of the flux', 3, None, '___sec144'),
              (u'Test problem', 3, None, '___sec145'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec147'),
              (u'Error functional', 3, None, '___sec148'),
              (u'Flux Functional', 3, None, '___sec149'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Computing error norms', 3, None, '___sec151'),
              (u'Computing convergence rates', 3, None, '___sec152'),
              (u'Test problem', 3, None, '___sec153'),
              (u'Experiments', 3, None, '___sec154'),
              (u'Bibliography', 1, None, '___sec155')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\ub}{u_{_\mathrm{D}}}
\newcommand{\GD}{\Gamma_{_\mathrm{D}}}
\newcommand{\GN}{\Gamma_{_\mathrm{N}}}
\newcommand{\GR}{\Gamma_{_\mathrm{R}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: vector function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: <code>nabla_grad</code></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: stress computation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem 1</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Simulate channel flow in a 3D geometry</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:reactionsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A system of advection--diffusion--reaction equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting initial conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting boundary conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessing components of mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:subdomains" style="font-size: 80%;"><b>Subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec92" style="font-size: 80%;"><b>Multiple domains and boundaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Neumann, Robin, and Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generating meshes with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson" style="font-size: 80%;"><b>Extensions: Improving the Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactoring the Poisson solver</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing the solver as a Python module</a></li>
     <!-- navigation toc: --> <li><a href="#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear solver and preconditioner</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List of linear solver methods and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit assembly and solve</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining matrix and vector values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing error norms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0012"></a>
<!-- !split -->

<center><h1 id="ch:poisson">Extensions: Improving the Poisson solver</h1></center> <!-- chapter heading -->

<p>
<blockquote>
    This chapter goes through common improvements of the codes presented
    in the previous chapter. In particular, we show how to
    
    <ul>
     <li> write general solver functions</li>
     <li> utilize iterative solvers with preconditioners for solving linear systems</li>
     <li> compute derived quantities (e.g., flux at a part of the boundary)</li>
     <li> specify subdomains and parts of the boundary</li>
    </ul>
</blockquote>


<h1 id="ch:poisson0:impl2">Refactoring the Poisson solver</h1>

<p>
All programs created in this book so far are &quot;flat&quot;; that is, they are
not organized into logical, reusable units in terms of Python
functions. Such flat programs are useful for quickly testing out some
software, but not well suited for serious problem solving. We shall
therefore look at how to <em>refactor</em> the Poisson solver from the chapter <a href="._ftut1004.html#ch:fundamentals">Fundamentals: Solving the Poisson equation</a>.  For a start, this means splitting the code into
functions, but this is just a reordering of the existing
statements. During refactoring, we also try make the functions we
create as reusable as possible in other contexts. We will also
encapsulate statements specific to a certain problem into
(non-reusable) functions. Being able to distinguish reusable code from
specialized code is a key issue when refactoring code, and this
ability depends on a good mathematical understanding of the problem at
hand (what is general, what is special?).  In a flat program,
general and specialized code (and mathematics) are often mixed
together.

<h2 id="ch:poisson0:impl2:func">A more general solver function</h2>

<p>
We consider the flat program developed in the section <a href="._ftut1006.html#ch:poisson0:impl">FEniCS implementation</a>.  Some of the code in this program
is needed to solve any Poisson problem \( -\nabla^2 u=f \) on \( [0,1]\times
[0,1] \) with \( u=\ub \) on the boundary, while other statements arise from
our simple test problem. Let us collect the general, reusable code in
a function called <code>solver</code>. Our special test problem will then just be
an application of <code>solver</code> with some additional statements. We limit
the <code>solver</code> function to just <em>compute the numerical
solution</em>. Plotting and comparing the solution with the exact solution
are considered to be problem-specific activities to be performed
elsewhere.

<p>
We parameterize <code>solver</code> by \( f \), \( \ub \), and the resolution of the
mesh. Since it is so trivial to use higher-order finite element
functions by changing the third argument to <code>FunctionSpace</code>, we let
also the polynomial degree of the finite element function space
be an argument to <code>solver</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(f, u_D, Nx, Ny, degree<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -Laplace(u) = f on [0,1] x [0,1] with 2*Nx*Ny Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of specified degree and u=u_D (Expresssion) on</span>
<span style="color: #BA2121; font-style: italic">    the boundary.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u_D, boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
The remaining tasks of our initial program, such calling the <code>solve</code>
function with problem-specific parameters and plotting,
can be placed in a separate function. Here we choose to put this code
in a function named <code>application_test</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application_test</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute and post-process solution&quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Set up problem parameters and call solver</span>
    u_D <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)
    u <span style="color: #666666">=</span> solver(f, u_D, <span style="color: #666666">6</span>, <span style="color: #666666">4</span>, <span style="color: #666666">1</span>)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;u&#39;</span>)
    plot(u)
    plot(mesh)

    <span style="color: #408080; font-style: italic"># Save solution to file in VTK format</span>
    vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;poisson.pvd&#39;</span>)
    vtkfile <span style="color: #666666">&lt;&lt;</span> u
</pre></div>
<p>
The solution can now be computed, plotted, and saved to file by
simply calling the <code>application_test</code> function.

<h2 id="___sec117">Writing the solver as a Python module </h2>

<p>
The refactored code is put in a file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/ft06_poisson_func.py" target="_self"><tt>ft06_poisson_func.py</tt></a>. We should make sure
that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program that are not inside functions
should appear within a test <code>if __name__ == '__main__':</code>. This test is
true if the file is executed as a program, but false if the file is
imported.  If we want to run this file in the same way as we can run
<code>ft06_poisson_func.py</code>, the main program is simply a call to
<code>application_test()</code> followed by a call <code>interactive()</code> to hold the
plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    application_test()
    interactive()
</pre></div>

<h2 id="___sec118">Verification and unit tests </h2>

<p>
The remaining part of our first program is to compare the numerical
and the exact solutions. Every time we edit the code we must rerun the
test and examine that <code>max_error</code> is sufficiently small so we know
that the code still works. To this end, we shall adopt <em>unit testing</em>,
meaning that we create a mathematical test and corresponding software
that can run all our tests automatically and check that all tests
pass.  Python has several tools for unit testing. Two very popular
ones are <code>pytest</code> and <code>nose</code>. These are almost identical and very easy
to use.  More classical unit testing with test classes is offered by
the built-in tool <code>unittest</code>, but here we are going to use <code>pytest</code>
(or <code>nose</code>) since that will result in shorter and clearer code.

<p>
Mathematically, our unit test is that the finite element solution of
our problem when \( f=-6 \) equals the exact solution \( u=\ub=1+x^2+2y^2 \).
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which
depends to the number of elements and the degrees of the polynomials
in the finite element basis functions.  If we want to test that the
<code>solver</code> function works for meshes up to \( 2\times(20\times 20) \)
elements and cubic Lagrange elements, \( 10^{-11} \) is an appropriate
tolerance for testing that the maximum error vanishes (see the section <a href="._ftut1006.html#ch:poisson0:impl:dissect">Dissection of the program</a>).

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 36</b>: Changed to <code>pytest</code> and <code>nose</code> here (in computer font). Change back if not appropriate.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 37</b>: Changed back as pytest and nose are standard phrasings on the net.)</font>
<!-- end inline comment -->

<p>
Only three statements are necessary to carry out the unit
test. However, we shall embed these statements a special way in our
code so that they are recognized by <code>pytest</code> and <code>nose</code>. The simple
rule is that each test must be placed in a function that

<ul>
 <li> has a name starting with <code>test_</code>,</li>
 <li> has no arguments,</li>
 <li> implements a test expressed as <code>assert success, msg</code>.</li>
</ul>

Regarding the last point, <code>success</code> is a boolean expression that is
<code>False</code> if the test fails, and in that case the string <code>msg</code> is
written to the screen. When the test fails, <code>assert</code> raises an
<code>AssertionError</code> exception in Python, otherwise the statement runs
silently. The <code>msg</code> string is optional, so <code>assert success</code> is the
minimal test. In our case, we will write <code>assert max_error &lt; tol</code>,
where <code>tol</code> is the tolerance (\( 10^{-11} \)) mentioned above.

<p>
A proper <em>test function</em> for implementing this unit test in the
<code>pytest</code> or <code>nose</code> testing frameworks has the following form. Note
that we perform the test for different mesh resolutions and degrees of
finite elements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Reproduce u = 1 + x^2 + 2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Set up parameters for testing</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-11</span>
    u_D <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span>)
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">-6.0</span>)

    <span style="color: #408080; font-style: italic"># Iterate over mesh sizes and degrees</span>
    <span style="color: #008000; font-weight: bold">for</span> Nx, Ny <span style="color: #AA22FF; font-weight: bold">in</span> [(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">3</span>,<span style="color: #666666">5</span>), (<span style="color: #666666">5</span>,<span style="color: #666666">3</span>), (<span style="color: #666666">20</span>,<span style="color: #666666">20</span>)]:
        <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Solving on a 2 x (</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> x </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh with P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements.&#39;</span>
                  <span style="color: #666666">%</span> (Nx, Ny, degree))

            <span style="color: #408080; font-style: italic"># Compute solution</span>
            u <span style="color: #666666">=</span> solver(f, u_D, Nx, Ny, degree)

            <span style="color: #408080; font-style: italic"># Compute maximum error at vertices</span>
            vertex_values_u_D <span style="color: #666666">=</span> u_D<span style="color: #666666">.</span>compute_vertex_values(mesh)
            vertex_values_u  <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values(mesh)
            <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
            error_max <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(np<span style="color: #666666">.</span>abs(vertex_values_u_D <span style="color: #666666">-</span> vertex_values_u))

            <span style="color: #408080; font-style: italic"># Check maximum error</span>
            msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;error_max = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> error_max
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
To run the test, we type the following command:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Terminal&gt; py.test -s -v ft06_poisson_func.py
</pre></div>
<p>
This will run all functions <code>test_*()</code> (currently only the
<code>test_solver</code> function) found in the file and report the results.

<p>
We shall make it a habit in the following test to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented.

<p>
<!-- We dare to assert that this is the only serious way -->
<!-- do reliable computational science with FEniCS. -->

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Print messages in test functions.</b>
The <code>assert</code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code>assert</code>
(as we do in the example above) such that it is clear that the
test really takes place.
Note that <code>py.test</code> needs the <code>-s</code> option to show printout
from the test functions.
</div>


<h2 id="ch:poisson0:verify1">Examining the degrees of freedom</h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 38</b>: Important section, but maybe it fits better somewhere else since it does not specifically deal with code structuring.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 39</b>: Agree, it has been moved around...and it is pretty basic and should appear early (not volume II).)</font>
<!-- end inline comment -->

<p>
We have seen how to grab the degrees of freedom array from a
finite element function <code>u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>dofs <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
For a finite function from a standard continuous piecewise linear
function space (\( \mathsf{P}_1 \) Lagrange elements), these values will
be the same as the values we get by the following statement:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>vertex_values <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values(mesh)
</pre></div>
<p>
Both <code>dofs</code> and <code>vertex_values</code> will be <code>numpy</code> arrays and they will
be of the same length and contain the same values, but with possibly
different ordering. The array <code>vertex_values</code> will have the same
ordering as the vertices of the mesh, while <code>dofs</code> will be ordered in
a way that (nearly) minimizes the bandwidth of the system matrix and
thus improves the efficiency of linear solvers.

<p>
A fundamental question is: What are the
coordinates of vertex <code>i</code> whose value is <code>dofs[i]</code>? To answer this
question, we need to understand how to get our hands on the
coordinates, and in particular, the numbering of degrees of freedom
and the numbering of vertices in the mesh.

<p>
The function <code>mesh.coordinates()</code> returns the coordinates of the
vertices as a <code>numpy</code> array with shape \( (M,d \)), \( M \) being the number
of vertices in the mesh and \( d \) being the number of space dimensions:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> coordinates <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
<span style="color: #666666">&gt;&gt;&gt;</span> coordinates
array([[ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.</span> ],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>],
       [ <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.</span> ],
       [ <span style="color: #666666">1.</span> ,  <span style="color: #666666">1.</span> ]])
</pre></div>
<p>
We see from this output that for this particular mesh, the vertices
are first numbered along \( y=0 \)
with increasing \( x \) coordinate, then along \( y=0.5 \), and so on.

<p>
Next we compute a function <code>u</code> on this mesh. Let's take \( u=x+y \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> interpolate(Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>), V)
<span style="color: #666666">&gt;&gt;&gt;</span> plot(u, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> dofs <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
<span style="color: #666666">&gt;&gt;&gt;</span> dofs
array([ <span style="color: #666666">1.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">0.</span> ,  <span style="color: #666666">1.</span> ,  <span style="color: #666666">2.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">1.</span> ])
</pre></div>
<p>
We observe that <code>dofs[0]</code> is <em>not</em> the value of \( x+y \) at vertex number 0,
since this vertex has coordinates \( x=y=0 \). The numbering of the
degrees of freedom \( U_1,\ldots,U_{N} \) is obviously not the same as the
numbering of the vertices.

<p>
In the plot window, we may take a closer look at the function <code>u</code> and
the vertex numbering. We type <code>w</code> to turn on wireframe instead of
a fully  colored surface, <code>m</code> to show the mesh, and then <code>v</code> to show the
numbering of the vertices.

<p>
<br /><br /><center><p><img src="fig/vertex_numbering.png" align="bottom" width=500></p></center><br /><br />

<p>
Let's instead examine the values we get by calling
<code>u.compute_vertex_values()</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> vertex_values <span style="color: #666666">=</span> u<span style="color: #666666">.</span>compute_vertex_values()
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i, x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(coordinates):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertex </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: vertex_values[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">] = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121">u(</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">) = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
<span style="color: #666666">...</span>           (i, i, vertex_values[i], x, u(x)))
vertex <span style="color: #666666">0</span>: vertex_values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>  	u([ <span style="color: #666666">0.</span>  <span style="color: #666666">0.</span>]) <span style="color: #666666">=</span> <span style="color: #666666">8.46545e-16</span>
vertex <span style="color: #666666">1</span>: vertex_values[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.</span> ]) <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
vertex <span style="color: #666666">2</span>: vertex_values[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>          u([ <span style="color: #666666">1.</span>  <span style="color: #666666">0.</span>]) <span style="color: #666666">=</span> <span style="color: #666666">1</span>
vertex <span style="color: #666666">3</span>: vertex_values[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>	u([ <span style="color: #666666">0.</span>   <span style="color: #666666">0.5</span>]) <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
vertex <span style="color: #666666">4</span>: vertex_values[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>          u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">0.5</span>]) <span style="color: #666666">=</span> <span style="color: #666666">1</span>
vertex <span style="color: #666666">5</span>: vertex_values[<span style="color: #666666">5</span>] <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>	u([ <span style="color: #666666">1.</span>   <span style="color: #666666">0.5</span>]) <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
vertex <span style="color: #666666">6</span>: vertex_values[<span style="color: #666666">6</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>          u([ <span style="color: #666666">0.</span>  <span style="color: #666666">1.</span>]) <span style="color: #666666">=</span> <span style="color: #666666">1</span>
vertex <span style="color: #666666">7</span>: vertex_values[<span style="color: #666666">7</span>] <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>	u([ <span style="color: #666666">0.5</span>  <span style="color: #666666">1.</span> ]) <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
vertex <span style="color: #666666">8</span>: vertex_values[<span style="color: #666666">8</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>          u([ <span style="color: #666666">1.</span>  <span style="color: #666666">1.</span>]) <span style="color: #666666">=</span> <span style="color: #666666">2</span>
</pre></div>
<p>
We can ask FEniCS to give us the mapping from vertices to degrees of
freedom for a certain function space \( V \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>v2d <span style="color: #666666">=</span> vertex_to_dof_map(V)
</pre></div>
<p>
Now, <code>dofs[v2d[i]]</code> will give us the value of the degree of freedom in
<code>u</code> corresponding to vertex <code>i</code> (<code>v2d[i]</code>). In particular, <code>dofs[v2d]</code>
is an array with all the elements in the same (vertex numbered) order
as <code>coordinates</code>.  The inverse map, from degrees of freedom number to
vertex number is given by <code>dof_to_vertex_map(V)</code>, so
<code>coordinates[dof_to_vertex_map(V)]</code> results in an array of all the
coordinates in the same order as the degrees of freedom.

<p>
For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices. For these
elements, we may still ask FEniCS to compute the vertex values by
calling <code>u.compute_vertex_values(mesh)</code>, and we can get the degrees of
freedom by calling <code>u.vector().array()</code>. To get the coordinates
associated with all degrees of freedom, we need to iterate over the
elements of the mesh and ask FEniCS to return the coordinates and dofs
associated with each cell. This information is stored in the
<code>FiniteElement</code> and <code>DofMap</code> object of a <code>FunctionSpace</code>. The
following code illustrates how to iterate over all elements of a mesh and
print the degrees of freedom and coordinates associated with the
element.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>element <span style="color: #666666">=</span> V<span style="color: #666666">.</span>element()
dofmap <span style="color: #666666">=</span> V<span style="color: #666666">.</span>dofmap()
<span style="color: #008000; font-weight: bold">for</span> cell <span style="color: #AA22FF; font-weight: bold">in</span> cells(mesh):
    <span style="color: #008000; font-weight: bold">print</span>(element<span style="color: #666666">.</span>tabulate_dof_coordinates(cell))
    <span style="color: #008000; font-weight: bold">print</span>(dofmap<span style="color: #666666">.</span>cell_dofs(cell<span style="color: #666666">.</span>index()))
</pre></div>
<p>
<!-- @@@CODE src/poisson_iter.py fromto: def compare_exact@def normalize -->
<!-- As expected, the error is either identically zero or about \( 10^{-15} \) or -->
<!-- \( 10^{-16} \). -->

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Cheap vs expensive function evaluation.</b>
Given a <code>Function</code> object <code>u</code>, we can evaluate its values in various
ways:

<ol>
<li> <code>u(x)</code> for an arbitrary point <code>x</code></li>
<li> <code>u.vector().array()[i]</code> for degree of freedom number <code>i</code></li>
<li> <code>u.compute_vertex_values()[i]</code> at vertex number <code>i</code></li>
</ol>

The first method, though very flexible, is in general expensive
while the other two are very efficient (but limited to certain points).
</div>


<p>
To demonstrate the use of point evaluations of <code>Function</code> objects, we
write out the computed <code>u</code> at the center point of the domain and
compare it with the exact solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>center <span style="color: #666666">=</span> (<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>)
error <span style="color: #666666">=</span> u_D(center) <span style="color: #666666">-</span> u(center)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Error at </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (center, error))
</pre></div>
<p>
Trying on a \( 2\times(3\times 3) \) mesh, the output from the
previous snippet becomes

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Error at (0.5, 0.5): -0.0833333
</pre></div>
<p>
The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell, and
<code>u</code> varies linearly over the cell while <code>u_D</code> is a quadratic
function. When the center point is a node, as in a \( 2\times(2\times
2) \) or \( 2\times(4\times 4) \) mesh, the error is of the order
\( 10^{-15} \).

<p>
We have seen how to extract the nodal values in a <code>numpy</code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that \( \max_j |U_j| = 1 \). Then we
must divide all \( U_j \) values
by \( \max_j |U_j| \). The following function performs the task:

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 40</b>: Why is it called <code>poisson_iter.py</code>? Don't understand the logic behind the name...)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 41</b>: Poission equation with iterative mthods. Now explained at the very end of the section.)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">normalize_solution</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Normalize u: return u divided by max(|u|).&quot;&quot;&quot;</span>
    dofs <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
    u_max <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(dofs)<span style="color: #666666">.</span>max()
    dofs <span style="color: #666666">/=</span> u_max
    u<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> dofs
    u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>set_local(dofs) <span style="color: #408080; font-style: italic"># alternative</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
That is, we manipulate <code>dofs</code> as desired, and then we insert this
array into <code>u</code>'s <code>Vector</code> object.  The <code>/=</code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the array <code>dofs</code> are divided by the value <code>u_max</code>.
Alternatively, one could write <code>dofs = dofs / u_max</code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code>dofs</code>.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Be careful when manipulating degrees of freedom.</b>
A call like <code>u.vector().array()</code> returns a <em>copy</em> of the data in
<code>u.vector()</code>. One must therefore never perform assignments like
<code>u.vector.array()[:] = ...</code>, but instead extract the <code>numpy</code> array
(i.e., a copy), manipulate it, and insert it back with <code>u.vector()[:]
= </code> or use <code>u.set_local(...)</code>.
</div>


<p>
All the code in this subsection can be found in the file
<code>ft07_poisson_iter.py</code> (Poission solver with use of iterative
methods)

<h2 id="ch:poisson0:nD">Parameterizing the number of space dimensions</h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 42</b>: Use consistent mesh resolution, perhaps 16 for all examples. Now the resolution looks very random between examples.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 43</b>: True, but the randomness stems from the fact that 2 is enough for most examples, so anything works. I agree that 16 is a better number to display (and copy), and if we choose the extreme 2, there is an explanation in the text for that choice.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>AL 44</b>: I'm changing everything to 16 from now on for consistency. With today's computers, 16 is a reasonably small problem and a nice number. Needs to be revisited throughout the book! If we use 16, it is clear that 16 is a nice ''round'' number but 6, 4, 5 may look like something special - why make the mesh anisotropic?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 45</b>: OK!)</font>
<!-- end inline comment -->

<p>
FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory programs <code>ft01_poisson.py</code> or
<code>ft06_poisson_func.py</code> and change the mesh construction from
<code>UnitSquareMesh(16, 16)</code> to <code>UnitCubeMesh(16, 16, 16)</code>. Now the domain is
the unit cube partitioned into \( 16\times 16\times16 \) boxes, and
each box is divided into six tetrahedron-shaped finite elements for
computations. Run the program and observe that we can solve a 3D
problem without any other modifications (!). The visualization allows
you to rotate the cube and observe the function values as colors on
the boundary.

<p>
If we want to parameterize the creation of unit interval, unit square,
or unit cube over dimension, we can do so by encapsulating this part
of the code in a function. Given a list or tuple with the divisions
into cells in the various spatial coordinates, the following function
returns the mesh for a \( d \)-dimensional cube:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">UnitHyperCube</span>(divisions):
    mesh_classes <span style="color: #666666">=</span> [UnitIntervalMesh, UnitSquareMesh, UnitCubeMesh]
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(divisions)
    mesh <span style="color: #666666">=</span> mesh_classes[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
    <span style="color: #008000; font-weight: bold">return</span> mesh
</pre></div>
<p>
The construction <code>mesh_class[d-1]</code> will pick the right name of the
object used to define the domain and generate the mesh.  Moreover, the
argument <code>*divisions</code> sends all the components of the list <code>divisions</code>
as separate arguments to the constructor of the mesh construction
class picked out by <code>mesh_class[d-1]</code>. For example, in a 2D problem
where <code>divisions</code> has two elements, the statement

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> mesh_classes[d<span style="color: #666666">-1</span>](<span style="color: #666666">*</span>divisions)
</pre></div>
<p>
is equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> UnitSquareMesh(divisions[<span style="color: #666666">0</span>], divisions[<span style="color: #666666">1</span>])
</pre></div>
<p>
Replacing the <code>Nx</code> and <code>Ny</code> parameters by <code>divisions</code> and calling the
function <code>UnitHyperCube</code> to create the mesh are the two modifications
that we need in any of the previously shown <code>solver</code> functions to turn
them into solvers for \( d \)-dimensional problems. Note that
<code>UnitHyperCube</code> is a <em>function</em> and not a <em>class</em> but we have named it
with <em>CamelCase</em> to make it look like a class so that our programs
look similar to using the standard FEniCS mesh classes:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> UnitHyperCube(divisions)
</pre></div>
<p>
<!-- --- begin exercise --- -->

<h2 id="___sec121">Exercise 4: Solve a Poisson problem </h2>

<p>
Solve the following problem

$$
\begin{align}
\nabla^2 u &= 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x))
\hbox{ in }\Omega = [0,1]\times [0,1]
\tag{6.1}\\ 
u &= 0\quad\hbox{ on }\partial\Omega
\tag{6.2}
\end{align}
$$

The exact solution is given by

$$ u(x,y) = 2e^{-2x}\sin(\pi x)\sin(\pi y)\tp$$

Compute the maximum numerical approximation error in a mesh with
\( 2(N_x\times N_y) \) elements and in a mesh with double resolution:
\( 4(N_x\times N_y) \) elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
Make an illustrative plot of the solution too.

<p>
<b>a)</b>
Base your implementation on editing the program
<code>ft01_poisson.py</code>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
In the string for an <code>Expression</code> object, <code>pi</code> is the value of
\( \pi \). Also note that \( \pi^2 \) must be expressed with syntax
<code>pow(pi,2)</code> and not (the common Python syntax) <code>pi**2</code>.

<p>
FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code>/very/long/path/compile.log</code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_2">

<p>
The result that with P1 elements, doubling the resolution reduces the error
with a factor of four, is an
asymptotic result so it requires a sufficiently fine mesh. Here
one may start with \( N_x=N_y=20 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>poisson_fsin_flat</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_3">

<p>
Looking at the <code>ft01_poisson.py</code> code, we realize that
the following edits are required:

<ul>
 <li> Modify the <code>mesh</code> computation.</li>
 <li> Modify <code>u_b</code> and <code>f</code>.</li>
 <li> Add expression for the exact solution.</li>
 <li> Modify the computation of the numerical error.</li>
 <li> Insert a loop to enable solving the problem twice.</li>
 <li> Put the error reduction computation and the plot statements after the loop.</li>
</ul>

Here is the modified code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

Nx <span style="color: #666666">=</span> Ny <span style="color: #666666">=</span> <span style="color: #666666">20</span>
error <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
    Nx <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)
    Ny <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
    mesh <span style="color: #666666">=</span> UnitSquareMesh(Nx, Ny)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">1</span>)

    <span style="color: #408080; font-style: italic"># Define boundary conditions</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u0_boundary</span>(x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

    bc <span style="color: #666666">=</span> DirichletBC(V, u0, u0_boundary)

    <span style="color: #408080; font-style: italic"># Define variational problem</span>
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>)
    <span style="color: #408080; font-style: italic"># Note: no need for pi=DOLFIN_PI in f, pi is valid variable</span>
    a <span style="color: #666666">=</span> inner(nabla_grad(u), nabla_grad(v))<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

    <span style="color: #408080; font-style: italic"># Compute solution</span>
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span>)

    u_e_Function <span style="color: #666666">=</span> interpolate(u_e, V)         <span style="color: #408080; font-style: italic"># exact solution</span>
    u_e_array <span style="color: #666666">=</span> u_e_Function<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()  <span style="color: #408080; font-style: italic"># dof values</span>
    max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
    error<span style="color: #666666">.</span>append(max_error)

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Error reduction:&#39;</span>, error[<span style="color: #666666">1</span>]<span style="color: #666666">/</span>error[<span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u)

<span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
<span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
<span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
The number \( \pi \) has the symbol <code>M_PI</code> in C and C++, but in C++
strings in <code>Expression</code> objects, the symbol <code>pi</code> can be used directly
(or one can use the less readable <code>DOLFIN_PI</code>).

<p>
<br /><br /><center><p><img src="fig/poisson_fsin.png" align="bottom" width=500></p></center><br /><br />

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Base your implementation on a new file that imports functionality
from the module <code>ft06_poisson_func.py</code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code>poisson_fsin_func</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_4">

<p>
Solving the two problems is a matter of calling <code>solver</code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code>test_solver</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">poisson_func</span> <span style="color: #008000; font-weight: bold">import</span> (
    solver, Expression, Constant, interpolate, File, plot,
    interactive)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">data</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    u0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    u_e <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span>)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span style="color: #BA2121">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span style="color: #BA2121">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> u0, f, u_e

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">20</span>
    Ny <span style="color: #666666">=</span> Nx
    error <span style="color: #666666">=</span> []
    <span style="color: #408080; font-style: italic"># Loop over refined meshes</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
        Nx <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        Ny <span style="color: #666666">*=</span> i<span style="color: #666666">+1</span>
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;solving on 2(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny))
        u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, degree<span style="color: #666666">=1</span>)
        <span style="color: #408080; font-style: italic"># Make a finite element function of the exact u_e</span>
        V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
        u_e_array <span style="color: #666666">=</span> interpolate(u_e, V)<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        max_error <span style="color: #666666">=</span> (u_e_array <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># Linf norm</span>
        error<span style="color: #666666">.</span>append(max_error)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max error:&#39;</span>, max_error)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(error)):
        error_reduction <span style="color: #666666">=</span> error[i]<span style="color: #666666">/</span>error[i<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error reduction:&#39;</span>, error_reduction)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(error_reduction <span style="color: #666666">-</span> <span style="color: #666666">0.25</span>) <span style="color: #666666">&lt;</span> <span style="color: #666666">0.1</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    u0, f, u_e <span style="color: #666666">=</span> data()
    Nx <span style="color: #666666">=</span> <span style="color: #666666">40</span>
    Ny <span style="color: #666666">=</span> Nx
    u <span style="color: #666666">=</span> solver(f, u0, Nx, Ny, <span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic"># Dump solution to file in VTK format</span>
    <span style="color: #008000">file</span> <span style="color: #666666">=</span> File(<span style="color: #BA2121">&quot;poisson.pvd&quot;</span>)
    <span style="color: #008000">file</span> <span style="color: #666666">&lt;&lt;</span> u
    <span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
    plot(u)

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    test_solver()
    application()
    <span style="color: #408080; font-style: italic"># Hold plot</span>
    interactive()
</pre></div>
<p>
The unit test is embedded in a proper test function <code>test_solver</code> for
the <code>pytest</code> or <code>nose</code> testing frameworks. Visualization of the
solution is encapsulated in the <code>application</code> function. Since we need
<code>u_e</code>, <code>u_b</code>, and <code>f</code> in two functions, we place the definitions in a
function <code>data</code> to avoid copies of these expressions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec122">Remarks </h3>

<p>
This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code>solver</code> function, requires <em>no modifications</em>
of the <code>ft06_poisson_func.py</code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code>ft06_poisson_func.py</code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension. Hopefully, with this exercise
you realize that embedding
PDE solvers in functions (or classes) makes more reusable software than
flat programs.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="ch:poisson0:exer:membrane">Exercise 5: Refactor the code for membrane deflection</h2>

<p>
The <code>ft02_membrane.py</code> program simulates the deflection of a
membrane. Refactor this code such that we have a <code>solver</code> function as
in the program with name <code>ft06_poisson_func.py</code>. Let the user
have the option to choose a direct or iterative solver for the linear
system.  Also implement a unit test where you have \( p=4 \) (constant)
and use P2 and P3 elements. In this case, the exact solution is
quadratic in \( x \) and \( y \) and will be &quot;exactly&quot; reproduced by P2 and
higher-order elements.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
We can use the <code>solver</code> function from <code>ft06_poisson_func.py</code>
right away. The major difference is that
the domain is now a circle and not a square. We change the <code>solver</code>
function by letting the mesh be an argument <code>mesh</code> (instead of <code>Nx</code>
and <code>Ny</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u_b, mesh, degree<span style="color: #666666">=1</span>,
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Alt: &#39;direct&#39;</span>
    <span style="color: #666666">...</span>):
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
    <span style="color: #408080; font-style: italic"># code as before</span>
</pre></div>
<p>
The complete code becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>(beta, R0, num_elements_radial_dir):
    <span style="color: #408080; font-style: italic"># Scaled pressure function</span>
    p <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
        beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)

    <span style="color: #408080; font-style: italic"># Generate mesh over the unit circle</span>
    domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
    mesh <span style="color: #666666">=</span> generate_mesh(domain, num_elements_radial_dir)

    w <span style="color: #666666">=</span> solver(p, Constant(<span style="color: #666666">0</span>), mesh, degree<span style="color: #666666">=1</span>,
               linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    w<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;w&#39;</span>, <span style="color: #BA2121">&#39;deflection&#39;</span>)  <span style="color: #408080; font-style: italic"># set name and label (description)</span>

    <span style="color: #408080; font-style: italic"># Plot scaled solution, mesh and pressure</span>
    plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Mesh over scaled domain&#39;</span>)
    plot(w, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> w<span style="color: #666666">.</span>label())
    V <span style="color: #666666">=</span> w<span style="color: #666666">.</span>function_space()
    p <span style="color: #666666">=</span> interpolate(p, V)
    p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;p&#39;</span>, <span style="color: #BA2121">&#39;pressure&#39;</span>)
    plot(p, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled &#39;</span> <span style="color: #666666">+</span> p<span style="color: #666666">.</span>label())

    <span style="color: #408080; font-style: italic"># Dump p and w to file in VTK format</span>
    vtkfile1 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_deflection.pvd&#39;</span>)
    vtkfile1 <span style="color: #666666">&lt;&lt;</span> w
    vtkfile2 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_load.pvd&#39;</span>)
    vtkfile2 <span style="color: #666666">&lt;&lt;</span> p
</pre></div>
<p>
The key function to simulate membrane deflection is named <code>application</code>.

<p>
For \( p=4 \), we have \( w=1-x^2-y^2 \) as exact solution.
The unit test for P2 and P3 goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_membrane</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Verification for constant pressure.&quot;&quot;&quot;</span>
    p <span style="color: #666666">=</span> Constant(<span style="color: #666666">4</span>)
    <span style="color: #408080; font-style: italic"># Generate mesh over the unit circle</span>
    domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">2</span>, <span style="color: #666666">3</span>:
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;********* P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements:&#39;</span> <span style="color: #666666">%</span> degree)
        n <span style="color: #666666">=</span> <span style="color: #666666">5</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">4</span>):  <span style="color: #408080; font-style: italic"># Run some resolutions</span>
            n <span style="color: #666666">*=</span> (i<span style="color: #666666">+1</span>)
            mesh <span style="color: #666666">=</span> generate_mesh(domain, n)
            <span style="color: #408080; font-style: italic">#info(mesh)</span>
            w <span style="color: #666666">=</span> solver(p, Constant(<span style="color: #666666">0</span>), mesh, degree<span style="color: #666666">=</span>degree,
                       linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max w: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, w(0,0)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, h=</span><span style="color: #BB6688; font-weight: bold">%.3E</span><span style="color: #BA2121">, dofs=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (w<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max(), w((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>)),
                   <span style="color: #666666">1/</span>np<span style="color: #666666">.</span>sqrt(mesh<span style="color: #666666">.</span>num_vertices()),
                   w<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim()))

            w_exact <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 - x[0]*x[0] - x[1]*x[1]&#39;</span>)
            w_e <span style="color: #666666">=</span> interpolate(w_exact, w<span style="color: #666666">.</span>function_space())
            error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(w_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span>
                           w<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error: </span><span style="color: #BB6688; font-weight: bold">%.3E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> error)
            <span style="color: #008000; font-weight: bold">assert</span> error <span style="color: #666666">&lt;</span> <span style="color: #666666">9.61E-03</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application2</span>(
    beta, R0, num_elements_radial_dir):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Explore more built-in visulization features.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Scaled pressure function</span>
    p <span style="color: #666666">=</span> Expression(
        <span style="color: #BA2121">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span>,
        beta<span style="color: #666666">=</span>beta, R0<span style="color: #666666">=</span>R0)

    <span style="color: #408080; font-style: italic"># Generate mesh over the unit circle</span>
    domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>), <span style="color: #666666">1.0</span>)
    mesh <span style="color: #666666">=</span> generate_mesh(domain, num_elements_radial_dir)

    w <span style="color: #666666">=</span> solver(p, Constant(<span style="color: #666666">0</span>), mesh, degree<span style="color: #666666">=1</span>,
               linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
    w<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;w&#39;</span>, <span style="color: #BA2121">&#39;deflection&#39;</span>)

    <span style="color: #408080; font-style: italic"># Plot scaled solution, mesh and pressure</span>
    plot(mesh, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Mesh over scaled domain&#39;</span>)
    viz_w <span style="color: #666666">=</span> plot(w,
                 wireframe<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                 title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled membrane deflection&#39;</span>,
                 axes<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                 interactive<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                 )
    viz_w<span style="color: #666666">.</span>elevate(<span style="color: #666666">-10</span>) <span style="color: #408080; font-style: italic"># adjust (lift) camera from default view</span>
    viz_w<span style="color: #666666">.</span>plot(w)      <span style="color: #408080; font-style: italic"># bring new settings into action</span>
    viz_w<span style="color: #666666">.</span>write_png(<span style="color: #BA2121">&#39;deflection&#39;</span>)
    viz_w<span style="color: #666666">.</span>write_pdf(<span style="color: #BA2121">&#39;deflection&#39;</span>)

    V <span style="color: #666666">=</span> w<span style="color: #666666">.</span>function_space()
    p <span style="color: #666666">=</span> interpolate(p, V)
    p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;p&#39;</span>, <span style="color: #BA2121">&#39;pressure&#39;</span>)
    viz_p <span style="color: #666666">=</span> plot(p, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Scaled pressure&#39;</span>, interactive<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    viz_p<span style="color: #666666">.</span>elevate(<span style="color: #666666">-10</span>)
    viz_p<span style="color: #666666">.</span>plot(p)
    viz_p<span style="color: #666666">.</span>write_png(<span style="color: #BA2121">&#39;pressure&#39;</span>)
    viz_p<span style="color: #666666">.</span>write_pdf(<span style="color: #BA2121">&#39;pressure&#39;</span>)

    <span style="color: #408080; font-style: italic"># Dump w and p to file in VTK format</span>
    vtkfile1 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_deflection.pvd&#39;</span>)
    vtkfile1 <span style="color: #666666">&lt;&lt;</span> w
    vtkfile2 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;membrane_load.pvd&#39;</span>)
    vtkfile2 <span style="color: #666666">&lt;&lt;</span> p
</pre></div>
<p>
The striking feature is that the solver does not reproduce the solution
to an accuracy more than about 0.01 (!), regardless of the resolution and
type of element.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>membrane_func</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1011.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li><a href="._ftut1010.html">11</a></li>
  <li><a href="._ftut1011.html">12</a></li>
  <li class="active"><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1014.html">15</a></li>
  <li><a href="._ftut1013.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

