<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,unit testing,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,linear algebra backend,PETSc,Eigen,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,KrylovSolver,random start vector (linear systems),SLEPc,Poisson's equation with variable coefficient,Postprocessing,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional">

<title>Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'New feature: vector function space', 3, None, '___sec70'),
              (u'New feature: constant vectors', 3, None, '___sec71'),
              (u'New feature: `nabla_grad`', 3, None, '___sec72'),
              (u'New feature: stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec78'),
              (u'Test problem 1: Channel flow', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Verification', 3, None, '___sec81'),
              (u'Exercise 2: Simulate channel flow in a 3D geometry',
               2,
               None,
               '___sec82'),
              (u'Flow past a cylinder', 2, None, '___sec83'),
              (u'FEniCS implementation', 3, None, '___sec84'),
              (u'A system of advection--diffusion--reaction equations',
               1,
               u'ftut1:reactionsystem',
               u'ftut1:reactionsystem'),
              (u'PDE problem', 2, None, '___sec86'),
              (u'Variational formulation', 2, None, '___sec87'),
              (u'A simple FEniCS implementation', 2, None, '___sec88'),
              (u'Setting initial conditions for mixed systems',
               2,
               None,
               '___sec89'),
              (u'Setting boundary conditions for mixed systems',
               2,
               None,
               '___sec90'),
              (u'Accessing components of mixed systems', 2, None, '___sec91'),
              (u'Subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Combining Dirichlet and Neumann conditions',
               1,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 2, None, '___sec94'),
              (u'Variational formulation', 2, None, '___sec95'),
              (u'FEniCS implementation', 2, None, '___sec96'),
              (u'Setting multiple Dirichlet conditions',
               1,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Working with subdomains',
               1,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 2, None, '___sec99'),
              (u'Mesh functions', 2, None, '___sec100'),
              (u'C++ strings for subdomain definitions',
               2,
               None,
               '___sec101'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Setting multiple Neumann, Robin, and Dirichlet conditions',
               1,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 2, None, '___sec104'),
              (u'PDE problem', 2, None, '___sec105'),
              (u'Variational formulation', 2, None, '___sec106'),
              (u'FEniCS implementation', 2, None, '___sec107'),
              (u'Test problem', 2, None, '___sec108'),
              (u'Debugging boundary conditions', 2, None, '___sec109'),
              (u'Generating meshes with subdomains', 1, None, '___sec110'),
              (u'PDE problem', 2, None, '___sec111'),
              (u'Variational formulation', 2, None, '___sec112'),
              (u'FEniCS implementation', 2, None, '___sec113'),
              (u'Extensions: Improving the Poisson solver',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactoring the Poisson solver',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Writing the solver as a Python module',
               2,
               None,
               '___sec117'),
              (u'Verification and unit tests', 2, None, '___sec118'),
              (u'Examining the degrees of freedom',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Exercise 4: Solve a Poisson problem', 2, None, '___sec121'),
              (u'Remarks', 3, None, '___sec122'),
              (u'Exercise 5: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec124'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Choosing a linear solver and preconditioner',
               3,
               None,
               '___sec126'),
              (u'Choosing a linear algebra backend', 3, None, '___sec127'),
              (u'Setting solver parameters', 3, None, '___sec128'),
              (u'An extended solver function', 3, None, '___sec129'),
              (u'A remark regarding unit tests', 3, None, '___sec130'),
              (u'List of linear solver methods and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Explicit assembly and solve',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'Examining matrix and vector values', 2, None, '___sec134'),
              (u'Postprocessing computations',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'A variable-coefficient Poisson problem',
               2,
               None,
               '___sec136'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec139'),
              (u'Finite difference approximations', 3, None, '___sec140'),
              (u'Surface plot', 3, None, '___sec141'),
              (u'Contour plot', 3, None, '___sec142'),
              (u'Curve plot through the mesh', 3, None, '___sec143'),
              (u'Curve plot of the flux', 3, None, '___sec144'),
              (u'Test problem', 3, None, '___sec145'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec147'),
              (u'Error functional', 3, None, '___sec148'),
              (u'Flux Functional', 3, None, '___sec149'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Computing error norms', 3, None, '___sec151'),
              (u'Computing convergence rates', 3, None, '___sec152'),
              (u'Test problem', 3, None, '___sec153'),
              (u'Experiments', 3, None, '___sec154'),
              (u'Bibliography', 1, None, '___sec155')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\ub}{u_{_\mathrm{D}}}
\newcommand{\GD}{\Gamma_{_\mathrm{D}}}
\newcommand{\GN}{\Gamma_{_\mathrm{N}}}
\newcommand{\GR}{\Gamma_{_\mathrm{R}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1001.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: vector function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: <code>nabla_grad</code></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: stress computation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem 1: Channel flow</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Simulate channel flow in a 3D geometry</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:reactionsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A system of advection--diffusion--reaction equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting initial conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting boundary conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessing components of mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:subdomains" style="font-size: 80%;"><b>Subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Neumann, Robin, and Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generating meshes with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson" style="font-size: 80%;"><b>Extensions: Improving the Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactoring the Poisson solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing the solver as a Python module</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear solver and preconditioner</a></li>
     <!-- navigation toc: --> <li><a href="#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List of linear solver methods and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit assembly and solve</a></li>
     <!-- navigation toc: --> <li><a href="#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining matrix and vector values</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec136" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functional</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing error norms</a></li>
     <!-- navigation toc: --> <li><a href="#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0012"></a>
<!-- !split -->

<h1 id="___sec124" class="anchor">Working with linear solvers </h1>

<p>
Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and simple method. It is the recommended method for systems
with up to a few thousand unknowns and may hence be the method of
choice in many 2D and smaller 3D problems. However, sparse LU
decomposition becomes slow and one quickly runs out of memory for
larger problems. For large problems, we instead need to use <em>iterative
methods</em> which are faster and require much less memory. We will now
look at how to take advantage of state-of-the-art iterative solution
methods in FEniCS.

<h2 id="ch:poisson0:solve:prm" class="anchor">Controlling the solution process</h2>

<h3 id="___sec126" class="anchor">Choosing a linear solver and preconditioner </h3>

<p>
Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite system matrix, for which the
optimal Krylov solver is the Conjugate Gradient (CG) method. However,
the CG method requires boundary conditions to be implemented in a
symmetric way. This is not the case by default, so then a Krylov
solver for non-symmetric system, such as GMRES, is a better choice.
Incomplete LU factorization (ILU) is a popular and robust all-round
preconditioner, so let us try the GMRES-ILU pair:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solve(a <span style="color: #666666">==</span> L, u, bc)
      solver_parameters<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                         <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>})
<span style="color: #408080; font-style: italic"># Alternative syntax</span>
solve(a <span style="color: #666666">==</span> L, u, bc,
      solver_parameters<span style="color: #666666">=</span><span style="color: #008000">dict</span>(linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;gmres&#39;</span>,
                             preconditioner<span style="color: #666666">=</span><span style="color: #BA2121">&#39;ilu&#39;</span>))
</pre></div>
<p>
the section <a href="#ftut:app:solver:prec">List of linear solver methods and preconditioners</a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.

<h3 id="___sec127" class="anchor">Choosing a linear algebra backend </h3>

<p>
The actual GMRES and ILU implementations that are brought into action
depend on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology. PETSc is the default choice if FEniCS is compiled
with PETSc. If PETSc is not available, then FEniCS falls back to using
the Eigen backend.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>] <span style="color: #666666">=</span> backendname
</pre></div>
<p>
where <code>backendname</code> is a string. To see which linear algebra backends
are available, you can call the FEniCS function
<code>list_linear_algebra_backends()</code>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 48</b>: Note that currently only PETSc and Eigen are available and Epetra is on its way back in.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 49</b>: OK, you have the overview here.)</font>
<!-- end inline comment -->

<h3 id="___sec128" class="anchor">Setting solver parameters </h3>

<p>
We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method. Such parameters can be controlled at both a <em>global</em>
and <em>local</em> level. We will start by looking at how to set global
parameters. For more advanced programs, one may want to use a number
of different linear solvers and set different tolerances and other
parameters. Then it becomes important to control the parameters at a
<em>local</em> level. We will return to this issue in the section <a href="#ch:poisson0:solver:problem">Linear variational problem and solver objects</a>.

<p>
Changing a parameter in the global FEniCS parameter database affects
all linear solvers (created <em>after</em> the parameter has been set).
The global FEniCS parameter database is simply called <code>parameters</code> and
it behaves as a nested dictionary. Write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>info(parameters, verbose<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code>info</code>.
According to this output, the relevant parameter set is
named <code>'krylov_solver'</code>, and the parameters are set like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-10</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-6</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.

<p>
<!-- To get a printout of the number of actual iterations to reach the -->
<!-- topping criterion, we can insert -->
<!--  -->
<!-- !bc pycod -->
<!-- set_log_level(PROGRESS) -->
<!-- set_log_level(DEBUG) -->
<!-- !ec -->
<!-- A message with the equation system size, solver type, and number of -->
<!-- iterations arises from specifying the argument <code>PROGRESS</code>, while -->
<!-- <code>DEBUG</code> results in more information, including CPU time spent in -->
<!-- the various parts of the matrix assembly and solve process. -->

<p>
We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>File(<span style="color: #BA2121">&#39;dolfin_parameters.xml&#39;</span>) <span style="color: #666666">&lt;&lt;</span> parameters
</pre></div>
<p>
If a <code>dolfin_parameters.xml</code> file is found in the directory where a
FEniCS program is run, this file is read and used to initialize the
<code>parameters</code> object. Otherwise, the file
<code>.config/fenics/dolfin_parameters.xml</code> in the user's home directory is
read, if it exists.  Another alternative is to load the XML (with any
name) manually in the program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>File(<span style="color: #BA2121">&#39;dolfin_parameters.xml&#39;</span>) <span style="color: #666666">&gt;&gt;</span> parameters
</pre></div>
<p>
The XML file can also be in gzip'ed form with the extension <code>.xml.gz</code>.

<h3 id="___sec129" class="anchor">An extended solver function </h3>

<p>
We may extend the previous solver function from
<code>ft06_poisson_func.py</code> in the section <a href="._ftut1011.html#ch:poisson0:impl2:func">A more general solver function</a>
such that it also offers the GMRES+ILU
preconditioned Krylov solver:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(
    f, u_b, Nx, Ny,
    degree<span style="color: #666666">=1</span>,               <span style="color: #408080; font-style: italic"># Polynomial degree of function space</span>
    linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Krylov&#39;</span>, <span style="color: #408080; font-style: italic"># Linear solver method (alt: &#39;direct&#39;)</span>
    abs_tol<span style="color: #666666">=1E-5</span>,           <span style="color: #408080; font-style: italic"># Absolute tolerance in Krylov solver</span>
    rel_tol<span style="color: #666666">=1E-3</span>,           <span style="color: #408080; font-style: italic"># Relative tolerance in Krylov solver</span>
    max_iter<span style="color: #666666">=1000</span>,          <span style="color: #408080; font-style: italic"># Max iterations in Krylov solver</span>
    log_level<span style="color: #666666">=</span>PROGRESS,     <span style="color: #408080; font-style: italic"># Amount of solver output</span>
    print_parameters<span style="color: #666666">=</span><span style="color: #008000">False</span>, <span style="color: #408080; font-style: italic"># Print solver parameters to screen?</span>
    ):
    <span style="color: #666666">...</span>
    <span style="color: #408080; font-style: italic"># Set up variational problem: a, L, declare u, etc.</span>

    <span style="color: #008000; font-weight: bold">if</span> linear_solver <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Krylov&#39;</span>:
        prm <span style="color: #666666">=</span> parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>]
        prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> abs_tol
        prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> rel_tol
        prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> max_iter
        <span style="color: #008000; font-weight: bold">print</span>(parameters[<span style="color: #BA2121">&#39;linear_algebra_backend&#39;</span>])
        set_log_level(log_level)
        <span style="color: #008000; font-weight: bold">if</span> dump_parameters:
            info(parameters, <span style="color: #008000">True</span>)
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;gmres&#39;</span>,
                             <span style="color: #BA2121">&#39;preconditioner&#39;</span>: <span style="color: #BA2121">&#39;ilu&#39;</span>}
    <span style="color: #008000; font-weight: bold">else</span>:
        solver_parameters <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;linear_solver&#39;</span>: <span style="color: #BA2121">&#39;lu&#39;</span>}

    solve(a <span style="color: #666666">==</span> L, u, bc, solver_parameters<span style="color: #666666">=</span>solver_parameters)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
This new <code>solver</code> function, found in the file
<code>ft07_poisson_iter.py</code>, replaces the one in <code>ft06_poisson_func.py</code>:
it has all the functionality of the previous <code>solver</code> function,
but can also solve the linear system with
iterative methods and report the progress of such solvers.

<h3 id="___sec130" class="anchor">A remark regarding unit tests </h3>

<p>
Regarding verification of the new <code>solver</code> function in terms of unit
tests, it turns out that unit testing for a problem where the
approximation error vanishes gets more complicated when we use
iterative methods. The problem is to keep the error due to iterative
solution smaller than the tolerance used in the verification
tests. First of all, this means that the tolerances used in the Krylov
solvers must be smaller than the tolerance used in the <code>assert</code> test,
but this is no guarantee to keep the linear solver error this small.
For linear elements and small meshes, a tolerance of \( 10^{-11} \) works
well in the case of Krylov solvers too (using a tolerance \( 10^{-12} \)
in those solvers). However, as soon as we switch to \( \mathsf{P}_2 \)
elements, it is hard to force the linear solver error below
\( 10^{-6} \). Consequently, tolerances in tests depend on the numerical
method being used. The interested reader is referred to the
<code>test_solver</code> function in <code>ft07_poisson_iter.py</code> for details:
this function tests the numerical solution for direct and iterative
linear solvers, for different meshes, and different degrees of the
polynomials in the finite element basis functions.

<h2 id="ftut:app:solver:prec" class="anchor">List of linear solver methods and preconditioners</h2>

<p>
Which linear solvers and preconditioners that are available
in FEniCS depends on how FEniCS has been configured and which
linear algebra backend is currently active. The following table
shows an example of which linear solvers that can be available
through FEniCS when the PETSc backend is active:

<p>

<div class="row">
  <div class="col-xs-8">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>            Name           </b></td> <td align="center"><b>                   Method                   </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>'bicgstab'</code>        </td> <td align="left">   Biconjugate gradient stabilized method          </td> </tr>
<tr><td align="left">   <code>'cg'</code>              </td> <td align="left">   Conjugate gradient method                       </td> </tr>
<tr><td align="left">   <code>'gmres'</code>           </td> <td align="left">   Generalized minimal residual method             </td> </tr>
<tr><td align="left">   <code>'minres'</code>          </td> <td align="left">   Minimal residual method                         </td> </tr>
<tr><td align="left">   <code>'petsc'</code>           </td> <td align="left">   PETSc built in LU solver                        </td> </tr>
<tr><td align="left">   <code>'richardson'</code>      </td> <td align="left">   Richardson method                               </td> </tr>
<tr><td align="left">   <code>'superlu_dist'</code>    </td> <td align="left">   Parallel SuperLU                                </td> </tr>
<tr><td align="left">   <code>'tfqmr'</code>           </td> <td align="left">   Transpose-free quasi-minimal residual method    </td> </tr>
<tr><td align="left">   <code>'umfpack'</code>         </td> <td align="left">   UMFPACK                                         </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-8 -->
</div> <!-- cell row -->
<p>
The set of available preconditioners also depends on configuration and
linear algebra backend. The following table shows an example of which
preconditioners may be available:

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>          Name          </b></td> <td align="center"><b>              Method             </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>'icc'</code>          </td> <td align="left">   Incomplete Cholesky factorization    </td> </tr>
<tr><td align="left">   <code>'ilu'</code>          </td> <td align="left">   Incomplete LU factorization          </td> </tr>
<tr><td align="left">   <code>'petsc_amg'</code>    </td> <td align="left">   PETSc algebraic multigrid            </td> </tr>
<tr><td align="left">   <code>'sor'</code>          </td> <td align="left">   Successive over-relaxation           </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-6 -->
</div> <!-- cell row -->
<p>
An up-to-date list of the available solvers and preconditioners
for your FEniCS installation can be produced by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>list_linear_solver_methods()
list_krylov_solver_preconditioners()
</pre></div>

<h2 id="ch:poisson0:solver:problem" class="anchor">Linear variational problem and solver objects</h2>

<p>
The FEniCS interface allows different ways to access the core
functionality, ranging from very high-level to low-level access. So
far, we have mostly used the high-level call <code>solve(a == L, u, bc)</code> to
solve a variational problem <code>a == L</code> with a certain boundary condition
<code>bc</code>. However, sometimes you may need more fine-grained control over
the solution process. In particular, the call to <code>solve</code> will create
certain objects that are thrown away after the solution has been
computed, and it may be practical or efficient to <em>reuse</em> those
objects.

<p>
In this section, we will look an alternative interface to solving
linear variational problems in FEniCS, which may be preferable in
many situations compared to the high-level <code>solve</code> function interface.
This interface uses the two classes <code>LinearVariationalProblem</code> and
<code>LinearVariationalSolver</code>. Using this interface, the equivalent of
<code>solve(a == L, u, bc)</code> looks as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> Function(V)
problem <span style="color: #666666">=</span> LinearVariationalProblem(a, L, u, bc)
solver  <span style="color: #666666">=</span> LinearVariationalSolver(problem)
solver<span style="color: #666666">.</span>solve()
</pre></div>
<p>
Many FEniCS objects have an attribute <code>parameters</code> corresponding to
a parameter set in the global <code>parameters</code> database,
but local to the object. Here, <code>solver.parameters</code> play that
role. Setting the CG method with ILU preconditioning as the solution
method and specifying solver-specific parameters can be done
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;linear_solver&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;gmres&#39;</span>
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;preconditioner&#39;</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ilu&#39;</span>
prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;krylov_solver&#39;</span>] <span style="color: #408080; font-style: italic"># short form</span>
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
</pre></div>
<p>
Settings in the global <code>parameters</code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as above. Note that global parameter
values can only affect local parameter values if set before the time
of creation of the local object. Thus, changing the value of the
tolerance in the global parameter database will not affect the
parameters for already created solvers.

<p>
The linear variational problem and solver objects as outlined above
are incorporated in an alternative solver function, named
<code>solver_objects</code>, in
<code>ft07_poisson_iter.py</code>. Otherwise, this function is similar to the
previously shown <code>solver</code> function.

<h2 id="ch:poisson0:linalg" class="anchor">Explicit assembly and solve</h2>

<p>
As we saw already in the section <a href="._ftut1008.html#ftut1:NS">The Navier--Stokes equations</a>, linear variational
problems can be assembled explicitly in FEniCS into matrices and
vectors using the <code>assemble</code> function. This allows even more
fine-grained control of the solution process compared to using the
high-level <code>solve</code> function or using the class
<code>LinearVariationalSolver</code>. We will now look more closely into how to
use the <code>assemble</code> function and how to combine this with low-level
calls for solving the assembled linear systems.

<p>
Given a variational problem \( a(u,v)=L(v) \), the discrete solution \( u \)
is computed by inserting \( u=\sum_{j=1}^N U_j \phi_j \) into \( a(u,v) \) and
demanding \( a(u,v)=L(v) \) to be fulfilled for \( N \) test functions
\( \hat\phi_1,\ldots,\hat\phi_N \). This implies

$$
\begin{equation*}
\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,
\end{equation*}
$$

which is nothing but a linear system,

$$
\begin{equation*}
  AU = b,
\end{equation*}
$$

where the entries of \( A \) and \( b \) are given by

$$
\begin{align*}
  A_{ij} &= a(\phi_j, \hat{\phi}_i), \\ 
  b_i &= L(\hat\phi_i)\tp
\end{align*}
$$

<p>
The examples so far have specified the left- and right-hand sides of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it. An alternative is to explicitly call
functions for assembling the coefficient matrix \( A \) and the right-hand
side vector \( b \), and then solve the linear system \( AU=b \) for
the vector \( U \). Instead of <code>solve(a == L, U, b)</code> we now write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
bc<span style="color: #666666">.</span>apply(A, b)
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
solve(A, U, b)
</pre></div>
<p>
The variables <code>a</code> and <code>L</code> are the same as before; that is, <code>a</code> refers
to the bilinear form involving a <code>TrialFunction</code> object <code>u</code>
and a <code>TestFunction</code> object <code>v</code>, and <code>L</code> involves the same <code>TestFunction</code>
object <code>v</code>. From <code>a</code> and <code>L</code>, the <code>assemble</code> function can compute
\( A \) and \( b \).

<p>
Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, \( A \) may
be constant throughout a time-dependent simulation, so we can avoid
recalculating \( A \) at every time level and save a significant amount
of simulation time.

<p>
The matrix \( A \) and vector \( b \) are first assembled without
incorporating essential (Dirichlet) boundary conditions. Thereafter,
the call <code>bc.apply(A, b)</code> performs the necessary modifications of the
linear system such that <code>u</code> is guaranteed to equal the prescribed
boundary values. When we have multiple Dirichlet conditions stored in
a list <code>bcs</code>, we must apply each condition in <code>bcs</code> to the system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># bcs is a list of DirichletBC objects</span>
<span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcs:
    bc<span style="color: #666666">.</span>apply(A, b)
</pre></div>
<p>
Alternatively, we can use the function <code>assemble_system</code>, which takes
the boundary conditions into account during the assembly of the matrix
and vector:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A, b <span style="color: #666666">=</span> assemble_system(a, L, bcs)
</pre></div>
<p>
The <code>assemble_system</code> function is preferable to the combination of
<code>assemble</code> and <code>bc.apply</code> when the linear system is symmetric, since
<code>assembly_system</code> will incorporate the boundary conditions in a
symmetric way. Even if the matrix <code>A</code> that comes out of the call to
<code>assemble</code> for a symmetric bilinear form <code>a</code>, the call to <code>bc.apply</code>
will break the symmetry.

<p>
<!-- That is, for each degree of freedom -->
<!-- that is known, the corresponding row and column is zero'ed out and 1 -->
<!-- is placed on the main diagonal, and the right-hand side <code>b</code> is -->
<!-- modified by subtracting the column in <code>A</code> times the value of the -->
<!-- degree of, and then the corresponding entry in <code>b</code> is replaced by the -->
<!-- known value of the degree of freedom. -->
<!-- With <code>bc.apply(A, b)</code> the -->
<!-- matrix <code>A</code> is modified in an nonsymmetric way. -->
<!-- : The row is zero'ed out -->
<!-- and 1 is placed on the main diagonal, and the degree of freedom value -->
<!-- is inserted in <code>b</code>. -->

<p>
Once the linear system has been assembled, we need to compute the
solution \( U=A^{-1}b \) and store the solution \( U \) in the vector
<code>U = u.vector()</code>. In the same way as linear variational problems can be
programmed using different interfaces in FEniCS&mdash;the high-level
<code>solve</code> function, the class <code>LinearVariationalSolve</code>, and the
low-level <code>assemble</code> function&mdash;linear systems can also be programmed
using different interfaces in FEniCS. The high-level interface to
solving a linear system in FEniCS also named <code>solve</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solve(A, U, b)
</pre></div>
<p>
By default, <code>solve(A, U, b)</code> uses sparse LU decomposition to compute
the solution. Specification of an iterative solver and preconditioner
can be made through two optional arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solve(A, U, b, <span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
</pre></div>
<p>
Appropriate names of solvers and preconditioners are found in
the section <a href="#ftut:app:solver:prec">List of linear solver methods and preconditioners</a>.

<p>
This high-level interface is useful for many applications, but
sometimes more fine-grained control is needed. One can then create one
or more <code>KrylovSolver</code> objects that are then used to solve linear
systems. Each different solver object can have its own set of
parameters and selection of iterative method and preconditioner. Here
is an example:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solver <span style="color: #666666">=</span> KrylovSolver(<span style="color: #BA2121">&#39;cg&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
prm <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>parameters
prm[<span style="color: #BA2121">&#39;absolute_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-7</span>
prm[<span style="color: #BA2121">&#39;relative_tolerance&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
prm[<span style="color: #BA2121">&#39;maximum_iterations&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
u <span style="color: #666666">=</span> Function(V)
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
The function <code>solver_linalg</code> in the program file
<code>ft07_poisson_iter.py</code> implements a solver function where the user
can choose between different types of assembly. The function
<code>application_linalg</code> runs a test problem on a sequence of meshes and
solves the problem with symmetric and non-symmetric modification of
the system matrix. One can monitor the number of Krylov method
iterations and realize that with a symmetric coefficient matrix, the
Conjugate Gradient method requires slightly fewer iterations than
GMRES in the non-symmetric case. Taking into account that the
Conjugate Gradient method has less work per iteration, there is some
efficiency to be gained by using <code>assemble_system</code> for this problem.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 50</b>: Running <code>application_linalg</code>, the results are strange: Why does the <code>solve(a==L,...)</code> method need many more iterations than <code>solve(A, U, b, ...)</code> when we use the same Krylov parameter settings? Something wrong with the settings?)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 51</b>: I don't know. I found a possibly related problem in that <code>monitor_convergence = True</code> had no effect when calling <code>solve</code> but it worked when setting it on a solver object. Will need to revisit and test run all codes later with latest FEniCS.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 52</b>: OK.)</font>
<!-- end inline comment -->

<p>
The choice of start vector for the iterations in a linear solver is
often important. By default, the values of <code>u</code> and thus the vector <code>U
= u.vector()</code> will be initialized to zero. If instead wanted to
initialize <code>U</code> with random numbers in the interval \( [-100,100] \) this
can be done as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>n <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>size
U <span style="color: #666666">=</span> u<span style="color: #666666">.</span>vector()
U[:] <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">-100</span>, <span style="color: #666666">100</span>, n)
solver<span style="color: #666666">.</span>parameters[<span style="color: #BA2121">&#39;nonzero_initial_guess&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">True</span>
solver<span style="color: #666666">.</span>solve(A, U, b)
</pre></div>
<p>
Note that we must both turn off the default behavior of setting the start
vector (&quot;initial guess&quot;) to zero, and also set the values of the
vector <code>U</code> to nonzero values.

<p>
Using a nonzero initial guess can be particularly important for
time-dependent problems or when solving a linear system as part of a
nonlinear iteration, since then the previous solution vector <code>U</code> will
often be a good initial guess for the solution in the next time step
or iteration.

<p>
<!-- In other problems, we may divide the variational -->
<!-- problem and linear system into different terms, say \( A=M + {\dt} K \), -->
<!-- where \( M \) is a matrix arising from a term like \( \partial u/\partial t \), -->
<!-- \( K \) is a term corresponding to a Laplace operator, and \( \dt \) is -->
<!-- a time discretization parameter. When \( \dt \) is changed in time, -->
<!-- we can efficiently recompute \( A = M + {\dt} K \) without -->
<!-- reassembling the constant matrices \( M \) and \( K \). This strategy may -->
<!-- speed up simulations significantly. -->

<h2 id="___sec134" class="anchor">Examining matrix and vector values </h2>

<p>
When calling <code>A = assemble(a)</code> and <code>b = assemble(L)</code>, the object <code>A</code>
will be of type <code>Matrix</code>, while <code>b</code> and <code>u.vector()</code> are of type
<code>Vector</code>. To examine the values, we may convert the matrix and vector
data to <code>numpy</code> arrays by calling the <code>array()</code> method as shown
before. For example, if you wonder how essential boundary conditions are
incorporated into linear systems, you can print out <code>A</code> and <code>b</code>
before and after the <code>bc.apply(A, b)</code> call:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A <span style="color: #666666">=</span> assemble(a)
b <span style="color: #666666">=</span> assemble(L)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>: <span style="color: #408080; font-style: italic"># print for small meshes only</span>
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
bc<span style="color: #666666">.</span>apply(A, b)
<span style="color: #008000; font-weight: bold">if</span> mesh<span style="color: #666666">.</span>num_cells() <span style="color: #666666">&lt;</span> <span style="color: #666666">16</span>:
    <span style="color: #008000; font-weight: bold">print</span>(A<span style="color: #666666">.</span>array())
    <span style="color: #008000; font-weight: bold">print</span>(b<span style="color: #666666">.</span>array())
</pre></div>
<p>
With access to the elements in <code>A</code> through a <code>numpy</code> array, we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code>eig</code> function in <code>numpy.linalg</code>). We can alternatively dump
<code>A.array()</code> and <code>b.array()</code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.io</span>
scipy<span style="color: #666666">.</span>io<span style="color: #666666">.</span>savemat(<span style="color: #BA2121">&#39;Ab.mat&#39;</span>, {<span style="color: #BA2121">&#39;A&#39;</span>: A<span style="color: #666666">.</span>array(), <span style="color: #BA2121">&#39;b&#39;</span>: b<span style="color: #666666">.</span>array()})
</pre></div>
<p>
Writing <code>load Ab.mat</code> in MATLAB or Octave will then make
the array variables <code>A</code> and <code>b</code> available for computations.

<p>
Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code>numpy</code> arrays or matrices in MATLAB file
format are dense matrices. FEniCS also has an interface to the
eigensolver package SLEPc, which is the preferred tool for computing
the eigenvalues of large, sparse matrices of the type encountered in
PDE problems (see <code>demo/documented/eigenvalue</code> in the FEniCS source
code tree for a demo).

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 53</b>: Aha, so vc means variable coefficient. Seems to be a mismatch between presenting the example here below and using referring to the example above.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 54</b>: Moved the code to avoid this mismatch.)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 55</b>: I changed the title here and put everything under the common theme 'post-processing' since flux computation and structured grids are also related to postprocessing (more than to variable coefficient Poisson).)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 56</b>: Fine.)</font>
<!-- end inline comment -->

<h1 id="ftut:possion:2D:varcoeff" class="anchor">Postprocessing computations</h1>

<p>
As the final theme in this chapter, we will look at how to perform
<em>postprocessing computations</em>; that is, how to compute various derived
quantities from the computed solution of a PDE. The solution \( u \)
itself may be of interest for visualizing general features of the
solution, but sometimes one is interested in computing the solution of
a PDE to compute a specific quantity that derives from the solution,
such as, e.g., the flux, a point-value, or some average of the
solution.

<h2 id="___sec136" class="anchor">A variable-coefficient Poisson problem </h2>

<p>
As a test problem, we will extend the Poisson problem from the chapter <a href="._ftut1004.html#ch:fundamentals">Fundamentals: Solving the Poisson equation</a> with a variable coefficient \( \kappa(x,y) \) in the
Laplace operator:

$$
\begin{alignat}{2}
    - \nabla\cdot \left\lbrack
\kappa(x,y)\nabla u(x,y)\right\rbrack &= f(x,y) \quad &\mbox{in } \Omega,
\tag{5.3} \\ 
    u(x,y) &= \ub(x,y) \quad &\mbox{on}\  \partial\Omega\tp
\end{alignat}
$$

Let us continue to use our favorite solution \( u(x,y)=1+x^2+2y^2 \) and
then prescribe \( p(x,y)=x+y \). It follows that
\( \ub(x,y) = 1 + x^2 + 2y^2 \) and \( f(x,y)=-8x-10y \).

<p>
We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS
program. The following simple changes must be made to the previously
shown codes:

<ul>
  <li> the <code>solver</code> function must take <code>p</code> as argument,</li>
  <li> the right-hand side <code>f</code>
    must be an <code>Expression</code> since it is no longer a constant,</li>
  <li> a new <code>Expression kappa</code> must be defined for the variable coefficient,</li>
  <li> the formula for \( a(u,v) \) in the variational problem must be updated.</li>
</ul>

We first address the modified variational problem. Multiplying the PDE
by a test function \( v \) and integrating by parts now results in

$$
\begin{equation*}
\int_\Omega \kappa\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} p{\partial u\over
\partial n}v \ds = \int_\Omega fv \dx\tp
\end{equation*}
$$

The function spaces for \( u \) and \( v \) are the same as in
the problem with \( \kappa=1 \), implying that the boundary integral
vanishes since \( v=0 \) on \( \partial\Omega \) where we have Dirichlet conditions.
The variational forms \( a \) and \( L \) in the variational problem
\( a(u,v)=L(v) \) then become

$$
\begin{equation}
a(u,v) = \int_\Omega \kappa\nabla u\cdot\nabla v \dx,\quad
L(v) = \int_\Omega fv \dx\tp
\tag{5.4}
\end{equation}
$$

In the code for solving \( -\nabla^2u=f \) we must thus replace

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>a <span style="color: #666666">=</span> dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>a <span style="color: #666666">=</span> kappa<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx
<span style="color: #408080; font-style: italic"># or</span>
a <span style="color: #666666">=</span> dot(kappa<span style="color: #666666">*</span>grad(u), grad(v))<span style="color: #666666">*</span>dx
</pre></div>
<p>
to solve \( -\nabla\cdot(\kappa\nabla u)=f \). Moreover,
the definitions of <code>kappa</code> and <code>f</code> in the test problem read

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>kappa <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[0] + x[1]&#39;</span>)
f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;-8*x[0] - 10*x[1]&#39;</span>)
</pre></div>
<p>
No additional modifications are necessary. The file
<code>ft08_poisson_vc.py</code> (Poisson problem, variable coefficients)
is a copy of <code>ft07_poisson_iter.py</code> with the mentioned changes
incorporated. Observe that \( p=1 \) recovers the original problem in
<code>ft07_poisson_iter.py</code>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 57</b>: Is <code>poisson_varcoeff.py</code> a better name?)</font>
<!-- end inline comment -->

<p>
You can execute the file and confirm that it recovers the exact solution \( u \) at
the nodes.

<h2 id="ch:poisson0:gradu" class="anchor">Flux computations</h2>

<p>
It is often of interest to compute the flux \( Q = -\kappa\nabla u \) is often
of interest to compute. Since \( u = \sum_{j=1}^N U_j \phi_j \), it
follows that

$$
\begin{equation*}
Q = -\kappa\sum_{j=1}^N U_j \nabla \phi_j\tp
\end{equation*}
$$

<p>
However, the gradient of a piecewise continuous finite element scalar
field is a discontinuous vector field since the basis functions
\( \{\phi_j\} \) have discontinuous derivatives at the boundaries of the
cells. For example, using Lagrange elements of degree 1, \( u \) is linear
over each cell, and the gradient becomes a piecewise
constant vector field. On the contrary, the exact gradient is
continuous. For visualization and data analysis purposes, we often
want the computed gradient to be a continuous vector field. Typically,
we want each component of \( \nabla u \) to be represented in the same way
as \( u \) itself. To this end, we can project the components of \( \nabla
u \) onto the same function space as we used for \( u \). This means that
we solve \( w = \nabla u \) approximately by a finite element method,
using the same elements for the components of \( w \) as we used for
\( u \). This process is known as <em>projection</em>.

<p>
Projection is a common operation in finite element analysis and FEniCS
has a function for easily performing the projection:
<code>project(expression, W)</code>, which returns the projection of some
expression into the space <code>W</code>. In our case, the flux \( Q = -\kappa\nabla u \)
is vector-valued and we need to pick <code>W</code> as the vector-valued function
space of the same degree as the space <code>V</code> where <code>u</code> resides:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
degree <span style="color: #666666">=</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
W <span style="color: #666666">=</span> VectorFunctionSpace(mesh(), <span style="color: #BA2121">&#39;P&#39;</span>, degree)

grad_u <span style="color: #666666">=</span> project(grad(u), W)
flux_u <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>grad(u), W)
</pre></div>
<p>
<!-- Figure <a href="#ch:poisson0:2D:fig:ex1:gradu">ch:poisson0:2D:fig:ex1:gradu</a> shows -->
<!-- example of how such a smoothed <code>gradu(u)</code> vector field is visualized. -->
<!-- FIGURE:[fig/ex1_gradu, width=480] Example of visualizing the vector field \( \nabla u \) by arrows at the nodes. <div id="ch:poisson0:2D:fig:ex1:gradu"></div> -->

<p>
An appropriate function for computing the flux based on <code>u</code> and <code>kappa</code> is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">flux</span>(u, kappa):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return -kappa*grad(u) projected into same space as u.&quot;&quot;&quot;</span>
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    degree <span style="color: #666666">=</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
    W <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
    flux_u <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>grad(u), W)
    flux_u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;flux(u)&#39;</span>, <span style="color: #BA2121">&#39;continuous flux field&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> flux_u
</pre></div>
<p>
The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.

<p>
Plotting the flux vector field is naturally as easy as plotting
anything else:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>plot(flux, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;flux field&#39;</span>)

flux_x, flux_y <span style="color: #666666">=</span> flux<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>) <span style="color: #408080; font-style: italic"># extract components</span>
plot(flux_x, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x-component of flux (-kappa*grad(u))&#39;</span>)
plot(flux_y, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y-component of flux (-kappa*grad(u))&#39;</span>)
</pre></div>
<p>
The <code>deepcopy=True</code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code>deepcopy=False</code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)

<p>
For data analysis of the nodal values of the flux field we can
grab the underlying <code>numpy</code> arrays (which demands a <code>deepcopy=True</code>
in the split of <code>flux</code>):

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 58</b>: Suggest we use <code>_dofs</code> instead of <code>_array</code> everywhere. Have made similar changes in previous chapters before.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 59</b>: OK! But found quite some <code>u_array</code> in the very first Poisson example. Should we keep the name there and <code>dofs</code> everywhere else, after the difference in numbering is explained? Sounds consistent to me.)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>flux_x_dofs <span style="color: #666666">=</span> flux_x<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>dofs()
flux_y_dofs <span style="color: #666666">=</span> flux_y<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>dofs()
</pre></div>
<p>
The degrees of freedom of the <code>flux_u</code> vector field can also be
reached by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>flux_u_dofs <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
</pre></div>
<p>
However, this is a flat <code>numpy</code> array containing the degrees of
freedom for both the \( x \) and \( y \) components of the flux and the
ordering of the components may be mixed up by FEniCS in order to
improve computational efficiency.

<p>
The function <code>application_test_flux</code> in the program
<code>ft08_poisson_vc.py</code> demonstrates the computations described
above.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Manual projection.</b>
Although you will always use <code>project</code> to project a finite element
function, it can be instructive to look at how to formulate the
projection mathematically and implement its steps manually in FEniCS.

<p>
Let's say we have an expression \( g = g(u) \) that we want to project
into some space \( W \). The mathematical formulation of the (\( L^2 \))
projection \( w = P_W g \) into \( W \) is the variational problem

$$
\begin{equation}
  \int_{\Omega} w v \dx = \int_{\Omega} g v \dx
\tag{5.5}
\end{equation}
$$

for all test functions \( v \). In other words we have a
standard variational problem \( a(w, v) = L(v) \) where now
$$
\begin{align}
a(w, v) &= \int_\Omega w v \dx,
\tag{5.6}\\ 
L(v) &= \int_\Omega g v \dx\tp
\tag{5.7}
\end{align}
$$

Note that when the functions in \( W \) are vector-valued, as is the case
when we project the gradient \( g(u) = \nabla u \), we must replace the
products above by \( w\cdot v \) and \( g\cdot v \).

<p>
The variational problem is easy to define in FEniCS.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>w <span style="color: #666666">=</span> TrialFunction(W)
v <span style="color: #666666">=</span> TestFunction(W)

a <span style="color: #666666">=</span> w<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #408080; font-style: italic"># or dot(w, v)*dx when w is vector-valued</span>
L <span style="color: #666666">=</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #408080; font-style: italic"># or dot(g, v)*dx when g is vector-valued</span>
w <span style="color: #666666">=</span> Function(W)
solve(a <span style="color: #666666">==</span> L, w)
</pre></div>
<p>
The boundary condition argument to <code>solve</code> is dropped since there are
no essential boundary conditions in this problem.
</div>


<h2 id="ftut:structviz" class="anchor">Taking advantage of structured mesh data</h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 60</b>: I haven't read this section yet. Is it necessary to include? If we need to save pages, this is the section I would drop. Since we can easily visualize unstructured mesh data, this looks to me like a complicated way to perform something we can already do by calling <code>plot</code> or saving to Paraview. It also relies on a non-standard utility (<code>BoxField</code>).)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 61</b>: A lot of readers come from the finite difference world and also from MATLAB computations of 2D scalar and vector fields. These are used to structured meshes and corresponding tools. At least students will ask you why you cannot to MATLAB-style data analysis in 2D/3D arrays when you have solved Poisson on a square. We may move to vol II, but I refer to these recipes so often that they need to be documented somewhere, and the FEniCS tutorial is natural...)</font>
<!-- end inline comment -->

<p>
Many readers have extensive experience with visualization and data
analysis of 1D, 2D, and 3D scalar and vector fields on <em>uniform,
structured meshes</em>, while FEniCS solvers exclusively work with
<em>unstructured</em> meshes.  The collection software and mathematical
techniques for investigating scalar and vector fields on structured
meshes is much broader than for the unstructured ones, so when we
finite element computations actually take place on a uniform,
structured mesh, it is advantageous to extract the results in data
structures based on a structured mesh assumption. The present section
shows how that can be done. It allows, for example, standard
techniques in MATLAB or NumPy to be used to analyze finite element
computations.
<!-- FEniCS users who apply FEniCS primarily for verifying their own tailored codes -->
<!-- will make use of such techniques. -->

<p>
A necessary first step is to transform our <code>mesh</code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
second step is to transform the one-dimensional array of nodal values
to a two-dimensional array holding the values at the corners of the
cells in the structured mesh. We want to access a value by its \( i \) and
\( j \) indices, \( i \) counting cells in the \( x \) direction, and \( j \) counting
cells in the \( y \) direction.  This transformation is in principle
straightforward, yet it frequently leads to obscure indexing errors,
so using software tools to ease the work is advantageous.

<p>
In the directory <code>src/modules</code>, associated with this booklet, we have
included a Python module <code>BoxField</code> that can take a finite element
function <code>u</code> computed by a FEniCS software and represent it on a
structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code>[i]</code> in 1D, <code>[i,j]</code> in 2D, and <code>[i,j,k]</code>
in 3D. Given a finite element function <code>u</code>, the following function
returns a <code>BoxField</code> object that represents <code>u</code> on a structured mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">structured_mesh</span>(u, divisions):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    u2 <span style="color: #666666">=</span> u <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
         interpolate(u, FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
    mesh <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">BoxField</span> <span style="color: #008000; font-weight: bold">import</span> fenics_function2BoxField
    u_box <span style="color: #666666">=</span> fenics_function2BoxField(
        u2, mesh, divisions, uniform_mesh<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u_box
</pre></div>
<p>
Note that we can only turn functions on meshes with P1 elements into
<code>BoxField</code> objects, so if <code>u</code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code>divisions</code>).

<p>
The <code>u_box</code> object contains several useful data structures:

<ul>
 <li> <code>u_box.grid</code>: object for the structured mesh</li>
 <li> <code>u_box.grid.coor[X]</code>: grid coordinates in <code>X=0</code> direction</li>
 <li> <code>u_box.grid.coor[Y]</code>: grid coordinates in <code>Y=1</code> direction</li>
 <li> <code>u_box.grid.coor[Z]</code>: grid coordinates in <code>Z=2</code> direction</li>
 <li> <code>u_box.grid.coorv[X]</code>: vectorized version of <code>u_box.grid.coor[X]</code>
   (for vectorized computations or surface plotting)</li>
 <li> <code>u_box.grid.coorv[Y]</code>: vectorized version of <code>u_box.grid.coor[Y]</code></li>
 <li> <code>u_box.grid.coorv[Z]</code>: vectorized version of <code>u_box.grid.coor[Z]</code></li>
 <li> <code>u_box.values</code>: <code>numpy</code> array holding the <code>u</code> values;
   <code>u_box.values[i,j]</code> holds <code>u</code> at the mesh point with coordinates <br />
   <code>(u_box.grid.coor[X], u_box.grid.coor[Y])</code></li>
</ul>

<h3 id="___sec139" class="anchor">Iterating over points and values </h3>

<p>
Let us go back to the <code>solver</code> function in the
<code>ft08_poisson_vc.py</code> code from
the section <a href="#ftut:possion:2D:varcoeff">Postprocessing computations</a>, compute <code>u</code>, map it onto a
<code>BoxField</code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> solver(p, f, u_b, nx, ny, <span style="color: #666666">1</span>, linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
u_box <span style="color: #666666">=</span> structured_mesh(u, (nx, ny))
u_ <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>values       <span style="color: #408080; font-style: italic"># numpy array</span>
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  Y <span style="color: #666666">=</span> <span style="color: #666666">1</span>           <span style="color: #408080; font-style: italic"># for indexing in x and y direction</span>

<span style="color: #408080; font-style: italic"># Iterate over 2D mesh points (i,j)</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u_ is defined on a structured mesh with </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
      <span style="color: #008000">str</span>(u_<span style="color: #666666">.</span>shape))
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(u_<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=u(</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
              (i, j,
               u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][i], u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X][j],
               u_[i,j]))
</pre></div>

<h3 id="___sec140" class="anchor">Finite difference approximations </h3>

<p>
Note that with <code>u_</code>, we can easily express finite difference approximation
of derivatives:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>x <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coor[X]
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
u_xx <span style="color: #666666">=</span> (u_[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_[i,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">+1</span>,j])<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
</pre></div>

<h3 id="___sec141" class="anchor">Surface plot </h3>

<p>
The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a href="#ftut:structviz:fig1">19</a> (upper left):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
cv <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>grid<span style="color: #666666">.</span>coorv  <span style="color: #408080; font-style: italic"># vectorized mesh coordinates</span>
ax<span style="color: #666666">.</span>plot_surface(cv[X], cv[Y], u_, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Surface plot of solution&#39;</span>)
</pre></div>
<p>
The key issue is to know that the coordinates needed for the surface
plot is in <code>u_box.grid.coorv</code> and that the values are in <code>u_</code>.

<p>
<center> <!-- figure label: --> <div id="ftut:structviz:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 19:  Various plots of the solution on a structured mesh.  <!-- caption label: ftut:structviz:fig1 --> </p></center>
<p><img src="fig/poisson_vc_structmesh2.png" align="bottom" width=800></p>
</center>

<h3 id="___sec142" class="anchor">Contour plot </h3>

<p>
A contour plot can also be made by Matplotlib:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca()
levels <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">2.0</span>, <span style="color: #666666">2.5</span>, <span style="color: #666666">3.5</span>]
cs <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>contour(cv[X], cv[Y], u_, levels<span style="color: #666666">=</span>levels)
plt<span style="color: #666666">.</span>clabel(cs)  <span style="color: #408080; font-style: italic"># add labels to contour lines</span>
plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;equal&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Contour plot of solution&#39;</span>)
</pre></div>
<p>
The result appears in Figure <a href="#ftut:structviz:fig1">19</a> (upper right).

<h3 id="___sec143" class="anchor">Curve plot through the mesh </h3>

<p>
A handy feature of <code>BoxField</code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot \( u \) along
the line \( y=0.4 \). The mesh points, <code>x</code>, and the \( u \) values
along this line, <code>u_val</code>, are extracted by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
X <span style="color: #666666">=</span> <span style="color: #666666">0</span>
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
</pre></div>
<p>
The variable <code>snapped</code> is true if the line had to be snapped onto a
gridline and in that case <code>y_fixed</code> holds the snapped
(altered) \( y \) value. To avoid interpolation in the structured mesh,
<code>snapped</code> is in fact <em>always</em> true.

<p>
A comparison of the numerical and exact solution along the line
\( y=0.5 \) (snapped from \( y=0.4 \)) is made by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>start <span style="color: #666666">=</span> (<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>)
x, u_val, y_fixed, snapped <span style="color: #666666">=</span> u_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
u_e_val <span style="color: #666666">=</span> [u_b((x_, y_fixed)) <span style="color: #008000; font-weight: bold">for</span> x_ <span style="color: #AA22FF; font-weight: bold">in</span> x]

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, u_e_val, <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
See Figure <a href="#ftut:structviz:fig1">19</a> (lower left) for the resulting curve plot.

<h3 id="___sec144" class="anchor">Curve plot of the flux </h3>

<p>
Let us also compare the numerical and
exact flux \( -p\partial u/\partial x \) along the same line as above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>flux_u <span style="color: #666666">=</span> flux(u, p)
flux_u_x, flux_u_y <span style="color: #666666">=</span> flux_u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)

<span style="color: #408080; font-style: italic"># Plot the numerical and exact flux along the same line</span>
flux2_x <span style="color: #666666">=</span> flux_u_x <span style="color: #008000; font-weight: bold">if</span> flux_u_x<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span> \ 
          <span style="color: #008000; font-weight: bold">else</span> interpolate(flux_x,
               FunctionSpace(u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>mesh(),
                             <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>))
flux_u_x_box <span style="color: #666666">=</span> structured_mesh(flux_u_x, (nx,ny))
x, flux_u_val, y_fixed, snapped <span style="color: #666666">=</span> \ 
   flux_u_x_box<span style="color: #666666">.</span>gridline(start, direction<span style="color: #666666">=</span>X)
y <span style="color: #666666">=</span> y_fixed

plt<span style="color: #666666">.</span>figure()
plt<span style="color: #666666">.</span>plot(x, flux_u_val, <span style="color: #BA2121">&#39;r-&#39;</span>)
plt<span style="color: #666666">.</span>plot(x, flux_u_x_exact(x, y_fixed), <span style="color: #BA2121">&#39;bo&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;P1 elements&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Flux along line y=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> y_fixed)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
</pre></div>
<p>
The second <code>plt.plot</code> command
requires a Python function <code>flux_u_x_exact(x,y)</code> to be
available for the exact flux expression.

<p>
Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a href="https://github.com/hplgit/scitools" target="_self">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.

<h3 id="___sec145" class="anchor">Test problem </h3>

<p>
The graphics referred to in Figure <a href="#ftut:structviz:fig1">19</a> correspond to
a test problem with prescribed solution \( \uex = H(x)H(y) \), where

$$ H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x)\tp$$

We just fit a function \( f(x,y) \) in the PDE (can choose \( p=1 \)),
and notice that \( u=0 \) along the
boundary of the unit square. Although it is easy to carry out the
differentiation of \( f \) by hand and hardcode the resulting expressions
in an <code>Expression</code> object, a more reliable habit is to use Python's
symbolic computing engine, SymPy, to perform mathematics and
automatically turn formulas into C++ syntax for <code>Expression</code> objects.
A short introduction was given in
the section <a href="._ftut1008.html#ftut:nonlinear:Newton:auto">A simple FEniCS implementation</a>.

<p>
We start out with defining the exact solution in <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, pi  <span style="color: #408080; font-style: italic"># for use in math formulas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
H <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: exp(<span style="color: #666666">-16*</span>(x<span style="color: #666666">-0.5</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>sin(<span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>x)
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0], x[1]&#39;</span>)
u <span style="color: #666666">=</span> H(x)<span style="color: #666666">*</span>H(y)
</pre></div>
<p>
Turning the expression for <code>u</code> into C or C++ syntax for <code>Expression</code> objects
needs two steps. First we ask for the C code of the expression,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
</pre></div>
<p>
Printing out <code>u_c</code> gives (the output is here manually broken into two
lines):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
<p>
The necessary syntax adjustment is replacing
the symbol <code>M_PI</code> for \( \pi \) in C/C++ by <code>pi</code> (or <code>DOLFIN_PI</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_c <span style="color: #666666">=</span> u_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
u_b <span style="color: #666666">=</span> Expression(u_c)
</pre></div>
<p>
Thereafter, we can progress with the computation of
\( f = -\nabla\cdot(\kappa\nabla u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>kappa <span style="color: #666666">=</span> <span style="color: #666666">1</span>
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">+</span> \ 
    sym<span style="color: #666666">.</span>diff(<span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
f_c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
f_c <span style="color: #666666">=</span> f_c<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;M_PI&#39;</span>, <span style="color: #BA2121">&#39;pi&#39;</span>)
f <span style="color: #666666">=</span> Expression(f_c)
</pre></div>
<p>
We also need a Python function for the exact flux
\( -\kappa\partial u/\partial x \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>flux_u_x_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y], <span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x),
                              modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
</pre></div>
<p>
It remains to define <code>kappa = Constant(1)</code> and set <code>nx</code> and <code>ny</code> before calling
<code>solver</code> to compute the finite element solution of this problem.

<p>
<!-- FIGURE: [fig/poisson_vc_structmesh, width=800 frac=1] Various plots of the solution on a structured mesh. <div id="ftut:structviz:fig1a"></div> -->

<h2 id="ch:poisson0:functionals" class="anchor">Computing functionals</h2>

<p>
After the solution \( u \) of a PDE is computed, we occasionally want to compute
functionals of \( u \), for example,

$$
\begin{equation}
{1\over2}||\nabla u||^2 = {1\over2}\int_\Omega \nabla u\cdot \nabla u \dx,
\tag{5.8}
\end{equation}
$$

which often reflects some energy quantity.
Another frequently occurring functional is the error

$$
\begin{equation}
||\uex-u|| = \left(\int_\Omega (\uex-u)^2 \dx\right)^{1/2},
\tag{5.9}
\end{equation}
$$

where \( \uex \) is the exact solution. The error is of particular
interest when studying convergence properties of finite element
methods. Other times, we may instead be interested in computing
the flux out of a part
\( \Gamma \) of the boundary \( \partial\Omega \),

$$
\begin{equation}
F = -\int_\Gamma \kappa\nabla u\cdot\normalvec \ds,
\tag{5.10}
\end{equation}
$$

where \( \normalvec \) is an outward unit normal at \( \Gamma \) and \( \kappa \) is a
coefficient (see the problem in the section <a href="#ftut:possion:2D:varcoeff">Postprocessing computations</a>
for a specific example).

<p>
All these functionals are easy to compute with FEniCS, as we shall see
in the examples below.

<h3 id="___sec147" class="anchor">Energy functional </h3>

<p>
The integrand of the energy functional
<a href="#mjx-eqn-5.8">(5.8)</a> is described in the UFL
language in the same manner as we describe weak forms:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>energy <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>dot(grad(u), grad(u))<span style="color: #666666">*</span>dx
E <span style="color: #666666">=</span> assemble(energy)
</pre></div>
<p>
The functional <code>energy</code> is evaluated by calling the <code>assemble</code>
function that we have previously used to assemble matrices and
vectors. FEniCS will recognize that the form has ''rank 0'' (since it
contains no trial and test functions) and return the result as a
scalar value.

<h3 id="___sec148" class="anchor">Error functional </h3>

<p>
Computing the functional <a href="#mjx-eqn-5.9">(5.9)</a> can be
done as follows:
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_exact)<span style="color: #666666">**2*</span>dx
E <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))
</pre></div>
<p>
The exact solution \( \uex \) is here in a <code>Function</code> or <code>Expression</code>
object <code>u_exact</code>, while <code>u</code> is the finite element approximation.
Sometimes, for very small error values, the result of
<code>assemble(error)</code> can be a (very small) negative number, so we have
used <code>abs</code> in the expression for <code>E</code> above to ensure a positive value
for the <code>sqrt</code> function.

<p>
As will be explained and demonstrated in the section <a href="#ch:poisson0:convrates">Computing convergence rates</a>, the integration of <code>(u - u_exact)**2*dx</code>
can result in too optimistic convergence rates unless one is careful
how <code>u_exact</code> is transferred onto a mesh. The general recommendation
for reliable error computation is to use the <code>errornorm</code> function (see
<code>help(errornorm)</code> and the section <a href="#ch:poisson0:convrates">Computing convergence rates</a> for
more information):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>E <span style="color: #666666">=</span> errornorm(u_exact, u)
</pre></div>

<h3 id="___sec149" class="anchor">Flux Functional </h3>

<p>
To compute flux integrals like \( F = -\int_\Gamma \kappa\nabla
u\cdot\normalvec \ds \), we need to define the \( \normalvec \) vector,
referred to as <em>facet normal</em> in FEniCS. If the surface domain
\( \Gamma \) in the flux integral is the complete boundary, we can perform
the flux computation by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>n <span style="color: #666666">=</span> FacetNormal(mesh)
flux <span style="color: #666666">=</span> <span style="color: #666666">-</span>kappa<span style="color: #666666">*</span>dot(grad(u), n)<span style="color: #666666">*</span>ds
total_flux <span style="color: #666666">=</span> assemble(flux)
</pre></div>
<p>
Although <code>grad(u)</code> and <code>grad(u)</code> are interchangeable in the above
expression when <code>u</code> is a scalar function, we have chosen to write
<code>grad(u)</code> because this is the right expression if we generalize the
underlying equation to a vector Laplace/Poisson PDE. With <code>grad(u)</code> we
must in that case write <code>dot(n, grad(u))</code>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 62</b>: Figure out which one is <code>grad</code> and which one is <code>nabla_grad</code> above... :-))</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 63</b>: Depends on what <code>u</code> is; no difference for scalar <code>u</code>, otherwise I'm pretty sure the natural dyadic normal derivative has <code>n</code> coming in from the left in the math so it should be <code>dot(n, nabla_grad(u))</code>. We should change the formula then to <code>dot(n, grad(u))</code> even here.)</font>
<!-- end inline comment -->

<p>
It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as explained in
the section <a href="._ftut1010.html#ch:poisson0:multi:bc">Setting multiple Neumann, Robin, and Dirichlet conditions</a>. Assuming that the part corresponds
to subdomain number <code>i</code>, the relevant syntax for the variational
formulation of the flux is <code>-kappa*dot(grad(u), n)*ds(i)</code>.

<h2 id="ch:poisson0:convrates" class="anchor">Computing convergence rates</h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 64</b>: Newer FEniCS examples have <code>dx(degree)</code>. Should explain that syntax. Also <code>Expression(string, degree)</code>.)</font>
<!-- end inline comment -->

<p>
A central question for any numerical method is its <em>convergence rate</em>:
how fast does the error approach zero when the resolution is
increased? For finite element methods, this typically corresponds to
proving, theoretically or empirically, that the error \( e = \uex - u \)
is bounded by the mesh size \( h \) to some power \( r \); that is, \( \|e\|
\leq C h^r \) for some constant \( C \). The number \( r \) is called the
<em>convergence rate</em> of the method. Note that different norms, like the
\( L^2 \)-norm \( \|e\| \) or \( H^1_0 \)-norm \( \|\nabla e\| \) typically have
different convergence rates.

<p>
To illustrate how to compute errors and convergence rates in FEniCS,
we have included the function <code>convergence_rate</code> in
<code>ft08_poisson_vc.py</code>. This is a tool that is very handy
when verifying finite element codes and will therefore be explained in
detail here.

<h3 id="___sec151" class="anchor">Computing error norms </h3>

<p>
The \( L^2 \)-norm of the error in a finite element approximation \( u \),
\( \uex \) being the exact solution, is given by

$$ E = \left(\int_\Omega (u_e-u)^2 \dx\right)^{1/2},$$

and can be implemented in FEniCS by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
E <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))
</pre></div>
<p>
As above, we have used <code>abs</code> in the expression for <code>E</code> above to ensure
a positive value for the <code>sqrt</code> function.

<p>
It is important to understand how FEniCS computes the error from the
above code, since we may otherwise run into subtle issues when using
the value for computing convergence rates. The first subtle issue is
that if <code>u_e</code> is not already finite element function (an object create
using <code>Function(V)</code>), which is the case if <code>u_e</code> is defined as an
<code>Expression</code>, FEniCS must interpolate <code>u_e</code> into some local finite
element space on each element of the mesh. The degree used for the
interpolation is determined by the mandatory keyword argument to the
<code>Expression</code> class, for example:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_e <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(x[0])&#39;</span>, degree<span style="color: #666666">=1</span>)
</pre></div>
<p>
This means that the error computed will not be equal to the actual
error \( \|\uex - u\| \) but rather the difference between the finite
element solution \( u \) and the piecewise linear interpolant of
\( \uex \). This may yield a too optimistic (too small) value for the
error. A better value may be achieved by interpolating the exact
solution into a higher-order function space, which can be done by
simply increasing the degree:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_e <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(x[0])&#39;</span>, degree<span style="color: #666666">=3</span>)
</pre></div>
<p>
The second subtle issue is that when FEniCS evaluates the expression
<code>(u_ex - u)**2</code>, this will be expanded into <code>u_ex**2 + u**2 -
2*u_ex*u</code>. If the error is small (and the solution itself is of
moderate size), this calculation will correspond to the subtraction of
two positive numbers (<code>u_ex**2 + u**2</code> \( \sim 1 \) and <code>2*u_ex*u</code> \( \sim
1 \)) yielding a small number. Such a computation is very prone to
round-off errors, which may again lead to an unreliable value for the
error. To make this situation worse, FEniCS may expand this
computation into a large number of terms, in particular for higher
order elements, making the computation very unstable.

<p>
To help with these issues, FEniCS provides the built-in function
<code>errornorm</code> which computes the error norm in a more intelligent
way. First, both <code>u_ex</code> and <code>u</code> are interpolated into a higher-order
function space. Then, the degrees of freedom of <code>u_ex</code> and <code>u</code> are
subtracted to produce a new function in the higher-order function
space. Finally, FEniCS integrates the square of the difference
function to get the value of the error norm. Using the <code>errornorm</code>
function is simple:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>E <span style="color: #666666">=</span> errornorm(u_e, u, normtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;L2&#39;</span>)
</pre></div>
<p>
It is illustrative to look at a short implementation of <code>errornorm</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">errornorm</span>(u_exact, u):
    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()
    mesh <span style="color: #666666">=</span> V<span style="color: #666666">.</span>mesh()
    degree <span style="color: #666666">=</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree()
    W <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree <span style="color: #666666">+</span> <span style="color: #666666">3</span>)
    u_W <span style="color: #666666">=</span> interpolate(u, W)
    u_e_W <span style="color: #666666">=</span> interpolate(u_e, W)
    e_W <span style="color: #666666">=</span> Function(W)
    e_W<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_e_W<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> \ 
                      u_W<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
    error <span style="color: #666666">=</span> e_W<span style="color: #666666">**2*</span>dx
    <span style="color: #008000; font-weight: bold">return</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))
</pre></div>
<p>
Sometimes it is of interest to compute the error of the
gradient field: \( ||\nabla (u-\uex)|| \),
often referred to as the \( H^1_0 \) or \( H^1 \) seminorm of the error.
This can either be expressed as above, replacing the expression for
<code>error</code> by <code>error = dot(grad(e_W), grad(e_W))*dx</code>, or by calling
<code>errornorm</code> in FEniCS:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>E <span style="color: #666666">=</span> errornorm(u_e, u, norm_type<span style="color: #666666">=</span><span style="color: #BA2121">&#39;H10&#39;</span>)
</pre></div>
<p>
Type <code>help(errornorm)</code> in Python for more information about available
norm types.

<p>
All the various types of error computations here are placed in a
function <code>compute_errors</code> in <code>ft08_poisson_vc.py</code>:

<!-- begin inline comment -->
<font color="red">(<b>hpl 65</b>: Necessary to repeat code? New info is essentiall the return dict.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 66</b>: Anders, I (in 2010...) ran into problems with <code>fenics.errornorm</code>, see comments in the code below, and made the version below. We should check out these problems again and adjust <code>fenics.errornorm</code> if necessary.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>AL 67</b>: Have not yet checked code, will rerun all code and update notation if necessary when I'm through with all text.)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_errors</span>(u, u_exact):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span style="color: #BA2121; font-style: italic">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># Compute error norm (for very small errors, the value can be</span>
    <span style="color: #408080; font-style: italic"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    V <span style="color: #666666">=</span> u<span style="color: #666666">.</span>function_space()

    <span style="color: #408080; font-style: italic"># Function - Expression</span>
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_exact)<span style="color: #666666">**2*</span>dx
    E1 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_e onto the same space as u:</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E2 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span style="color: #408080; font-style: italic"># u will also be interpolated to the space Ve before integration</span>
    Ve <span style="color: #666666">=</span> FunctionSpace(V<span style="color: #666666">.</span>mesh(), <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">5</span>)
    u_e <span style="color: #666666">=</span> interpolate(u_exact, Ve)
    error <span style="color: #666666">=</span> (u <span style="color: #666666">-</span> u_e)<span style="color: #666666">**2*</span>dx
    E3 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># fenics.errornorm interpolates u and u_e to a space with</span>
    <span style="color: #408080; font-style: italic"># given degree, and creates the error field by subtracting</span>
    <span style="color: #408080; font-style: italic"># the degrees of freedom, then the error field is integrated</span>
    <span style="color: #408080; font-style: italic"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span style="color: #408080; font-style: italic">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span style="color: #408080; font-style: italic"># Manual implementation errornorm to get around the bug:</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">errornorm</span>(u_exact, u, Ve):
        u_Ve <span style="color: #666666">=</span> interpolate(u, Ve)
        u_e_Ve <span style="color: #666666">=</span> interpolate(u_exact, Ve)
        e_Ve <span style="color: #666666">=</span> Function(Ve)
        <span style="color: #408080; font-style: italic"># Subtract degrees of freedom for the error field</span>
        e_Ve<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> u_e_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u_Ve<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()
        <span style="color: #408080; font-style: italic"># More efficient computation (avoids the rhs array result above)</span>
        <span style="color: #408080; font-style: italic">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span style="color: #408080; font-style: italic">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        error <span style="color: #666666">=</span> e_Ve<span style="color: #666666">**2*</span>dx(Ve<span style="color: #666666">.</span>mesh())
        <span style="color: #008000; font-weight: bold">return</span> sqrt(<span style="color: #008000">abs</span>(assemble(error))), e_Ve
    E4, e_Ve <span style="color: #666666">=</span> errornorm(u_exact, u, Ve)

    <span style="color: #408080; font-style: italic"># Infinity norm based on nodal values</span>
    u_e <span style="color: #666666">=</span> interpolate(u_exact, V)
    E5 <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()

    <span style="color: #408080; font-style: italic"># H1 seminorm</span>
    error <span style="color: #666666">=</span> dot(grad(e_Ve), grad(e_Ve))<span style="color: #666666">*</span>dx
    E6 <span style="color: #666666">=</span> sqrt(<span style="color: #008000">abs</span>(assemble(error)))

    <span style="color: #408080; font-style: italic"># Collect error measures in a dictionary with self-explanatory keys</span>
    errors <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;u - u_exact&#39;</span>: E1,
              <span style="color: #BA2121">&#39;u - interpolate(u_exact,V)&#39;</span>: E2,
              <span style="color: #BA2121">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span>: E3,
              <span style="color: #BA2121">&#39;errornorm&#39;</span>: E4,
              <span style="color: #BA2121">&#39;infinity norm (of dofs)&#39;</span>: E5,
              <span style="color: #BA2121">&#39;grad(error) H1 seminorm&#39;</span>: E6}

    <span style="color: #008000; font-weight: bold">return</span> errors
</pre></div>

<h3 id="___sec152" class="anchor">Computing convergence rates </h3>

<p>
Calling the <code>solver</code> function for finer and finer meshes enables us to
study the convergence rate. Define the element size \( h=1/n \), where \( n \)
is the number of cell divisions in \( x \) and \( y \) direction (<code>n=Nx=Ny</code> in
the code). We perform experiments with \( h_0>h_1>h_2\cdots \) and compute
the corresponding errors \( E_0, E_1, E_2 \) and so forth. Assuming
\( E_i=Ch_i^r \) for unknown constants \( C \) and \( r \), we can compare two
consecutive experiments, \( E_{i-1}=Ch_{i-1}^r \) and \( E_i=Ch_i^r \), and
solve for \( r \):

$$
\begin{equation*}
r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}\tp
\end{equation*}
$$

The \( r \) values should approach the expected convergence rate
(typically the polynomial degree + 1 for the \( L^2 \)-error) as \( i \)
increases.

<p>
The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by <code>compute_errors</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rate</span>(u_exact, f, u_D, kappa, degrees):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute convergence rates for various error norms for a</span>
<span style="color: #BA2121; font-style: italic">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span style="color: #BA2121; font-style: italic">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span style="color: #BA2121; font-style: italic">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    h <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Discretization parameter, h[degree][experiment]</span>
    E <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># Error measure(s), E[degree][experiment][error_type]</span>
    P_degrees <span style="color: #666666">=</span> <span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>
    num_meshes <span style="color: #666666">=</span> <span style="color: #666666">5</span>

    <span style="color: #408080; font-style: italic"># Perform experiments with meshes and element types</span>
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        n <span style="color: #666666">=</span> <span style="color: #666666">4</span>   <span style="color: #408080; font-style: italic"># Coarsest mesh division</span>
        h[degree] <span style="color: #666666">=</span> []
        E[degree] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
            n <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
            h[degree]<span style="color: #666666">.</span>append(<span style="color: #666666">1.0/</span>n)
            u <span style="color: #666666">=</span> solver(kappa, f, u_D, n, n, degree,
                       linear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>)
            errors <span style="color: #666666">=</span> compute_errors(u, u_exact)
            E[degree]<span style="color: #666666">.</span>append(errors)
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;2*(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">) P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh, </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> unknowns, E1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                  (n, n, degree, u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
                   errors[<span style="color: #BA2121">&#39;u - u_exact&#39;</span>]))
    <span style="color: #408080; font-style: italic"># Convergence rates</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log <span style="color: #008000; font-weight: bold">as</span> ln  <span style="color: #408080; font-style: italic"># log is a fenics name too</span>
    error_types <span style="color: #666666">=</span> <span style="color: #008000">list</span>(E[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>keys())
    rates <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> P_degrees:
        rates[degree] <span style="color: #666666">=</span> {}
        <span style="color: #008000; font-weight: bold">for</span> error_type <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(error_types):
            rates[degree][error_type] <span style="color: #666666">=</span> []
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_meshes):
                Ei   <span style="color: #666666">=</span> E[degree][i][error_type]
                Eim1 <span style="color: #666666">=</span> E[degree][i<span style="color: #666666">-1</span>][error_type]
                r <span style="color: #666666">=</span> ln(Ei<span style="color: #666666">/</span>Eim1)<span style="color: #666666">/</span>ln(h[degree][i]<span style="color: #666666">/</span>h[degree][i<span style="color: #666666">-1</span>])
                rates[degree][error_type]<span style="color: #666666">.</span>append(<span style="color: #008000">round</span>(r,<span style="color: #666666">2</span>))
    <span style="color: #008000; font-weight: bold">return</span> rates
</pre></div>

<h3 id="___sec153" class="anchor">Test problem </h3>

<p>
To demonstrate the computation of convergence rates, we will pick an
exact solution \( \uex \) given by

$$
\begin{equation*}
\uex(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)
\end{equation*}
$$

on the unit square. This choice implies \( f(x,y)=2\omega^2\pi^2 u(x,y) \).
With \( \omega \) restricted to an integer
it follows that the boundary value is given by \( \ub=0 \).

<p>
We need to define the appropriate boundary conditions, the exact
solution, and the \( f \) function in the code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)

omega <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
u_e <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span>,
                 omega<span style="color: #666666">=</span>omega)

f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">**2*</span>omega<span style="color: #666666">**2*</span>u_e
</pre></div>

<h3 id="___sec154" class="anchor">Experiments </h3>

<p>
The function <code>convergence_rate_sin()</code> in <code>ft08_poisson_vc.py</code>
implements the test problem
above and applies the <code>convergence_rate</code> function to estimate
convergence rates.
We achieve some interesting results.
Using the error measure <code>E5</code> based on the infinity norm of the
difference of the degrees of freedom, we have

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>element</b></td> <td align="center">\( n=8 \)</td> <td align="center">\( n=16 \)</td> <td align="center">\( n=32 \)</td> <td align="center">\( n=64 \)</td> <td align="center">\( n=128 \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   P1         </td> <td align="right">   1.99         </td> <td align="right">   1.97          </td> <td align="right">   1.99          </td> <td align="right">   2.0           </td> <td align="right">   2.0            </td> </tr>
<tr><td align="left">   P2         </td> <td align="right">   3.99         </td> <td align="right">   3.96          </td> <td align="right">   3.99          </td> <td align="right">   4.0           </td> <td align="right">   3.99           </td> </tr>
<tr><td align="left">   P3         </td> <td align="right">   3.96         </td> <td align="right">   3.89          </td> <td align="right">   3.96          </td> <td align="right">   3.99          </td> <td align="right">   4.0            </td> </tr>
<tr><td align="left">   P4         </td> <td align="right">   3.75         </td> <td align="right">   4.99          </td> <td align="right">   5.0           </td> <td align="right">   5.0           </td> <td align="right">                  </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-6 -->
</div> <!-- cell row -->
<p>
An entry like 3.96 for \( n=32 \) and P3 means that we estimate the
a rate 3.96 by comparing two meshes, with resolutions \( n=32 \) and \( n=16 \),
using P3 elements. The coarsest mesh has \( n=4 \). The best estimates of
the rates appear in the right-most column.

<!-- begin inline comment -->
<font color="red">(<b>AL 68</b>: Don't understand this table. What does each cell in the table correspond to? I understand the elements, but what does for example \( n = 32 \) mean? The rate needs two different meshes. Is the \( n = 32 \) column the difference with \( n = 64 \) or \( n = 16 \)?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 69</b>: Inserted explanation, according to the shown code, but there was a misleading argument <code>n</code> (list of resolutions) in the function that was not used.)</font>
<!-- end inline comment -->

<p>
The computations with \( \mathsf{P}_4 \) elements on a \( 2\times(128\times
128) \) mesh with a direct solver (UMFPACK) on a small laptop broke down
so these results have been left out of the table.  Otherwise we
achieve expected results: the error goes like \( h^{d+1} \) for elements
of degree \( d \). Also \( L^2 \) norms based on the <code>errornorm</code> gives the
expected \( h^{d+1} \) rate for \( u \) and \( h^d \) for \( \nabla u \).

<p>
However, using <code>(u_e - u)**2</code> for the error computation, with the same
degree for the interpolation of <code>u_e</code> as for <code>u</code>, results in \( h^4 \)
convergence for P2 elements.

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>element</b></td> <td align="center">\( n=8 \)</td> <td align="center">\( n=16 \)</td> <td align="center">\( n=32 \)</td> <td align="center">\( n=64 \)</td> <td align="center">\( n=128 \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   P1         </td> <td align="right">   1.98         </td> <td align="right">   1.94          </td> <td align="right">   1.98          </td> <td align="right">   2.0           </td> <td align="right">   2.0            </td> </tr>
<tr><td align="left">   P2         </td> <td align="right">   3.98         </td> <td align="right">   3.95          </td> <td align="right">   3.99          </td> <td align="right">   3.99          </td> <td align="right">   3.99           </td> </tr>
<tr><td align="left">   P3         </td> <td align="right">   3.69         </td> <td align="right">   4.03          </td> <td align="right">   4.01          </td> <td align="right">   3.95          </td> <td align="right">   2.77           </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-6 -->
</div> <!-- cell row -->
<p>
This is an example where it is important to interpolate <code>u_exact</code> to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.

<p>
<!-- Problems with interpolate(u,Ve) - interpolate(u_exact,Ve) for -->
<!-- high degree and large meshes. Rounding errors? errornorm is the -->
<!-- remedy? -->
<!-- interpolate(u,Ve) - interpolate(u_exact,Ve) -->
<!-- P1: 1.98, 1.96, 1.99, 2.0, 2.0 -->
<!-- P2: 3.01, 3.03, 3.01, 3.0, 3.02 -->
<!-- P3: 2.7, 4.02, 4.0, 2.63, 0.17 -->
<!-- P4: 1.54, 5.11, 0.91, 0.15, -0.01 -->

<p>
Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section <a href="._ftut1011.html#ch:poisson0:verify1">Examining the degrees of freedom</a> and many other places in this tutorial).

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1011.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li><a href="._ftut1010.html">11</a></li>
  <li><a href="._ftut1011.html">12</a></li>
  <li class="active"><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1013.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

