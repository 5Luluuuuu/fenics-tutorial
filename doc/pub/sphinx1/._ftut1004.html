
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A Gallery of finite element solvers</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial Volume I" href="index.html" />
    <link rel="next" title="Mesh generation, subdomains and boundary conditions" href="._ftut1005.html" />
    <link rel="prev" title="Fundamentals: Solving the Poisson equation" href="._ftut1003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut1003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut1005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-gallery-of-finite-element-solvers">
<span id="ch-gallery"></span><h1>A Gallery of finite element solvers<a class="headerlink" href="#a-gallery-of-finite-element-solvers" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>The goal of this chapter is to demonstrate how a range of important PDEs
from science and engineering can be quickly solved with a few lines of
FEniCS code. We start with the heat equation and continue with a
nonlinear Poisson equation, the equations for linear elasticity, and
the Navier-Stokes equations. These problems illustrate how to solve
time-dependent problems, nonlinear problems, vector-valued problems,
and systems of PDE. For each problem, we derive the variational
formulation and express the problem in Python in a way that closely
resembles the mathematics.</div></blockquote>
<div class="section" id="the-heat-equation">
<span id="ch-fundamentals-diffusion"></span><h2>The heat equation<a class="headerlink" href="#the-heat-equation" title="Permalink to this headline">¶</a></h2>
<p>As a first extension of the Poisson problem from the previous chapter,
we consider the time-dependent heat equation, or time-dependent
diffusion equation. This is the natural extension of the Poisson
equation describing the stationary distribution of heat in a body to a
time-dependent problem.</p>
<p>We will see that by discretizing time into small time intervals and
applying standard time-stepping methods, we can solve the heat
equation by solving a sequence of variational problems, much like the
one we encountered for the Poisson equation.</p>
<div class="section" id="pde-problem-1">
<h3>PDE problem<a class="headerlink" href="#pde-problem-1" title="Permalink to this headline">¶</a></h3>
<p>Our model problem for time-dependent PDEs reads</p>
<div class="math" id="eq-ch-diffusion0-pde1">
\[\tag{17}
{\partial u\over\partial t} = \nabla^2 u + f\hbox{ in }\Omega,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-bc">
\[\tag{18}
u = u_{_\mathrm{D}}\hbox{ on } \partial \Omega,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-ic">
\[\tag{19}
u = u_0 \mbox{ at } t=0{\thinspace .}\]</div>
<p>Here, <span class="math">\(u\)</span> varies with space and time, e.g., <span class="math">\(u=u(x,y,t)\)</span> if the spatial
domain <span class="math">\(\Omega\)</span> is two-dimensional. The source function <span class="math">\(f\)</span> and the
boundary values <span class="math">\(u_{_\mathrm{D}}\)</span> may also vary with space and time.
The initial condition <span class="math">\(u_0\)</span> is a function of space only.</p>
</div>
<div class="section" id="variational-formulation-1">
<span id="ftut-timedep-diffusion1"></span><h3>Variational formulation<a class="headerlink" href="#variational-formulation-1" title="Permalink to this headline">¶</a></h3>
<p id="index-0">A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a sequence of
stationary problems, and then turn each stationary problem into a
variational formulation.</p>
<p>Let superscript <span class="math">\(n\)</span> denote a quantity at time <span class="math">\(t_n\)</span>, where <span class="math">\(n\)</span> is an
integer counting time levels. For example, <span class="math">\(u^n\)</span> means <span class="math">\(u\)</span> at time
level <span class="math">\(n\)</span>. A finite difference discretization in time first consists
of sampling the PDE at some time level, say <span class="math">\(t_n\)</span>:</p>
<div class="math" id="eq-ch-diffusion0-pde1-tk">
\[\tag{20}
{\partial \over\partial t}u^n = \nabla^2 u^n + f^n{\thinspace .}\]</div>
<p>The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons, we choose a
simple backward difference:</p>
<div class="math" id="eq-ch-diffusion0-be">
\[\tag{21}
{\partial \over\partial t}u^n\approx {u^n - u^{n-1}\over{{\Delta t}}},\]</div>
<p>where <span class="math">\({\Delta t}\)</span> is the time discretization parameter.
Inserting <a class="reference internal" href="#eq-ch-diffusion0-be"><span class="std std-ref">(21)</span></a> in <a class="reference internal" href="#eq-ch-diffusion0-pde1-tk"><span class="std std-ref">(20)</span></a> yields</p>
<div class="math" id="eq-ch-diffusion0-pde1-be">
\[\tag{22}
{u^n - u^{n-1}\over{{\Delta t}}} = \nabla^2 u^n + f^n{\thinspace .}\]</div>
<p>This is our time-discrete version of the heat equation
<a class="reference internal" href="#eq-ch-diffusion0-pde1"><span class="std std-ref">(17)</span></a>. This is a so-called <em>backward Euler</em> or
<em>implicit Euler</em> discretization. Alternatively, we may also view this
as a finite element discretization in time in the form of the first order
<span class="math">\(\mathrm{dG}(0)\)</span> method, which here is identical to the backward Euler
method.</p>
<p>We may reorder <a class="reference internal" href="#eq-ch-diffusion0-pde1-be"><span class="std std-ref">(22)</span></a> so
that the left-hand side contains the terms with the unknown <span class="math">\(u^n\)</span> and
the right-hand side contains computed terms only. The result
is a sequence of spatial
(stationary) problems for <span class="math">\(u^n\)</span> (assuming <span class="math">\(u^{n-1}\)</span> is known from
computations at the previous time level):</p>
<div class="math" id="eq-ch-diffusion0-pde1-u0">
\[\tag{23}
u^0 = u_0,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-uk">
\[\tag{24}
u^n - {{\Delta t}}\nabla^2 u^n =  u^{n-1} + {{\Delta t}} f^n,\quad n=1,2,\ldots\]</div>
<p>Given <span class="math">\(u_0\)</span>, we can solve for <span class="math">\(u^0\)</span>, <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and so on.</p>
<p>An alternative to <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a>, which can be
convenient in implementations, is to collect
all terms on one side of the equality sign:</p>
<div class="math" id="eq-ch-diffusion0-pde1-uk2">
\[\tag{25}
u^n - {{\Delta t}}\nabla^2 u^n -  u^{n-1} - {{\Delta t}} f^n = 0,\quad n=1,2,\ldots\]</div>
<p>We use a finite element method to solve
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0"><span class="std std-ref">(23)</span></a> and either of the equations
<a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a> or <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk2"><span class="std std-ref">(25)</span></a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function <span class="math">\(v\in \hat V\)</span> and integrate second-derivatives by
parts. Introducing the symbol <span class="math">\(u\)</span> for <span class="math">\(u^n\)</span> (which is natural in the
program), the resulting weak form arising from
formulation <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a>
can be conveniently written in
the standard notation:</p>
<div class="math">
\[a(u,v)=L_n(v),\]</div>
<p>where</p>
<div class="math" id="eq-ch-diffusion0-pde1-a">
\[\tag{26}
a(u,v) = \int_\Omega\left( uv + {{\Delta t}}
    \nabla u\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-l">
\[\tag{27}
L_n(v) = \int_\Omega \left(u^{n-1} + {{\Delta t}}  f^n\right)v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The alternative form <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk2"><span class="std std-ref">(25)</span></a> has an
abstract formulation</p>
<div class="math">
\[F(u;v) = 0,\]</div>
<p>where</p>
<div class="math" id="eq-ch-diffusion0-pde1-f">
\[\tag{28}
F(u; v) = \int_\Omega  uv + {{\Delta t}}
    \nabla u\cdot \nabla v -
    (u^{n-1} + {{\Delta t}} f^n)v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>In addition to the variational problem to be solved in each time step,
we also need to approximate the initial condition
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0"><span class="std std-ref">(23)</span></a>. This equation can also be turned into a
variational problem:</p>
<div class="math">
\[a_0(u,v)=L_0(v),\]</div>
<p>with</p>
<div class="math" id="eq-ch-diffusion0-pde1-a0">
\[\tag{29}
a_0(u,v) = \int_\Omega uv {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-l0">
\[\tag{30}
L_0(v) = \int_\Omega u_0 v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>When solving this variational problem, <span class="math">\(u^0\)</span> becomes the
<span class="math">\(L^2\)</span> projection of the given initial value <span class="math">\(u_0\)</span> into the finite
element space. The alternative is to construct <span class="math">\(u^0\)</span> by just
interpolating the initial value <span class="math">\(u_0\)</span>; that is,
if <span class="math">\(u^0=\sum_{j=1}^N U^0_j\phi_j\)</span>, we simply set <span class="math">\(U_j=u_0(x_j,y_j)\)</span>,
where <span class="math">\((x_j,y_j)\)</span> are the coordinates of node number <span class="math">\(j\)</span>. We refer to
these two strategies as computing the initial condition by either
projection or interpolation. Both operations are easy to
compute in FEniCS through one statement, using either the <code class="docutils literal"><span class="pre">project</span></code> or
<code class="docutils literal"><span class="pre">interpolate</span></code> function.</p>
<p>In summary, we thus need to solve the following sequence of variational
problems to compute the finite element solution to the heat equation:
find <span class="math">\(u^0\in V\)</span> such that <span class="math">\(a_0(u^0,v)=L_0(v)\)</span> holds for all <span class="math">\(v\in\hat V\)</span>,
and then find <span class="math">\(u^n\in V\)</span>
such that <span class="math">\(a(u^n,v)=L_n(v)\)</span> for all <span class="math">\(v\in\hat V\)</span>,
or alternatively, <span class="math">\(F(u^n,v)=0\)</span> for all <span class="math">\(v\in\hat V\)</span>,
for <span class="math">\(n=1,2,\ldots\)</span>.</p>
</div>
<div class="section" id="a-simple-fenics-implementation-1">
<span id="ftut-timedep-diffusion1-impl"></span><h3>A simple FEniCS implementation<a class="headerlink" href="#a-simple-fenics-implementation-1" title="Permalink to this headline">¶</a></h3>
<p>Our program needs to implement the time-stepping manually, but can
rely on FEniCS to easily compute <span class="math">\(a_0\)</span>, <span class="math">\(L_0\)</span>, <span class="math">\(F\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(L\)</span>, and solve
the linear systems for the unknowns.</p>
<div class="section" id="test-problem-1">
<h4>Test problem<a class="headerlink" href="#test-problem-1" title="Permalink to this headline">¶</a></h4>
<p>Just as for the Poisson problem from the previous chapter, we
construct a test problem that makes it easy to determine if the
calculations are correct. Since we know that our first-order
time-stepping scheme is exact for linear functions, we create a test
problem which has a linear variation in time. We combine this with a
quadratic variation in space. We thus take</p>
<div class="math" id="eq-ch-diffusion0-pde1-u0test">
\[\tag{31}
u = 1 + x^2 + \alpha y^2 + \beta t,\]</div>
<p>which yields a function whose computed values at the nodes will be
exact, regardless of the size of the elements and <span class="math">\({\Delta t}\)</span>, as long as
the mesh is uniformly partitioned. By inserting
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a> into the heat equation
<a class="reference internal" href="#eq-ch-diffusion0-pde1"><span class="std std-ref">(17)</span></a>, we find that the right-hand side <span class="math">\(f\)</span> must
be given by <span class="math">\(f(x,y,t)=\beta - 2 - 2\alpha\)</span>. The boundary value
is <span class="math">\(u_{_\mathrm{D}}(x, y, t) = 1 + x^2 + \alpha y^2 + \beta t\)</span> and the initial
value is <span class="math">\(u_0(x, y) = 1 + x^2 + \alpha y^2\)</span>.</p>
</div>
<div class="section" id="fenics-implementation-2">
<span id="index-1"></span><h4>FEniCS implementation<a class="headerlink" href="#fenics-implementation-2" title="Permalink to this headline">¶</a></h4>
<p>A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition <span class="math">\(u_{_\mathrm{D}}(x, y,
t) = 1 + x^2 + \alpha y^2 + \beta t\)</span>. A natural solution is to use a
FEniCS <code class="docutils literal"><span class="pre">Expression</span></code> with time <span class="math">\(t\)</span> as a parameter, in addition to the
parameters <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u_b</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                 <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This expression uses the components of <code class="docutils literal"><span class="pre">x</span></code> as independent
variables, while <code class="docutils literal"><span class="pre">alpha</span></code>, <code class="docutils literal"><span class="pre">beta</span></code>, and <code class="docutils literal"><span class="pre">t</span></code> are parameters.  The
parameters can later be updated as in</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_b</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>The essential boundary conditions, along the entire boundary in this case,
are set in the usual way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>We shall use <code class="docutils literal"><span class="pre">u</span></code> for the unknown <span class="math">\(u^n\)</span> at the new time level and <code class="docutils literal"><span class="pre">u_p</span></code>
for <span class="math">\(u^{n-1}\)</span> at the previous time level. The initial value of <code class="docutils literal"><span class="pre">u_p</span></code> can be
computed by either projection or interpolation of <span class="math">\(u_0\)</span>. Since we set
<code class="docutils literal"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">0</span></code> for the boundary value <code class="docutils literal"><span class="pre">u_b</span></code>, we can use this also to specify
the initial condition. We can then do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_p</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-projecting-versus-interpolating-the-initial-condition admonition">
<p class="first admonition-title">Projecting versus interpolating the initial condition</p>
<p class="last">To actually recover the
exact solution <a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a> to machine precision,
it is important not to compute the discrete initial condition by
projecting <span class="math">\(u_0\)</span>, but by interpolating <span class="math">\(u_0\)</span> so that the degrees of freedom have
exact values at <span class="math">\(t=0\)</span> (projection results in approximative values at the
nodes).</p>
</div>
<span class="target" id="index-2"></span><p id="index-3">We may either define <span class="math">\(a\)</span> or <span class="math">\(L\)</span> according to the formulas above, or
we may just define <span class="math">\(F\)</span> and ask FEniCS to figure out which terms that
go into the bilinear form <span class="math">\(a\)</span> and which that go into the linear form
<span class="math">\(L\)</span>. The latter is convenient, especially in more complicated problems,
so we illustrate that construction of <span class="math">\(a\)</span> and <span class="math">\(L\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_p</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we perform the time-stepping in a loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_b</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>

    <span class="c1"># Solve variational problem</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>


    <span class="c1"># Update previous solution</span>
    <span class="n">u_p</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>In the last step of the time-stepping loop, we assign the values of
the variable <code class="docutils literal"><span class="pre">u</span></code> (the new computed solution) to the variable
containing the values at the previous time step. This must be done
using the <code class="docutils literal"><span class="pre">assign</span></code> member function. If we instead try to do <code class="docutils literal"><span class="pre">u_p</span> <span class="pre">=</span> <span class="pre">u</span></code>,
we will set the <code class="docutils literal"><span class="pre">u_p</span></code> Python variable to be the <em>same</em> variable as <code class="docutils literal"><span class="pre">u</span></code>
which is not what we want. (We need two variables, one for the values
at the previous time step and one for the values at the current time
step.)</p>
<div class="admonition-remember-to-update-expression-objects-with-the-current-time admonition">
<p class="first admonition-title">Remember to update expression objects with the current time</p>
<p class="last">Inside the time loop,
observe that <code class="docutils literal"><span class="pre">u_b.t</span></code> must be updated before the <code class="docutils literal"><span class="pre">solve</span></code> statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the <code class="docutils literal"><span class="pre">u_b</span></code> object
for values.)</p>
</div>
<p>The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in the Poisson equation example in
the section <a class="reference internal" href="._ftut1003.html#ch-poisson0-impl-dissect"><span class="std std-ref">Dissection of the program</span></a>, we compute the
difference between the array of nodal values of <code class="docutils literal"><span class="pre">u</span></code> and the array
nodal values of
the interpolated exact solution. This may be done as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;error, t=</span><span class="si">%.2f</span><span class="s1">: </span><span class="si">%-10.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete program code for this time-dependent case goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">2.0</span>            <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">10</span>     <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span>          <span class="c1"># parameter alpha</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>         <span class="c1"># parameter beta</span>

<span class="c1"># Create mesh and define function space</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundary condition</span>
<span class="n">u_D</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                 <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c1"># Define initial value</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_D</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c1">#u_p = project(u_D, V)</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_p</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Time-stepping</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_D</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="c1"># update for bc</span>

    <span class="c1"># Solve variational problem</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="c1"># Compute error at vertices</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_D</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;t = </span><span class="si">%.2f</span><span class="s1">: error = </span><span class="si">%.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u_p</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>The code is available in the
file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/heat.py">ft03_heat.py</a>.</p>
</div>
</div>
<div class="section" id="diffusion-of-a-gaussian-function">
<h3>Diffusion of a Gaussian function<a class="headerlink" href="#diffusion-of-a-gaussian-function" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-mathematical-problem">
<h4>The mathematical problem<a class="headerlink" href="#the-mathematical-problem" title="Permalink to this headline">¶</a></h4>
<p>Now we want to solve a more relevant test problem, namely the diffusion of
a Gaussian hill. It means that the initial value is given by</p>
<div class="math">
\[u_0(x,y)= e^{-ax^2 - ay^2}\]</div>
<p>on a domain <span class="math">\([-2,2]\times [2,2]\)</span>. We will take <span class="math">\(a = 5\)</span>. For this
problem we will use homogeneous Dirichlet boundary conditions (<span class="math">\(u_{_\mathrm{D}} = 0\)</span>).</p>
</div>
<div class="section" id="fenics-implementation-3">
<h4>FEniCS implementation<a class="headerlink" href="#fenics-implementation-3" title="Permalink to this headline">¶</a></h4>
<p>Which are the required changes to our previous program? One major
change is that the domain is not a unit square anymore. We also want to
use much higher resolution. The new domain can
be created easily in FEniCS using <code class="docutils literal"><span class="pre">RectangleMesh</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
</pre></div>
</div>
<p>We also need to redefine the initial condition and boundary condition.
Both are easily changed by defining a new <code class="docutils literal"><span class="pre">Expression</span></code> and by setting
<span class="math">\(u = 0\)</span> on the boundary. We will also save the solution to file in VTK
format in each time step:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>[<strong>AL 5</strong>: Remember to output as <code class="docutils literal"><span class="pre">(u,</span> <span class="pre">t)</span></code> also in other examples below.]</p>
<p>The complete program appears below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">2.0</span>            <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">50</span>     <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>

<span class="c1"># Create mesh and define function space</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundary condition</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c1"># Define initial value</span>
<span class="n">u_0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;exp(-a*pow(x[0],2) - a*pow(x[1],2))&#39;</span><span class="p">,</span>
                 <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">u_p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;initial value&#39;</span><span class="p">)</span>
<span class="n">vtkfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;gaussian_diffusion.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u_p</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_p</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;solution&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Solve variational problem</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="c1"># Save to file and plot solution</span>
    <span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u_p</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This program is also available in the
file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/gaussian_diffusion.py">ft04_gaussian_diffusion.py</a>.</p>
</div>
<div class="section" id="visualization-in-paraview">
<h4>Visualization in ParaView<a class="headerlink" href="#visualization-in-paraview" title="Permalink to this headline">¶</a></h4>
<p>To visualize the diffusion of the Gaussian hill, start ParaView,
choose <strong>File - Open</strong>, open the file <code class="docutils literal"><span class="pre">gaussian_diffusion.pvd</span></code>, click
the green <strong>Apply</strong> button on the left to see the initial condition
being plotted. Choose <strong>View - Animation View</strong>. Click on the play
button or (better) the next frame button in the row of buttons at the
top of the GUI to see the evolution of the scalar field you have just
computed:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/paraview_animation_buttons.png"><img alt="_images/paraview_animation_buttons.png" src="_images/paraview_animation_buttons.png" style="width: 300px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>The cross in the middle of the plot can be turned off by the <strong>Show Center</strong>
button:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/paraview_show_center_button.png"><img alt="_images/paraview_show_center_button.png" src="_images/paraview_show_center_button.png" style="width: 150px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>Choose <strong>File - Save Animation...</strong> to save the animation to the AVI or OGG video format.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov/diffusion0.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><div class="figure">
<a class="reference internal image-reference" href="_images/diffusion0_paraview_animation.png"><img alt="_images/diffusion0_paraview_animation.png" src="_images/diffusion0_paraview_animation.png" style="width: 600px;" /></a>
</div>
<p>Once the animation has been saved to file, you can play the animation
offline using a player such as mplayer or VLC, or upload your
animation to YouTube. Below is a sequence of
snapshots of the solution.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/diffusion0_3snapshots.png"><img alt="_images/diffusion0_3snapshots.png" src="_images/diffusion0_3snapshots.png" style="width: 800px;" /></a>
</div>
</div>
</div>
</div>
<div class="section" id="a-nonlinear-poisson-equation">
<span id="ftut1-gallery-nonlinearpoisson"></span><h2>A nonlinear Poisson equation<a class="headerlink" href="#a-nonlinear-poisson-equation" title="Permalink to this headline">¶</a></h2>
<p>We shall now address how to solve nonlinear PDEs. We will see that
nonlinear problems can be solved just as easily as linear problems in
FEniCS, by simply defining a nonlinear variational problem and calling
the <code class="docutils literal"><span class="pre">solve</span></code> function. When doing so, we will encounter a subtle
difference in how the variational problem is defined.</p>
<div class="section" id="pde-problem-2">
<h3>PDE problem<a class="headerlink" href="#pde-problem-2" title="Permalink to this headline">¶</a></h3>
<p>As a sample PDE for the implementation of nonlinear problems, we
take the following nonlinear Poisson equation:</p>
<div class="math" id="eq-auto5">
\[\tag{32}
-\nabla\cdot\left( q(u)\nabla u\right) = f,\]</div>
<p>in <span class="math">\(\Omega\)</span>, with <span class="math">\(u=u_{_\mathrm{D}}\)</span> on the boundary <span class="math">\(\partial\Omega\)</span>.
The coefficient <span class="math">\(q(u)\)</span> makes the equation nonlinear (unless <span class="math">\(q(u)\)</span>
is constant in <span class="math">\(u\)</span>).</p>
</div>
<div class="section" id="variational-formulation-2">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-2" title="Permalink to this headline">¶</a></h3>
<p>As usual, we multiply our PDE by a test function <span class="math">\(v\in\hat V\)</span>,
integrate over the domain, and integrate the second-order derivatives
by parts.  The boundary integral arising from integration by parts
vanishes wherever we employ Dirichlet conditions.  The resulting
variational formulation of our model problem becomes: find <span class="math">\(u \in V\)</span>
such that</p>
<div class="math" id="eq-ch-poisson0-nonlinear1">
\[\tag{33}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>where</p>
<div class="math" id="eq-ch-poisson0-nonlinear2">
\[\tag{34}
F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v + fv {\, \mathrm{d}x},\]</div>
<p>and</p>
<div class="math">
\[\begin{split} V      &amp;= \{v \in H^1(\Omega) : v = u_{_\mathrm{D}} \mbox{ on } \partial\Omega\},\\
\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}{\thinspace .}\end{split}\]</div>
<p>The discrete problem arises as usual by restricting <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>
to a pair of discrete spaces. As before, we omit any subscript on
the discrete spaces and discrete solution.
The discrete nonlinear problem is then written as: find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-ch-poisson0-nonlinear-d">
\[\tag{35}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>with <span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>. Since <span class="math">\(F\)</span> is a nonlinear function
of <span class="math">\(u\)</span>, the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns <span class="math">\(U_1,\ldots,U_N\)</span>.</p>
</div>
<div class="section" id="a-simple-fenics-implementation-2">
<span id="ftut-nonlinear-newton-auto"></span><h3>A simple FEniCS implementation<a class="headerlink" href="#a-simple-fenics-implementation-2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="test-problem-2">
<h4>Test problem<a class="headerlink" href="#test-problem-2" title="Permalink to this headline">¶</a></h4>
<p>To solve a test problem, we need to choose the right-hand side <span class="math">\(f\)</span>,
the coefficient <span class="math">\(q(u)\)</span> and the boundary value <span class="math">\(u_{_\mathrm{D}}\)</span>.  Previously, we
have worked with manufactured solutions that can be reproduced without
approximation errors. This is more difficult in nonlinear problems,
and the algebra is more tedious. However, we may utilize SymPy for
symbolic computing and integrate such computations in the FEniCS
solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package. In particular, we will use the
SymPy functions <code class="docutils literal"><span class="pre">diff</span></code> for symbolic differentiation and <code class="docutils literal"><span class="pre">ccode</span></code> for
C/C++ code generation.</p>
<p>We try out a two-dimensional manufactured
solution that is linear in the unknowns:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Warning: from fenics import * will import both `sym` and</span>
<span class="c1"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span class="c1"># overwrite these objects.</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Use SymPy to compute f given manufactured solution u</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="n">f</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> \
      <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-define-symbolic-coordinates-as-required-in-expression-objects admonition">
<p class="first admonition-title">Define symbolic coordinates as required in <code class="docutils literal"><span class="pre">Expression</span></code> objects</p>
<p class="last">Note that we would normally write <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x</span> <span class="pre">y')</span></code>, but
if we want the resulting expressions to have valid syntax for
FEniCS <code class="docutils literal"><span class="pre">Expression</span></code> objects, we must use <code class="docutils literal"><span class="pre">x[0]</span></code> and <code class="docutils literal"><span class="pre">x[1]</span></code>.
This is easily accomplished with <code class="docutils literal"><span class="pre">sympy</span></code> by defining the names of <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">x[0]</span></code> and <code class="docutils literal"><span class="pre">x[1]</span></code>: <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x[0]</span> <span class="pre">x[1]')</span></code>.</p>
</div>
<p>Turning the expressions for <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">f</span></code> into C or C++ syntax for
FEniCS <code class="docutils literal"><span class="pre">Expression</span></code> objects needs two steps. First, we ask for the C
code of the expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">f_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometimes, we need some editing of the result to match the required
syntax of <code class="docutils literal"><span class="pre">Expression</span></code> objects, but not in this case. (The primary
example is that <code class="docutils literal"><span class="pre">M_PI</span></code> for <span class="math">\(\pi\)</span> in C/C++ must be replaced by <code class="docutils literal"><span class="pre">pi</span></code> for
<code class="docutils literal"><span class="pre">Expression</span></code> objects.) In our case here, the output of <code class="docutils literal"><span class="pre">c_code</span></code> and
<code class="docutils literal"><span class="pre">f_code</span></code> is</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">20</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
</pre></div>
</div>
<p>After having defined the mesh, the function space, and the boundary,
we define the boundary value <code class="docutils literal"><span class="pre">u_b</span></code> as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_b</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_code</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we define the right-hand side function as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_code</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-name-clash-between-fenics-and-program-variables admonition">
<p class="first admonition-title">Name clash between <code class="docutils literal"><span class="pre">fenics</span></code> and program variables</p>
<p class="last">In a program like the one above, strange errors may occur due to
name clashes. If you define <code class="docutils literal"><span class="pre">sym</span></code> and <code class="docutils literal"><span class="pre">q</span></code> prior to doing
<code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code>, the latter statement will also import
variables with the names <code class="docutils literal"><span class="pre">sym</span></code> and <code class="docutils literal"><span class="pre">q</span></code>, overwriting
the objects you have previously defined! This may lead to strange
errors. The safest solution is to do <code class="docutils literal"><span class="pre">import</span> <span class="pre">fenics</span> <span class="pre">as</span> <span class="pre">fe</span></code>
and then prefix all FEniCS
object names by <code class="docutils literal"><span class="pre">fe</span></code>. The next best solution is to do
<code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code> first and then define your own variables
that overwrite those imported from <code class="docutils literal"><span class="pre">fenics</span></code>. This is acceptable
if we do not need <code class="docutils literal"><span class="pre">sym</span></code> and <code class="docutils literal"><span class="pre">q</span></code> from <code class="docutils literal"><span class="pre">fenics</span></code>.</p>
</div>
</div>
<div class="section" id="fenics-implementation-4">
<h4>FEniCS implementation<a class="headerlink" href="#fenics-implementation-4" title="Permalink to this headline">¶</a></h4>
<p>A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is to state the formula for <span class="math">\(F\)</span> and call
<code class="docutils literal"><span class="pre">solve(F</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> instead of <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> as we did
in the linear case. Here is a minimalistic code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u_b</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_b</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Compute solution</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>The major difference from a linear problem is that the unknown function
<code class="docutils literal"><span class="pre">u</span></code> in the variational form in the nonlinear case
must be defined as a <code class="docutils literal"><span class="pre">Function</span></code>, not a <code class="docutils literal"><span class="pre">TrialFunction</span></code>. In some sense
this is a simplification from the linear case where we must define <code class="docutils literal"><span class="pre">u</span></code>
first as a <code class="docutils literal"><span class="pre">TrialFunction</span></code> and then as a <code class="docutils literal"><span class="pre">Function</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">solve</span></code> function takes the nonlinear equations, derives symbolically
the Jacobian matrix, and runs a Newton method to compute the solution.</p>
<p>[<strong>AL 6</strong>: Should we display all codes like this one?]
[<strong>hpl 7</strong>: Now experimenting with refernce to repo and in html and sphinx a button will fold out the code.]</p>
<p>The complete code is found in the file
<a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/ft05_nlpoisson.py">ft05_nlpoisson.py</a>.</p>
<div class="toggle container">
<div class="header container">
<strong>Show/Hide Code</strong></div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">FEniCS tutorial demo program: Poisson equation with Dirichlet conditions.</span>
<span class="sd">Simplest example of computation and visualization with FEniCS.</span>

<span class="sd">-div(q(u)*grad(u)) = f on the unit square.</span>
<span class="sd">u = u0 on the boundary.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="c1"># Warning: from fenics import * will import both `sym` and</span>
<span class="c1"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span class="c1"># overwrite these objects.</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Use SymPy to compute f given manufactured solution u</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="n">f</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> \
      <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">u_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">f_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;u =&#39;</span><span class="p">,</span> <span class="n">u_code</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;f =&#39;</span><span class="p">,</span> <span class="n">f_code</span><span class="p">)</span>

<span class="c1"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundary condition</span>
<span class="n">u_b</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_code</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_b</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="c1"># not TrialFunction!</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_code</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Compute solution</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c1"># Plot solution</span>
<span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;solution&#39;</span><span class="p">)</span>
<span class="c1">#plot(u)</span>

<span class="c1"># Compute error at vertices</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;error = </span><span class="si">%.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="p">)</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Running the code gives output that tells how the Newton iteration
progresses. With <span class="math">\(2(6\times 4)\)</span> cells we get convergence in 7
iterations with a tolerance of <span class="math">\(10^{-9}\)</span>, and the error in the
numerical solution is about <span class="math">\(10^{-11}\)</span>. With <span class="math">\(2(3\times 3)\)</span> and
<span class="math">\(2(8\times 8)\)</span> cells the error is identically zero.  Other resolutions
may bring the error up to the level of the tolerance in the Newton
iterations. These results bring evidence for a correct implementation.
Thinking in terms of finite differences on a uniform mesh, P1 elements
mimic standard second-order differences, which compute the derivative
of a linear or quadratic function exactly. Here, <span class="math">\(\nabla
u\)</span> is a constant vector, but then multiplied by <span class="math">\((1+u^2)\)</span>, which is a
second-order polynomial in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, which the divergence
&#8220;difference operator&#8221; should compute exactly.  We can therefore,
even with P1 elements, expect the manufactured <span class="math">\(u\)</span> to be reproduced by
the numerical method. With a nonlinearity like <span class="math">\(1+u^4\)</span>, this will not be the
case, and we would need to verify convergence rates instead.</p>
<p>The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on the numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much better manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter
&#8220;Implementing solvers for nonlinear PDEs&#8221;: &#8220;&#8221; <a class="reference internal" href="._ftut1007.html#ref24" id="id1">[Ref24]</a>
and show how we can implement our
own solution algorithms for nonlinear equations and also how we can
steer the parameters in the automated Newton method used above. You
will then see how easy it is to implement tailored solution
strategies for nonlinear problems in FEniCS.</p>
</div>
</div>
</div>
<div class="section" id="the-equations-of-linear-elasticity">
<span id="ftut-elast"></span><h2>The equations of linear elasticity<a class="headerlink" href="#the-equations-of-linear-elasticity" title="Permalink to this headline">¶</a></h2>
<p>Analysis of structures is one of the major activities of modern
engineering, thus making the PDEs for deformation of elastic bodies
likely the most popular PDE model in the world.
It takes just one page of code to solve the equations of 2D or 3D
elasticity in FEniCS, and the details follow below.</p>
<div class="section" id="pde-problem-3">
<h3>PDE problem<a class="headerlink" href="#pde-problem-3" title="Permalink to this headline">¶</a></h3>
<p>The equations governing small elastic deformations of a body <span class="math">\(\Omega\)</span>
can be written as</p>
<div class="math" id="eq-ftut-elast-varform-equilibrium">
\[\tag{36}
-\nabla\cdot\sigma = f\hbox{ in }\Omega,\]</div>
<div class="math" id="eq-ftut-elast-varform-stresstrain">
\[\tag{37}
\sigma = \lambda\,\hbox{tr}\,\varepsilon I + 2\mu\varepsilon,\]</div>
<div class="math" id="eq-ftut-elast-varform-strainu">
\[\tag{38}
\varepsilon = \frac{1}{2}\left(\nabla u + (\nabla u)^{\top}\right),\]</div>
<p>where <span class="math">\(\sigma\)</span> is the stress tensor, <span class="math">\(f\)</span> is the body force per unit
volume, <span class="math">\(\lambda\)</span> and <span class="math">\(\mu\)</span> are Lame&#8217;s elasticity parameters for the
material in <span class="math">\(\Omega\)</span>, <span class="math">\(I\)</span> is the identity tensor, <span class="math">\(\mathrm{tr}\)</span> is the
trace operator on a tensor, <span class="math">\(\varepsilon\)</span> is the strain tensor
(symmetric gradient), and <span class="math">\(u\)</span> is the displacement vector field.
We have here assumed isotropic elastic conditions.</p>
<p>We combine <a class="reference internal" href="#eq-ftut-elast-varform-stresstrain"><span class="std std-ref">(37)</span></a> and
<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a> to obtain</p>
<div class="math" id="eq-ftut-elast-varform-stressu">
\[\tag{39}
\sigma = \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top}){\thinspace .}\]</div>
<p>Note that <a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>-<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a>
can easily be transformed to a single vector PDE for <span class="math">\(u\)</span>, which is the governing
PDE for the unknown <span class="math">\(u\)</span> (Navier&#8217;s equation).
In the derivation of the variational formulation,
however, it is convenient to keep the splitting of the equations as above.</p>
</div>
<div class="section" id="variational-formulation-3">
<span id="ftut-elast-varform"></span><h3>Variational formulation<a class="headerlink" href="#variational-formulation-3" title="Permalink to this headline">¶</a></h3>
<p>The variational formulation of
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>&#8211;<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a>
consists of forming the inner product of
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a> and a <em>vector</em> test function
<span class="math">\(v\in \hat{V}\)</span>, where <span class="math">\(\hat{V}\)</span> is a test vector function space, and
integrating over the domain <span class="math">\(\Omega\)</span>:</p>
<div class="math">
\[-\int_\Omega (\nabla\cdot\sigma) \cdot v {\, \mathrm{d}x} =
\int_\Omega f\cdot v{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Since <span class="math">\(\nabla\cdot\sigma\)</span> contains second-order derivatives of the primary
unknown <span class="math">\(u\)</span>, we integrate this term by parts:</p>
<div class="math">
\[-\int_\Omega (\nabla\cdot\sigma) \cdot v {\, \mathrm{d}x}
= \int_\Omega \sigma : \nabla v{\, \mathrm{d}x} - \int_{\partial\Omega}
(\sigma\cdot n)\cdot v {\, \mathrm{d}s},\]</div>
<p>where the colon operator is the inner product between tensors
(summed pairwise product of all elements), and <span class="math">\(n\)</span>
is the outward unit normal at the boundary. The quantity <span class="math">\(\sigma\cdot n\)</span>
is known as the <em>traction</em> or stress vector at the boundary, and is often
prescribed as a boundary condition. We assume that it is prescribed
at a part <span class="math">\(\partial\Omega_T\)</span> of the boundary and set <span class="math">\(T = \sigma\cdot
n\)</span>. On the remaining part of the boundary, we assume that the value of
the displacement is given as a Dirichlet condition.
We then have</p>
<div class="math">
\[\int_\Omega \sigma : \nabla v {\, \mathrm{d}x} =
\int_\Omega f\cdot v {\, \mathrm{d}x}
+ \int_{\partial\Omega_T} T\cdot v{\, \mathrm{d}s}{\thinspace .}\]</div>
<p>Inserting the expression <a class="reference internal" href="#eq-ftut-elast-varform-stressu"><span class="std std-ref">(39)</span></a> for
<span class="math">\(\sigma\)</span> gives the variational form with <span class="math">\(u\)</span> as unknown. Note that the
boundary integral on the remaining part
<span class="math">\(\partial\Omega\setminus\Omega_T\)</span> vanishes due to the Dirichlet
condition (<span class="math">\(v = 0\)</span>).</p>
<p>We can now summarize the variational formulation as: find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-auto6">
\[\tag{40}
a(u,v) = L(v)\quad\forall v\in\hat{V},\]</div>
<p>where</p>
<div class="math" id="eq-ftut-elast-varform-sigma-inner-gradv">
\[\tag{41}
a(u,v) = \int_\Omega\sigma(u) :\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto7">
\[\tag{42}
\sigma(u) = \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top}),\]</div>
<div class="math" id="eq-auto8">
\[\tag{43}
L(v) = \int_\Omega f\cdot v{\, \mathrm{d}x} + \int_{\partial\Omega_T}
    T\cdot v{\, \mathrm{d}s}{\thinspace .}\]</div>
<p>One can show that the inner product of a symmetric tensor <span class="math">\(A\)</span> and a
non-symmetric tensor <span class="math">\(B\)</span> vanishes. If we express <span class="math">\(\nabla v\)</span> as a sum
of its symmetric and non-symmetric parts, only the symmetric part will
survive in the product <span class="math">\(\sigma :\nabla v\)</span> since <span class="math">\(\sigma\)</span> is a
symmetric tensor. Thus replacing <span class="math">\(\nabla u\)</span> by the symmetric gradient
<span class="math">\(\epsilon(u)\)</span> gives rise to the slightly different variational form</p>
<div class="math" id="eq-ftut-elast-varform-sigma-inner-eps">
\[\tag{44}
a(u,v) = \int_\Omega\sigma(u) :\varepsilon(v) {\, \mathrm{d}x},\]</div>
<p>where <span class="math">\(\varepsilon(v)\)</span> is the symmetric part of <span class="math">\(\nabla v\)</span>:</p>
<div class="math">
\[\varepsilon(v) = \frac{1}{2}\left(\nabla v + (\nabla v)^{\top}\right){\thinspace .}\]</div>
<p>The formulation <a class="reference internal" href="#eq-ftut-elast-varform-sigma-inner-eps"><span class="std std-ref">(44)</span></a> is what naturally
arises from minimization of elastic potential energy is a more
popular formulation than <a class="reference internal" href="#eq-ftut-elast-varform-sigma-inner-gradv"><span class="std std-ref">(41)</span></a>.</p>
</div>
<div class="section" id="a-simple-fenics-implementation-3">
<h3>A simple FEniCS implementation<a class="headerlink" href="#a-simple-fenics-implementation-3" title="Permalink to this headline">¶</a></h3>
<div class="section" id="test-problem-3">
<h4>Test problem<a class="headerlink" href="#test-problem-3" title="Permalink to this headline">¶</a></h4>
<p>As a test example, we may look at a clamped beam deformed under its
own weight. Then <span class="math">\(f=(0,0,-\varrho g)\)</span> is the body force per unit
volume with <span class="math">\(\varrho\)</span> the
density of the beam and <span class="math">\(g\)</span> the acceleration of gravity. The beam is
box-shaped with length <span class="math">\(L\)</span> and square cross section of width <span class="math">\(W\)</span>. We
set <span class="math">\(u=(0,0,0)\)</span> at the clamped end, <span class="math">\(x=0\)</span>. The rest of the boundary is
traction free; that is, we set <span class="math">\(T = 0\)</span>.</p>
</div>
<div class="section" id="the-code">
<h4>The code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h4>
<p>We first list the code and then comment upon the new constructions
compared to the Poisson equation case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Scaled variables</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">W</span><span class="o">/</span><span class="n">L</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="n">lambda_</span> <span class="o">=</span> <span class="n">beta</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">gamma</span>

<span class="c1"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">W</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

<span class="k">def</span> <span class="nf">clamped_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">clamped_boundary</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="c1">#return sym(nabla_grad(u))</span>

<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="o">*</span><span class="n">nabla_div</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span>  <span class="c1"># no of space dim</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">rho</span><span class="o">*</span><span class="n">g</span><span class="p">))</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>

<span class="c1"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c1"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Displacement&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;displacement&#39;</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">tr</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># deviatoric stress</span>
<span class="n">von_Mises</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">von_Mises</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">von_Mises</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">von_Mises</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Stress intensity&#39;</span><span class="p">)</span>
<span class="n">u_magnitude</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">u</span><span class="p">))</span>
<span class="n">u_magnitude</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u_magnitude</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u_magnitude</span><span class="p">,</span> <span class="s1">&#39;Displacement magnitude&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;min/max u:&#39;</span><span class="p">,</span> <span class="n">u_magnitude</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
      <span class="n">u_magnitude</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="new-feature-vector-function-space">
<h4>New feature: vector function space<a class="headerlink" href="#new-feature-vector-function-space" title="Permalink to this headline">¶</a></h4>
<p>The primary unknown is now a vector field <span class="math">\(u\)</span> and not a scalar field,
so we need to work with a vector function space:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>With <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">Function(V)</span></code> we get <code class="docutils literal"><span class="pre">u</span></code> as a vector finite element function.</p>
</div>
<div class="section" id="new-feature-constant-vectors">
<h4>New feature: constant vectors<a class="headerlink" href="#new-feature-constant-vectors" title="Permalink to this headline">¶</a></h4>
<p>In the boundary condition <span class="math">\(u=0\)</span>, we must set a vector value to zero, not just
a scalar, and a constant zero vector is specified as <code class="docutils literal"><span class="pre">Constant((0,0,0))</span></code> in
FEniCS. The corresponding 2D code would use <code class="docutils literal"><span class="pre">Constant((0,0))</span></code>.
Later in the code, we also need <code class="docutils literal"><span class="pre">f</span></code> as a vector and specify it
as <code class="docutils literal"><span class="pre">Constant(0,0,rho*g))</span></code>.</p>
</div>
<div class="section" id="new-feature-nabla-grad">
<h4>New feature: <code class="docutils literal"><span class="pre">nabla_grad</span></code><a class="headerlink" href="#new-feature-nabla-grad" title="Permalink to this headline">¶</a></h4>
<p>The gradient and divergence operators now have a prefix <code class="docutils literal"><span class="pre">nabla_</span></code>.
This is strictly not necessary in the present problem, but
recommended in general for vector PDEs arising from continuum mechanics,
if you interpret <span class="math">\(\nabla\)</span> as a vector in the PDE notation,
see the box about <code class="docutils literal"><span class="pre">nabla_grad</span></code> in the section <a class="reference internal" href="#ftut1-ns-varform"><span class="std std-ref">Variational formulation</span></a>.</p>
</div>
<div class="section" id="new-feature-stress-computation">
<h4>New feature: stress computation<a class="headerlink" href="#new-feature-stress-computation" title="Permalink to this headline">¶</a></h4>
<p>As soon as <code class="docutils literal"><span class="pre">u</span></code> is computed, we can compute various stress measures, here
the von Mises stress defined as <span class="math">\(\sigma_M = \sqrt{\frac{3}{2}s:s}\)</span>
where <span class="math">\(s\)</span> is the deviatoric stress tensor</p>
<div class="math">
\[s = \sigma - \frac{1}{3}\mathrm{tr}\,\sigma\,I{\thinspace .}\]</div>
<p>There is a one to one mapping between these formulas and the FEniCS code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">tr</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">von_Mises</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">von_Mises</span></code> variable is now an expression that must be projected to
a finite element space before we can visualize it.</p>
</div>
<div class="section" id="scaling-2">
<h4>Scaling<a class="headerlink" href="#scaling-2" title="Permalink to this headline">¶</a></h4>
<p>Before doing simulations, it is often advantageous to scale the problem
as it reduces the need for setting physical parameters, and one obtains
dimensionsless numbers that reflect the competition of parameters and
physical effects. These numbers are often easy to assign values for
scientific investigations.</p>
<p>In Navier&#8217;s equation for <span class="math">\(u\)</span>, arising from inserting
<a class="reference internal" href="#eq-ftut-elast-varform-stresstrain"><span class="std std-ref">(37)</span></a> and
<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a> in
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>,</p>
<div class="math">
\[\nabla\cdot(\lambda\nabla\cdot u) + \mu\nabla^2 u = f,\]</div>
<p>we insert coordinates made dimensionless by <span class="math">\(L\)</span>, and <span class="math">\(\bar u=u/U\)</span>,
which results in the dimensionless governing equation</p>
<div class="math">
\[\beta\bar\nabla\cdot(\bar\nabla\cdot \bar u) + \bar\nabla^2 \bar u =
\bar f,\quad \bar f = (0,0,\gamma),\]</div>
<p>where <span class="math">\(\beta = \lambda/\mu\)</span> is a dimensionless elasticity parameter and</p>
<div class="math">
\[\gamma = \frac{\varrho gL^2}{\mu U}\]</div>
<p>is also a dimensionless variable reflecting the ratio of the load
<span class="math">\(\varrho g\)</span> and the shear stress
term <span class="math">\(\mu\nabla^2 u\sim \mu U/L^2\)</span> in the PDE.</p>
<p>[<strong>AL 8</strong>: Need to change above scaling argument now that <span class="math">\(\varrho\)</span> is not part of the equation?]
[<strong>hpl 9</strong>: No, we just inserted our particular <span class="math">\(f\)</span> which is <span class="math">\(\varrho g\)</span>.]</p>
<p>[<strong>AL 10</strong>: <span class="math">\(W\)</span> not defined below. Width?] [<strong>hpl 11</strong>: Defined in the test problem in the intro. But a comment what <span class="math">\(L/W\)</span> is, is now inserted.]</p>
<p>Sometimes, one will argue to chose <span class="math">\(U\)</span> to make <span class="math">\(\gamma\)</span> unity (<span class="math">\(U
= \varrho gL^2/\mu\)</span>). However, in elasticity, this leads us
to displacements of the size of the geometry, which makes plots look
very strange. We therefore want the characteristic displacement to be a
small fraction of the characteristic length of the geometry.
Actually, for a clamped beam, one has a deflection formula which gives
<span class="math">\(U = \frac{3}{2}\varrho gL^2\delta^2/E\)</span>, where <span class="math">\(\delta = L/W\)</span> is
a parameter reflecting how slender the beam is.
Thus, the dimensionless parameter <span class="math">\(\delta\)</span> is very important in the
problem (as expected, since <span class="math">\(\delta\gg 1\)</span> is what gives beam theory!).
Taking <span class="math">\(E\)</span> to be of the same order as <span class="math">\(\mu\)</span>, we realize that
<span class="math">\(\gamma \sim \delta^{-2}\)</span>.  Experiments with the code point to <span class="math">\(\gamma
= 0.4\delta^{-2}\)</span> as an appropriate choice of <span class="math">\(\gamma\)</span>.</p>
<p>The simulation code implements the problem with dimensions and
physical parameters <span class="math">\(\lambda\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(g\)</span>, <span class="math">\(L\)</span>, and <span class="math">\(W\)</span>.
However, we can usually easily reuse this code for a scaled problem.
In the present case, we just set <span class="math">\(\mu = \varrho = L = 1\)</span>, <span class="math">\(W\)</span> as
<span class="math">\(W/L\)</span>, <span class="math">\(g=\gamma\)</span>, and <span class="math">\(\lambda=\beta\)</span>.</p>
<p>[<strong>AL 12</strong>: I find this somewhat confusing. First we talk about a rescaled equation but then we solve the unscaled equation, but we choose the parameters so that it is somehow related to the scaled problem...?]</p>
<p>[<strong>AL 13</strong>: Need to look at code again once I have understood the scaling.]</p>
<p>[<strong>hpl 14</strong>: This is the way to do it ;-) Implement with dimensions to have the code as general as possible. Then scale a particular problem - and the scaling is restricted to this problem.  It makes it much easier to set parameters for numerical investigations and to understand the model and what the competing effects are. You can run the scaled model with the original program by a proper choice of parameters.]</p>
<div class="figure" id="id6">
<a class="reference internal image-reference" href="_images/beam2.png"><img alt="_images/beam2.png" src="_images/beam2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Gravity-induced deformation of a clamped beam: deflection (left) and stress intensity seen from below (right)</span></p>
</div>
</div>
</div>
</div>
<div class="section" id="the-navier-stokes-equations">
<span id="ftut1-ns"></span><h2>The Navier - Stokes equations<a class="headerlink" href="#the-navier-stokes-equations" title="Permalink to this headline">¶</a></h2>
<p>As our next example in this chapter, we will solve the incompressible
Navier-Stokes equations. This problem combines many of the challenges
from our previously studied problems: time-dependence, nonlinearity,
and vector-valued variables.</p>
<div class="section" id="pde-problem-4">
<h3>PDE problem<a class="headerlink" href="#pde-problem-4" title="Permalink to this headline">¶</a></h3>
<p>The incompressible Navier-Stokes equations are a system of equations
for the velocity <span class="math">\(u\)</span> and pressure <span class="math">\(p\)</span> in an incompressible fluid:</p>
<p>[<strong>hpl 15</strong>: Quite uncommon to write <span class="math">\(\dot u\)</span> for the time-derivative in the N-S equations. Only Claes Johnson comes to my mind... In mechanics, the dot is reserved for ODEs. I suggest the more common notation <span class="math">\(\partial u/\partial t\)</span>, also since we use this elsewhere in the books.]</p>
<div class="math" id="eq-ftut1-ns-momentum">
\[\tag{45}
\varrho(\dot{u} + u \cdot \nabla u) = \nabla\cdot\sigma(u, p) + f,\]</div>
<div class="math" id="eq-ftut1-ns-continuity">
\[\tag{46}
\nabla \cdot u = 0.\]</div>
<p>The right-hand side <span class="math">\(f\)</span> is a given force per unit volume and
just as for the equations of linear elasticity,
<span class="math">\(\sigma(u, p)\)</span> denotes the stress tensor which for a Newtonian fluid
is given by</p>
<div class="math" id="eq-auto9">
\[\tag{47}
\sigma(u, p) = 2\mu\epsilon(u) - pI,\]</div>
<p>where <span class="math">\(\epsilon(u)\)</span> is the strain-rate tensor</p>
<div class="math">
\[\epsilon(u) = \frac{1}{2}(\nabla u + (\nabla u)^T)){\thinspace .}\]</div>
<p>The parameter <span class="math">\(\mu\)</span> is the dynamic viscosity. Note that the momentum
equation <a class="reference internal" href="#eq-ftut1-ns-momentum"><span class="std std-ref">(45)</span></a> is very similar to the elasticity
equation <a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>. The difference is the
two additional terms <span class="math">\(\varrho(\dot{u} + u \cdot \nabla u)\)</span> and the different
expression for the stress tensor. The two extra terms express the
acceleration <span class="math">\(\rho \ddot{x}\)</span> balanced by the force <span class="math">\(F = f +
\nabla\cdot\sigma\)</span> per unit volume in Newton&#8217;s second law of motion.</p>
</div>
<div class="section" id="variational-formulation-4">
<span id="ftut1-ns-varform"></span><h3>Variational formulation<a class="headerlink" href="#variational-formulation-4" title="Permalink to this headline">¶</a></h3>
<p>The Navier - Stokes equations are different from
the time-dependent heat equation in that we need to solve a system of
equations and this system is of a special type. If we apply the same
technique as for the heat equation; that is, replacing the time
derivative with a simple difference quotient, we face two
challenges. First, we obtain a nonlinear system of equations. This in
itself is not a problem for FEniCS as we saw in the section <a class="reference internal" href="#ftut1-gallery-nonlinearpoisson"><span class="std std-ref">A nonlinear Poisson equation</span></a>, but the system has a so-called
<em>saddle point structure</em> and requires special techniques
(preconditioners and iterative methods) to be solved efficiently.</p>
<p>Instead, we will apply a simpler and often very efficient approach
which is to use a <em>splitting method</em>. In a splitting method, we
consider the two equations <a class="reference internal" href="#eq-ftut1-ns-momentum"><span class="std std-ref">(45)</span></a> and
<a class="reference internal" href="#eq-ftut1-ns-continuity"><span class="std std-ref">(46)</span></a> separately. There exist many splitting
strategies for the incompressible Navier-Stokes equations. One of the
oldest is the method proposed by Chorin <a class="reference internal" href="._ftut1007.html#ref25" id="id2">[Ref25]</a> and
Temam <a class="reference internal" href="._ftut1007.html#ref26" id="id3">[Ref26]</a>, often referred to as <em>Chorin&#8217;s method</em>. We will
use a modified version of Chorin&#8217;s method, the so-called incremental
pressure correction scheme (IPCS) due to <a class="reference internal" href="._ftut1007.html#ref27" id="id4">[Ref27]</a> which gives
improved accuracy compared to the original scheme at little extra
cost.</p>
<p>The IPCS scheme involves three steps. First, we compute a <em>tentative
velocity</em> <span class="math">\(u^{\bigstar}\)</span> by advancing the momentum equation
<a class="reference internal" href="#eq-ftut1-ns-momentum"><span class="std std-ref">(45)</span></a> using the pressure <span class="math">\(p^{n-1}\)</span> from the
previous time interval. We will also be using the velocity <span class="math">\(u^{n-1}\)</span>
in the nonlinear term <span class="math">\(u\cdot\nabla u\)</span>. The variational problem for
this first step is:</p>
<p>[<strong>hpl 16</strong>: This equation applies <code class="docutils literal"><span class="pre">textit</span></code> and <code class="docutils literal"><span class="pre">multiline</span></code> in math. At least <code class="docutils literal"><span class="pre">textit</span></code> does not work in MathJax. Must test what works in Sphinx. Answer: Sphinx MathJax did not accept anything of this.]</p>
<div class="math" id="eq-ftut1-ipcs1">
\[\begin{split}\tag{48}
{\langle \rho(u^{\bigstar, v \rangle} - u^{n-1}) / {\Delta t}}
          + {\langle \rho u^{n-1, v \rangle} \cdot \nabla u^{n-1}}
          + {\langle \sigma(u^{n-\frac{1, \epsilon(v) \rangle}{2}}, p^{n-1})}
          \\
          + {\langle p^{n-1, v \rangle} n}_{\partial\Omega}
          - {\langle \mu \nabla u^{n-\frac{1, v \rangle}{2}}\cdot n}_{\partial\Omega}
          = {\langle \rho f^n, v \rangle}\end{split}\]</div>
<p>This notation requires some explanation. First, we use the short-hand
notation</p>
<div class="math">
\[{\langle v, w \rangle} = \int_{\Omega} vw {\, \mathrm{d}x}, \quad
{\langle v, w \rangle}_{\partial\Omega} = \int_{\partial\Omega} vw {\, \mathrm{d}s}.\]</div>
<p>This allows us to express the variational problem in a more compact
way. Second, we use the notation <span class="math">\(u^{n-\frac{1}{2}}\)</span>. This notation
means the value of <span class="math">\(u\)</span> at the midpoint of the interval, usually approximated
by an arithmetic mean</p>
<div class="math">
\[u^{n-\frac{1}{2}} \approx (u^{n-1} + u^n) / 2.\]</div>
<p>Third, we notice that the variational problem <a class="reference internal" href="#eq-ftut1-ipcs1"><span class="std std-ref">(48)</span></a>
arises from the integration by parts of the term
<span class="math">\({\langle -\nabla\cdot\sigma, v \rangle}\)</span>. Just as for the elasticity problem in
the section <a class="reference internal" href="#ftut-elast"><span class="std std-ref">The equations of linear elasticity</span></a>, we obtain</p>
<div class="math">
\[{\langle -\nabla\cdot\sigma, v \rangle}
= {\langle \sigma, \epsilon(v) \rangle}
- {\langle T, v \rangle}_{\partial\Omega},\]</div>
<p>where <span class="math">\(T = \sigma\cdot n\)</span> is the boundary traction. If we solve a
problem with a free boundary, we can take <span class="math">\(T = 0\)</span> on the
boundary. However, if we compute the flow through a channel or a pipe
and want to model e flow that continues into an &#8220;imaginary channel&#8221; at
the outflow, we need to treat this term with some care. The assumption
we then make is that the derivative of the velocity in the direction
of the channel is zero at the outflow, corresponding to a flow that is
&#8220;fully developed&#8221; or doesn&#8217;t change significantly downstream of the
outflow. Doing so, the remaining boundary term at the outflow becomes
<span class="math">\(pn - \nu \nabla u \cdot n\)</span> which is the term appearing in the
variational problem <a class="reference internal" href="#eq-ftut1-ipcs1"><span class="std std-ref">(48)</span></a>.</p>
<p>[<strong>hpl 17</strong>: Here a boundary term <span class="math">\((\mu n\cdot \nabla u^{n-\frac{1}{2}},v)\)</span> is missing. This is the intricate discussions we had back in 2009-2010 with Harish on using N-S with <span class="math">\(\sigma\)</span> or <span class="math">\(\nabla^2 u\)</span>.]</p>
<p>[<strong>AL 18</strong>: Apostrophes like &#8220;these&#8221; don&#8217;t look like what I would expect in LaTeX.]
[<strong>hpl 19</strong>: No, double quotes must be written as in LaTeX &#8220;quotes&#8221;. Two backticks and two forward ticks become the right double quotes in various output formats.]</p>
<div class="admonition-grad-u-vs-nabla-grad-u admonition">
<p class="first admonition-title"><code class="docutils literal"><span class="pre">grad(u)</span></code> vs. <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code></p>
<p>For scalar functions <span class="math">\(\nabla u\)</span> has a clear meaning as the vector</p>
<div class="math">
\[\nabla u =(\frac{\partial u}{\partial x}, \frac{\partial u}{\partial y},
\frac{\partial u}{\partial z}){\thinspace .}\]</div>
<p>However, if <span class="math">\(u\)</span> is vector-valued, the meaning is less clear.
Some sources define <span class="math">\(\nabla u\)</span> as the matrix with elements
<span class="math">\(\partial u_j / \partial x_i\)</span> while other sources prefer
<span class="math">\(\partial u_i / \partial x_j\)</span>. In FEniCS, <code class="docutils literal"><span class="pre">grad(u)</span></code> is defined as the
matrix with elements <span class="math">\(\partial u_i / \partial x_j\)</span>, which is the
natural definition of <span class="math">\(\nabla u\)</span> if we think of this as the <em>gradient</em> or
<em>derivative</em> of <span class="math">\(u\)</span>. This way, the matrix <span class="math">\(\nabla u\)</span> can be applied to
a differential <span class="math">\({\, \mathrm{d}x}\)</span> to give an increment <span class="math">\(\mathrm{d}u = \nabla u \,
{\, \mathrm{d}x}\)</span>. Since the alternative interpretation of <span class="math">\(\nabla u\)</span> as the matrix
with elements <span class="math">\(\partial u_j / \partial x_i\)</span> is very common, in
particular in continuum mechanics, FEniCS
provides the operator <code class="docutils literal"><span class="pre">nabla_grad</span></code> for this purpose.
For the Navier-Stokes equations, it is important to consider the
term <span class="math">\(u \cdot \nabla u\)</span> which should be interpreted as the vector
<span class="math">\(w\)</span> with elements</p>
<div class="math">
\[w_i = \sum_j \left(u_j \frac{\partial}{\partial x_j}\right) u_i
= \sum_j u_j \frac{\partial u_i}{\partial x_j}{\thinspace .}\]</div>
<p>This term can be implemented in FEniCS either as
<code class="docutils literal"><span class="pre">grad(u)*u</span></code>, since this is expression becomes
<span class="math">\(\sum_j \partial u_i/\partial x_j u_j\)</span>, or as
<code class="docutils literal"><span class="pre">dot(u,</span> <span class="pre">nabla_grad(u))</span></code> since this expression becomes
<span class="math">\(\sum_i u_i \partial u_j/\partial x_i\)</span>. We will use the notation
<code class="docutils literal"><span class="pre">dot(u,</span> <span class="pre">nabla_grad(u))</span></code> below since it corresponds more closely
to the standard notation <span class="math">\(u \cdot \nabla u\)</span>.</p>
<p>[<strong>hpl 20</strong>: I like the straightforward formulation above, but it should be complemented by the arguments below since it is not a matter of taste in the end, but dictated by derivation of the PDE and what <span class="math">\(\nabla\)</span> was meant to be there.]</p>
<p class="last">To be more precise, there are three different notations used for PDEs
involving gradient, divergence, and curl operators.
One employs <span class="math">\(\mathrm{grad}\, u\)</span>, <span class="math">\(\mathrm{div}\, u\)</span>, and
<span class="math">\(\mathrm{curl}\, u\)</span> operators. Another employs <span class="math">\(\nabla u\)</span>
as a synonym for <span class="math">\(\mathrm{grad}\, u\)</span>, <span class="math">\(\nabla\cdot u\)</span> means <span class="math">\(\mathrm{div}\, u\)</span>,
and <span class="math">\(\nabla\times u\)</span> is the name for <span class="math">\(\mathrm{curl}\, u\)</span>. The
third operates with <span class="math">\(\nabla u\)</span>, <span class="math">\(\nabla\cdot u\)</span>, and <span class="math">\(\nabla\times u\)</span>
in which <span class="math">\(\nabla\)</span> is a <em>vector</em> and, e.g., <span class="math">\(\nabla u\)</span> is a dyadic
expression (<span class="math">\((\nabla u)_{i,j} = \partial u_j/\partial x_i =
(\mathrm{grad} u)^T\)</span>).
The latter notation, with <span class="math">\(\nabla\)</span> as a vector operator,
is often handy when deriving equations in continuum mechanics, and if
this interpretation of <span class="math">\(\nabla\)</span> is the foundation of your PDE, you must
use <code class="docutils literal"><span class="pre">nabla_grad</span></code>, <code class="docutils literal"><span class="pre">nabla_div</span></code>, and <code class="docutils literal"><span class="pre">nabla_curl</span></code> in FEniCS code as
these operators are compatible with dyadic computations.
From the Navier-Stokes equations we can easily see what <span class="math">\(\nabla\)</span> means:
if the convective term has the form <span class="math">\(u\cdot \nabla u\)</span> (actually meaning
<span class="math">\((u\cdot\nabla) u\)</span>), <span class="math">\(\nabla\)</span> is a vector operator, reading
<code class="docutils literal"><span class="pre">dot(u,</span> <span class="pre">nabla_grad(u))</span></code> in FEniCS, but if we see
<span class="math">\(\nabla u\cdot u\)</span> or <span class="math">\((\mathrm{grad} u)\cdot u\)</span>, the
corresponding FEniCS
expression is <code class="docutils literal"><span class="pre">dot(grad(u),</span> <span class="pre">u)</span></code>.</p>
</div>
<p>We now move on to the second step in our splitting scheme for the
incompressible Navier-Stokes equations. In the first step, we computed
the tentative velocity <span class="math">\(u^{\star}\)</span> based on the pressure from the
previous time step. We may now use the computed tentative velocity to
compute the new pressure <span class="math">\(p^n\)</span>:</p>
<div class="math" id="eq-ftut1-ipcs2">
\[\tag{49}
{\langle \nabla p^n, \nabla q \rangle}
      = {\langle \nabla p^{n-1, \nabla q \rangle}} - {\Delta t}^{-1}{\langle \nabla \cdot u^{\bigstar, q \rangle}}.\]</div>
<p>Note here that <span class="math">\(q\)</span> is a scalar-valued test function from the pressure
space, whereas the test function <span class="math">\(v\)</span> in <a class="reference internal" href="#eq-ftut1-ipcs1"><span class="std std-ref">(48)</span></a> is a
vector-valued test function from the velocity space.</p>
<p>One way to think about this step is to subtract the Navier-Stokes
momentum equation <a class="reference internal" href="#eq-ftut1-ns-momentum"><span class="std std-ref">(45)</span></a> expressed in terms of the
tentative velocity <span class="math">\(u^{\star}\)</span> and the pressure <span class="math">\(p^{n-1}\)</span> from the
momentum equation expressed in terms of the velocity <span class="math">\(u^n\)</span> and
pressure <span class="math">\(p^n\)</span>. This results in the equation</p>
<div class="math" id="eq-ftut1-ipcs-step">
\[\tag{50}
\
      (u^n - u^{\star}) / {\Delta t} + \nabla p^n - \nabla p^{n-1} = 0.\]</div>
<p>Taking the divergence and requiring that <span class="math">\(\nabla \cdot u^n = 0\)</span> by the
Navier-Stokes continuity equation <a class="reference internal" href="#eq-ftut1-ns-continuity"><span class="std std-ref">(46)</span></a>, we
obtain the equation <span class="math">\(-\nabla\cdot u^{\star} / {\Delta t} + \nabla^2 p^n -
\nabla p^{n-1}\)</span>, which is a Poisson problem for the pressure <span class="math">\(p^n\)</span>
resulting in the variational problem <a class="reference internal" href="#eq-ftut1-ipcs2"><span class="std std-ref">(49)</span></a>.</p>
<p>Finally, we compute the corrected velocity <span class="math">\(u^n\)</span> from the equation
<a class="reference internal" href="#eq-ftut1-ipcs-step"><span class="std std-ref">(50)</span></a>. Multiplying this equation by a test function
<span class="math">\(v\)</span>, we obtain</p>
<div class="math" id="eq-ftut1-ipcs3">
\[\tag{51}
{\langle u^n, v \rangle} =
      {\langle u^{\bigstar, v \rangle}} - {\Delta t}{\langle \nabla(p^n-p^{n-1, v \rangle})}.\]</div>
<p>[<strong>hpl 21</strong>: Check that <span class="math">\(\rho\)</span> is correctly handled in the three steps.]</p>
<p>In summary, we may thus solve the incompressible Navier-Stokes
equations efficiently by solving a sequence of three linear variational
problems (steps 1, 2, 3) in each time step.</p>
</div>
<div class="section" id="a-simple-fenics-implementation-4">
<h3>A simple FEniCS implementation<a class="headerlink" href="#a-simple-fenics-implementation-4" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id5">
<h4>Test problem 1<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>As a first test problem, we compute the flow between two infinite plates,
so-called channel or Poiseuille flow, since this problem has a known
analytical solution. Let <span class="math">\(H\)</span> be the distance between the plates and <span class="math">\(L\)</span>
the length of the channel. There are no body forces.</p>
<p>We may scale the problem first to get rid of seemingly independent
physical parameters. The physics of this problem is governed by
viscous effects only, in the direction perpendicular to the flow, so a
time scale should be based in diffusion accross the channel: <span class="math">\(t_c =
H^2/\nu\)</span>. We let <span class="math">\(U\)</span>, some characteristic inflow, be the velocity
scale and <span class="math">\(H\)</span> the spatial scale. The pressure scale is taken as the
characteristic shear stress, <span class="math">\(\mu U/H\)</span>, since this is a primary
example of shear flow.  Inserting <span class="math">\(\bar x = x/H\)</span>, <span class="math">\(\bar y = y/H\)</span>,
<span class="math">\(\bar z = z/H\)</span>, <span class="math">\(\bar u =u/U\)</span>, <span class="math">\(\bar p = Hp/(\mu U)\)</span>, and <span class="math">\(\bar t =
H^2/\nu\)</span> in the equations results in the scaled Navier-Stokes equations
(dropping bars after the scaling):</p>
<div class="math">
\[\begin{split}\frac{\partial u}{\partial t} + \mathrm{Re}\, u\cdot\nabla u
&amp;= -\nabla p + \mu\nabla^2 u + \mu\nabla(\nabla\cdot u),\\
\nabla\cdot u &amp;= 0{\thinspace .}\end{split}\]</div>
<p>Here, Re is the Reynolds number <span class="math">\(\rho UH/\mu\)</span>. Because of the time and
pressure scale, which are different from convection-dominated fluid flow,
the Reynolds number is associated with the convective term and not the
viscosity term (as usual). Note that the last term in the first
equation is zero, but we included this term as it arises naturally
from the original <span class="math">\(\nabla\cdot\sigma\)</span> term.</p>
<p>The exact solution is derived by assuming <span class="math">\(u=(u_x(x,y,z),0,0)\)</span>, with
the <span class="math">\(x\)</span> axis pointing along the channel. Since <span class="math">\(\nabla\cdot u=0\)</span>, <span class="math">\(u\)</span>
cannot depend on <span class="math">\(x\)</span>. The physics of channel flow is also
two-dimensional so we can omit the <span class="math">\(z\)</span> coordinate (more precisely:
<span class="math">\(\partial/\partial z=0\)</span>). Inserting <span class="math">\(u=(u_x,0,0)\)</span> in the (scaled)
governing equations gives <span class="math">\(u_x''(y) = \partial p/\partial x\)</span>.
Differentiating this equation with respect to <span class="math">\(x\)</span> shows that <span class="math">\(\partial
p/\partial x\)</span> is a constant, here called <span class="math">\(-\beta\)</span>. This is the driving
force of the flow and specified as known in the problem.  Integrating
<span class="math">\(u_x''(y)=-\beta\)</span> over the width of the channel, <span class="math">\([0,1]\)</span>, and
requiring <span class="math">\(u=0\)</span> at the channel walls, results in <span class="math">\(u_x=\frac{1}{2}\beta
y(1-y)\)</span>. The characteristic inlet flow in the channel, <span class="math">\(U\)</span>, can be
taken as the maximum inflow at <span class="math">\(x=1/2\)</span>, implying that <span class="math">\(\beta = 8\)</span>.
The length of the channel, <span class="math">\(L/H\)</span> in the scaled model, has no impact on
the result, so for simplicity we just compute on the unit square.  The
pressure can then be set to <span class="math">\(p=0\)</span> at the outlet <span class="math">\(x=1\)</span>, giving
<span class="math">\(p(x)=8(1-x)\)</span> and <span class="math">\(u_x=4y(1-y)\)</span>.</p>
<p>The boundary conditions can be set as <span class="math">\(p=1\)</span> on <span class="math">\(x=0\)</span>, <span class="math">\(p=0\)</span> on
<span class="math">\(x=1\)</span> and <span class="math">\(u=0\)</span> on the walls <span class="math">\(y=0,1\)</span>. This defines the pressure
drop and should result in unit maximum velocity at the inlet and outlet
and a parabolic velocity profile without further specifications.
Note that it is only meaningful to solve the Navier-Stokes equations in
2D or 3D geometries, although the underlying mathematical problem
collapses to two 1D problems, one for <span class="math">\(u_x\)</span> and one for <span class="math">\(p\)</span>.</p>
<p>The scaled model is not so easy to simulate using a standard Navier-Stokes
solver with dimensions. However, one can argue that the convection term
is zero, so the Re coefficient in front of this term in the scaled PDEs
is not important and can be set to unity. In that case, setting
<span class="math">\(\rho = \mu = 1\)</span>
in the original Navier-Stokes equations resembles the scaled model.</p>
</div>
<div class="section" id="fenics-implementation-5">
<h4>FEniCS implementation<a class="headerlink" href="#fenics-implementation-5" title="Permalink to this headline">¶</a></h4>
<p>Our previous examples have all started out with the creation of a
mesh and then the definition of a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> on the mesh. For the
splitting scheme we will use to solve the Navier-Stokes equations we
need to define two function spaces, one for the velocity and one for
the pressure:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The first space <code class="docutils literal"><span class="pre">V</span></code> is a vector-valued function space for the velocity
and the second space <code class="docutils literal"><span class="pre">P</span></code> is a scalar-valued function space for the
pressure. We use piecewise quadratic elements for the velocity and
piecewise linear elements for the pressure. When creating a
<code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> in FEniCS, the value-dimension (the length of
the vectors) will be set equal to the geometric dimension of the
finite element mesh. One can easily create vector-valued function
spaces with other dimensions in FEniCS by adding the keyword parameter
<code class="docutils literal"><span class="pre">dim</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-stable-finite-element-spaces-for-the-navier-stokes-equations admonition">
<p class="first admonition-title">Stable finite element spaces for the Navier-Stokes equations</p>
<p class="last">It is well-known that certain finite element spaces are not <em>stable</em>
for the Navier-Stokes equations, or even for the simpler Stokes
equations. The prime example of an unstable pair of finite element
spaces is to use continuous piecewise polynomials for both the
velocity and the pressure. Using an
unstable pair of spaces typically results in a solution with
<em>spurious</em> (unwanted, non-physical) oscillations in the pressure
solution. The simple remedy is to use piecewise continuous piecewise
quadratic elements for the velocity and continuous piecewise linear
elements for the pressure. Together, these elements form the so-called
<em>Taylor-Hood</em> element. Spurious oscillations may occur also for
splitting methods if an unstable element pair is used.</p>
</div>
<p>Since we have two different function spaces, we need to create two sets
of trial and test functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
</pre></div>
</div>
<p>As we have seen in previous examples, boundaries may be defined in
FEniCS by defining Python functions that return <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>
depending on whether a point should be considered part of the
boundary, for example</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This function defines the boundary to be all points with
<span class="math">\(x\)</span>-coordinate equal to (near) zero. Alternatively, we may give the boundary
definition as a string of C++ code, much like we have previously
defined expressions such as <code class="docutils literal"><span class="pre">u0</span> <span class="pre">=</span> <span class="pre">Expression('1</span> <span class="pre">+</span> <span class="pre">x[0]*x[0]</span> <span class="pre">+</span>
<span class="pre">2*x[1]*x[1]')</span></code>. The above definition of the boundary in terms of a
Python function may thus be replaced by a simple C++ string:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">boundary</span> <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
</pre></div>
</div>
<p>This has the advantage of moving the computation of which nodes
belong to boundary to C++ from Python, which improves the efficiency
of the program.
For the current example, we will set three different boundary
conditions. First, we will set <span class="math">\(u = 0\)</span> at the walls of the channel;
that is, at <span class="math">\(y = 0\)</span> and <span class="math">\(y = 1\)</span>. Second, we will set <span class="math">\(p = 1\)</span> at the
inflow (<span class="math">\(x = 0\)</span>) and, finally, <span class="math">\(p = 0\)</span> at the outflow (<span class="math">\(x = 1\)</span>). This
will result in a pressure gradient that will accelerate the flow from an
initial stationary state. These
boundary conditions may be defined as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define boundaries</span>
<span class="n">inflow</span>   <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
<span class="n">outflow</span>  <span class="o">=</span> <span class="s1">&#39;near(x[0], 1)&#39;</span>
<span class="n">walls</span>    <span class="o">=</span> <span class="s1">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">bcu_noslip</span>  <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">walls</span><span class="p">)</span>
<span class="n">bcp_inflow</span>  <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">inflow</span><span class="p">)</span>
<span class="n">bcp_outflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">outflow</span><span class="p">)</span>
<span class="n">bcu</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcu_noslip</span><span class="p">]</span>
<span class="n">bcp</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcp_inflow</span><span class="p">,</span> <span class="n">bcp_outflow</span><span class="p">]</span>
</pre></div>
</div>
<p>At the end, we collect the boundary conditions for the velocity and
pressure in Python lists so we can easily access them in the
following computation.</p>
<p>We now move on to the definition of the variational forms. There are
three variational problems to be defined, one for each step in the
IPCS scheme. Let&#8217;s look at the definition of the first variational
problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">U</span>   <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u0</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span>
<span class="n">n</span>   <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">k</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">mu</span>  <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="n">rho</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
</pre></div>
</div>
<p>This expression for <code class="docutils literal"><span class="pre">F1</span></code> is very similar to the mathematical definition
<a class="reference internal" href="#eq-ftut1-ipcs1"><span class="std std-ref">(48)</span></a>. Since the variational problem contains a mix of
known and unknown quantities - the unknown <span class="math">\(u^n\)</span> (which we name <code class="docutils literal"><span class="pre">u</span></code>
in the variational problem) and the known value <span class="math">\(u^{n-1}\)</span> (which we
name <code class="docutils literal"><span class="pre">u0</span></code>) - it is convenient to use the FEniCS functions <code class="docutils literal"><span class="pre">lhs</span></code> and
<code class="docutils literal"><span class="pre">rhs</span></code> to extract the left- and right-hand sides of the variational
problem.</p>
<p>In the definition of the variational problem, we take advantage of the
Python programming language to define our own operators <code class="docutils literal"><span class="pre">sigma</span></code> and
<code class="docutils literal"><span class="pre">epsilon</span></code>. Using Python this way makes it easy to extend the
mathematical language of FEniCS with special operators and
constitutive laws:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
</pre></div>
</div>
<p>The splitting scheme requires the solution of a sequence of three
variational problems in each time step. We have previously used the
built-in FEniCS function <code class="docutils literal"><span class="pre">solve</span></code> to solve variational problems. Under
the hood, when a user calls <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code>, FEniCS will
perform the following steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>In the last step, FEniCS uses the overloaded <code class="docutils literal"><span class="pre">solve</span></code> function to solve
the linear system <code class="docutils literal"><span class="pre">AU</span> <span class="pre">=</span> <span class="pre">b</span></code> where <code class="docutils literal"><span class="pre">U</span></code> is the vector of degrees of
freedom for the function <span class="math">\(u(x) = \sum_{j=1} U_j \phi_j(x)\)</span>.</p>
<p>In our implementation of the splitting scheme, we will make use of
these low-level commands to first assemble and then call solve. This
has the advantage that we may control when we assemble and when we
solve the linear system. In particular, since the matrices for the
three variational problems are all time-independent, it makes sense to
assemble them once and for all outside of the time-stepping loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
</pre></div>
</div>
<p>Within the time-stepping loop, we may then assemble only the
right-hand side vectors, apply boundary conditions, and call the solve
function as here for the first of the three steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">b1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L1</span><span class="p">)</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b1</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice the Python <em>list comprehension</em> <code class="docutils literal"><span class="pre">[bc.apply(b1)</span> <span class="pre">for</span> <span class="pre">bc</span> <span class="pre">in</span> <span class="pre">bcu]</span></code>
which iterates over all <code class="docutils literal"><span class="pre">bc</span></code> in the list <code class="docutils literal"><span class="pre">bcu</span></code>. This is a convenient
and compact way to construct a loop that applies
all boundary conditions in a single line. Also, the code works if
we add more Dirichlet boundary conditions in the future.</p>
<p>Finally, let&#8217;s look at an important detail in how we use parameters
such as the time step <code class="docutils literal"><span class="pre">dt</span></code> and viscosity <code class="docutils literal"><span class="pre">mu</span></code> in the
definition of our variational problems. Since we might want to change
these later, for example if we want to experiment with smaller or
larger time steps, we wrap these using a FEniCS <code class="docutils literal"><span class="pre">Constant</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
</pre></div>
</div>
<p>The assembly of matrices and vectors in FEniCS is based on code
generation. This means that whenever we change a variational problem,
FEniCS will have to generate new code, which may take a little
time. New code will also be generated when a float value for the time
step or viscosity is changed. By wrapping these parameters using
<code class="docutils literal"><span class="pre">Constant</span></code>, FEniCS will treat these parameters as generic constants and
not specific numerical values, which prevents repeated code
generation. In the case of the time step, we choose a new name <code class="docutils literal"><span class="pre">k</span></code>
instead of <code class="docutils literal"><span class="pre">dt</span></code> for the <code class="docutils literal"><span class="pre">Constant</span></code> since we also want to use the
variable <code class="docutils literal"><span class="pre">dt</span></code> as a Python float as part of the time-stepping.</p>
<p>[<strong>hpl 22</strong>: Some pure fluid mechanics guys will think of Poiseulle as 1D, so they get confused why you need to launch 2D/3D code when it&#8217;s about <span class="math">\(u''=4\)</span> and can be done in Matlab... Renamed file to <code class="docutils literal"><span class="pre">navier_stokes_channel.py</span></code>.]</p>
<p>The complete code for simulating 2D channel flow with FEniCS looks as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>           <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">500</span>    <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span>             <span class="c1"># kinematic viscosity</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>            <span class="c1"># density</span>

<span class="c1"># Create mesh and define function spaces</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundaries</span>
<span class="n">inflow</span>  <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
<span class="n">outflow</span> <span class="o">=</span> <span class="s1">&#39;near(x[0], 1)&#39;</span>
<span class="n">walls</span>   <span class="o">=</span> <span class="s1">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">bcu_noslip</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">walls</span><span class="p">)</span>
<span class="n">bcp_inflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">inflow</span><span class="p">)</span>
<span class="n">bcp_outflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">outflow</span><span class="p">)</span>
<span class="n">bcu</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcu_noslip</span><span class="p">]</span>
<span class="n">bcp</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcp_inflow</span><span class="p">,</span> <span class="n">bcp_outflow</span><span class="p">]</span>

<span class="c1"># Define trial and test functions</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define functions for solutions at previous and current time steps</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define expressions used in variational forms</span>
<span class="n">U</span>   <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u0</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span>
<span class="n">n</span>   <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">k</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">mu</span>  <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="n">rho</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>

<span class="c1"># Define strain-rate tensor</span>
<span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define stress tensor</span>
<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define variational problem for step 1</span>
<span class="n">F1</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">((</span><span class="n">u</span> <span class="o">-</span> <span class="n">u0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
     <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u0</span><span class="p">)),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">p0</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">p0</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> \
   <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
<span class="n">L1</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>

<span class="c1"># Define variational problem for step 2</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">div</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Define variational problem for step 3</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Assemble matrices</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>

<span class="c1"># Apply boundary conditions to matrices</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>

<span class="c1"># Time-stepping</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Step 1: Tentative velocity step</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L1</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b1</span><span class="p">)</span>

    <span class="c1"># Step 2: Pressure correction step</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b2</span><span class="p">)</span>

    <span class="c1"># Step 3: Velocity correction step</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L3</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b3</span><span class="p">)</span>

    <span class="c1"># Plot solution</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

    <span class="c1"># Compute error</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">((</span><span class="s1">&#39;4*x[1]*(1.0 - x[1])&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;t = </span><span class="si">%.2f</span><span class="s1">: error = </span><span class="si">%.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;max u:&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
    <span class="n">p0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>We compute the error at the nodes as we have done before to verify
that our implementation is correct. Our Navier-Stokes solver computes
the solution to the time-dependent incompressible Navier-Stokes
equations, starting from the initial condition <span class="math">\(u = (0, 0)\)</span>. We have
not specified the initial condition explicitly in our solver which
means that FEniCS will initialize all variables, in particular the
previous and current velocities <code class="docutils literal"><span class="pre">u0</span></code> and <code class="docutils literal"><span class="pre">u1</span></code>, to zero. Since the
exact solution is quadratic, we expect the solution to be exact to
within machine precision at the nodes at the final time. For our
implementation, the error quickly approaches zero and is approximately
<span class="math">\(10^{-9}\)</span> at final time <span class="math">\(T = 10\)</span>.</p>
<div class="figure" id="id7">
<span id="ftut1-fig-navier-stokes-poisseuille"></span><a class="reference internal image-reference" href="_images/navier_stokes_poiseuille.png"><img alt="_images/navier_stokes_poiseuille.png" src="_images/navier_stokes_poiseuille.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the velocity profile at the final time for the Navier-Stokes Poiseuille flow example</em></span></p>
</div>
</div>
</div>
<div class="section" id="exercise-2-simulate-channel-flow-in-a-3d-geometry">
<h3>Exercise 2: Simulate channel flow in a 3D geometry<a class="headerlink" href="#exercise-2-simulate-channel-flow-in-a-3d-geometry" title="Permalink to this headline">¶</a></h3>
<p>FEniCS solvers typically have the number of space dimensions
parameterized, so a 1D, 2D, and 3D code all look the same.
We shall demonstrate what this means by extending the 2D solver
<code class="docutils literal"><span class="pre">navier_stokes_channel.py</span></code> to a simulator where the domain is a box
(the unit cube in the scaled model).</p>
<p><strong>a)</strong>
Set up boundary conditions for <span class="math">\(\boldsymbol{u}\)</span> at all points on the boundary.
Set up boundary conditions for <span class="math">\(p\)</span> at all points on the boundary as
this is required by our Poisson equation for <span class="math">\(p\)</span> (but not in the
original mathematical model - there, knowing <span class="math">\(p\)</span> at one point throughout
time is sufficient).</p>
<p><strong>Solution.</strong>
At the inlet <span class="math">\(x=0\)</span> we have the velocity completely described: <span class="math">\((u_x,0,0)\)</span>.
At the channel walls, <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>, we also have the velocity
completely described: <span class="math">\(u=(0,0,0)\)</span> because of no-slip.
At the outlet x=1 we do not specify anything. This means that the
boundary integrals in Step 1 vanish and that <span class="math">\(p=0\)</span> and
<span class="math">\(\partial\boldsymbol{u}/\partial n = 0\)</span>, with <span class="math">\(n\)</span> as the <span class="math">\(x\)</span> direction,
implying &#8220;no change&#8221; with <span class="math">\(x\)</span>, which is reasonable (since we know
that <span class="math">\(\partial/\partial x=0\)</span> because of incompressibility).
For the pressure we set <span class="math">\(p=8\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(p=0\)</span> at <span class="math">\(x=1\)</span> to
represent a scaled pressure gradient equal to 8 (which leads to
a unit maximum velocity). At <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span> we do not specify anything,
which implies <span class="math">\(\partial p/\partial y=0\)</span>. This is a condition much
discussed in the literature, but it works perfectly in channel flow
with straight walls.</p>
<p>The two remaining boundaries, <span class="math">\(z=0\)</span> and <span class="math">\(z=1\)</span>, requires attention.
For the pressure, &#8220;nothing happens&#8221; in the <span class="math">\(z\)</span> direction so
<span class="math">\(\partial p/\partial z=\partial p/\partial n=0\)</span> is the condition.
This is automatically implemented by the finite element method.
For the velocity we also have a &#8220;nothing happens&#8221; criterion in the
3rd direction, and we can in addition use the assumption of <span class="math">\(u_z=0\)</span>,
if needed.
The derivative criterion means <span class="math">\(\partial\boldsymbol{u}/\partial z=\partial\boldsymbol{u}/\partial n=0\)</span>
in the boundary integrals. There is also an integral involving <span class="math">\(pn_z\)</span>
in a component PDE with <span class="math">\(u_z\)</span> in all terms.</p>
<p><strong>b)</strong>
Modify the <code class="docutils literal"><span class="pre">navier_stokes_channel.py</span></code> file so it computes 3D channel flow.</p>
<p><strong>Solution.</strong>
We must switch the domain from <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code> to <code class="docutils literal"><span class="pre">UnitCubeMesh</span></code>.
We must also switch all 3-vectors to 2-vectors, such as
replacing going from <code class="docutils literal"><span class="pre">(0,0)</span></code> to <code class="docutils literal"><span class="pre">(0,0,0)</span></code> in <code class="docutils literal"><span class="pre">bcu_noslip</span></code>. Similarly,
<code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">u_e</span></code> must extend their 2-vectors to 3-vectors.</p>
<div class="toggle container">
<div class="header container">
<strong>Show/Hide Code</strong></div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">FEniCS tutorial demo program: Incompressible Navier-Stokes equations</span>
<span class="sd">for Poisseuille flow in the unit square using the Incremental Pressure</span>
<span class="sd">Correction Scheme (IPCS).</span>

<span class="sd">  u&#39; + u . nabla(u)) - div(sigma) = f</span>
<span class="sd">                           div(u) = 0</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>           <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">500</span>    <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span>             <span class="c1"># kinematic viscosity</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>            <span class="c1"># density</span>

<span class="c1"># Create mesh and define function spaces</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundaries</span>
<span class="n">inflow</span>  <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
<span class="n">outflow</span> <span class="o">=</span> <span class="s1">&#39;near(x[0], 1)&#39;</span>
<span class="n">walls</span>   <span class="o">=</span> <span class="s1">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">bcu_noslip</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">walls</span><span class="p">)</span>
<span class="n">bcp_inflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">inflow</span><span class="p">)</span>
<span class="n">bcp_outflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">outflow</span><span class="p">)</span>
<span class="n">bcu</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcu_noslip</span><span class="p">]</span>
<span class="n">bcp</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcp_inflow</span><span class="p">,</span> <span class="n">bcp_outflow</span><span class="p">]</span>

<span class="c1"># Define trial and test functions</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define functions for solutions at previous and current time steps</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define expressions used in variational forms</span>
<span class="n">U</span>   <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u0</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span>
<span class="n">n</span>   <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">k</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">mu</span>  <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="n">rho</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>

<span class="c1"># Define strain-rate tensor</span>
<span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define stress tensor</span>
<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define variational problem for step 1</span>
<span class="n">F1</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">((</span><span class="n">u</span> <span class="o">-</span> <span class="n">u0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
     <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u0</span><span class="p">)),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">p0</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">p0</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> \
   <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
<span class="n">L1</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>

<span class="c1"># Define variational problem for step 2</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">div</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Define variational problem for step 3</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Assemble matrices</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>

<span class="c1"># Apply boundary conditions to matrices</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>

<span class="c1"># Time-stepping</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Step 1: Tentative velocity step</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L1</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b1</span><span class="p">)</span>

    <span class="c1"># Step 2: Pressure correction step</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b2</span><span class="p">)</span>

    <span class="c1"># Step 3: Velocity correction step</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L3</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b3</span><span class="p">)</span>

    <span class="c1"># Plot solution</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

    <span class="c1"># Compute error</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">((</span><span class="s1">&#39;4*x[1]*(1.0 - x[1])&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;t = </span><span class="si">%.2f</span><span class="s1">: error = </span><span class="si">%.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;max u:&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
    <span class="n">p0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="flow-past-a-cylinder">
<h3>Flow past a cylinder<a class="headerlink" href="#flow-past-a-cylinder" title="Permalink to this headline">¶</a></h3>
<p>We now turn our attention to a more challenging physical example: flow
past a circular cylinder. The geometry and parameters are taken from
problem DFG 2D-2 in the <a class="reference external" href="http://www.featflow.de/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark2_re100.html">FEATFLOW/1995-DFG benchmark suite</a>
and is illustrated in Figure
<a class="reference internal" href="#ftut1-navier-stokes-cylinder-geometry"><span class="std std-ref">Geometry for the flow past a cylinder test problem. Notice the slightly perturbed and unsymmetric geometry</span></a>. The kinematic viscosity is
given by <span class="math">\(\nu = 0.001 = \mu/\rho\)</span> and the inflow velocity profile is
specified as</p>
<div class="math">
\[u(x, y, t) = \left(1.5 \cdot \frac{4y(1-y)}{0.41^2}, 0\right),\]</div>
<p>which has a maximum magnitude of <span class="math">\(1.5\)</span> at <span class="math">\(y = 0.41/2\)</span>. We do not
scale anything in this benchmark.</p>
<div class="figure" id="id8">
<span id="ftut1-navier-stokes-cylinder-geometry"></span><a class="reference internal image-reference" href="_images/navier_stokes_cylinder_geometry.png"><img alt="_images/navier_stokes_cylinder_geometry.png" src="_images/navier_stokes_cylinder_geometry.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Geometry for the flow past a cylinder test problem. Notice the slightly perturbed and unsymmetric geometry</em></span></p>
</div>
<div class="section" id="fenics-implementation-6">
<h4>FEniCS implementation<a class="headerlink" href="#fenics-implementation-6" title="Permalink to this headline">¶</a></h4>
<p>So far all our domains have been simple shapes such as a unit square or
a rectangular box. A number of such simple meshes may be created in
FEniCS using the built-in meshes
<code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code> (1D),
<code class="docutils literal"><span class="pre">UnitSquareMesh</span></code> (2D),
<code class="docutils literal"><span class="pre">UnitCubeMesh</span></code> (3D),
<code class="docutils literal"><span class="pre">IntervalMesh</span></code> (1D),
<code class="docutils literal"><span class="pre">RectangleMesh</span></code> (2D),
<code class="docutils literal"><span class="pre">BoxMesh</span></code> (3D), and
<code class="docutils literal"><span class="pre">UnitDiscMesh</span></code> (2D).
FEniCS supports the creation of more complex meshes via a technique
called <em>constructive solid geometry</em> (CSG), which lets us define
geometries in terms of simple shapes (primitives) and set operations:
union, intersection, and set difference. The set operations are
encoded in FEniCS using the operators <code class="docutils literal"><span class="pre">+</span></code> (union), <code class="docutils literal"><span class="pre">*</span></code> (intersection),
and <code class="docutils literal"><span class="pre">-</span></code> (set difference). To access the CSG functionality in FEniCS,
one must import the FEniCS module <code class="docutils literal"><span class="pre">mshr</span></code> which provides the
extended meshing functionality of FEniCS.</p>
<p>[<strong>AL 23</strong>: Need to cite mshr.]</p>
<p>The geometry for the cylinder flow test problem can be defined easily
by first defining the rectangular channel and then subtracting the
circle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">channel</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mf">2.2</span><span class="p">,</span> <span class="mf">0.41</span><span class="p">))</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">-</span> <span class="n">cylinder</span>
</pre></div>
</div>
<p>We may then create the mesh by calling the function <code class="docutils literal"><span class="pre">generate_mesh</span></code>:</p>
<p>[<strong>hpl 24</strong>: Should do some refinement of the boundary layer? Can we mark elements in a distance from the cylinder and ask these elements to be refine a given number of times?]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>To solve the cylinder test problem, we only need to make a few minor
changes to the code we wrote for the Poiseuille flow test
case. Besides defining the new mesh, the only change we need to make
is to modify the boundary conditions and the time step size. The
boundaries are specified as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">inflow</span>   <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
<span class="n">outflow</span>  <span class="o">=</span> <span class="s1">&#39;near(x[0], 2.2)&#39;</span>
<span class="n">walls</span>    <span class="o">=</span> <span class="s1">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="s1">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>
</pre></div>
</div>
<p>[<strong>hpl 25</strong>: I did not understand the <code class="docutils literal"><span class="pre">cylinder</span></code> line. Seems to be all points in a square that also lie on the boundary? Are there any?]</p>
<p>[<strong>AL 26</strong>: We set <span class="math">\(p = 0\)</span> at the outflow. This seems to be necessary, but we should really not need to specify the pressure at all.]
[<strong>hpl 27</strong>: Need to specify the pressure at one point, mathematically.]</p>
<span class="target" id="index-4"></span><span class="target" id="index-5"></span><p id="index-6">In addition to these essential changes, we will make a number of small
changes to improve our solver. First, since we need to choose a
relatively small time step to compute the solution (a time step that
is too large will make the solution blow up) we add a progress bar so
that we can follow the progress of our computation. This can be done
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">progress</span> <span class="o">=</span> <span class="n">Progress</span><span class="p">(</span><span class="s1">&#39;Time-stepping&#39;</span><span class="p">)</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Place computation here</span>

    <span class="c1"># Update progress bar</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-log-levels-and-printing-in-fenics admonition">
<p class="first admonition-title">Log levels and printing in FEniCS</p>
<p class="last">Notice the call to <code class="docutils literal"><span class="pre">set_log_level(PROGRESS)</span></code> which is essential to
make FEniCS actually display the progress bar. FEniCS is actually
quite informative about what is going on during a computation but the
amount of information printed to screen depends on the current log
level. Only messages with a priority higher than or equal to the
current log level will be displayed. The predefined log levels in
FEniCS are
<code class="docutils literal"><span class="pre">DBG</span></code>,
<code class="docutils literal"><span class="pre">TRACE</span></code>,
<code class="docutils literal"><span class="pre">PROGRESS</span></code>,
<code class="docutils literal"><span class="pre">INFO</span></code>,
<code class="docutils literal"><span class="pre">WARNING</span></code>,
<code class="docutils literal"><span class="pre">ERROR</span></code>, and
<code class="docutils literal"><span class="pre">CRITICAL</span></code>. By default, the log level is set to <code class="docutils literal"><span class="pre">INFO</span></code> which means
that messages at level <code class="docutils literal"><span class="pre">DBG</span></code>, <code class="docutils literal"><span class="pre">TRACE</span></code>, and <code class="docutils literal"><span class="pre">PROGRESS</span></code> will not be
printed. Users may print messages using the FEniCS functions <code class="docutils literal"><span class="pre">info</span></code>,
<code class="docutils literal"><span class="pre">warning</span></code>, and <code class="docutils literal"><span class="pre">error</span></code> which will print messages at the obvious log
level (and in the case of <code class="docutils literal"><span class="pre">error</span></code> also throw an exception and
exit). One may also use the call <code class="docutils literal"><span class="pre">log(level,</span> <span class="pre">message)</span></code> to print a
message at a specific log level.</p>
</div>
<p>Since the system(s) of linear equations are significantly larger than
for the simple Poiseuille flow test problem, we choose to use an
iterative method instead of the default direct (sparse) solver used by
FEniCS when calling <code class="docutils literal"><span class="pre">solve</span></code>. Efficient solution of linear systems
arising from the discretization of PDEs requires the choice of both a
good iterative (Krylov subspace) method and a good
preconditioner. For this problem, we will simply use the biconjugate
gradient stabilized method (BiCGSTAB). This can be done by adding the
keyword <code class="docutils literal"><span class="pre">bicgstab</span></code> in the call to <code class="docutils literal"><span class="pre">solve</span></code>. We also add a preconditioner,
<code class="docutils literal"><span class="pre">ilu</span></code> to further speed up the computations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b1</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b2</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b3</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, to be able to postprocess the computed solution in Paraview,
we store the solution to file in each time step. To avoid cluttering
our working directory with a large number of solution
files, we make sure to store the solution in a subdirectory:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vtkfile_u</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;solutions/velocity.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_p</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;solutions/pressure.pvd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that one does not need to create the directory before running the
program. It will be created automatically by FEniCS.</p>
<p>We also store the solution using a FEniCS <code class="docutils literal"><span class="pre">TimeSeries</span></code>. This allows us
to store the solution not for visualization (as when using VTK
files), but for later reuse in a computation as we will see in the
next section. Using a <code class="docutils literal"><span class="pre">TimeSeries</span></code> it is easy and efficient to read in
solutions from certain points in time during a simulation. The
<code class="docutils literal"><span class="pre">TimeSeries</span></code> class uses a binary HDF5 file for efficient storage and
access to data.</p>
<p>Figures <a class="reference internal" href="#ftut1-fig-navier-stokes-cylinder-velocity"><span class="std std-ref">Plot of the velocity for the cylinder test problem at final time</span></a> and
<a class="reference internal" href="#ftut1-fig-navier-stokes-cylinder-pressure"><span class="std std-ref">Plot of the pressure for the cylinder test problem at final time</span></a> show the velocity and
pressure at final time visualized in Paraview. For the visualization
of the velocity, we have used the <strong>Glyph</strong> filter to visualize the
vector velocity field. For the visualization of the pressure, we have
used the <strong>Warp By Scalar</strong> filter.</p>
<div class="figure" id="id9">
<span id="ftut1-fig-navier-stokes-cylinder-velocity"></span><a class="reference internal image-reference" href="_images/navier_stokes_cylinder_velocity.png"><img alt="_images/navier_stokes_cylinder_velocity.png" src="_images/navier_stokes_cylinder_velocity.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the velocity for the cylinder test problem at final time</em></span></p>
</div>
<div class="figure" id="id10">
<span id="ftut1-fig-navier-stokes-cylinder-pressure"></span><a class="reference internal image-reference" href="_images/navier_stokes_cylinder_pressure.png"><img alt="_images/navier_stokes_cylinder_pressure.png" src="_images/navier_stokes_cylinder_pressure.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the pressure for the cylinder test problem at final time</em></span></p>
</div>
<p>The complete code for the cylinder test problem looks as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">5.0</span>            <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">5000</span>   <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.001</span>         <span class="c1"># dynamic viscosity</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>            <span class="c1"># density</span>

<span class="c1"># Create mesh</span>
<span class="n">channel</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mf">2.2</span><span class="p">,</span> <span class="mf">0.41</span><span class="p">))</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">-</span> <span class="n">cylinder</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Define function spaces</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundaries</span>
<span class="n">inflow</span>   <span class="o">=</span> <span class="s1">&#39;near(x[0], 0)&#39;</span>
<span class="n">outflow</span>  <span class="o">=</span> <span class="s1">&#39;near(x[0], 2.2)&#39;</span>
<span class="n">walls</span>    <span class="o">=</span> <span class="s1">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="s1">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>

<span class="c1"># Define inflow profile</span>
<span class="n">inflow_profile</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;4.0*1.5*x[1]*(0.41 - x[1]) / pow(0.41, 2)&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">bcu_inflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Expression</span><span class="p">(</span><span class="n">inflow_profile</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">inflow</span><span class="p">)</span>
<span class="n">bcu_walls</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">walls</span><span class="p">)</span>
<span class="n">bcu_cylinder</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">cylinder</span><span class="p">)</span>
<span class="n">bcp_outflow</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">outflow</span><span class="p">)</span>
<span class="n">bcu</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcu_inflow</span><span class="p">,</span> <span class="n">bcu_walls</span><span class="p">,</span> <span class="n">bcu_cylinder</span><span class="p">]</span>
<span class="n">bcp</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcp_outflow</span><span class="p">]</span>

<span class="c1"># Define trial and test functions</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define functions for solutions at previous and current time steps</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Define expressions used in variational forms</span>
<span class="n">U</span>   <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u0</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span>
<span class="n">n</span>   <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">k</span>   <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">mu</span>  <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

<span class="c1"># Define symmetric gradient</span>
<span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define stress tensor</span>
<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

<span class="c1"># Define variational problem for step 1</span>
<span class="n">F1</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">((</span><span class="n">u</span> <span class="o">-</span> <span class="n">u0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u0</span><span class="p">)),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">p0</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> \
   <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">p0</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span> \
   <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
<span class="n">L1</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>

<span class="c1"># Define variational problem for step 2</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">div</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Define variational problem for step 3</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L3</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Assemble matrices</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>

<span class="c1"># Apply boundary conditions to matrices</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
<span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>

<span class="c1"># Save mesh to file for later</span>
<span class="n">File</span><span class="p">(</span><span class="s1">&#39;channel.xml.gz&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Create VTK files for visualization output</span>
<span class="n">vtkfile_u</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;ns/velocity.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_p</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;ns/pressure.pvd&#39;</span><span class="p">)</span>

<span class="c1"># FIXME: mpi_comm_world should not be needed here, fix in FEniCS!</span>

<span class="c1"># Create time series for saving solution for later</span>
<span class="n">timeseries_u</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="s1">&#39;ns/velocity&#39;</span><span class="p">)</span>
<span class="n">timeseries_p</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="s1">&#39;ns/pressure&#39;</span><span class="p">)</span>

<span class="c1"># Save mesh to file for later</span>
<span class="n">File</span><span class="p">(</span><span class="s1">&#39;cylinder.xml.gz&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>

<span class="c1"># Create progress bar</span>
<span class="n">progress</span> <span class="o">=</span> <span class="n">Progress</span><span class="p">(</span><span class="s1">&#39;Time-stepping&#39;</span><span class="p">)</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="c1"># Time-stepping</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Step 1: Tentative velocity step</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L1</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcu</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b1</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>

    <span class="c1"># Step 2: Pressure correction step</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcp</span><span class="p">]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b2</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>

    <span class="c1"># Step 3: Velocity correction step</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L3</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b3</span><span class="p">,</span> <span class="s1">&#39;bicgstab&#39;</span><span class="p">)</span>

    <span class="c1"># Plot solution</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Velocity&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Pressure&#39;</span><span class="p">)</span>

    <span class="c1"># Save solution to file</span>
    <span class="n">vtkfile_u</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">vtkfile_p</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="c1"># Save solution to file (HDF5)</span>
    <span class="n">timeseries_u</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">timeseries_p</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">t</span><span class="p">)</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
    <span class="n">p0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

    <span class="c1"># Update progress bar</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;u max:&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="a-system-of-advection-diffusion-reaction-equations">
<span id="ftut1-reactionsystem"></span><h2>A system of advection - diffusion - reaction equations<a class="headerlink" href="#a-system-of-advection-diffusion-reaction-equations" title="Permalink to this headline">¶</a></h2>
<p>The problems we have encountered so far&#8212;with the notable exception
of the Navier - Stokes equations&#8212;all share a common feature, which is
that they all involve models expressed by a <em>single</em> PDE. In many
situations the model is instead expressed as a system of PDEs,
describing different quantities and possibly different physics. As we
saw for the Navier - Stokes equations, one way to solve a system of
PDEs in FEniCS is to use a splitting method where we solve one
equation at a time and feed the solution from one equation into the
next. However, one of the strengths with FEniCS is the ease by which
one can instead define variational problems that couple several PDEs
into one system. In this section, we will look at how to use FEniCS to
write solvers for such systems of coupled PDEs.</p>
<div class="section" id="pde-problem-5">
<h3>PDE problem<a class="headerlink" href="#pde-problem-5" title="Permalink to this headline">¶</a></h3>
<p>Our model problem is the following system of
advection - diffusion - reaction equations:</p>
<div class="math" id="eq-ftut1-reactionsystem-system-1">
\[\tag{52}
\dot{u}_1 + \beta \cdot \nabla u_1 - \nabla\cdot(\epsilon\nabla u_1)
        = f_1 -K u_1 u_2,\]</div>
<div class="math" id="eq-ftut1-reactionsystem-system-2">
\[\tag{53}
\dot{u}_2 + \beta \cdot \nabla u_2 - \nabla\cdot(\epsilon\nabla u_2)
        = f_2 -K u_1 u_2,\]</div>
<div class="math" id="eq-ftut1-reactionsystem-system-3">
\[\tag{54}
\dot{u}_1 + \beta \cdot \nabla u_3 - \nabla\cdot(\epsilon\nabla u_3)
        = f_3 + K u_1 u_2 - K u_3.\]</div>
<p>This system models the chemical reaction between two species <span class="math">\(A\)</span> and
<span class="math">\(B\)</span> in some domain <span class="math">\(\Omega\)</span>:</p>
<div class="math">
\[A + B \rightarrow C.\]</div>
<p>We assume that the equation is <em>first-order</em>, meaning that the
reaction rate is proportional to the concentrations <span class="math">\([A]\)</span> and <span class="math">\([B]\)</span> of
the two species <span class="math">\(A\)</span> and <span class="math">\(B\)</span>:</p>
<div class="math">
\[\frac{\mathrm{d}}{\mathrm{d}t} [C] = K [A] [B].\]</div>
<p>We also assume that the formed species <span class="math">\(C\)</span> spontaneously decays with a
rate proportional to the concentration <span class="math">\([C]\)</span>. In the PDE system
<a class="reference internal" href="#eq-ftut1-reactionsystem-system-1"><span class="std std-ref">(52)</span></a>&#8211;<a class="reference internal" href="#eq-ftut1-reactionsystem-system-3"><span class="std std-ref">(54)</span></a>,
we use the variables <span class="math">\(u_1\)</span>, <span class="math">\(u_2\)</span>, and <span class="math">\(u_3\)</span> to denote the
concentrations of the three species:</p>
<div class="math">
\[u_1 = [A], \quad u_2 = [B], \quad u_3 = [C].\]</div>
<p>We see that the chemical reactions are accounted for in the
right-hand sides of the PDE system <a class="reference internal" href="#eq-ftut1-reactionsystem-system-1"><span class="std std-ref">(52)</span></a>&#8211;<a class="reference internal" href="#eq-ftut1-reactionsystem-system-3"><span class="std std-ref">(54)</span></a>.</p>
<p>The chemical reactions take part at each point in the domain
<span class="math">\(\Omega\)</span>. In addition, we assume that the species <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, and <span class="math">\(C\)</span>
diffuse throughout the domain with diffusivity <span class="math">\(\epsilon\)</span> (the terms
<span class="math">\(-\nabla\cdot(\epsilon\nabla u_i)\)</span>) and are advected with velocity
<span class="math">\(\beta\)</span> (the terms <span class="math">\(\beta\cdot\nabla u_i\)</span>). The
advection - diffusion - reaction system
<a class="reference internal" href="#eq-ftut1-reactionsystem-system-1"><span class="std std-ref">(52)</span></a>&#8211;<a class="reference internal" href="#eq-ftut1-reactionsystem-system-3"><span class="std std-ref">(54)</span></a>
is expressed using mathematical dimensionless parameters <span class="math">\(\beta\)</span> and
<span class="math">\(\epsilon\)</span> and we will not worry about scaling for this particular
problem.</p>
<p>To make things interesting, we will use the velocity field
computed from the solution of the incompressible Navier - Stokes
equations from the previous section. In summary, we will thus be
solving the following coupled system of nonlinear PDEs:</p>
<div class="math" id="eq-ftut1-reactionsystem-full">
\[\tag{55}
\varrho(\dot{w} + w \cdot \nabla w) = \nabla\cdot\sigma(w, p) + f,\]</div>
<div class="math" id="eq-auto10">
\[\tag{56}
\nabla \cdot u = 0,\]</div>
<div class="math" id="eq-auto11">
\[\tag{57}
\dot{u}_1 + w \cdot \nabla u_1 - \nabla\cdot(\epsilon\nabla u_1)
        = f_1 - K u_1 u_2,\]</div>
<div class="math" id="eq-auto12">
\[\tag{58}
\dot{u}_2 + w \cdot \nabla u_2 - \nabla\cdot(\epsilon\nabla u_2)
        = f_2 - K u_1 u_2,\]</div>
<div class="math" id="eq-auto13">
\[\tag{59}
\dot{u}_1 + w \cdot \nabla u_3 - \nabla\cdot(\epsilon\nabla u_3)
        = f_3 + K u_1 u_2 - K u_3.\]</div>
<p>We assume that <span class="math">\(u_1 = u_2 = u_3 = 0\)</span> at <span class="math">\(t = 0\)</span> and inject the species
<span class="math">\(A\)</span> and <span class="math">\(B\)</span> into the system by specifying nonzero source terms <span class="math">\(f_1\)</span>
and <span class="math">\(f_2\)</span> close to the corners at the inflow, and take <span class="math">\(f_3 = 0\)</span>. The
result will be that <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are convected by advection and
diffusion throughout the channel, and when they mix the species <span class="math">\(C\)</span>
will be formed.</p>
<p>Since the system is one-way coupled from the Navier - Stokes subsystem
to the advection - diffusion - reaction subsystem, we don&#8217;t need to
recompute the solution to the Navier - Stokes equations, but can just
read back the previously computed velocity field <span class="math">\(w\)</span> and feed it into
our equations. But we <em>do</em> need to learn how to read and write
solutions from time-dependent PDE problems.</p>
</div>
<div class="section" id="variational-formulation-5">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-5" title="Permalink to this headline">¶</a></h3>
<p>We obtain the variational formulation of our system by multiplying
each equation by a test function, integrating the second-order terms
<span class="math">\(-\nabla\cdot(\epsilon\nabla u_i)\)</span> by parts, and summing up the
equations. We let <span class="math">\(v_1\)</span>, <span class="math">\(v_2\)</span>, and <span class="math">\(v_3\)</span> be the test functions and
obtain</p>
<div class="math" id="eq-ftu1-reactionsystem-varproblem">
\[\tag{60}
\int_{\Omega}
      {\Delta t}^{-1} (u_1^{n+1} - u_1^n) v_1 + w \cdot \nabla U_1 \, v_1
      + \epsilon \nabla U_1 \cdot \nabla v_1 {\, \mathrm{d}x}\]</div>
<div class="math" id="eq-auto14">
\[\tag{61}
+  \int_{\Omega} {\Delta t}^{-1} (u_2^{n+1} - u_2^n) v_2
      + w \cdot \nabla U_2 \, v_2
      + \epsilon \nabla U_2 \cdot \nabla v_2 {\, \mathrm{d}x}\]</div>
<div class="math" id="eq-auto15">
\[\tag{62}
+  \int_{\Omega} {\Delta t}^{-1} (u_3^{n+1} - u_3^n) v_3
      + w \cdot \nabla U_3 \, v_3
      + \epsilon \nabla U_3 \cdot \nabla v_3 {\, \mathrm{d}x}\]</div>
<div class="math" id="eq-auto16">
\[\tag{63}
\quad + \int_{\Omega} f_1 v_1 + f_2 v_2 + f_3 v_3 {\, \mathrm{d}x}\]</div>
<div class="math" id="eq-auto17">
\[\tag{64}
\quad + \int_{\Omega} K U_1 U_2 v_1 + K U_1 U_2 v_2
      - K U_1 U_2 v_3 + K U_3 v_3 {\, \mathrm{d}x} = 0.\]</div>
<p>For this problem it is natural to assume homogeneous Neumann boundary
conditions on the entire boundary for <span class="math">\(u_1\)</span>, <span class="math">\(u_2\)</span>, and <span class="math">\(u_3\)</span>; that
is, <span class="math">\(\partial u_i/\partial n = 0\)</span> for <span class="math">\(i = 1, 2, 3\)</span>. This means that
the boundary terms vanish when we integrate by parts.</p>
<p>We have replaced the time-derivatives <span class="math">\(\dot{u}_i\)</span> by the difference
quotients <span class="math">\({\Delta t}^{-1} (u_i^{n+1} - u_i^n)\)</span>. We also introduce the
shorthand notation</p>
<p>[<strong>hpl 28</strong>: If you use <span class="math">\(\theta=1\)</span> anyway, I would simplify already here. The problem is that you need to consistently evaluate the other terms (including the reaction and <span class="math">\(w\)</span> terms) also at the weighted time point <span class="math">\(\theta t_n + (1-\theta)t_{n+1}\)</span>, and besides giving very long formulas, this brings up some nontrivial FEniCS issues that I now deal with in detail in the time-dependent solver chapter in volume II - in a simpler context.  It is very easy to make mistakes here as the code works and converges, but Crank-Nicolson/midpoint method does not give increased convergence rate. This may be misleading for the students. It may work here as you have a stationary velocity field etc., but the <span class="math">\(\theta\)</span> rule is a tricky thing that when generalized from this example easily goes wrong, unless we really emphasize the <span class="math">\(\theta\)</span> weighting of all terms.]</p>
<div class="math">
\[U_i = (1 - \theta) u_i^n + \theta u_i^{n + 1},\]</div>
<p>for some parameter <span class="math">\(0 \leq \theta \leq 1\)</span>. The parameter <span class="math">\(\theta\)</span> lets
us easily adjust the level of implicitness of our time-stepping
method. For <span class="math">\(\theta = 0\)</span> we recover the explicit Euler method, for
<span class="math">\(\theta = 0.5\)</span> we recover the midpoint method, and for <span class="math">\(\theta = 1\)</span>,
we recover the implicit Euler method. We will use <span class="math">\(\theta = 1\)</span> in our
simulation below.</p>
</div>
<div class="section" id="a-simple-fenics-implementation-5">
<h3>A simple FEniCS implementation<a class="headerlink" href="#a-simple-fenics-implementation-5" title="Permalink to this headline">¶</a></h3>
<p>The first step is to read the mesh from file. Luckily, we made sure to
save the mesh to file in the Navier - Stokes example and can now easily
read it back from file:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s1">&#39;channel.xml.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The mesh is stored in the native FEniCS XML format (with additional
gzipping to decrease the file size).</p>
<p>Next, we need to define the finite element function space. For this
problem, we need to define several spaces. The first space we create
is the space for the velocity field <span class="math">\(w\)</span> from the Navier - Stokes
simulation. We call this space <span class="math">\(W\)</span> and define the space by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>It is important that this space is exactly the same as the space we
used for the velocity field in the Navier - Stokes solver. To read the
values for the velocity field, we use a <code class="docutils literal"><span class="pre">TimeSeries</span></code></p>
<p>[<strong>AL 29</strong>: Check if we can remove <cite>mpi_comm_world</cite>]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">timeseries_w</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="s1">&#39;navier_stokes/velocity&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will initialize the object <code class="docutils literal"><span class="pre">timeseries_w</span></code> which we will call
later in the time-stepping loop to retrieve values from the
file <code class="docutils literal"><span class="pre">velocity.h5</span></code> (in binary HDF5 format).</p>
<p>For the three concentrations <span class="math">\(u_1\)</span>, <span class="math">\(u_2\)</span>, and <span class="math">\(u_3\)</span>, we want to
create a <em>mixed space</em> with functions that represent the full system
<span class="math">\((u_1, u_2, u_3)\)</span> as a single entity. To do this, we need to define a
<code class="docutils literal"><span class="pre">MixedElement</span></code> as the product space of three simple finite elements
and then used the mixed element to define the function space:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">P1</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">MixedElement</span><span class="p">([</span><span class="n">P1</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P1</span><span class="p">])</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-mixed-elements-as-products-of-elements admonition">
<p class="first admonition-title">Mixed elements as products of elements</p>
<p>FEniCS also allows finite elements to be defined as products of simple
elements (or mixed elements). For example, the well-known Taylor - Hood
element may be defined as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">P2</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">P1</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">TH</span> <span class="o">=</span> <span class="n">P2</span> <span class="o">*</span> <span class="n">P1</span>
</pre></div>
</div>
<p>This syntax works great for two elements, but for three or more
elements we meet a subtle issue of how the Python interpreter handles
the <code class="docutils literal"><span class="pre">*</span></code> operator. For the reaction system, we create the mixed element
by <code class="docutils literal"><span class="pre">element</span> <span class="pre">=</span> <span class="pre">MixedElement([P1,</span> <span class="pre">P1,</span> <span class="pre">P1])</span></code> and one would be tempted to
write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">P1</span> <span class="o">*</span> <span class="n">P1</span> <span class="o">*</span> <span class="n">P1</span>
</pre></div>
</div>
<p>However, this is equivalent to writing <code class="docutils literal"><span class="pre">element</span> <span class="pre">=</span> <span class="pre">(P1</span> <span class="pre">*</span> <span class="pre">P1)</span> <span class="pre">*</span> <span class="pre">P1</span></code> so
the result will be a mixed element consisting of two subsystems, the
first of which in turn consists of two scalar subsystems.</p>
<p>Finally, we remark that for the simple case of a mixed system
consisting of three scalar elements as for the reaction system, the
definition is in fact equivalent to using a standard vector-valued
element:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<p>or we can even write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">if that is found simpler.</p>
</div>
<p>Once the space has been created, we need to define our test functions
and functions. Test functions for a mixed function space can be
created by replacing <code class="docutils literal"><span class="pre">TestFunction</span></code> by <code class="docutils literal"><span class="pre">TestFunctions</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">,</span> <span class="n">v_3</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the problem is nonlinear, we need to work with functions rather
than trial functions for the unknowns. This can be done by using the
corresponding <code class="docutils literal"><span class="pre">Functions</span></code> construction in FEniCS. However, as we will
need to access the <code class="docutils literal"><span class="pre">Function</span></code> for the entire system itself, we first
need to create that function and then access its components:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">u_3</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>These functions will be used to represent the unknown values at the
right end-point of each time interval. The corresponding values at the
left end-points will be denoted by <code class="docutils literal"><span class="pre">u_p1</span></code>, <code class="docutils literal"><span class="pre">u_p2</span></code>, and <code class="docutils literal"><span class="pre">u_p3</span></code>. Our
<span class="math">\(\theta\)</span>-method is implemented by defining</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">U_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p1</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
<span class="n">U_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p2</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_2</span>
<span class="n">U_3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p3</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_3</span>
</pre></div>
</div>
<p>When now all functions and test functions have been defined, we can
express the nonlinear variational problem
<a class="reference internal" href="#eq-ftu1-reactionsystem-varproblem"><span class="std std-ref">(60)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="p">((</span><span class="n">u_1</span> <span class="o">-</span> <span class="n">u_p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_1</span><span class="p">))</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_1</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_1</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span>  \
  <span class="o">+</span> <span class="p">((</span><span class="n">u_2</span> <span class="o">-</span> <span class="n">u_p2</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_2</span><span class="p">))</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_2</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_2</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span>  \
  <span class="o">+</span> <span class="p">((</span><span class="n">u_3</span> <span class="o">-</span> <span class="n">u_p3</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_3</span><span class="p">))</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_3</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_3</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_3</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">-</span> <span class="n">f_1</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f_2</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f_3</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The time-stepping simply consists of solving this variational problem
in each time step by a call to the <code class="docutils literal"><span class="pre">solve</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">timeseries_w</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">t</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">u_p</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>In each time step, we first read the current value for the velocity
field from the time series we have previously stored. We then solve
the nonlinear system, and assign the computed values to the left-hand
side values for the next time interval.</p>
<p>[<strong>FIXME 30</strong>: Haven&#8217;t learned how to reference figures yet in Doconce so I just write &#8216;below&#8217; - fix!]</p>
<p>The solution at the final time is shown in the figure below. We
clearly see the advection of the species <span class="math">\(A\)</span> and <span class="math">\(B\)</span> and the formation
of <span class="math">\(C\)</span> along the center of the channel where <span class="math">\(A\)</span> and <span class="math">\(B\)</span> meet.</p>
<div class="figure" id="id11">
<span id="ftut1-fig-reactionsystem-solution"></span><a class="reference internal image-reference" href="_images/reaction_system.png"><img alt="_images/reaction_system.png" src="_images/reaction_system.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the concentrations of the three species  \( A \) ,  \( B \) , and  \( C \)  (from top to bottom) at final time</em></span></p>
</div>
<p>The complete code is presented below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">5.0</span>            <span class="c1"># final time</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">500</span>    <span class="c1"># number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">num_steps</span> <span class="c1"># time step size</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">0.01</span>         <span class="c1"># diffusion coefficient</span>
<span class="n">K</span> <span class="o">=</span> <span class="mf">10.0</span>           <span class="c1"># reaction rate</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c1"># implicitness parameter for time-stepping</span>

<span class="c1"># Read mesh from file</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s1">&#39;channel.xml.gz&#39;</span><span class="p">)</span>

<span class="c1"># Define function space for velocity</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Define function space for system</span>
<span class="n">P1</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">MixedElement</span><span class="p">([</span><span class="n">P1</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P1</span><span class="p">])</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

<span class="c1"># Define test functions</span>
<span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">,</span> <span class="n">v_3</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Define functions for velocity and concentrations</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Split system functions to access components</span>
<span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">u_3</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">u_p1</span><span class="p">,</span> <span class="n">u_p2</span><span class="p">,</span> <span class="n">u_p3</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u_p</span><span class="p">)</span>

<span class="c1"># Define source terms</span>
<span class="n">f_1</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;pow(x[0]-0.1,2)+pow(x[1]-0.1,2)&lt;0.05*0.05 ? 0.1 : 0&#39;</span><span class="p">,</span>
                 <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f_2</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;pow(x[0]-0.1,2)+pow(x[1]-0.3,2)&lt;0.05*0.05 ? 0.1 : 0&#39;</span><span class="p">,</span>
                 <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f_3</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Define expressions used in variational forms</span>
<span class="n">U_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p1</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
<span class="n">U_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p2</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_2</span>
<span class="n">U_3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">*</span><span class="n">u_p3</span> <span class="o">+</span> <span class="n">Constant</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">u_3</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">eps</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">((</span><span class="n">u_1</span> <span class="o">-</span> <span class="n">u_p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_1</span><span class="p">))</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_1</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_1</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span>  \
  <span class="o">+</span> <span class="p">((</span><span class="n">u_2</span> <span class="o">-</span> <span class="n">u_p2</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_2</span><span class="p">))</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_2</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_2</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span>  \
  <span class="o">+</span> <span class="p">((</span><span class="n">u_3</span> <span class="o">-</span> <span class="n">u_p3</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">U_3</span><span class="p">))</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">+</span> <span class="n">eps</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U_3</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_3</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">K</span><span class="o">*</span><span class="n">U_1</span><span class="o">*</span><span class="n">U_2</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="n">U_3</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span> \
  <span class="o">-</span> <span class="n">f_1</span><span class="o">*</span><span class="n">v_1</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f_2</span><span class="o">*</span><span class="n">v_2</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f_3</span><span class="o">*</span><span class="n">v_3</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Create time series for reading velocity data</span>
<span class="n">timeseries_w</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="s1">&#39;ns/velocity&#39;</span><span class="p">)</span>

<span class="c1"># FIXME: mpi_comm_world should not be needed here, fix in FEniCS!</span>

<span class="c1"># Create VTK files for visualization output</span>
<span class="n">vtkfile_u_1</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;reaction_system/u_1.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_u_2</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;reaction_system/u_2.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_u_3</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;reaction_system/u_3.pvd&#39;</span><span class="p">)</span>

<span class="c1"># Create progress bar</span>
<span class="n">progress</span> <span class="o">=</span> <span class="n">Progress</span><span class="p">(</span><span class="s1">&#39;Time-stepping&#39;</span><span class="p">)</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="c1"># Time-stepping</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>

    <span class="c1"># Update current time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="c1"># Read velocity from file</span>
    <span class="n">timeseries_w</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">t</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># Solve variational problem for time step</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="c1"># Plot solution</span>
    <span class="n">_u_1</span><span class="p">,</span> <span class="n">_u_2</span><span class="p">,</span> <span class="n">_u_3</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">_u_1</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;u_1&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;u_1&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">_u_2</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;u_2&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;u_2&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">_u_3</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;u_3&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;u_3&#39;</span><span class="p">)</span>

    <span class="c1"># Save solution to file (VTK)</span>
    <span class="n">vtkfile_u_1</span> <span class="o">&lt;&lt;</span> <span class="n">_u_1</span>
    <span class="n">vtkfile_u_2</span> <span class="o">&lt;&lt;</span> <span class="n">_u_2</span>
    <span class="n">vtkfile_u_3</span> <span class="o">&lt;&lt;</span> <span class="n">_u_3</span>

    <span class="c1"># Update previous solution</span>
    <span class="n">u_p</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="c1"># Update progress bar</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, we comment on three important techniques that are very useful
when working with systems of PDEs: setting initial conditions, setting
boundary conditions, and extracting components of the system for
plotting or postprocessing.</p>
</div>
<div class="section" id="setting-initial-conditions-for-mixed-systems">
<h3>Setting initial conditions for mixed systems<a class="headerlink" href="#setting-initial-conditions-for-mixed-systems" title="Permalink to this headline">¶</a></h3>
<p>In our example, we did not need to worry about setting an initial
condition, since we start with <span class="math">\(u_1 = u_2 = u_3 = 0\)</span>. This happens
automatically in the code when we set <code class="docutils literal"><span class="pre">u_p</span> <span class="pre">=</span> <span class="pre">Function(V)</span></code>. This
creates a <code class="docutils literal"><span class="pre">Function</span></code> for the whole system and all degrees of freedom
are set to zero.</p>
<p>If we wanted to set initial conditions for the components of the
system separately, the easiest solution is to define the initial
conditions as a vector-valued <code class="docutils literal"><span class="pre">Expression</span></code> and then
project this to the <code class="docutils literal"><span class="pre">Function</span></code> representing the whole system. For
example,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">((</span><span class="s1">&#39;sin(x[0])&#39;</span><span class="p">,</span> <span class="s1">&#39;cos(x[0]*x[1])&#39;</span><span class="p">,</span> <span class="s1">&#39;exp(x[1])&#39;</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u_0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>This defines <span class="math">\(u_1\)</span>, <span class="math">\(u_2\)</span>, and <span class="math">\(u_2\)</span> to be the projections of <span class="math">\(\sin
x\)</span>, <span class="math">\(\cos (xy)\)</span>, and <span class="math">\(\exp(y)\)</span>, respectively.</p>
</div>
<div class="section" id="setting-boundary-conditions-for-mixed-systems">
<h3>Setting boundary conditions for mixed systems<a class="headerlink" href="#setting-boundary-conditions-for-mixed-systems" title="Permalink to this headline">¶</a></h3>
<p>In our example, we also did not need to worry about setting boundary
conditions since we used a natural Neumann condition. If we want to set
Dirichlet conditions for individual components of the system, this can
be done as usual by the class <code class="docutils literal"><span class="pre">DirichletBC</span></code>, but we must specify for
which subsystem we set the boundary condition. For example, to specify
that <span class="math">\(u_2\)</span> should be equal to <span class="math">\(xy\)</span> on the boundary defined by
<code class="docutils literal"><span class="pre">boundary</span></code>, we do</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>u_b = Expression(&#39;x[0]*x[1]&#39;, degree=1)
bc = DirichletBC(V.sub(1), u_b, boundary)
</pre></div>
</div>
<p>The object <code class="docutils literal"><span class="pre">bc</span></code> or a list of such objects containing different
boundary conditions, can then be passed to the <code class="docutils literal"><span class="pre">solve</span></code> function as usual.
Note that numbering starts at <span class="math">\(0\)</span> in FEniCS so the subspace
corresponding to <span class="math">\(u_2\)</span> is <code class="docutils literal"><span class="pre">V.sub(1)</span></code>.</p>
</div>
<div class="section" id="accessing-components-of-mixed-systems">
<h3>Accessing components of mixed systems<a class="headerlink" href="#accessing-components-of-mixed-systems" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal"><span class="pre">u</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code> defined on a mixed function space in FEniCS,
there are several ways in which <code class="docutils literal"><span class="pre">u</span></code> can be <em>split</em> into components.
Above we already saw an example of the first of these:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">u_3</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This extracts the components of <code class="docutils literal"><span class="pre">u</span></code> as <em>symbols</em> that can be used in a
variational problem. The above statement is in fact equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">u_3</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">u[0]</span></code> is not really a <code class="docutils literal"><span class="pre">Function</span></code> object, but merely a
symbolic expression, just like <code class="docutils literal"><span class="pre">grad(u)</span></code> in FEniCS is a symbolic
expression and not a <code class="docutils literal"><span class="pre">Function</span></code> representing the gradient.  This means
that <code class="docutils literal"><span class="pre">u_1</span></code>, <code class="docutils literal"><span class="pre">u_2</span></code>, <code class="docutils literal"><span class="pre">u_3</span></code> can be used in a variational problem, but
cannot be used for plotting or postprocessing.</p>
<p>To access the components of <code class="docutils literal"><span class="pre">u</span></code> for plotting and saving the solution
to file, we need to use a different variant of the <code class="docutils literal"><span class="pre">split</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_u_1</span><span class="p">,</span> <span class="n">_u_2</span><span class="p">,</span> <span class="n">_u_3</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</pre></div>
</div>
<p>This returns three subfunctions as actual objects with access to the
common underlying data stored in <code class="docutils literal"><span class="pre">u</span></code>, which makes plotting and saving
to file possible. Alternatively, we can do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_u_1</span><span class="p">,</span> <span class="n">_u_2</span><span class="p">,</span> <span class="n">_u_3</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>which will create <code class="docutils literal"><span class="pre">_u_1</span></code>, <code class="docutils literal"><span class="pre">_u_2</span></code>, and <code class="docutils literal"><span class="pre">u_3</span></code> as stand-alone <code class="docutils literal"><span class="pre">Function</span></code>
objects, each holding a copy of the subfunction data extracted from
<code class="docutils literal"><span class="pre">u</span></code>. This is useful in many situations but is not necessary for
plotting and saving solutions to file.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>