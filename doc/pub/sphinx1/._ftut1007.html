
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Extensions: Improving the Poisson solver</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial Volume I" href="index.html" />
    <link rel="prev" title="Extensions: Improving the Poisson solver" href="._ftut1006.html" />

  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <!-- Default Bootstrap-->
  <link rel="stylesheet" href="_static/css/bootstrap.min.css"/>
  <link rel="shortcut icon" href="_static/fenics.ico" />
  <!-- Template styles CSS-->
  <link rel="stylesheet" href="_static/css/main.css"/>
  <link rel="stylesheet" href="_static/css/custom.css"/>
  <link rel="stylesheet" href="_static/css/font-awesome.min.css"/>
  <link rel="stylesheet" href="_static/css/animate.min.css"/>
  <link rel="stylesheet" href="_static/css/responsive.css"/>

  <!-- Template styles JS-->
  <script src="_static/slides.min.jquery.js"></script>
  <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
  <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
  <script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <script type="text/javascript" src="_static/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="_static/js/wow.min.js"></script>
  <script type="text/javascript" src="_static/js/main.js"></script>
  <script type="text/javascript" src="_static/js/jquery.bcSwipe.js"></script>
  <script>
    $(document).ready(function() {
         $("#mycarousel").swiperight(function() {
            $(this).carousel('prev');
            });
         $("#mycarousel").swipeleft(function() {
            $(this).carousel('next');
       });
    });
  </script>

  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<header id="header">
      <div class="navbar navbar-inverse" role="banner">
          <div class="container">
              <div class="navbar-header">
                  <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#headernavbar">
                      <span class="sr-only">Toggle navigation</span>
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                  </button>

                  <a class="navbar-brand" href="http://fenicsproject.org/index.html">
                      <h1><img src="_static/fenics_banner.png" alt="FEniCS Project Logo" class="img-responsive center-block banner-image"></h1>
                  </a>

              </div>
              <div class="collapse navbar-collapse" id="headernavbar">
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="._ftut1006.html" title="Previous page">Prev</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/index.html">Home</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
                  </ul>
              </div>
          </div>
      </div>
  </header>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="extensions-improving-the-poisson-solver">
<span id="ch-poisson"></span><h1>Extensions: Improving the Poisson solver<a class="headerlink" href="#extensions-improving-the-poisson-solver" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>This chapter goes through common improvements of the codes presented
in the previous chapter. In particular, we show how to</p>
<blockquote>
<div><ul class="simple">
<li>write general solver functions</li>
<li>utilize iterative solvers with preconditioners for solving linear systems</li>
<li>compute derived quantities (e.g., flux at a part of the boundary)</li>
<li>specify subdomains and parts of the boundary</li>
</ul>
</div></blockquote>
</div></blockquote>
<div class="section" id="refactoring-the-poisson-solver">
<span id="ch-poisson0-impl2"></span><h2>Refactoring the Poisson solver<a class="headerlink" href="#refactoring-the-poisson-solver" title="Permalink to this headline">¶</a></h2>
<p>All programs created in this book so far are &#8220;flat&#8221;; that is, they are
not organized into logical, reusable units in terms of Python
functions. Such flat programs are useful for quickly testing out some
software, but not well suited for serious problem solving. We shall
therefore look at how to <em>refactor</em> the Poisson solver from the chapter <a class="reference internal" href="._ftut1003.html#ch-fundamentals"><span class="std std-ref">Fundamentals: Solving the Poisson equation</span></a>.  For a start, this means splitting the code into
functions, but this is just a reordering of the existing
statements. During refactoring, we also try make the functions we
create as reusable as possible in other contexts. We will also
encapsulate statements specific to a certain problem into
(non-reusable) functions. Being able to distinguish reusable code from
specialized code is a key issue when refactoring code, and this
ability depends on a good mathematical understanding of the problem at
hand (what is general, what is special?).  In a flat program,
general and specialized code (and mathematics) are often mixed
together.</p>
<div class="section" id="a-more-general-solver-function">
<span id="ch-poisson0-impl2-func"></span><h3>A more general solver function<a class="headerlink" href="#a-more-general-solver-function" title="Permalink to this headline">¶</a></h3>
<p>We consider the flat program developed in the section <a class="reference internal" href="._ftut1003.html#ch-poisson0-impl"><span class="std std-ref">FEniCS implementation</span></a>.  Some of the code in this program
is needed to solve any Poisson problem <span class="math">\(-\nabla^2 u=f\)</span> on <span class="math">\([0,1]\times
[0,1]\)</span> with <span class="math">\(u=u_{_\mathrm{D}}\)</span> on the boundary, while other statements arise from
our simple test problem. Let us collect the general, reusable code in
a function called <code class="docutils literal"><span class="pre">solver</span></code>. Our special test problem will then just be
an application of <code class="docutils literal"><span class="pre">solver</span></code> with some additional statements. We limit
the <code class="docutils literal"><span class="pre">solver</span></code> function to just <em>compute the numerical
solution</em>. Plotting and comparing the solution with the exact solution
are considered to be problem-specific activities to be performed
elsewhere.</p>
<p>We parameterize <code class="docutils literal"><span class="pre">solver</span></code> by <span class="math">\(f\)</span>, <span class="math">\(u_{_\mathrm{D}}\)</span>, and the resolution of the
mesh. Since it is so trivial to use higher-order finite element
functions by changing the third argument to <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, we let
also the polynomial degree of the finite element function space
be an argument to <code class="docutils literal"><span class="pre">solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u) = f on [0,1] x [0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u_D (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The remaining tasks of our initial program, such calling the <code class="docutils literal"><span class="pre">solve</span></code>
function with problem-specific parameters and plotting,
can be placed in a separate function. Here we choose to put this code
in a function named <code class="docutils literal"><span class="pre">application_test</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">application_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute and post-process solution&quot;&quot;&quot;</span>

    <span class="c1"># Set up problem parameters and call solver</span>
    <span class="n">u_D</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Plot solution</span>
    <span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

    <span class="c1"># Save solution to file in VTK format</span>
    <span class="n">vtkfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;poisson.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The solution can now be computed, plotted, and saved to file by
simply calling the <code class="docutils literal"><span class="pre">application_test</span></code> function.</p>
</div>
<div class="section" id="writing-the-solver-as-a-python-module">
<h3>Writing the solver as a Python module<a class="headerlink" href="#writing-the-solver-as-a-python-module" title="Permalink to this headline">¶</a></h3>
<p>The refactored code is put in a file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/ft06_poisson_func.py">ft06_poisson_func.py</a>. We should make sure
that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program that are not inside functions
should appear within a test <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code>. This test is
true if the file is executed as a program, but false if the file is
imported.  If we want to run this file in the same way as we can run
<code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>, the main program is simply a call to
<code class="docutils literal"><span class="pre">application_test()</span></code> followed by a call <code class="docutils literal"><span class="pre">interactive()</span></code> to hold the
plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application_test</span><span class="p">()</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-and-unit-tests">
<span id="index-0"></span><h3>Verification and unit tests<a class="headerlink" href="#verification-and-unit-tests" title="Permalink to this headline">¶</a></h3>
<p>The remaining part of our first program is to compare the numerical
and the exact solutions. Every time we edit the code we must rerun the
test and examine that <code class="docutils literal"><span class="pre">max_error</span></code> is sufficiently small so we know
that the code still works. To this end, we shall adopt <em>unit testing</em>,
meaning that we create a mathematical test and corresponding software
that can run all our tests automatically and check that all tests
pass.  Python has several tools for unit testing. Two very popular
ones are <code class="docutils literal"><span class="pre">pytest</span></code> and <code class="docutils literal"><span class="pre">nose</span></code>. These are almost identical and very easy
to use.  More classical unit testing with test classes is offered by
the built-in tool <code class="docutils literal"><span class="pre">unittest</span></code>, but here we are going to use <code class="docutils literal"><span class="pre">pytest</span></code>
(or <code class="docutils literal"><span class="pre">nose</span></code>) since that will result in shorter and clearer code.</p>
<p>Mathematically, our unit test is that the finite element solution of
our problem when <span class="math">\(f=-6\)</span> equals the exact solution <span class="math">\(u=u_{_\mathrm{D}}=1+x^2+2y^2\)</span>.
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which
depends to the number of elements and the degrees of the polynomials
in the finite element basis functions.  If we want to test that the
<code class="docutils literal"><span class="pre">solver</span></code> function works for meshes up to <span class="math">\(2\times(20\times 20)\)</span>
elements and cubic Lagrange elements, <span class="math">\(10^{-11}\)</span> is an appropriate
tolerance for testing that the maximum error vanishes (see the section <a class="reference internal" href="._ftut1003.html#ch-poisson0-impl-dissect"><span class="std std-ref">Dissection of the program</span></a>).</p>
<p>[<strong>AL 37</strong>: Changed to <code class="docutils literal"><span class="pre">pytest</span></code> and <code class="docutils literal"><span class="pre">nose</span></code> here (in computer font). Change back if not appropriate.]
[<strong>hpl 38</strong>: Changed back as pytest and nose are standard phrasings on the net.]</p>
<p>Only three statements are necessary to carry out the unit
test. However, we shall embed these statements a special way in our
code so that they are recognized by <code class="docutils literal"><span class="pre">pytest</span></code> and <code class="docutils literal"><span class="pre">nose</span></code>. The simple
rule is that each test must be placed in a function that</p>
<blockquote>
<div><ul class="simple">
<li>has a name starting with <code class="docutils literal"><span class="pre">test_</span></code>,</li>
<li>has no arguments,</li>
<li>implements a test expressed as <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success,</span> <span class="pre">msg</span></code>.</li>
</ul>
</div></blockquote>
<p>Regarding the last point, <code class="docutils literal"><span class="pre">success</span></code> is a boolean expression that is
<code class="docutils literal"><span class="pre">False</span></code> if the test fails, and in that case the string <code class="docutils literal"><span class="pre">msg</span></code> is
written to the screen. When the test fails, <code class="docutils literal"><span class="pre">assert</span></code> raises an
<code class="docutils literal"><span class="pre">AssertionError</span></code> exception in Python, otherwise the statement runs
silently. The <code class="docutils literal"><span class="pre">msg</span></code> string is optional, so <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success</span></code> is the
minimal test. In our case, we will write <code class="docutils literal"><span class="pre">assert</span> <span class="pre">max_error</span> <span class="pre">&lt;</span> <span class="pre">tol</span></code>,
where <code class="docutils literal"><span class="pre">tol</span></code> is the tolerance (<span class="math">\(10^{-11}\)</span>) mentioned above.</p>
<p>A proper <em>test function</em> for implementing this unit test in the
<code class="docutils literal"><span class="pre">pytest</span></code> or <code class="docutils literal"><span class="pre">nose</span></code> testing frameworks has the following form. Note
that we perform the test for different mesh resolutions and degrees of
finite elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u = 1 + x^2 + 2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>

    <span class="c1"># Set up parameters for testing</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-11</span>
    <span class="n">u_D</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>

    <span class="c1"># Iterate over mesh sizes and degrees</span>
    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Solving on a 2 x (</span><span class="si">%d</span><span class="s1"> x </span><span class="si">%d</span><span class="s1">) mesh with P</span><span class="si">%d</span><span class="s1"> elements.&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>

            <span class="c1"># Compute solution</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

            <span class="c1"># Compute maximum error at vertices</span>
            <span class="n">vertex_values_u_D</span> <span class="o">=</span> <span class="n">u_D</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="n">vertex_values_u</span>  <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
            <span class="n">error_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vertex_values_u_D</span> <span class="o">-</span> <span class="n">vertex_values_u</span><span class="p">))</span>

            <span class="c1"># Check maximum error</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;error_max = </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">error_max</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>To run the test, we type the following command:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; py.test -s -v ft06_poisson_func.py
</pre></div>
</div>
<p>This will run all functions <code class="docutils literal"><span class="pre">test_*()</span></code> (currently only the
<code class="docutils literal"><span class="pre">test_solver</span></code> function) found in the file and report the results.</p>
<p>We shall make it a habit in the following test to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented.</p>
<div class="admonition-tip-print-messages-in-test-functions admonition">
<p class="first admonition-title">Tip: Print messages in test functions</p>
<p class="last">The <code class="docutils literal"><span class="pre">assert</span></code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code class="docutils literal"><span class="pre">assert</span></code>
(as we do in the example above) such that it is clear that the
test really takes place.
Note that <code class="docutils literal"><span class="pre">py.test</span></code> needs the <code class="docutils literal"><span class="pre">-s</span></code> option to show printout
from the test functions.</p>
</div>
</div>
<div class="section" id="examining-the-degrees-of-freedom">
<span id="ch-poisson0-verify1"></span><h3>Examining the degrees of freedom<a class="headerlink" href="#examining-the-degrees-of-freedom" title="Permalink to this headline">¶</a></h3>
<p>[<strong>AL 39</strong>: Important section, but maybe it fits better somewhere else since it does not specifically deal with code structuring.]
[<strong>hpl 40</strong>: Agree, it has been moved around...and it is pretty basic and should appear early (not volume II).]</p>
<p>We have seen how to grab the degrees of freedom array from a
finite element function <code class="docutils literal"><span class="pre">u</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dofs</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>For a finite function from a standard continuous piecewise linear
function space (<span class="math">\(\mathsf{P}_1\)</span> Lagrange elements), these values will
be the same as the values we get by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vertex_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Both <code class="docutils literal"><span class="pre">dofs</span></code> and <code class="docutils literal"><span class="pre">vertex_values</span></code> will be <code class="docutils literal"><span class="pre">numpy</span></code> arrays and they will
be of the same length and contain the same values, but with possibly
different ordering. The array <code class="docutils literal"><span class="pre">vertex_values</span></code> will have the same
ordering as the vertices of the mesh, while <code class="docutils literal"><span class="pre">dofs</span></code> will be ordered in
a way that (nearly) minimizes the bandwidth of the system matrix and
thus improves the efficiency of linear solvers.</p>
<p>A fundamental question is: What are the
coordinates of vertex <code class="docutils literal"><span class="pre">i</span></code> whose value is <code class="docutils literal"><span class="pre">dofs[i]</span></code>? To answer this
question, we need to understand how to get our hands on the
coordinates, and in particular, the numbering of degrees of freedom
and the numbering of vertices in the mesh.</p>
<p>The function <code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns the coordinates of the
vertices as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape <span class="math">\((M,d\)</span>), <span class="math">\(M\)</span> being the number
of vertices in the mesh and <span class="math">\(d\)</span> being the number of space dimensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordinates</span>
<span class="go">array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0. ],</span>
<span class="go">       [ 1. ,  0. ],</span>
<span class="go">       [ 0. ,  0.5],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  0.5],</span>
<span class="go">       [ 0. ,  1. ],</span>
<span class="go">       [ 0.5,  1. ],</span>
<span class="go">       [ 1. ,  1. ]])</span>
</pre></div>
</div>
<p>We see from this output that for this particular mesh, the vertices
are first numbered along <span class="math">\(y=0\)</span>
with increasing <span class="math">\(x\)</span> coordinate, then along <span class="math">\(y=0.5\)</span>, and so on.</p>
<p>Next we compute a function <code class="docutils literal"><span class="pre">u</span></code> on this mesh. Let&#8217;s take <span class="math">\(u=x+y\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;x[0] + x[1]&#39;</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dofs</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dofs</span>
<span class="go">array([ 1. ,  0.5,  1.5,  0. ,  1. ,  2. ,  0.5,  1.5,  1. ])</span>
</pre></div>
</div>
<p>We observe that <code class="docutils literal"><span class="pre">dofs[0]</span></code> is <em>not</em> the value of <span class="math">\(x+y\)</span> at vertex number 0,
since this vertex has coordinates <span class="math">\(x=y=0\)</span>. The numbering of the
degrees of freedom <span class="math">\(U_1,\ldots,U_{N}\)</span> is obviously not the same as the
numbering of the vertices.</p>
<p>In the plot window, we may take a closer look at the function <code class="docutils literal"><span class="pre">u</span></code> and
the vertex numbering. We type <code class="docutils literal"><span class="pre">w</span></code> to turn on wireframe instead of
a fully  colored surface, <code class="docutils literal"><span class="pre">m</span></code> to show the mesh, and then <code class="docutils literal"><span class="pre">v</span></code> to show the
numbering of the vertices.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/vertex_numbering.png"><img alt="_images/vertex_numbering.png" src="_images/vertex_numbering.png" style="width: 500px;" /></a>
</div>
<span class="target" id="index-1"></span><p id="index-2">Let&#8217;s instead examine the values we get by calling
<code class="docutils literal"><span class="pre">u.compute_vertex_values()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;vertex </span><span class="si">%d</span><span class="s1">: vertex_values[</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%g</span><span class="se">\t</span><span class="s1">u(</span><span class="si">%s</span><span class="s1">) = </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span>
<span class="gp">... </span>          <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vertex_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">vertex 0: vertex_values[0] = 0      u([ 0.  0.]) = 8.46545e-16</span>
<span class="go">vertex 1: vertex_values[1] = 0.5    u([ 0.5  0. ]) = 0.5</span>
<span class="go">vertex 2: vertex_values[2] = 1          u([ 1.  0.]) = 1</span>
<span class="go">vertex 3: vertex_values[3] = 0.5    u([ 0.   0.5]) = 0.5</span>
<span class="go">vertex 4: vertex_values[4] = 1          u([ 0.5  0.5]) = 1</span>
<span class="go">vertex 5: vertex_values[5] = 1.5    u([ 1.   0.5]) = 1.5</span>
<span class="go">vertex 6: vertex_values[6] = 1          u([ 0.  1.]) = 1</span>
<span class="go">vertex 7: vertex_values[7] = 1.5    u([ 0.5  1. ]) = 1.5</span>
<span class="go">vertex 8: vertex_values[8] = 2          u([ 1.  1.]) = 2</span>
</pre></div>
</div>
<span class="target" id="index-3"></span><p id="index-4">We can ask FEniCS to give us the mapping from vertices to degrees of
freedom for a certain function space <span class="math">\(V\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v2d</span> <span class="o">=</span> <span class="n">vertex_to_dof_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, <code class="docutils literal"><span class="pre">dofs[v2d[i]]</span></code> will give us the value of the degree of freedom in
<code class="docutils literal"><span class="pre">u</span></code> corresponding to vertex <code class="docutils literal"><span class="pre">i</span></code> (<code class="docutils literal"><span class="pre">v2d[i]</span></code>). In particular, <code class="docutils literal"><span class="pre">dofs[v2d]</span></code>
is an array with all the elements in the same (vertex numbered) order
as <code class="docutils literal"><span class="pre">coordinates</span></code>.  The inverse map, from degrees of freedom number to
vertex number is given by <code class="docutils literal"><span class="pre">dof_to_vertex_map(V)</span></code>, so
<code class="docutils literal"><span class="pre">coordinates[dof_to_vertex_map(V)]</span></code> results in an array of all the
coordinates in the same order as the degrees of freedom.</p>
<p>For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices. For these
elements, we may still ask FEniCS to compute the vertex values by
calling <code class="docutils literal"><span class="pre">u.compute_vertex_values(mesh)</span></code>, and we can get the degrees of
freedom by calling <code class="docutils literal"><span class="pre">u.vector().array()</span></code>. To get the coordinates
associated with all degrees of freedom, we need to iterate over the
elements of the mesh and ask FEniCS to return the coordinates and dofs
associated with each cell. This information is stored in the
<code class="docutils literal"><span class="pre">FiniteElement</span></code> and <code class="docutils literal"><span class="pre">DofMap</span></code> object of a <code class="docutils literal"><span class="pre">FunctionSpace</span></code>. The
following code illustrates how to iterate over all elements of a mesh and
print the degrees of freedom and coordinates associated with the
element.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
<span class="n">dofmap</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span>
<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tabulate_dof_coordinates</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dofmap</span><span class="o">.</span><span class="n">cell_dofs</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span><span class="p">()))</span>
</pre></div>
</div>
<div class="admonition-cheap-vs-expensive-function-evaluation admonition">
<p class="first admonition-title">Cheap vs expensive function evaluation</p>
<p>Given a <code class="docutils literal"><span class="pre">Function</span></code> object <code class="docutils literal"><span class="pre">u</span></code>, we can evaluate its values in various
ways:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">u(x)</span></code> for an arbitrary point <code class="docutils literal"><span class="pre">x</span></code></li>
<li><code class="docutils literal"><span class="pre">u.vector().array()[i]</span></code> for degree of freedom number <code class="docutils literal"><span class="pre">i</span></code></li>
<li><code class="docutils literal"><span class="pre">u.compute_vertex_values()[i]</span></code> at vertex number <code class="docutils literal"><span class="pre">i</span></code></li>
</ol>
<p class="last">The first method, though very flexible, is in general expensive
while the other two are very efficient (but limited to certain points).</p>
</div>
<p>To demonstrate the use of point evaluations of <code class="docutils literal"><span class="pre">Function</span></code> objects, we
write out the computed <code class="docutils literal"><span class="pre">u</span></code> at the center point of the domain and
compare it with the exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">u_D</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Error at </span><span class="si">%s</span><span class="s1">: </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>Trying on a <span class="math">\(2\times(3\times 3)\)</span> mesh, the output from the
previous snippet becomes</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Error at (0.5, 0.5): -0.0833333
</pre></div>
</div>
<p>The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell, and
<code class="docutils literal"><span class="pre">u</span></code> varies linearly over the cell while <code class="docutils literal"><span class="pre">u_D</span></code> is a quadratic
function. When the center point is a node, as in a <span class="math">\(2\times(2\times
2)\)</span> or <span class="math">\(2\times(4\times 4)\)</span> mesh, the error is of the order
<span class="math">\(10^{-15}\)</span>.</p>
<p>We have seen how to extract the nodal values in a <code class="docutils literal"><span class="pre">numpy</span></code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that <span class="math">\(\max_j |U_j| = 1\)</span>. Then we
must divide all <span class="math">\(U_j\)</span> values
by <span class="math">\(\max_j |U_j|\)</span>. The following function performs the task:</p>
<p>[<strong>AL 41</strong>: Why is it called <code class="docutils literal"><span class="pre">poisson_iter.py</span></code>? Don&#8217;t understand the logic behind the name...]
[<strong>hpl 42</strong>: Poission equation with iterative mthods. Now explained at the very end of the section.]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">normalize_solution</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize u: return u divided by max(|u|).&quot;&quot;&quot;</span>
    <span class="n">dofs</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">u_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dofs</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">dofs</span> <span class="o">/=</span> <span class="n">u_max</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">dofs</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">dofs</span><span class="p">)</span> <span class="c1"># alternative</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>That is, we manipulate <code class="docutils literal"><span class="pre">dofs</span></code> as desired, and then we insert this
array into <code class="docutils literal"><span class="pre">u</span></code>&#8216;s <code class="docutils literal"><span class="pre">Vector</span></code> object.  The <code class="docutils literal"><span class="pre">/=</span></code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the array <code class="docutils literal"><span class="pre">dofs</span></code> are divided by the value <code class="docutils literal"><span class="pre">u_max</span></code>.
Alternatively, one could write <code class="docutils literal"><span class="pre">dofs</span> <span class="pre">=</span> <span class="pre">dofs</span> <span class="pre">/</span> <span class="pre">u_max</span></code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code class="docutils literal"><span class="pre">dofs</span></code>.</p>
<div class="admonition-be-careful-when-manipulating-degrees-of-freedom admonition">
<p class="first admonition-title">Be careful when manipulating degrees of freedom</p>
<p class="last">A call like <code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a <em>copy</em> of the data in
<code class="docutils literal"><span class="pre">u.vector()</span></code>. One must therefore never perform assignments like
<code class="docutils literal"><span class="pre">u.vector.array()[:]</span> <span class="pre">=</span> <span class="pre">...</span></code>, but instead extract the <code class="docutils literal"><span class="pre">numpy</span></code> array
(i.e., a copy), manipulate it, and insert it back with <code class="docutils literal"><span class="pre">u.vector()[:]</span>
<span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">use</span> <span class="pre">``u.set_local(...)</span></code>.</p>
</div>
<p id="index-5">All the code in this subsection can be found in the file
<code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code> (Poission solver with use of iterative
methods)</p>
</div>
<div class="section" id="parameterizing-the-number-of-space-dimensions">
<span id="ch-poisson0-nd"></span><h3>Parameterizing the number of space dimensions<a class="headerlink" href="#parameterizing-the-number-of-space-dimensions" title="Permalink to this headline">¶</a></h3>
<p id="index-6">[<strong>AL 43</strong>: Use consistent mesh resolution, perhaps 16 for all examples. Now the resolution looks very random between examples.]
[<strong>hpl 44</strong>: True, but the randomness stems from the fact that 2 is enough for most examples, so anything works. I agree that 16 is a better number to display (and copy), and if we choose the extreme 2, there is an explanation in the text for that choice.]
[<strong>AL 45</strong>: I&#8217;m changing everything to 16 from now on for consistency. With today&#8217;s computers, 16 is a reasonably small problem and a nice number. Needs to be revisited throughout the book! If we use 16, it is clear that 16 is a nice &#8216;&#8217;round&#8217;&#8217; number but 6, 4, 5 may look like something special - why make the mesh anisotropic?]
[<strong>hpl 46</strong>: OK!]</p>
<p>FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory programs <code class="docutils literal"><span class="pre">ft01_poisson.py</span></code> or
<code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code> and change the mesh construction from
<code class="docutils literal"><span class="pre">UnitSquareMesh(16,</span> <span class="pre">16)</span></code> to <code class="docutils literal"><span class="pre">UnitCubeMesh(16,</span> <span class="pre">16,</span> <span class="pre">16)</span></code>. Now the domain is
the unit cube partitioned into <span class="math">\(16\times 16\times16\)</span> boxes, and
each box is divided into six tetrahedron-shaped finite elements for
computations. Run the program and observe that we can solve a 3D
problem without any other modifications (!). The visualization allows
you to rotate the cube and observe the function values as colors on
the boundary.</p>
<p>If we want to parameterize the creation of unit interval, unit square,
or unit cube over dimension, we can do so by encapsulating this part
of the code in a function. Given a list or tuple with the divisions
into cells in the various spatial coordinates, the following function
returns the mesh for a <span class="math">\(d\)</span>-dimensional cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">UnitHyperCube</span><span class="p">(</span><span class="n">divisions</span><span class="p">):</span>
    <span class="n">mesh_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnitIntervalMesh</span><span class="p">,</span> <span class="n">UnitSquareMesh</span><span class="p">,</span> <span class="n">UnitCubeMesh</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_classes</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span>
</pre></div>
</div>
<p>The construction <code class="docutils literal"><span class="pre">mesh_class[d-1]</span></code> will pick the right name of the
object used to define the domain and generate the mesh.  Moreover, the
argument <code class="docutils literal"><span class="pre">*divisions</span></code> sends all the components of the list <code class="docutils literal"><span class="pre">divisions</span></code>
as separate arguments to the constructor of the mesh construction
class picked out by <code class="docutils literal"><span class="pre">mesh_class[d-1]</span></code>. For example, in a 2D problem
where <code class="docutils literal"><span class="pre">divisions</span></code> has two elements, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_classes</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Replacing the <code class="docutils literal"><span class="pre">Nx</span></code> and <code class="docutils literal"><span class="pre">Ny</span></code> parameters by <code class="docutils literal"><span class="pre">divisions</span></code> and calling the
function <code class="docutils literal"><span class="pre">UnitHyperCube</span></code> to create the mesh are the two modifications
that we need in any of the previously shown <code class="docutils literal"><span class="pre">solver</span></code> functions to turn
them into solvers for <span class="math">\(d\)</span>-dimensional problems. Note that
<code class="docutils literal"><span class="pre">UnitHyperCube</span></code> is a <em>function</em> and not a <em>class</em> but we have named it
with <em>CamelCase</em> to make it look like a class so that our programs
look similar to using the standard FEniCS mesh classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitHyperCube</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="exercise-4-solve-a-poisson-problem">
<h3>Exercise 4: Solve a Poisson problem<a class="headerlink" href="#exercise-4-solve-a-poisson-problem" title="Permalink to this headline">¶</a></h3>
<p>Solve the following problem</p>
<div class="math" id="eq-auto34">
\[\tag{93}
\nabla^2 u = 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x))
    \hbox{ in }\Omega = [0,1]\times [0,1]\]</div>
<div class="math" id="eq-auto35">
\[\tag{94}
u = 0\quad\hbox{ on }\partial\Omega\]</div>
<p>The exact solution is given by</p>
<div class="math">
\[u(x,y) = 2e^{-2x}\sin(\pi x)\sin(\pi y){\thinspace .}\]</div>
<p>Compute the maximum numerical approximation error in a mesh with
<span class="math">\(2(N_x\times N_y)\)</span> elements and in a mesh with double resolution:
<span class="math">\(4(N_x\times N_y)\)</span> elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
Make an illustrative plot of the solution too.</p>
<p><strong>a)</strong>
Base your implementation on editing the program
<code class="docutils literal"><span class="pre">ft01_poisson.py</span></code>.</p>
<p><strong>Hint 1.</strong>
In the string for an <code class="docutils literal"><span class="pre">Expression</span></code> object, <code class="docutils literal"><span class="pre">pi</span></code> is the value of
<span class="math">\(\pi\)</span>. Also note that <span class="math">\(\pi^2\)</span> must be expressed with syntax
<code class="docutils literal"><span class="pre">pow(pi,2)</span></code> and not (the common Python syntax) <code class="docutils literal"><span class="pre">pi**2</span></code>.</p>
<p>FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code class="docutils literal"><span class="pre">/very/long/path/compile.log</span></code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.</p>
<p><strong>Hint 2.</strong>
The result that with P1 elements, doubling the resolution reduces the error
with a factor of four, is an
asymptotic result so it requires a sufficiently fine mesh. Here
one may start with <span class="math">\(N_x=N_y=20\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">poisson_fsin_flat</span></code>.</p>
<p><strong>Solution.</strong>
Looking at the <code class="docutils literal"><span class="pre">ft01_poisson.py</span></code> code, we realize that
the following edits are required:</p>
<blockquote>
<div><ul class="simple">
<li>Modify the <code class="docutils literal"><span class="pre">mesh</span></code> computation.</li>
<li>Modify <code class="docutils literal"><span class="pre">u_b</span></code> and <code class="docutils literal"><span class="pre">f</span></code>.</li>
<li>Add expression for the exact solution.</li>
<li>Modify the computation of the numerical error.</li>
<li>Insert a loop to enable solving the problem twice.</li>
<li>Put the error reduction computation and the plot statements after the loop.</li>
</ul>
</div></blockquote>
<p>Here is the modified code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">Nx</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Ny</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Define boundary conditions</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c1"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s1">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s1">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="c1"># Note: no need for pi=DOLFIN_PI in f, pi is valid variable</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s1">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>

    <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>         <span class="c1"># exact solution</span>
    <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c1"># dof values</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
    <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Error reduction:&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c1"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c1"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The number <span class="math">\(\pi\)</span> has the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> in C and C++, but in C++
strings in <code class="docutils literal"><span class="pre">Expression</span></code> objects, the symbol <code class="docutils literal"><span class="pre">pi</span></code> can be used directly
(or one can use the less readable <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/poisson_fsin.png"><img alt="_images/poisson_fsin.png" src="_images/poisson_fsin.png" style="width: 500px;" /></a>
</div>
<p><strong>b)</strong>
Base your implementation on a new file that imports functionality
from the module <code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code class="docutils literal"><span class="pre">poisson_fsin_func</span></code>.</p>
<p><strong>Solution.</strong>
Solving the two problems is a matter of calling <code class="docutils literal"><span class="pre">solver</span></code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code class="docutils literal"><span class="pre">test_solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">poisson_func</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span>
    <span class="n">interactive</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s1">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s1">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s1">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span>

<span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Loop over refined meshes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Nx</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">Ny</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;solving on 2(</span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1">) mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Make a finite element function of the exact u_e</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># Linf norm</span>
        <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">error</span><span class="p">)):</span>
        <span class="n">error_reduction</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;error reduction:&#39;</span><span class="p">,</span> <span class="n">error_reduction</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error_reduction</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c1"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_solver</span><span class="p">()</span>
    <span class="n">application</span><span class="p">()</span>
    <span class="c1"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The unit test is embedded in a proper test function <code class="docutils literal"><span class="pre">test_solver</span></code> for
the <code class="docutils literal"><span class="pre">pytest</span></code> or <code class="docutils literal"><span class="pre">nose</span></code> testing frameworks. Visualization of the
solution is encapsulated in the <code class="docutils literal"><span class="pre">application</span></code> function. Since we need
<code class="docutils literal"><span class="pre">u_e</span></code>, <code class="docutils literal"><span class="pre">u_b</span></code>, and <code class="docutils literal"><span class="pre">f</span></code> in two functions, we place the definitions in a
function <code class="docutils literal"><span class="pre">data</span></code> to avoid copies of these expressions.</p>
<div class="section" id="remarks">
<h4>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h4>
<p>This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code class="docutils literal"><span class="pre">solver</span></code> function, requires <em>no modifications</em>
of the <code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension. Hopefully, with this exercise
you realize that embedding
PDE solvers in functions (or classes) makes more reusable software than
flat programs.</p>
</div>
</div>
<div class="section" id="exercise-5-refactor-the-code-for-membrane-deflection">
<span id="ch-poisson0-exer-membrane"></span><h3>Exercise 5: Refactor the code for membrane deflection<a class="headerlink" href="#exercise-5-refactor-the-code-for-membrane-deflection" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">ft02_membrane.py</span></code> program simulates the deflection of a
membrane. Refactor this code such that we have a <code class="docutils literal"><span class="pre">solver</span></code> function as
in the program with name <code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>. Let the user
have the option to choose a direct or iterative solver for the linear
system.  Also implement a unit test where you have <span class="math">\(p=4\)</span> (constant)
and use P2 and P3 elements. In this case, the exact solution is
quadratic in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> and will be &#8220;exactly&#8221; reproduced by P2 and
higher-order elements.</p>
<p><strong>Solution.</strong>
We can use the <code class="docutils literal"><span class="pre">solver</span></code> function from <code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>
right away. The major difference is that
the domain is now a circle and not a square. We change the <code class="docutils literal"><span class="pre">solver</span></code>
function by letting the mesh be an argument <code class="docutils literal"><span class="pre">mesh</span></code> (instead of <code class="docutils literal"><span class="pre">Nx</span></code>
and <code class="docutils literal"><span class="pre">Ny</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u_b</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c1"># Alt: &#39;direct&#39;</span>
    <span class="o">...</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="c1"># code as before</span>
</pre></div>
</div>
<p>The complete code becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">):</span>
    <span class="c1"># Scaled pressure function</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s1">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="n">R0</span><span class="p">)</span>

    <span class="c1"># Generate mesh over the unit circle</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c1"># set name and label (description)</span>

    <span class="c1"># Plot scaled solution, mesh and pressure</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>

    <span class="c1"># Dump p and w to file in VTK format</span>
    <span class="n">vtkfile1</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;membrane_deflection.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile1</span> <span class="o">&lt;&lt;</span> <span class="n">w</span>
    <span class="n">vtkfile2</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;membrane_load.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile2</span> <span class="o">&lt;&lt;</span> <span class="n">p</span>
</pre></div>
</div>
<p>The key function to simulate membrane deflection is named <code class="docutils literal"><span class="pre">application</span></code>.</p>
<p>For <span class="math">\(p=4\)</span>, we have <span class="math">\(w=1-x^2-y^2\)</span> as exact solution.
The unit test for P2 and P3 goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_membrane</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Verification for constant pressure.&quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="c1"># Generate mesh over the unit circle</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;********* P</span><span class="si">%d</span><span class="s1"> elements:&#39;</span> <span class="o">%</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>  <span class="c1"># Run some resolutions</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="c1">#info(mesh)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                       <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;max w: </span><span class="si">%g</span><span class="s1">, w(0,0)=</span><span class="si">%g</span><span class="s1">, h=</span><span class="si">%.3E</span><span class="s1">, dofs=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">w</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span>
                   <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()),</span>
                   <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()))</span>

            <span class="n">w_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 - x[0]*x[0] - x[1]*x[1]&#39;</span><span class="p">)</span>
            <span class="n">w_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">w_exact</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                           <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;error: </span><span class="si">%.3E</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="mf">9.61E-03</span>

<span class="k">def</span> <span class="nf">application2</span><span class="p">(</span>
    <span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Explore more built-in visulization features.&quot;&quot;&quot;</span>
    <span class="c1"># Scaled pressure function</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s1">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="n">R0</span><span class="p">)</span>

    <span class="c1"># Generate mesh over the unit circle</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;deflection&#39;</span><span class="p">)</span>

    <span class="c1"># Plot scaled solution, mesh and pressure</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
    <span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
                 <span class="n">wireframe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Scaled membrane deflection&#39;</span><span class="p">,</span>
                 <span class="n">axes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">interactive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="p">)</span>
    <span class="n">viz_w</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># adjust (lift) camera from default view</span>
    <span class="n">viz_w</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>      <span class="c1"># bring new settings into action</span>
    <span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s1">&#39;deflection&#39;</span><span class="p">)</span>
    <span class="n">viz_w</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s1">&#39;deflection&#39;</span><span class="p">)</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">viz_p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Scaled pressure&#39;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">viz_p</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">viz_p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">viz_p</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">viz_p</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>

    <span class="c1"># Dump w and p to file in VTK format</span>
    <span class="n">vtkfile1</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;membrane_deflection.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile1</span> <span class="o">&lt;&lt;</span> <span class="n">w</span>
    <span class="n">vtkfile2</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;membrane_load.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile2</span> <span class="o">&lt;&lt;</span> <span class="n">p</span>
</pre></div>
</div>
<p>The striking feature is that the solver does not reproduce the solution
to an accuracy more than about 0.01 (!), regardless of the resolution and
type of element.</p>
<p>Filename: <code class="docutils literal"><span class="pre">membrane_func</span></code>.</p>
</div>
</div>
<div class="section" id="working-with-linear-solvers">
<h2>Working with linear solvers<a class="headerlink" href="#working-with-linear-solvers" title="Permalink to this headline">¶</a></h2>
<p>Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and simple method. It is the recommended method for systems
with up to a few thousand unknowns and may hence be the method of
choice in many 2D and smaller 3D problems. However, sparse LU
decomposition becomes slow and one quickly runs out of memory for
larger problems. For large problems, we instead need to use <em>iterative
methods</em> which are faster and require much less memory. We will now
look at how to take advantage of state-of-the-art iterative solution
methods in FEniCS.</p>
<div class="section" id="controlling-the-solution-process">
<span id="ch-poisson0-solve-prm"></span><h3>Controlling the solution process<a class="headerlink" href="#controlling-the-solution-process" title="Permalink to this headline">¶</a></h3>
<div class="section" id="choosing-a-linear-solver-and-preconditioner">
<h4>Choosing a linear solver and preconditioner<a class="headerlink" href="#choosing-a-linear-solver-and-preconditioner" title="Permalink to this headline">¶</a></h4>
<p>Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite system matrix, for which the
optimal Krylov solver is the Conjugate Gradient (CG) method. However,
the CG method requires boundary conditions to be implemented in a
symmetric way. This is not the case by default, so then a Krylov
solver for non-symmetric system, such as GMRES, is a better choice.
Incomplete LU factorization (ILU) is a popular and robust all-round
preconditioner, so let us try the GMRES-ILU pair:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s1">&#39;gmres&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s1">&#39;ilu&#39;</span><span class="p">})</span>
<span class="c1"># Alternative syntax</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="n">preconditioner</span><span class="o">=</span><span class="s1">&#39;ilu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>the section <a class="reference internal" href="#ftut-app-solver-prec"><span class="std std-ref">List of linear solver methods and preconditioners</span></a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.</p>
<span class="target" id="index-7"></span><span class="target" id="index-8"></span></div>
<div class="section" id="choosing-a-linear-algebra-backend">
<span id="index-9"></span><h4>Choosing a linear algebra backend<a class="headerlink" href="#choosing-a-linear-algebra-backend" title="Permalink to this headline">¶</a></h4>
<p>The actual GMRES and ILU implementations that are brought into action
depend on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology. PETSc is the default choice if FEniCS is compiled
with PETSc. If PETSc is not available, then FEniCS falls back to using
the Eigen backend.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">backendname</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">backendname</span></code> is a string. To see which linear algebra backends
are available, you can call the FEniCS function
<code class="docutils literal"><span class="pre">list_linear_algebra_backends()</span></code>.</p>
<p>[<strong>AL 47</strong>: Note that currently only PETSc and Eigen are available and Epetra is on its way back in.]
[<strong>hpl 48</strong>: OK, you have the overview here.]</p>
<span class="target" id="index-10"></span></div>
<div class="section" id="setting-solver-parameters">
<span id="index-11"></span><h4>Setting solver parameters<a class="headerlink" href="#setting-solver-parameters" title="Permalink to this headline">¶</a></h4>
<p>We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method. Such parameters can be controlled at both a <em>global</em>
and <em>local</em> level. We will start by looking at how to set global
parameters. For more advanced programs, one may want to use a number
of different linear solvers and set different tolerances and other
parameters. Then it becomes important to control the parameters at a
<em>local</em> level. We will return to this issue in the section <a class="reference internal" href="#ch-poisson0-solver-problem"><span class="std std-ref">Linear variational problem and solver objects</span></a>.</p>
<p>Changing a parameter in the global FEniCS parameter database affects
all linear solvers (created <em>after</em> the parameter has been set).
The global FEniCS parameter database is simply called <code class="docutils literal"><span class="pre">parameters</span></code> and
it behaves as a nested dictionary. Write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code class="docutils literal"><span class="pre">info</span></code>.
According to this output, the relevant parameter set is
named <code class="docutils literal"><span class="pre">'krylov_solver'</span></code>, and the parameters are set like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c1"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.</p>
<p>We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;dolfin_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>If a <code class="docutils literal"><span class="pre">dolfin_parameters.xml</span></code> file is found in the directory where a
FEniCS program is run, this file is read and used to initialize the
<code class="docutils literal"><span class="pre">parameters</span></code> object. Otherwise, the file
<code class="docutils literal"><span class="pre">.config/fenics/dolfin_parameters.xml</span></code> in the user&#8217;s home directory is
read, if it exists.  Another alternative is to load the XML (with any
name) manually in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;dolfin_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>The XML file can also be in gzip&#8217;ed form with the extension <code class="docutils literal"><span class="pre">.xml.gz</span></code>.</p>
</div>
<div class="section" id="an-extended-solver-function">
<span id="index-12"></span><h4>An extended solver function<a class="headerlink" href="#an-extended-solver-function" title="Permalink to this headline">¶</a></h4>
<p>We may extend the previous solver function from
<code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code> in the section <a class="reference internal" href="#ch-poisson0-impl2-func"><span class="std std-ref">A more general solver function</span></a>
such that it also offers the GMRES+ILU
preconditioned Krylov solver:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u_b</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># Polynomial degree of function space</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c1"># Linear solver method (alt: &#39;direct&#39;)</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c1"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c1"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c1"># Max iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c1"># Amount of solver output</span>
    <span class="n">print_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># Print solver parameters to screen?</span>
    <span class="p">):</span>
    <span class="o">...</span>
    <span class="c1"># Set up variational problem: a, L, declare u, etc.</span>

    <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s1">&#39;Krylov&#39;</span><span class="p">:</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;krylov_solver&#39;</span><span class="p">]</span>
        <span class="n">prm</span><span class="p">[</span><span class="s1">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s1">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s1">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s1">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s1">&#39;ilu&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s1">&#39;lu&#39;</span><span class="p">}</span>

    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>This new <code class="docutils literal"><span class="pre">solver</span></code> function, found in the file
<code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code>, replaces the one in <code class="docutils literal"><span class="pre">ft06_poisson_func.py</span></code>:
it has all the functionality of the previous <code class="docutils literal"><span class="pre">solver</span></code> function,
but can also solve the linear system with
iterative methods and report the progress of such solvers.</p>
</div>
<div class="section" id="a-remark-regarding-unit-tests">
<h4>A remark regarding unit tests<a class="headerlink" href="#a-remark-regarding-unit-tests" title="Permalink to this headline">¶</a></h4>
<p>Regarding verification of the new <code class="docutils literal"><span class="pre">solver</span></code> function in terms of unit
tests, it turns out that unit testing for a problem where the
approximation error vanishes gets more complicated when we use
iterative methods. The problem is to keep the error due to iterative
solution smaller than the tolerance used in the verification
tests. First of all, this means that the tolerances used in the Krylov
solvers must be smaller than the tolerance used in the <code class="docutils literal"><span class="pre">assert</span></code> test,
but this is no guarantee to keep the linear solver error this small.
For linear elements and small meshes, a tolerance of <span class="math">\(10^{-11}\)</span> works
well in the case of Krylov solvers too (using a tolerance <span class="math">\(10^{-12}\)</span>
in those solvers). However, as soon as we switch to <span class="math">\(\mathsf{P}_2\)</span>
elements, it is hard to force the linear solver error below
<span class="math">\(10^{-6}\)</span>. Consequently, tolerances in tests depend on the numerical
method being used. The interested reader is referred to the
<code class="docutils literal"><span class="pre">test_solver</span></code> function in <code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code> for details:
this function tests the numerical solution for direct and iterative
linear solvers, for different meshes, and different degrees of the
polynomials in the finite element basis functions.</p>
</div>
</div>
<div class="section" id="list-of-linear-solver-methods-and-preconditioners">
<span id="ftut-app-solver-prec"></span><h3>List of linear solver methods and preconditioners<a class="headerlink" href="#list-of-linear-solver-methods-and-preconditioners" title="Permalink to this headline">¶</a></h3>
<p>Which linear solvers and preconditioners that are available
in FEniCS depends on how FEniCS has been configured and which
linear algebra backend is currently active. The following table
shows an example of which linear solvers that can be available
through FEniCS when the PETSc backend is active:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'bicgstab'</span></code></td>
<td>Biconjugate gradient stabilized method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'cg'</span></code></td>
<td>Conjugate gradient method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'gmres'</span></code></td>
<td>Generalized minimal residual method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'minres'</span></code></td>
<td>Minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'petsc'</span></code></td>
<td>PETSc built in LU solver</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'richardson'</span></code></td>
<td>Richardson method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'superlu_dist'</span></code></td>
<td>Parallel SuperLU</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'tfqmr'</span></code></td>
<td>Transpose-free quasi-minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'umfpack'</span></code></td>
<td>UMFPACK</td>
</tr>
</tbody>
</table>
<p>The set of available preconditioners also depends on configuration and
linear algebra backend. The following table shows an example of which
preconditioners may be available:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'icc'</span></code></td>
<td>Incomplete Cholesky factorization</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ilu'</span></code></td>
<td>Incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'petsc_amg'</span></code></td>
<td>PETSc algebraic multigrid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'sor'</span></code></td>
<td>Successive over-relaxation</td>
</tr>
</tbody>
</table>
<p>An up-to-date list of the available solvers and preconditioners
for your FEniCS installation can be produced by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">list_linear_solver_methods</span><span class="p">()</span>
<span class="n">list_krylov_solver_preconditioners</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="linear-variational-problem-and-solver-objects">
<span id="ch-poisson0-solver-problem"></span><h3>Linear variational problem and solver objects<a class="headerlink" href="#linear-variational-problem-and-solver-objects" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-13"></span><span class="target" id="index-14"></span><p id="index-15">The FEniCS interface allows different ways to access the core
functionality, ranging from very high-level to low-level access. So
far, we have mostly used the high-level call <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> to
solve a variational problem <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">L</span></code> with a certain boundary condition
<code class="docutils literal"><span class="pre">bc</span></code>. However, sometimes you may need more fine-grained control over
the solution process. In particular, the call to <code class="docutils literal"><span class="pre">solve</span></code> will create
certain objects that are thrown away after the solution has been
computed, and it may be practical or efficient to <em>reuse</em> those
objects.</p>
<p>In this section, we will look an alternative interface to solving
linear variational problems in FEniCS, which may be preferable in
many situations compared to the high-level <code class="docutils literal"><span class="pre">solve</span></code> function interface.
This interface uses the two classes <code class="docutils literal"><span class="pre">LinearVariationalProblem</span></code> and
<code class="docutils literal"><span class="pre">LinearVariationalSolver</span></code>. Using this interface, the equivalent of
<code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Many FEniCS objects have an attribute <code class="docutils literal"><span class="pre">parameters</span></code> corresponding to
a parameter set in the global <code class="docutils literal"><span class="pre">parameters</span></code> database,
but local to the object. Here, <code class="docutils literal"><span class="pre">solver.parameters</span></code> play that
role. Setting the CG method with ILU preconditioning as the solution
method and specifying solver-specific parameters can be done
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gmres&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ilu&#39;</span>
<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c1"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Settings in the global <code class="docutils literal"><span class="pre">parameters</span></code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as above. Note that global parameter
values can only affect local parameter values if set before the time
of creation of the local object. Thus, changing the value of the
tolerance in the global parameter database will not affect the
parameters for already created solvers.</p>
<p>The linear variational problem and solver objects as outlined above
are incorporated in an alternative solver function, named
<code class="docutils literal"><span class="pre">solver_objects</span></code>, in
<code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code>. Otherwise, this function is similar to the
previously shown <code class="docutils literal"><span class="pre">solver</span></code> function.</p>
</div>
<div class="section" id="explicit-assembly-and-solve">
<span id="ch-poisson0-linalg"></span><h3>Explicit assembly and solve<a class="headerlink" href="#explicit-assembly-and-solve" title="Permalink to this headline">¶</a></h3>
<p>As we saw already in the section <a class="reference internal" href="._ftut1004.html#ftut1-ns"><span class="std std-ref">The Navier - Stokes equations</span></a>, linear variational
problems can be assembled explicitly in FEniCS into matrices and
vectors using the <code class="docutils literal"><span class="pre">assemble</span></code> function. This allows even more
fine-grained control of the solution process compared to using the
high-level <code class="docutils literal"><span class="pre">solve</span></code> function or using the class
<code class="docutils literal"><span class="pre">LinearVariationalSolver</span></code>. We will now look more closely into how to
use the <code class="docutils literal"><span class="pre">assemble</span></code> function and how to combine this with low-level
calls for solving the assembled linear systems.</p>
<p>Given a variational problem <span class="math">\(a(u,v)=L(v)\)</span>, the discrete solution <span class="math">\(u\)</span>
is computed by inserting <span class="math">\(u=\sum_{j=1}^N U_j \phi_j\)</span> into <span class="math">\(a(u,v)\)</span> and
demanding <span class="math">\(a(u,v)=L(v)\)</span> to be fulfilled for <span class="math">\(N\)</span> test functions
<span class="math">\(\hat\phi_1,\ldots,\hat\phi_N\)</span>. This implies</p>
<div class="math">
\[\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,\]</div>
<p>which is nothing but a linear system,</p>
<div class="math">
\[AU = b,\]</div>
<p>where the entries of <span class="math">\(A\)</span> and <span class="math">\(b\)</span> are given by</p>
<div class="math">
\[\begin{split}\begin{align*}
  A_{ij} &amp;= a(\phi_j, \hat{\phi}_i), \\
  b_i &amp;= L(\hat\phi_i){\thinspace .}
\end{align*}\end{split}\]</div>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><p id="index-18">The examples so far have specified the left- and right-hand sides of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it. An alternative is to explicitly call
functions for assembling the coefficient matrix <span class="math">\(A\)</span> and the right-hand
side vector <span class="math">\(b\)</span>, and then solve the linear system <span class="math">\(AU=b\)</span> for
the vector <span class="math">\(U\)</span>. Instead of <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> we now write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> are the same as before; that is, <code class="docutils literal"><span class="pre">a</span></code> refers
to the bilinear form involving a <code class="docutils literal"><span class="pre">TrialFunction</span></code> object <code class="docutils literal"><span class="pre">u</span></code>
and a <code class="docutils literal"><span class="pre">TestFunction</span></code> object <code class="docutils literal"><span class="pre">v</span></code>, and <code class="docutils literal"><span class="pre">L</span></code> involves the same <code class="docutils literal"><span class="pre">TestFunction</span></code>
object <code class="docutils literal"><span class="pre">v</span></code>. From <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code>, the <code class="docutils literal"><span class="pre">assemble</span></code> function can compute
<span class="math">\(A\)</span> and <span class="math">\(b\)</span>.</p>
<p>Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, <span class="math">\(A\)</span> may
be constant throughout a time-dependent simulation, so we can avoid
recalculating <span class="math">\(A\)</span> at every time level and save a significant amount
of simulation time.</p>
<p>The matrix <span class="math">\(A\)</span> and vector <span class="math">\(b\)</span> are first assembled without
incorporating essential (Dirichlet) boundary conditions. Thereafter,
the call <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> performs the necessary modifications of the
linear system such that <code class="docutils literal"><span class="pre">u</span></code> is guaranteed to equal the prescribed
boundary values. When we have multiple Dirichlet conditions stored in
a list <code class="docutils literal"><span class="pre">bcs</span></code>, we must apply each condition in <code class="docutils literal"><span class="pre">bcs</span></code> to the system:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># bcs is a list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-19">Alternatively, we can use the function <code class="docutils literal"><span class="pre">assemble_system</span></code>, which takes
the boundary conditions into account during the assembly of the matrix
and vector:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble_system</span></code> function is preferable to the combination of
<code class="docutils literal"><span class="pre">assemble</span></code> and <code class="docutils literal"><span class="pre">bc.apply</span></code> when the linear system is symmetric, since
<code class="docutils literal"><span class="pre">assembly_system</span></code> will incorporate the boundary conditions in a
symmetric way. Even if the matrix <code class="docutils literal"><span class="pre">A</span></code> that comes out of the call to
<code class="docutils literal"><span class="pre">assemble</span></code> for a symmetric bilinear form <code class="docutils literal"><span class="pre">a</span></code>, the call to <code class="docutils literal"><span class="pre">bc.apply</span></code>
will break the symmetry.</p>
<p>Once the linear system has been assembled, we need to compute the
solution <span class="math">\(U=A^{-1}b\)</span> and store the solution <span class="math">\(U\)</span> in the vector
<code class="docutils literal"><span class="pre">U</span> <span class="pre">=</span> <span class="pre">u.vector()</span></code>. In the same way as linear variational problems can be
programmed using different interfaces in FEniCS&#8212;the high-level
<code class="docutils literal"><span class="pre">solve</span></code> function, the class <code class="docutils literal"><span class="pre">LinearVariationalSolve</span></code>, and the
low-level <code class="docutils literal"><span class="pre">assemble</span></code> function&#8212;linear systems can also be programmed
using different interfaces in FEniCS. The high-level interface to
solving a linear system in FEniCS also named <code class="docutils literal"><span class="pre">solve</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, <code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> uses sparse LU decomposition to compute
the solution. Specification of an iterative solver and preconditioner
can be made through two optional arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Appropriate names of solvers and preconditioners are found in
the section <a class="reference internal" href="#ftut-app-solver-prec"><span class="std std-ref">List of linear solver methods and preconditioners</span></a>.</p>
<p id="index-20">This high-level interface is useful for many applications, but
sometimes more fine-grained control is needed. One can then create one
or more <code class="docutils literal"><span class="pre">KrylovSolver</span></code> objects that are then used to solve linear
systems. Each different solver object can have its own set of
parameters and selection of iterative method and preconditioner. Here
is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">prm</span><span class="p">[</span><span class="s1">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">solver_linalg</span></code> in the program file
<code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code> implements a solver function where the user
can choose between different types of assembly. The function
<code class="docutils literal"><span class="pre">application_linalg</span></code> runs a test problem on a sequence of meshes and
solves the problem with symmetric and non-symmetric modification of
the system matrix. One can monitor the number of Krylov method
iterations and realize that with a symmetric coefficient matrix, the
Conjugate Gradient method requires slightly fewer iterations than
GMRES in the non-symmetric case. Taking into account that the
Conjugate Gradient method has less work per iteration, there is some
efficiency to be gained by using <code class="docutils literal"><span class="pre">assemble_system</span></code> for this problem.</p>
<p>[<strong>hpl 49</strong>: Running <code class="docutils literal"><span class="pre">application_linalg</span></code>, the results are strange: Why does the <code class="docutils literal"><span class="pre">solve(a==L,...)</span></code> method need many more iterations than <code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b,</span> <span class="pre">...)</span></code> when we use the same Krylov parameter settings? Something wrong with the settings?]</p>
<p>[<strong>AL 50</strong>: I don&#8217;t know. I found a possibly related problem in that <code class="docutils literal"><span class="pre">monitor_convergence</span> <span class="pre">=</span> <span class="pre">True</span></code> had no effect when calling <code class="docutils literal"><span class="pre">solve</span></code> but it worked when setting it on a solver object. Will need to revisit and test run all codes later with latest FEniCS.]
[<strong>hpl 51</strong>: OK.]</p>
<p id="index-21">The choice of start vector for the iterations in a linear solver is
often important. By default, the values of <code class="docutils literal"><span class="pre">u</span></code> and thus the vector <code class="docutils literal"><span class="pre">U</span>
<span class="pre">=</span> <span class="pre">u.vector()</span></code> will be initialized to zero. If instead wanted to
initialize <code class="docutils literal"><span class="pre">U</span></code> with random numbers in the interval <span class="math">\([-100,100]\)</span> this
can be done as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we must both turn off the default behavior of setting the start
vector (&#8220;initial guess&#8221;) to zero, and also set the values of the
vector <code class="docutils literal"><span class="pre">U</span></code> to nonzero values.</p>
<p>Using a nonzero initial guess can be particularly important for
time-dependent problems or when solving a linear system as part of a
nonlinear iteration, since then the previous solution vector <code class="docutils literal"><span class="pre">U</span></code> will
often be a good initial guess for the solution in the next time step
or iteration.</p>
</div>
<div class="section" id="examining-matrix-and-vector-values">
<h3>Examining matrix and vector values<a class="headerlink" href="#examining-matrix-and-vector-values" title="Permalink to this headline">¶</a></h3>
<p>When calling <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">assemble(a)</span></code> and <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">assemble(L)</span></code>, the object <code class="docutils literal"><span class="pre">A</span></code>
will be of type <code class="docutils literal"><span class="pre">Matrix</span></code>, while <code class="docutils literal"><span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">u.vector()</span></code> are of type
<code class="docutils literal"><span class="pre">Vector</span></code>. To examine the values, we may convert the matrix and vector
data to <code class="docutils literal"><span class="pre">numpy</span></code> arrays by calling the <code class="docutils literal"><span class="pre">array()</span></code> method as shown
before. For example, if you wonder how essential boundary conditions are
incorporated into linear systems, you can print out <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code>
before and after the <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span> <span class="c1"># print for small meshes only</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
</pre></div>
</div>
<p>With access to the elements in <code class="docutils literal"><span class="pre">A</span></code> through a <code class="docutils literal"><span class="pre">numpy</span></code> array, we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code class="docutils literal"><span class="pre">eig</span></code> function in <code class="docutils literal"><span class="pre">numpy.linalg</span></code>). We can alternatively dump
<code class="docutils literal"><span class="pre">A.array()</span></code> and <code class="docutils literal"><span class="pre">b.array()</span></code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s1">&#39;Ab.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()})</span>
</pre></div>
</div>
<p>Writing <code class="docutils literal"><span class="pre">load</span> <span class="pre">Ab.mat</span></code> in MATLAB or Octave will then make
the array variables <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> available for computations.</p>
<p id="index-22">Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code class="docutils literal"><span class="pre">numpy</span></code> arrays or matrices in MATLAB file
format are dense matrices. FEniCS also has an interface to the
eigensolver package SLEPc, which is the preferred tool for computing
the eigenvalues of large, sparse matrices of the type encountered in
PDE problems (see <code class="docutils literal"><span class="pre">demo/documented/eigenvalue</span></code> in the FEniCS source
code tree for a demo).</p>
<p>[<strong>AL 52</strong>: Aha, so vc means variable coefficient. Seems to be a mismatch between presenting the example here below and using referring to the example above.]
[<strong>hpl 53</strong>: Moved the code to avoid this mismatch.]</p>
<p>[<strong>AL 54</strong>: I changed the title here and put everything under the common theme &#8216;post-processing&#8217; since flux computation and structured grids are also related to postprocessing (more than to variable coefficient Poisson).]
[<strong>hpl 55</strong>: Fine.]</p>
</div>
</div>
<div class="section" id="postprocessing-computations">
<span id="ftut-possion-2d-varcoeff"></span><h2>Postprocessing computations<a class="headerlink" href="#postprocessing-computations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-23"></span><span class="target" id="index-24"></span><p id="index-25">As the final theme in this chapter, we will look at how to perform
<em>postprocessing computations</em>; that is, how to compute various derived
quantities from the computed solution of a PDE. The solution <span class="math">\(u\)</span>
itself may be of interest for visualizing general features of the
solution, but sometimes one is interested in computing the solution of
a PDE to compute a specific quantity that derives from the solution,
such as, e.g., the flux, a point-value, or some average of the
solution.</p>
<div class="section" id="a-variable-coefficient-poisson-problem">
<h3>A variable-coefficient Poisson problem<a class="headerlink" href="#a-variable-coefficient-poisson-problem" title="Permalink to this headline">¶</a></h3>
<p>As a test problem, we will extend the Poisson problem from the chapter <a class="reference internal" href="._ftut1003.html#ch-fundamentals"><span class="std std-ref">Fundamentals: Solving the Poisson equation</span></a> with a variable coefficient <span class="math">\(p(x,y)\)</span> in the
Laplace operator:</p>
<div class="math" id="eq-ch-poisson0-2d-varcoeff">
\[\begin{split}\tag{95}
\begin{split}
        - \nabla\cdot \left\lbrack
    p(x,y)\nabla u(x,y)\right\rbrack &amp;= f(x,y) \quad \mbox{in } \Omega,
        \\
        u(x,y) &amp;= u_{_\mathrm{D}}(x,y) \quad \mbox{on}\  \partial\Omega{\thinspace .}
      \end{split}\end{split}\]</div>
<p>Let us continue to use our favorite solution <span class="math">\(u(x,y)=1+x^2+2y^2\)</span> and
then prescribe <span class="math">\(p(x,y)=x+y\)</span>. It follows that
<span class="math">\(u_{_\mathrm{D}}(x,y) = 1 + x^2 + 2y^2\)</span> and <span class="math">\(f(x,y)=-8x-10y\)</span>.</p>
<p>We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS
program. The following simple changes must be made to the previously
shown codes:</p>
<blockquote>
<div><ul class="simple">
<li>the <code class="docutils literal"><span class="pre">solver</span></code> function must take <code class="docutils literal"><span class="pre">p</span></code> as argument,</li>
<li>the right-hand side <code class="docutils literal"><span class="pre">f</span></code>
must be an <code class="docutils literal"><span class="pre">Expression</span></code> since it is no longer a constant,</li>
<li>a new <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">p</span></code> must be defined for the variable coefficient,</li>
<li>the formula for <span class="math">\(a(u,v)\)</span> in the variational problem must be updated.</li>
</ul>
</div></blockquote>
<p>We first address the modified variational problem. Multiplying
the PDE by a test function <span class="math">\(v\)</span> and
integrating by parts now results
in</p>
<div class="math">
\[\int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega} p{\partial u\over
\partial n}v {\, \mathrm{d}s} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The function spaces for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the same as in
the problem with <span class="math">\(p=1\)</span>, implying that the boundary integral
vanishes since <span class="math">\(v=0\)</span> on <span class="math">\(\partial\Omega\)</span> where we have Dirichlet conditions.
The variational forms <span class="math">\(a\)</span> and <span class="math">\(L\)</span> in the variational problem
<span class="math">\(a(u,v)=L(v)\)</span> then become</p>
<div class="math" id="eq-auto36">
\[\tag{96}
a(u,v) = \int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x},\quad
    L(v) = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>In the code for solving <span class="math">\(-\nabla^2u=f\)</span> we must thus replace</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>to solve <span class="math">\(-\nabla\cdot(p\nabla u)=f\)</span>. Moreover,
the definitions of <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">f</span></code> in the test problem read</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No additional modifications are necessary. The file
<code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code> (Poisson problem, variable coefficients)
is a copy of <code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code> with the mentioned changes
incorporated. Observe that <span class="math">\(p=1\)</span> recovers the original problem in
<code class="docutils literal"><span class="pre">ft07_poisson_iter.py</span></code>.</p>
<p>[<strong>hpl 56</strong>: Is <code class="docutils literal"><span class="pre">poisson_varcoeff.py</span></code> a better name?]</p>
<p>You can execute the file and confirm that it recovers the exact solution <span class="math">\(u\)</span> at
the nodes.</p>
</div>
<div class="section" id="flux-computations">
<span id="ch-poisson0-gradu"></span><h3>Flux computations<a class="headerlink" href="#flux-computations" title="Permalink to this headline">¶</a></h3>
<p id="index-26">It is often of interest to compute the flux <span class="math">\(Q = -p\nabla u\)</span> is often of interest to compute. Since
<span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>, it follows that</p>
<div class="math">
\[Q = -p\sum_{j=1}^N U_j \nabla \phi_j{\thinspace .}\]</div>
<p>However, the gradient of a piecewise continuous finite element scalar
field is a discontinuous vector field since the basis functions
<span class="math">\(\{\phi_j\}\)</span> have discontinuous derivatives at the boundaries of the
cells. For example, using Lagrange elements of degree 1, <span class="math">\(u\)</span> is linear
over each cell, and the gradient becomes a piecewise
constant vector field. On the contrary, the exact gradient is
continuous. For visualization and data analysis purposes, we often
want the computed gradient to be a continuous vector field. Typically,
we want each component of <span class="math">\(\nabla u\)</span> to be represented in the same way
as <span class="math">\(u\)</span> itself. To this end, we can project the components of <span class="math">\(\nabla
u\)</span> onto the same function space as we used for <span class="math">\(u\)</span>. This means that
we solve <span class="math">\(w = \nabla u\)</span> approximately by a finite element method,
using the same elements for the components of <span class="math">\(w\)</span> as we used for
<span class="math">\(u\)</span>. This process is known as <em>projection</em>.</p>
<span class="target" id="index-27"></span><p id="index-28">Projection is a common operation in finite element analysis and FEniCS
has a function for easily performing the projection:
<code class="docutils literal"><span class="pre">project(expression,</span> <span class="pre">W)</span></code>, which returns the projection of some
expression into the space <code class="docutils literal"><span class="pre">W</span></code>. In our case, the flux <span class="math">\(Q = -p\nabla u\)</span>
is vector-valued and we need to pick <code class="docutils literal"><span class="pre">W</span></code> as the vector-valued function
space of the same degree as the space <code class="docutils literal"><span class="pre">V</span></code> where <code class="docutils literal"><span class="pre">u</span></code> resides:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
<span class="n">degree</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">(),</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

<span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">W</span><span class="p">)</span>
<span class="n">flux_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p>An appropriate function for computing the flux based on <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">p</span></code> is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return -p*grad(u) projected into same space as u.&quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="n">flux_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">W</span><span class="p">)</span>
    <span class="n">flux_u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;flux(u)&#39;</span><span class="p">,</span> <span class="s1">&#39;continuous flux field&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flux_u</span>
</pre></div>
</div>
<p>The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.</p>
<p>Plotting the flux vector field is naturally as easy as plotting
anything else:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;flux field&#39;</span><span class="p">)</span>

<span class="n">flux_x</span><span class="p">,</span> <span class="n">flux_y</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;x-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;y-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">deepcopy=True</span></code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code class="docutils literal"><span class="pre">deepcopy=False</span></code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)</p>
<span class="target" id="index-29"></span><span class="target" id="index-30"></span><p id="index-31">For data analysis of the nodal values of the flux field we can
grab the underlying <code class="docutils literal"><span class="pre">numpy</span></code> arrays (which demands a <code class="docutils literal"><span class="pre">deepcopy=True</span></code>
in the split of <code class="docutils literal"><span class="pre">flux</span></code>):</p>
<p>[<strong>AL 57</strong>: Suggest we use <code class="docutils literal"><span class="pre">_dofs</span></code> instead of <code class="docutils literal"><span class="pre">_array</span></code> everywhere. Have made similar changes in previous chapters before.]
[<strong>hpl 58</strong>: OK! But found quite some <code class="docutils literal"><span class="pre">u_array</span></code> in the very first Poisson example. Should we keep the name there and <code class="docutils literal"><span class="pre">dofs</span></code> everywhere else, after the difference in numbering is explained? Sounds consistent to me.]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">flux_x_dofs</span> <span class="o">=</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">dofs</span><span class="p">()</span>
<span class="n">flux_y_dofs</span> <span class="o">=</span> <span class="n">flux_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">dofs</span><span class="p">()</span>
</pre></div>
</div>
<p>The degrees of freedom of the <code class="docutils literal"><span class="pre">flux_u</span></code> vector field can also be
reached by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">flux_u_dofs</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>However, this is a flat <code class="docutils literal"><span class="pre">numpy</span></code> array containing the degrees of
freedom for both the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> components of the flux and the
ordering of the components may be mixed up by FEniCS in order to
improve computational efficiency.</p>
<p>The function <code class="docutils literal"><span class="pre">application_test_flux</span></code> in the program
<code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code> demonstrates the computations described
above.</p>
<div class="admonition-manual-projection admonition">
<p class="first admonition-title">Manual projection</p>
<p>Although you will always use <code class="docutils literal"><span class="pre">project</span></code> to project a finite element
function, it can be instructive to look at how to formulate the
projection mathematically and implement its steps manually in FEniCS.</p>
<p class="last">Let&#8217;s say we have an expression <span class="math">\(g = g(u)\)</span> that we want to project
into some space <span class="math">\(W\)</span>. The mathematical formulation of the (<span class="math">\(L^2\)</span>)
projection <span class="math">\(w = P_W g\)</span> into <span class="math">\(W\)</span> is the variational problem</p>
</div>
<div class="math" id="eq-auto37">
\[ \begin{align}\begin{aligned} \tag{97}
 \int_{\Omega} w v {\, \mathrm{d}x} = \int_{\Omega} g v {\, \mathrm{d}x}\\for all test functions  \( v \) . In other words we have a
standard variational problem  \( a(w, v) = L(v) \)  where now\\.. _Eq:_auto38:\end{aligned}\end{align} \]</div>
<div class="math">
\[ \begin{align}\begin{aligned} \tag{98}
 a(w, v) = \int_\Omega w v {\, \mathrm{d}x},\\.. _Eq:_auto39:\end{aligned}\end{align} \]</div>
<div class="math">
\[ \begin{align}\begin{aligned} \tag{99}
 L(v) = \int_\Omega g v {\, \mathrm{d}x}{\thinspace .}\\Note that when the functions in  \( W \)  are vector-valued, as is the case
when we project the gradient  \( g(u) = \nabla u \) , we must replace the
products above by  \( w\cdot v \)  and  \( g\cdot v \) .\\The variational problem is easy to define in FEniCS.\\.. code-block:: python\\    w = TrialFunction(W)
    v = TestFunction(W)\\    a = w*v*dx # or dot(w, v)*dx when w is vector-valued
    L = g*v*dx # or dot(g, v)*dx when g is vector-valued
    w = Function(W)
    solve(a == L, w)\\The boundary condition argument to ``solve`` is dropped since there are
no essential boundary conditions in this problem.\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="taking-advantage-of-structured-mesh-data">
<span id="ftut-structviz"></span><h3>Taking advantage of structured mesh data<a class="headerlink" href="#taking-advantage-of-structured-mesh-data" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-32"></span><span class="target" id="index-33"></span><p id="index-34">[<strong>AL 59</strong>: I haven&#8217;t read this section yet. Is it necessary to include? If we need to save pages, this is the section I would drop. Since we can easily visualize unstructured mesh data, this looks to me like a complicated way to perform something we can already do by calling <code class="docutils literal"><span class="pre">plot</span></code> or saving to Paraview. It also relies on a non-standard utility (<code class="docutils literal"><span class="pre">BoxField</span></code>).]
[<strong>hpl 60</strong>: A lot of readers come from the finite difference world and also from MATLAB computations of 2D scalar and vector fields. These are used to structured meshes and corresponding tools. At least students will ask you why you cannot to MATLAB-style data analysis in 2D/3D arrays when you have solved Poisson on a square. We may move to vol II, but I refer to these recipes so often that they need to be documented somewhere, and the FEniCS tutorial is natural...]</p>
<p>Many readers have extensive experience with visualization and data
analysis of 1D, 2D, and 3D scalar and vector fields on <em>uniform,
structured meshes</em>, while FEniCS solvers exclusively work with
<em>unstructured</em> meshes.  The collection software and mathematical
techniques for investigating scalar and vector fields on structured
meshes is much broader than for the unstructured ones, so when we
finite element computations actually take place on a uniform,
structured mesh, it is advantageous to extract the results in data
structures based on a structured mesh assumption. The present section
shows how that can be done. It allows, for example, standard
techniques in MATLAB or NumPy to be used to analyze finite element
computations.</p>
<p id="index-35">A necessary first step is to transform our <code class="docutils literal"><span class="pre">mesh</span></code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
second step is to transform the one-dimensional array of nodal values
to a two-dimensional array holding the values at the corners of the
cells in the structured mesh. We want to access a value by its <span class="math">\(i\)</span> and
<span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span> direction, and <span class="math">\(j\)</span> counting
cells in the <span class="math">\(y\)</span> direction.  This transformation is in principle
straightforward, yet it frequently leads to obscure indexing errors,
so using software tools to ease the work is advantageous.</p>
<p>In the directory <code class="docutils literal"><span class="pre">src/modules</span></code>, associated with this booklet, we have
included a Python module <code class="docutils literal"><span class="pre">BoxField</span></code> that can take a finite element
function <code class="docutils literal"><span class="pre">u</span></code> computed by a FEniCS software and represent it on a
structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code class="docutils literal"><span class="pre">[i]</span></code> in 1D, <code class="docutils literal"><span class="pre">[i,j]</span></code> in 2D, and <code class="docutils literal"><span class="pre">[i,j,k]</span></code>
in 3D. Given a finite element function <code class="docutils literal"><span class="pre">u</span></code>, the following function
returns a <code class="docutils literal"><span class="pre">BoxField</span></code> object that represents <code class="docutils literal"><span class="pre">u</span></code> on a structured mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">divisions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span class="c1"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
         <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">BoxField</span> <span class="kn">import</span> <span class="n">fenics_function2BoxField</span>
    <span class="n">u_box</span> <span class="o">=</span> <span class="n">fenics_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">divisions</span><span class="p">,</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_box</span>
</pre></div>
</div>
<p>Note that we can only turn functions on meshes with P1 elements into
<code class="docutils literal"><span class="pre">BoxField</span></code> objects, so if <code class="docutils literal"><span class="pre">u</span></code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code class="docutils literal"><span class="pre">divisions</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">u_box</span></code> object contains several useful data structures:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u_box.grid</span></code>: object for the structured mesh</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">X=0</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Y=1</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Z=2</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[X]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>
(for vectorized computations or surface plotting)</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Y]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Z]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.values</span></code>: <code class="docutils literal"><span class="pre">numpy</span></code> array holding the <code class="docutils literal"><span class="pre">u</span></code> values;
<code class="docutils literal"><span class="pre">u_box.values[i,j]</span></code> holds <code class="docutils literal"><span class="pre">u</span></code> at the mesh point with coordinates</li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">(u_box.grid.coor[X],</span> <span class="pre">u_box.grid.coor[Y])</span></code></div>
</div>
<div class="section" id="iterating-over-points-and-values">
<h4>Iterating over points and values<a class="headerlink" href="#iterating-over-points-and-values" title="Permalink to this headline">¶</a></h4>
<p>Let us go back to the <code class="docutils literal"><span class="pre">solver</span></code> function in the
<code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code> code from
the section <a class="reference internal" href="#ftut-possion-2d-varcoeff"><span class="std std-ref">Postprocessing computations</span></a>, compute <code class="docutils literal"><span class="pre">u</span></code>, map it onto a
<code class="docutils literal"><span class="pre">BoxField</span></code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_b</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span>       <span class="c1"># numpy array</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c1"># for indexing in x and y direction</span>

<span class="c1"># Iterate over 2D mesh points (i,j)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;u_ is defined on a structured mesh with </span><span class="si">%s</span><span class="s1"> points&#39;</span> <span class="o">%</span>
      <span class="nb">str</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;u[</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">]=u(</span><span class="si">%g</span><span class="s1">,</span><span class="si">%g</span><span class="s1">)=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
               <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
               <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="finite-difference-approximations">
<h4>Finite difference approximations<a class="headerlink" href="#finite-difference-approximations" title="Permalink to this headline">¶</a></h4>
<p>Note that with <code class="docutils literal"><span class="pre">u_</span></code>, we can easily express finite difference approximation
of derivatives:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u_xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="surface-plot">
<span id="index-36"></span><h4>Surface plot<a class="headerlink" href="#surface-plot" title="Permalink to this headline">¶</a></h4>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a class="reference internal" href="#ftut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper left):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span>  <span class="c1"># vectorized mesh coordinates</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span>
                <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Surface plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The key issue is to know that the coordinates needed for the surface
plot is in <code class="docutils literal"><span class="pre">u_box.grid.coorv</span></code> and that the values are in <code class="docutils literal"><span class="pre">u_</span></code>.</p>
<div class="figure" id="id1">
<span id="ftut-structviz-fig1"></span><a class="reference internal image-reference" href="_images/poisson_vc_structmesh2.png"><img alt="_images/poisson_vc_structmesh2.png" src="_images/poisson_vc_structmesh2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Various plots of the solution on a structured mesh</em></span></p>
</div>
</div>
<div class="section" id="contour-plot">
<span id="index-37"></span><h4>Contour plot<a class="headerlink" href="#contour-plot" title="Permalink to this headline">¶</a></h4>
<p>A contour plot can also be made by Matplotlib:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>  <span class="c1"># add labels to contour lines</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Contour plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result appears in Figure <a class="reference internal" href="#ftut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper right).</p>
</div>
<div class="section" id="curve-plot-through-the-mesh">
<h4>Curve plot through the mesh<a class="headerlink" href="#curve-plot-through-the-mesh" title="Permalink to this headline">¶</a></h4>
<p>A handy feature of <code class="docutils literal"><span class="pre">BoxField</span></code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot <span class="math">\(u\)</span> along
the line <span class="math">\(y=0.4\)</span>. The mesh points, <code class="docutils literal"><span class="pre">x</span></code>, and the <span class="math">\(u\)</span> values
along this line, <code class="docutils literal"><span class="pre">u_val</span></code>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal"><span class="pre">snapped</span></code> is true if the line had to be snapped onto a
gridline and in that case <code class="docutils literal"><span class="pre">y_fixed</span></code> holds the snapped
(altered) <span class="math">\(y\)</span> value. To avoid interpolation in the structured mesh,
<code class="docutils literal"><span class="pre">snapped</span></code> is in fact <em>always</em> true.</p>
<p>A comparison of the numerical and exact solution along the line
<span class="math">\(y=0.5\)</span> (snapped from <span class="math">\(y=0.4\)</span>) is made by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">u_e_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_b</span><span class="p">((</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">))</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e_val</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Solution along line y=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See Figure <a class="reference internal" href="#ftut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (lower left) for the resulting curve plot.</p>
</div>
<div class="section" id="curve-plot-of-the-flux">
<h4>Curve plot of the flux<a class="headerlink" href="#curve-plot-of-the-flux" title="Permalink to this headline">¶</a></h4>
<p>Let us also compare the numerical and
exact flux <span class="math">\(-p\partial u/\partial x\)</span> along the same line as above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">flux_u</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">flux_u_x</span><span class="p">,</span> <span class="n">flux_u_y</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Plot the numerical and exact flux along the same line</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_u_x</span> <span class="k">if</span> <span class="n">flux_u_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> \
          <span class="k">else</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span>
               <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span>
                             <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_u_x_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">flux_u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
<span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
   <span class="n">flux_u_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_x_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Flux along line y=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The second <code class="docutils literal"><span class="pre">plt.plot</span></code> command
requires a Python function <code class="docutils literal"><span class="pre">flux_u_x_exact(x,y)</span></code> to be
available for the exact flux expression.</p>
<p>Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a class="reference external" href="https://github.com/hplgit/scitools">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.</p>
</div>
<div class="section" id="test-problem-5">
<span id="index-38"></span><h4>Test problem<a class="headerlink" href="#test-problem-5" title="Permalink to this headline">¶</a></h4>
<p>The graphics referred to in Figure <a class="reference internal" href="#ftut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> correspond to
a test problem with prescribed solution <span class="math">\({u_{\small\mbox{e}}} = H(x)H(y)\)</span>, where</p>
<div class="math">
\[H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x){\thinspace .}\]</div>
<p>We just fit a function <span class="math">\(f(x,y)\)</span> in the PDE (can choose <span class="math">\(p=1\)</span>),
and notice that <span class="math">\(u=0\)</span> along the
boundary of the unit square. Although it is easy to carry out the
differentiation of <span class="math">\(f\)</span> by hand and hardcode the resulting expressions
in an <code class="docutils literal"><span class="pre">Expression</span></code> object, a more reliable habit is to use Python&#8217;s
symbolic computing engine, SymPy, to perform mathematics and
automatically turn formulas into C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects.
A short introduction was given in
the section <a class="reference internal" href="._ftut1004.html#ftut-nonlinear-newton-auto"><span class="std std-ref">A simple FEniCS implementation</span></a>.</p>
<p>We start out with defining the exact solution in <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>  <span class="c1"># for use in math formulas</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">H</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x[0], x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">H</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Turning the expression for <code class="docutils literal"><span class="pre">u</span></code> into C or C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects
needs two steps. First we ask for the C code of the expression,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Printing out <code class="docutils literal"><span class="pre">u_c</span></code> gives (the output is here manually broken into two
lines):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
</div>
<p>The necessary syntax adjustment is replacing
the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> for <span class="math">\(\pi\)</span> in C/C++ by <code class="docutils literal"><span class="pre">pi</span></code> (or <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_c</span> <span class="o">=</span> <span class="n">u_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s1">&#39;pi&#39;</span><span class="p">)</span>
<span class="n">u_b</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_c</span><span class="p">)</span>
</pre></div>
</div>
<p>Thereafter, we can progress with the computation of <span class="math">\(f = -\nabla\cdot(p\nabla u)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">f_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s1">&#39;pi&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_c</span><span class="p">)</span>
</pre></div>
</div>
<p>We also need a Python function for the exact flux <span class="math">\(-p\partial u/\partial x\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">flux_u_x_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                              <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It remains to define <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Constant(1)</span></code> and set <code class="docutils literal"><span class="pre">nx</span></code> and <code class="docutils literal"><span class="pre">ny</span></code> before calling
<code class="docutils literal"><span class="pre">solver</span></code> to compute the finite element solution of this problem.</p>
</div>
</div>
<div class="section" id="computing-functionals">
<span id="ch-poisson0-functionals"></span><h3>Computing functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h3>
<p id="index-39">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally want to compute
functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="eq-ch-poisson0-functionals-energy">
\[\tag{100}
{1\over2}||\nabla u||^2 = {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},\]</div>
<p>which often reflects some energy quantity.
Another frequently occurring functional is the error</p>
<div class="math" id="eq-ch-poisson0-functionals-error">
\[\tag{101}
||{u_{\small\mbox{e}}}-u|| = \left(\int_\Omega ({u_{\small\mbox{e}}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>where <span class="math">\({u_{\small\mbox{e}}}\)</span> is the exact solution. The error is of particular
interest when studying convergence properties of finite element
methods. Other times, we may instead be interested in computing
the flux out of a part
<span class="math">\(\Gamma\)</span> of the boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="eq-ch-poisson0-functionals-flux">
\[\tag{102}
F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},\]</div>
<p>where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and <span class="math">\(p\)</span> is a
coefficient (see the problem in the section <a class="reference internal" href="#ftut-possion-2d-varcoeff"><span class="std std-ref">Postprocessing computations</span></a>
for a specific example).</p>
<p>All these functionals are easy to compute with FEniCS, as we shall see
in the examples below.</p>
<div class="section" id="energy-functional">
<span id="index-40"></span><h4>Energy functional<a class="headerlink" href="#energy-functional" title="Permalink to this headline">¶</a></h4>
<p>The integrand of the energy functional
<a class="reference internal" href="#eq-ch-poisson0-functionals-energy"><span class="std std-ref">(100)</span></a> is described in the UFL
language in the same manner as we describe weak forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The functional <code class="docutils literal"><span class="pre">energy</span></code> is evaluated by calling the <code class="docutils literal"><span class="pre">assemble</span></code>
function that we have previously used to assemble matrices and
vectors. FEniCS will recognize that the form has &#8216;&#8217;rank 0&#8217;&#8217; (since it
contains no trial and test functions) and return the result as a
scalar value.</p>
</div>
<div class="section" id="error-functional">
<span id="index-41"></span><h4>Error functional<a class="headerlink" href="#error-functional" title="Permalink to this headline">¶</a></h4>
<p>Computing the functional <a class="reference internal" href="#eq-ch-poisson0-functionals-error"><span class="std std-ref">(101)</span></a> can be
done as follows:
by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> is here in a <code class="docutils literal"><span class="pre">Function</span></code> or <code class="docutils literal"><span class="pre">Expression</span></code>
object <code class="docutils literal"><span class="pre">u_exact</span></code>, while <code class="docutils literal"><span class="pre">u</span></code> is the finite element approximation.
Sometimes, for very small error values, the result of
<code class="docutils literal"><span class="pre">assemble(error)</span></code> can be a (very small) negative number, so we have
used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive value
for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.</p>
<p>As will be explained and demonstrated in the section <a class="reference internal" href="#ch-poisson0-convrates"><span class="std std-ref">Computing convergence rates</span></a>, the integration of <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_exact)**2*dx</span></code>
can result in too optimistic convergence rates unless one is careful
how <code class="docutils literal"><span class="pre">u_exact</span></code> is transferred onto a mesh. The general recommendation
for reliable error computation is to use the <code class="docutils literal"><span class="pre">errornorm</span></code> function (see
<code class="docutils literal"><span class="pre">help(errornorm)</span></code> and the section <a class="reference internal" href="#ch-poisson0-convrates"><span class="std std-ref">Computing convergence rates</span></a> for
more information):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="flux-functional">
<span id="index-42"></span><h4>Flux Functional<a class="headerlink" href="#flux-functional" title="Permalink to this headline">¶</a></h4>
<p>To compute flux integrals like <span class="math">\(F = -\int_\Gamma p\nabla
u\cdot\boldsymbol{n} {\, \mathrm{d}s}\)</span>, we need to define the <span class="math">\(\boldsymbol{n}\)</span> vector,
referred to as <em>facet normal</em> in FEniCS. If the surface domain
<span class="math">\(\Gamma\)</span> in the flux integral is the complete boundary, we can perform
the flux computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <code class="docutils literal"><span class="pre">grad(u)</span></code> and <code class="docutils literal"><span class="pre">grad(u)</span></code> are interchangeable in the above
expression when <code class="docutils literal"><span class="pre">u</span></code> is a scalar function, we have chosen to write
<code class="docutils literal"><span class="pre">grad(u)</span></code> because this is the right expression if we generalize the
underlying equation to a vector Laplace/Poisson PDE. With <code class="docutils literal"><span class="pre">grad(u)</span></code> we
must in that case write <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></code>.</p>
<p>[<strong>AL 61</strong>: Figure out which one is <code class="docutils literal"><span class="pre">grad</span></code> and which one is <code class="docutils literal"><span class="pre">nabla_grad</span></code> above... :-)]
[<strong>hpl 62</strong>: Depends on what <code class="docutils literal"><span class="pre">u</span></code> is; no difference for scalar <code class="docutils literal"><span class="pre">u</span></code>, otherwise I&#8217;m pretty sure the natural dyadic normal derivative has <code class="docutils literal"><span class="pre">n</span></code> coming in from the left in the math so it should be <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">nabla_grad(u))</span></code>. We should change the formula then to <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></code> even here.]</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as explained in
the section <a class="reference internal" href="._ftut1005.html#ch-poisson0-multi-bc"><span class="std std-ref">Setting multiple Neumann, Robin, and Dirichlet conditions</span></a>. Assuming that the part corresponds
to subdomain number <code class="docutils literal"><span class="pre">i</span></code>, the relevant syntax for the variational
formulation of the flux is <code class="docutils literal"><span class="pre">-p*dot(grad(u),</span> <span class="pre">n)*ds(i)</span></code>.</p>
</div>
</div>
<div class="section" id="computing-convergence-rates-1">
<span id="ch-poisson0-convrates"></span><h3>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates-1" title="Permalink to this headline">¶</a></h3>
<p>[<strong>hpl 63</strong>: Newer FEniCS examples have <code class="docutils literal"><span class="pre">dx(degree)</span></code>. Should explain that syntax. Also <code class="docutils literal"><span class="pre">Expression(string,</span> <span class="pre">degree)</span></code>.]</p>
<p>A central question for any numerical method is its <em>convergence rate</em>:
how fast does the error approach zero when the resolution is
increased? For finite element methods, this typically corresponds to
proving, theoretically or empirically, that the error <span class="math">\(e = {u_{\small\mbox{e}}} - u\)</span>
is bounded by the mesh size <span class="math">\(h\)</span> to some power <span class="math">\(r\)</span>; that is, <span class="math">\(\|e\|
\leq C h^r\)</span> for some constant <span class="math">\(C\)</span>. The number <span class="math">\(r\)</span> is called the
<em>convergence rate</em> of the method. Note that different norms, like the
<span class="math">\(L^2\)</span>-norm <span class="math">\(\|e\|\)</span> or <span class="math">\(H^1_0\)</span>-norm <span class="math">\(\|\nabla e\|\)</span> typically have
different convergence rates.</p>
<p>To illustrate how to compute errors and convergence rates in FEniCS,
we have included the function <code class="docutils literal"><span class="pre">convergence_rate</span></code> in
<code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code>. This is a tool that is very handy
when verifying finite element codes and will therefore be explained in
detail here.</p>
<div class="section" id="computing-error-norms">
<h4>Computing error norms<a class="headerlink" href="#computing-error-norms" title="Permalink to this headline">¶</a></h4>
<p>The <span class="math">\(L^2\)</span>-norm of the error in a finite element approximation <span class="math">\(u\)</span>,
<span class="math">\({u_{\small\mbox{e}}}\)</span> being the exact solution, is given by</p>
<div class="math">
\[E = \left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>and can be implemented in FEniCS by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>As above, we have used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure
a positive value for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.</p>
<p>It is important to understand how FEniCS computes the error from the
above code, since we may otherwise run into subtle issues when using
the value for computing convergence rates. The first subtle issue is
that if <code class="docutils literal"><span class="pre">u_e</span></code> is not already finite element function (an object create
using <code class="docutils literal"><span class="pre">Function(V)</span></code>), which is the case if <code class="docutils literal"><span class="pre">u_e</span></code> is defined as an
<code class="docutils literal"><span class="pre">Expression</span></code>, FEniCS must interpolate <code class="docutils literal"><span class="pre">u_e</span></code> into some local finite
element space on each element of the mesh. The degree used for the
interpolation is determined by the mandatory keyword argument to the
<code class="docutils literal"><span class="pre">Expression</span></code> class, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;sin(x[0])&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that the error computed will not be equal to the actual
error <span class="math">\(\|{u_{\small\mbox{e}}} - u\|\)</span> but rather the difference between the finite
element solution <span class="math">\(u\)</span> and the piecewise linear interpolant of
<span class="math">\({u_{\small\mbox{e}}}\)</span>. This may yield a too optimistic (too small) value for the
error. A better value may be achieved by interpolating the exact
solution into a higher-order function space, which can be done by
simply increasing the degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;sin(x[0])&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The second subtle issue is that when FEniCS evaluates the expression
<code class="docutils literal"><span class="pre">(u_ex</span> <span class="pre">-</span> <span class="pre">u)**2</span></code>, this will be expanded into <code class="docutils literal"><span class="pre">u_ex**2</span> <span class="pre">+</span> <span class="pre">u**2</span> <span class="pre">-</span>
<span class="pre">2*u_ex*u</span></code>. If the error is small (and the solution itself is of
moderate size), this calculation will correspond to the subtraction of
two positive numbers (<code class="docutils literal"><span class="pre">u_ex**2</span> <span class="pre">+</span> <span class="pre">u**2</span></code> <span class="math">\(\sim 1\)</span> and <code class="docutils literal"><span class="pre">2*u_ex*u</span></code> <span class="math">\(\sim
1\)</span>) yielding a small number. Such a computation is very prone to
round-off errors, which may again lead to an unreliable value for the
error. To make this situation worse, FEniCS may expand this
computation into a large number of terms, in particular for higher
order elements, making the computation very unstable.</p>
<p>To help with these issues, FEniCS provides the built-in function
<code class="docutils literal"><span class="pre">errornorm</span></code> which computes the error norm in a more intelligent
way. First, both <code class="docutils literal"><span class="pre">u_ex</span></code> and <code class="docutils literal"><span class="pre">u</span></code> are interpolated into a higher-order
function space. Then, the degrees of freedom of <code class="docutils literal"><span class="pre">u_ex</span></code> and <code class="docutils literal"><span class="pre">u</span></code> are
subtracted to produce a new function in the higher-order function
space. Finally, FEniCS integrates the square of the difference
function to get the value of the error norm. Using the <code class="docutils literal"><span class="pre">errornorm</span></code>
function is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at a short implementation of <code class="docutils literal"><span class="pre">errornorm</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">u_W</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
    <span class="n">u_e_W</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
    <span class="n">e_W</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="n">e_W</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_W</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                      <span class="n">u_W</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_W</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>Sometimes it is of interest to compute the error of the
gradient field: <span class="math">\(||\nabla (u-{u_{\small\mbox{e}}})||\)</span>,
often referred to as the <span class="math">\(H^1_0\)</span> or <span class="math">\(H^1\)</span> seminorm of the error.
This can either be expressed as above, replacing the expression for
<code class="docutils literal"><span class="pre">error</span></code> by <code class="docutils literal"><span class="pre">error</span> <span class="pre">=</span> <span class="pre">dot(grad(e_W),</span> <span class="pre">grad(e_W))*dx</span></code>, or by calling
<code class="docutils literal"><span class="pre">errornorm</span></code> in FEniCS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;H10&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Type <code class="docutils literal"><span class="pre">help(errornorm)</span></code> in Python for more information about available
norm types.</p>
<p>All the various types of error computations here are placed in a
function <code class="docutils literal"><span class="pre">compute_errors</span></code> in <code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code>:
[<strong>hpl 64</strong>: Necessary to repeat code? New info is essentiall the return dict.]
[<strong>hpl 65</strong>: Anders, I (in 2010...) ran into problems with <code class="docutils literal"><span class="pre">fenics.errornorm</span></code>, see comments in the code below, and made the version below. We should check out these problems again and adjust <code class="docutils literal"><span class="pre">fenics.errornorm</span></code> if necessary.]
[<strong>AL 66</strong>: Have not yet checked code, will rerun all code and update notation if necessary when I&#8217;m through with all text.]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span class="sd">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span class="c1"># Compute error norm (for very small errors, the value can be</span>
    <span class="c1"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="c1"># Function - Expression</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c1"># Explicit interpolation of u_e onto the same space as u:</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c1"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span class="c1"># u will also be interpolated to the space Ve before integration</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c1"># fenics.errornorm interpolates u and u_e to a space with</span>
    <span class="c1"># given degree, and creates the error field by subtracting</span>
    <span class="c1"># the degrees of freedom, then the error field is integrated</span>
    <span class="c1"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span class="c1">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span class="c1"># Manual implementation errornorm to get around the bug:</span>
    <span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
        <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
        <span class="c1"># Subtract degrees of freedom for the error field</span>
        <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="c1"># More efficient computation (avoids the rhs array result above)</span>
        <span class="c1">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span class="c1">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">Ve</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))),</span> <span class="n">e_Ve</span>
    <span class="n">E4</span><span class="p">,</span> <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>

    <span class="c1"># Infinity norm based on nodal values</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">E5</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># H1 seminorm</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E6</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c1"># Collect error measures in a dictionary with self-explanatory keys</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;u - u_exact&#39;</span><span class="p">:</span> <span class="n">E1</span><span class="p">,</span>
              <span class="s1">&#39;u - interpolate(u_exact,V)&#39;</span><span class="p">:</span> <span class="n">E2</span><span class="p">,</span>
              <span class="s1">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span><span class="p">:</span> <span class="n">E3</span><span class="p">,</span>
              <span class="s1">&#39;errornorm&#39;</span><span class="p">:</span> <span class="n">E4</span><span class="p">,</span>
              <span class="s1">&#39;infinity norm (of dofs)&#39;</span><span class="p">:</span> <span class="n">E5</span><span class="p">,</span>
              <span class="s1">&#39;grad(error) H1 seminorm&#39;</span><span class="p">:</span> <span class="n">E6</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">errors</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-convergence-rates-2">
<h4>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates-2" title="Permalink to this headline">¶</a></h4>
<p>Calling the <code class="docutils literal"><span class="pre">solver</span></code> function for finer and finer meshes enables us to
study the convergence rate. Define the element size <span class="math">\(h=1/n\)</span>, where <span class="math">\(n\)</span>
is the number of cell divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction (<code class="docutils literal"><span class="pre">n=Nx=Ny</span></code> in
the code). We perform experiments with <span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span> and compute
the corresponding errors <span class="math">\(E_0, E_1, E_2\)</span> and so forth. Assuming
<span class="math">\(E_i=Ch_i^r\)</span> for unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare two
consecutive experiments, <span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span> and <span class="math">\(E_i=Ch_i^r\)</span>, and
solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace .}\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence rate
(typically the polynomial degree + 1 for the <span class="math">\(L^2\)</span>-error) as <span class="math">\(i\)</span>
increases.</p>
<p>The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by <code class="docutils literal"><span class="pre">compute_errors</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convergence_rate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute convergence rates for various error norms for a</span>
<span class="sd">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span class="sd">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span class="sd">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Discretization parameter, h[degree][experiment]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Error measure(s), E[degree][experiment][error_type]</span>
    <span class="n">P_degrees</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">num_meshes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># Perform experiments with meshes and element types</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1"># Coarsest mesh division</span>
        <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_D</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                       <span class="n">linear_solver</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;2*(</span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1">) P</span><span class="si">%d</span><span class="s1"> mesh, </span><span class="si">%d</span><span class="s1"> unknowns, E1=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
                   <span class="n">errors</span><span class="p">[</span><span class="s1">&#39;u - u_exact&#39;</span><span class="p">]))</span>
    <span class="c1"># Convergence rates</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c1"># log is a fenics name too</span>
    <span class="n">error_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">error_types</span><span class="p">):</span>
            <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
                <span class="n">Ei</span>   <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">Eim1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">Ei</span><span class="o">/</span><span class="n">Eim1</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rates</span>
</pre></div>
</div>
</div>
<div class="section" id="test-problem-6">
<h4>Test problem<a class="headerlink" href="#test-problem-6" title="Permalink to this headline">¶</a></h4>
<p>To demonstrate the computation of convergence rates, we will pick an
exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> given by</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square. This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2 u(x,y)\)</span>.
With <span class="math">\(\omega\)</span> restricted to an integer
it follows that the boundary value is given by <span class="math">\(u_{_\mathrm{D}}=0\)</span>.</p>
<p>We need to define the appropriate boundary conditions, the exact
solution, and the <span class="math">\(f\)</span> function in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
</div>
<div class="section" id="experiments">
<h4>Experiments<a class="headerlink" href="#experiments" title="Permalink to this headline">¶</a></h4>
<p>The function <code class="docutils literal"><span class="pre">convergence_rate_sin()</span></code> in <code class="docutils literal"><span class="pre">ft08_poisson_vc.py</span></code>
implements the test problem
above and applies the <code class="docutils literal"><span class="pre">convergence_rate</span></code> function to estimate
convergence rates.
We achieve some interesting results.
Using the error measure <code class="docutils literal"><span class="pre">E5</span></code> based on the infinity norm of the
difference of the degrees of freedom, we have</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.99</td>
<td>1.97</td>
<td>1.99</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.99</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.96</td>
<td>3.89</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
</tr>
<tr class="row-odd"><td>P4</td>
<td>3.75</td>
<td>4.99</td>
<td>5.0</td>
<td>5.0</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>An entry like 3.96 for <span class="math">\(n=32\)</span> and P3 means that we estimate the
a rate 3.96 by comparing two meshes, with resolutions <span class="math">\(n=32\)</span> and <span class="math">\(n=16\)</span>,
using P3 elements. The coarsest mesh has <span class="math">\(n=4\)</span>. The best estimates of
the rates appear in the right-most column.
[<strong>AL 67</strong>: Don&#8217;t understand this table. What does each cell in the table correspond to? I understand the elements, but what does for example <span class="math">\(n = 32\)</span> mean? The rate needs two different meshes. Is the <span class="math">\(n = 32\)</span> column the difference with <span class="math">\(n = 64\)</span> or <span class="math">\(n = 16\)</span>?]
[<strong>hpl 68</strong>: Inserted explanation, according to the shown code, but there was a misleading argument <code class="docutils literal"><span class="pre">n</span></code> (list of resolutions) in the function that was not used.]</p>
<p>The computations with <span class="math">\(\mathsf{P}_4\)</span> elements on a <span class="math">\(2\times(128\times
128)\)</span> mesh with a direct solver (UMFPACK) on a small laptop broke down
so these results have been left out of the table.  Otherwise we
achieve expected results: the error goes like <span class="math">\(h^{d+1}\)</span> for elements
of degree <span class="math">\(d\)</span>. Also <span class="math">\(L^2\)</span> norms based on the <code class="docutils literal"><span class="pre">errornorm</span></code> gives the
expected <span class="math">\(h^{d+1}\)</span> rate for <span class="math">\(u\)</span> and <span class="math">\(h^d\)</span> for <span class="math">\(\nabla u\)</span>.</p>
<p>However, using <code class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2</span></code> for the error computation, with the same
degree for the interpolation of <code class="docutils literal"><span class="pre">u_e</span></code> as for <code class="docutils literal"><span class="pre">u</span></code>, results in <span class="math">\(h^4\)</span>
convergence for P2 elements.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.98</td>
<td>1.94</td>
<td>1.98</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.98</td>
<td>3.95</td>
<td>3.99</td>
<td>3.99</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.69</td>
<td>4.03</td>
<td>4.01</td>
<td>3.95</td>
<td>2.77</td>
</tr>
</tbody>
</table>
<p>This is an example where it is important to interpolate <code class="docutils literal"><span class="pre">u_exact</span></code> to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.</p>
<p>Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section <a class="reference internal" href="#ch-poisson0-verify1"><span class="std std-ref">Examining the degrees of freedom</span></a> and many other places in this tutorial).</p>
</div>
</div>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="ref01" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref01]</td><td><strong>A. Logg, K.-A. Mardal and G. N. Wells</strong>. Automated Solution of Partial Differential Equations by the Finite Element Method,
Springer,
2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref02]</td><td><strong>P. S. Foundation</strong>. The Python Tutorial.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref03" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref03]</td><td><strong>H. P. Langtangen and L. R. Hellevik</strong>. Brief Tutorials on Scientific Python,
<a class="reference external" href="http://hplgit.github.io/bumpy/doc/web/index.html">http://hplgit.github.io/bumpy/doc/web/index.html</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref04]</td><td><strong>M. Pilgrim</strong>. <em>Dive into Python</em>,
Apress,
2004,
<a class="reference external" href="http://www.diveintopython.net">http://www.diveintopython.net</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref05]</td><td><strong>H. P. Langtangen</strong>. <em>Python Scripting for Computational Science</em>,
third edition,
Springer,
2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref06]</td><td><strong>H. P. Langtangen</strong>. <em>A Primer on Scientific Programming With Python</em>,
fifth edition,
<em>Texts in Computational Science and Engineering</em>,
Springer,
2016.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref07" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref07]</td><td><strong>J. M. Kinder and P. Nelson</strong>. <em>A Student&#8217;s Guide to Python for Physical Modeling</em>,
Princeton University Press,
2015.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref08]</td><td><strong>J. Kiusalaas</strong>. <em>Numerical Methods in Engineering With Python</em>,
Cambridge University Press,
2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref09" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref09]</td><td><strong>R. H. Landau, M. J. Paez and C. C. Bordeianu</strong>. <em>Computational Physics: Problem Solving with Python</em>,
third edition,
Wiley,
2015.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref10]</td><td><strong>M. G. Larson and F. Bengzon</strong>. <em>The Finite Element Method: Theory, Implementation, and Applications</em>,
<em>Texts in Computational Science and Engineering</em>,
Springer,
2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref11]</td><td><strong>M. Gockenbach</strong>. <em>Understanding and Implementing the Finite Element Method</em>,
SIAM,
2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref12]</td><td><strong>J. Donea and A. Huerta</strong>. <em>Finite Element Methods for Flow Problems</em>,
Wiley Press,
2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref13]</td><td><strong>T. J. R. Hughes</strong>. <em>The Finite Element Method: Linear Static and Dynamic Finite Element    Analysis</em>,
Prentice-Hall,
1987.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref14]</td><td><strong>W. B. Bickford</strong>. <em>A First Course in the Finite Element Method</em>,
2nd edition,
Irwin,
1994.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref15]</td><td><strong>K. Eriksson, D. Estep, P. Hansbo and C. Johnson</strong>. <em>Computational Differential Equations</em>,
Cambridge University Press,
1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref16]</td><td><strong>S. C. Brenner and L. R. Scott</strong>. <em>The Mathematical Theory of Finite Element Methods</em>,
third edition,
<em>Texts in Applied Mathematics</em>,
Springer,
2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref17]</td><td><strong>D. Braess</strong>. <em>Finite Elements</em>,
third edition,
Cambridge University Press,
2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref18]</td><td><strong>A. Ern and J.-L. Guermond</strong>. <em>Theory and Practice of Finite Elements</em>,
Springer,
2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref19]</td><td><strong>A. Quarteroni and A. Valli</strong>. <em>Numerical Approximation of Partial Differential Equations</em>,
<em>Springer Series in Computational Mathematics</em>,
Springer,
1994.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref20]</td><td><strong>P. G. Ciarlet</strong>. <em>The Finite Element Method for Elliptic Problems</em>,
<em>Classics in Applied Mathematics</em>,
SIAM,
2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref21]</td><td><strong>D. N. Arnold and A. Logg</strong>. Periodic Table of the Finite Elements,
<em>SIAM News</em>,
2014.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref22]</td><td><strong>M. S. Alnæs, A. Logg, K. B. Ølgaard, M. E. Rognes and G. N. Wells</strong>. Unified Form Language: A domain-specific language for weak formulations of partial differential equations,
<em>ACM Transactions on Mathematical Software</em>,
40(2),
2014.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref23]</td><td><strong>A. H. Squillacote</strong>. The Paraview Guide,
Kitware,
2007,
<a class="reference external" href="http://www.paraview.org/paraview-guide/">http://www.paraview.org/paraview-guide/</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref24]</td><td><strong>H. P. Langtangen and A. Logg</strong>. <em>The Advanced FEniCS Tutorial - Writing State-of-the-art Finite Element Solvers in Hours</em>,
Springer,
2016.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref25]</td><td><strong>A. J. Chorin</strong>. Numerical solution of the Navier-Stokes equations,
<em>Math. Comp.</em>,
22,
pp. 745-762,
1968.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref26]</td><td><strong>R. Temam</strong>. Sur l&#8217;approximation de la solution des &#8216;equations de Navier-Stokes,
<em>Arc. Ration. Mech. Anal.</em>,
32,
pp. 377-385,
1969.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref27]</td><td><strong>K. Goda</strong>. A multistep technique with implicit difference schemes for calculating two- or three-dimensional cavity flows,
<em>Journal of Computational Physics</em>,
30(1),
pp. 76-95,
1979.</td></tr>
</tbody>
</table>
</div>
</div>


    </div>
  </div>
</div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>