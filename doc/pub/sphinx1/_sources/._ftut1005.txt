.. !split

.. _ch:subdomains:

Mesh generation, subdomains and boundary conditions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


..

    In this chapter, we focus on a fundamental step in the solution of
    many PDE problems: the generation of a mesh, and the specification of subdomains and boundary conditions. Our starting point is the 2D Poisson equation where
    we introduce the basic concepts, before applying them in a more
    challenging 3D convection-diffusion problem.



Multiple domains and boundaries
===============================

[**hpl 31**: Need a little intro.]

.. _ch:poisson0:DN:

Combining Dirichlet and Neumann conditions
------------------------------------------

Let us make a slight extension of our two-dimensional Poisson problem
with Dirichlet conditions on the entire boundary and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition :math:`u=u_{_\mathrm{D}}` at the left and right sides, :math:`x=0` and
:math:`x=1`, while the Neumann condition

.. math::
        
        -{\partial u\over\partial n}=g
        

is applied to the remaining
sides :math:`y=0` and :math:`y=1`.
The Neumann condition is also known as a *natural boundary condition*
(in contrast to an essential boundary condition).

.. index:: Neumann boundary conditions

PDE problem          (6)
------------------------

Let :math:`\Gamma_D` and :math:`\Gamma_N` denote the parts of :math:`\partial\Omega`
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

.. _Eq:_auto18:

.. math::

    \tag{65}
    - \nabla^2 u = f \mbox{ in } \Omega,  
        
        

.. _Eq:_auto19:

.. math::

    \tag{66}
    u = u_{_\mathrm{D}} \mbox{ on } \Gamma_D,       
        
        

.. _Eq:_auto20:

.. math::

    \tag{67}
    - {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}
        
        

Again we choose :math:`u=1+x^2 + 2y^2` as the exact solution and adjust :math:`f`, :math:`g`, and
:math:`u_{_\mathrm{D}}` accordingly:

.. math::
        
        f &= -6,\\ 
        g &= \left\lbrace\begin{array}{ll}
        -4, & y=1\\ 
        0,  & y=0
        \end{array}\right.\\ 
        u_{_\mathrm{D}} &= 1 + x^2 + 2y^2{\thinspace .}
        

For ease of programming we may introduce a :math:`g` function defined over the whole
of :math:`\Omega` such that :math:`g` takes on the right values at :math:`y=0` and
:math:`y=1`. One possible extension is

.. math::
        
        g(x,y) = -4y{\thinspace .}
        

Variational formulation          (6)
------------------------------------

The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
:math:`v` is only zero on :math:`\Gamma_D`. We have

.. math::
        
         -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
        = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
        \partial n}v {\, \mathrm{d}s},
        

and since :math:`v=0` on :math:`\Gamma_D`,

.. math::
        
        - \int_{\partial\Omega}{\partial u\over
        \partial n}v {\, \mathrm{d}s}
        =
        - \int_{\Gamma_N}{\partial u\over
        \partial n}v {\, \mathrm{d}s}
        = \int_{\Gamma_N}gv {\, \mathrm{d}s},
        

by applying the boundary condition on :math:`\Gamma_N`.
The resulting weak form reads

.. _Eq:ch:poisson0:2D:DN:weak:

.. math::

    \tag{68}
    \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
        \int_{\Gamma_N} gv {\, \mathrm{d}s}
        = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}
        
        

Expressing this equation
in the standard notation :math:`a(u,v)=L(v)` is straightforward with

.. _Eq:ftut:poisson2:vard:a:

.. math::

    \tag{69}
    a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},
        
        

.. _Eq:ftut:poisson2:vard:L:

.. math::

    \tag{70}
    L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
        \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}  
        

FEniCS implementation          (7)
----------------------------------

How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
``ft01_poisson.py``, from
the section :ref:`ch:poisson0:impl`,
we realize that the statements remain almost the same.
Only two adjustments are necessary:

  * The function describing the boundary where Dirichlet conditions
    apply must be modified.

  * The new boundary term must be added to the expression in ``L``.

The first adjustment can be coded as

.. code-block:: python

    def Dirichlet_boundary(x, on_boundary):
        if on_boundary:
            if x[0] == 0 or x[0] == 1:
                return True
            else:
                return False
        else:
            return False

A more compact implementation reads

.. code-block:: python

    def Dirichlet_boundary(x, on_boundary):
        return on_boundary and (x[0] == 0 or x[0] == 1)


.. admonition:: Never use ``==`` for comparing real numbers

   A list like ``x[0] == 1`` should never be used if ``x[0]`` is a real number,
   because rounding errors in ``x[0]`` may make the test fail even when it is
   mathematically correct. Consider
   
   .. code-block:: python
   
       >>> 0.1 + 0.2 == 0.3
       False
       >>> 0.1 + 0.2
       0.30000000000000004
   
   Comparison of real numbers need to use tolerances! The values of the
   tolerances depend on the size of the numbers involved in arithmetic
   operations:
   
   .. code-block:: python
   
       >>> abs(0.1+0.2 - 0.3)
       5.551115123125783e-17
       >>> abs(1.1+1.2 - 2.3)
       0.0
       >>> abs(10.1+10.2 - 20.3)
       3.552713678800501e-15
       >>> abs(100.1+100.2 - 200.3)
       0.0
       >>> abs(1000.1+1000.2 - 2000.3)
       2.2737367544323206e-13
       >>> abs(10000.1+10000.2 - 20000.3)
       3.637978807091713e-12
   
   For numbers around unity, tolerances as low as :math:`3\cdot 10^{-16}` can be used
   (in fact, this tolerance is known as the constant ``DOLFIN_EPS`` in FEniCS),
   otherwise an appropriate tolerance must be found.
   
   Testing for ``x[0] == 1`` should therefore be implemented as
   
   .. code-block:: python
   
       tol = 1E-14
       if abs(x[0] - 1) < tol:
           ...




.. index:: near

Here is a new boundary function using tolerances in the test:

.. code-block:: python

    def Dirichlet_boundary(x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and \ 
               (abs(x[0]) < tol or abs(x[0] - 1) < tol)

This function can be written a bit more elegantly using the ``near``
function in FEniCS:

.. code-block:: python

    def Dirichlet_boundary(x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and \ 
               (near(x[0], 0, tol) or near(x[1], 1, tol))

The second adjustment of our program concerns the definition of ``L``,
where we have to add a boundary integral and a definition of the :math:`g`
function to be integrated:

.. code-block:: python

    g = Expression('-4*x[1]')
    L = f*v*dx - g*v*ds

The ``ds`` variable implies a boundary integral, while ``dx``
implies an integral over the domain :math:`\Omega`.
No more modifications are necessary.

.. _ch:poisson0:multiple:Dirichlet:

Setting multiple Dirichlet conditions
-------------------------------------

The PDE problem from the previous section applies a function :math:`u_{_\mathrm{D}}(x,y)`
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have :math:`m` functions for
setting Dirichlet conditions on :math:`m` parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

Let us return to the case from the section :ref:`ch:poisson0:DN` and define
two separate functions for the two Dirichlet conditions:

.. math::
        
            - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
            u &= u_L \mbox{ on } \Gamma_{D,0}, \\ 
            u &= u_R \mbox{ on } \Gamma_{D,1}, \\ 
            - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N {\thinspace .}
        

Here, :math:`\Gamma_{D,0}` is the boundary :math:`x=0`, while :math:`\Gamma_{D,1}` corresponds
to the boundary :math:`x=1`.  We have that :math:`u_L = 1 + 2y^2`, :math:`u_R = 2 +
2y^2`, and :math:`g=-4y`.

For the left boundary :math:`\Gamma_0` we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a ``DirichletBC`` object:

.. code-block:: python

    u_L = Expression('1 + 2*x[1]*x[1]')
    
    def left_boundary(x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and abs(x[0]) < tol
    
    Gamma_0 = DirichletBC(V, u_L, left_boundary)

For the boundary :math:`x=1` we write a similar code snippet:

.. code-block:: python

    u_R = Expression('2 + 2*x[1]*x[1]')
    
    def right_boundary(x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and abs(x[0] - 1) < tol
    
    Gamma_1 = DirichletBC(V, u_R, right_boundary)

The various essential conditions are then collected in a list
and used in the solution process:

.. code-block:: python

    bcs = [Gamma_0, Gamma_1]
    ...
    solve(a == L, u, bcs)
    # or
    problem = LinearVariationalProblem(a, L, u, bcs)
    solver  = LinearVariationalSolver(problem)
    solver.solve()

In other problems, where the :math:`u` values are constant at a part of the
boundary, we may use a simple ``Constant`` object instead of an
``Expression`` object.

.. _ftut:possion:2D:2mat:impl:

Working with subdomains
=======================

.. index:: heterogeneous media

.. index:: multi-material domain

Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent
the various materials. We can thereafter define material properties
through functions, known in FEniCS as *mesh functions*, that are
piecewise constant in each subdomain.  A simple example with two
materials (subdomains) in 2D will demonstrate the basic steps in the
process.

.. _ftut:possion:2D:2mat:fig1:

.. figure:: layered_medium_2.png
   :width: 400

   *Medium with discontinuous material properties*

Suppose we want to solve

.. _Eq:ch:poisson0:2D:2mat:varcoeff2:

.. math::

    \tag{71}
    \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,
        

in a domain :math:`\Omega` consisting of two subdomains where :math:`k` takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain :math:`\Omega = [0,1]\times [0,1]` and divide it into two equal
subdomains,
as depicted in Figure :ref:`ftut:possion:2D:2mat:fig1`,

.. math::
        
        \Omega_0 = [0, 1]\times [0,1/2],\quad
        \Omega_1 = [0, 1]\times (1/2,1]{\thinspace .}
        

We define :math:`k(x,y)=k_0` in :math:`\Omega_0` and :math:`k(x,y)=k_1` in :math:`\Omega_1`,
where :math:`k_0>0` and :math:`k_1>0` are given constants.

Physically, the present problem may correspond to heat conduction, where
the heat conduction in :math:`\Omega_1` is more efficient than
in :math:`\Omega_0`. An alternative interpretation is flow in porous media
with two geological layers, where the layers' ability to transport
the fluid differ.

Expression objects with if test
-------------------------------

The simplest way of implementing a variable :math:`k` is to define an
``Expression`` object where we return the appropriate :math:`k` value
depending on the position in space.  Since we need some testing on the
coordinates, the most straightforward approach is to define a subclass
of ``Expression``, where we can use a full Python method instead of just
a C++ string formula for specifying a function.  The method that
defines the function is called ``eval``:

.. code-block:: python

    class K(Expression):
        def set_k_values(self, k0, k1):
            self.k0, self.k1 = k0, k1
    
        def eval(self, value, x):
            """x: spatial point, value[0]: function value."""
    	# Fill in-place value[0] for scalar function,
    	# value[:] for vector function (no return)
    
    	tol = 1E-14  # Tolerance for coordinate comparisons
            if x[1] <= 0.5+tol:
    	    value[0] = self.k0
    	else:
    	    value[0] = self.k1
    
    # Initialize
    k = K()
    k.set_k_values(1, 0.01)

The ``eval`` method gives great flexibility in defining functions, but a
downside is that C++ calls up ``eval`` in Python for each point ``x``,
which is a slow process, and the number of calls is proportional to
the number of numerical integration points in the mesh (about the
number of degrees of freedom).  Function expressions in terms of
strings are compiled to efficient C++ functions, being called from
C++, so we should try to express functions as string expressions if
possible. (The ``eval`` method can also be defined through C++ code, but
this is much more complicated and not covered here.)  The idea is to
use inline if tests in C++:

.. code-block:: python

    tol = 1E-14
    k0 = 1.0
    k1 = 0.01
    k = Expression('x[1] <= 0.5+tol? k0 : k1',
                   tol=tol, k0=k0, k1=k1)

The method with if tests on the location is feasible when the
subdomains have very simple shapes. A completely general method,
utilizing *mesh functions*, is described next.

.. index:: boundary specification (class)

Mesh functions
--------------

We now address how to specify the subdomains :math:`\Omega_0` and :math:`\Omega_1`
so that the method also works for subdomains of any shape. For this
purpose we need to use subclasses of class ``SubDomain``, not only plain
functions as we have used so far for specifying boundaries. Consider
the boundary function

.. code-block:: python

    def boundary(x, on_boundary):
        tol = 1E-14
        return on_boundary and abs(x[0]) < tol

for defining the boundary :math:`x=0`. Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of ``SubDomain``,
which implements the ``inside`` method as an alternative to the
``boundary`` function:

.. code-block:: python

    class Boundary(SubDomain):
        def inside(self, x, on_boundary):
            tol = 1E-14
            return on_boundary and abs(x[0]) < tol
    
    boundary = Boundary()
    bc = DirichletBC(V, Constant(0), boundary)

A word about computer science terminology may be used here: The term
*instance* means a Python object of a particular type (such as
``SubDomain``, ``Function``, ``FunctionSpace``, etc.).  Many use *instance*
and *object* as interchangeable terms. In other computer programming
languages one may also use the term *variable* for the same thing.  We
mostly use the well-known term *object* in this text.

A subclass of ``SubDomain`` with an ``inside`` method offers functionality
for marking parts of the domain or the boundary. Now we need to define
one class for the subdomain :math:`\Omega_0` where :math:`y\leq 1/2` and another
for the subdomain :math:`\Omega_1` where :math:`y\geq 1/2`:

.. code-block:: python

    tol = 1E-14  # Tolerance for coordinate comparisons
    
    class Omega0(SubDomain):
        def inside(self, x, on_boundary):
            return x[1] <= 0.5+tol
    
    class Omega1(SubDomain):
        def inside(self, x, on_boundary):
            return x[1] >= 0.5-tol

Notice the use of ``<=`` and ``>=`` in both tests. For a cell to belong
to, e.g., :math:`\Omega_1`, the ``inside`` method must return ``True`` for all
the vertices ``x`` of the cell. So to make the cells at the internal
boundary :math:`y=1/2` belong to :math:`\Omega_1`, we need the test ``x[1] >=
0.5``. However, because of potential rounding errors in the coordinates
``x[1]``, we use a tolerance in the comparisons: ``x[1] >= 0.5-tol``.

The next task is to use a *mesh function* to mark all cells in
:math:`\Omega_0` with the subdomain number 0 and all cells in :math:`\Omega_1`
with the subdomain number 1.  Our convention is to number subdomains
as :math:`0,1,2,\ldots`.

A ``MeshFunction`` object is a discrete function that can be evaluated
at a set of so-called *mesh entities*. Examples of mesh entities are
cells, facets, and vertices. A ``MeshFunction`` over cells is suitable
to represent subdomains (materials), while a ``MeshFunction`` over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous
fields.  The specialized classes ``CellFunction`` and ``FacetFunction``
are used to construct mesh functions of cells and facets,
respectively.

Since we need to define subdomains of :math:`\Omega` in the present example,
we make use of a ``CellFunction``. The constructor
is fed with two arguments: 1) the type of value: ``'int'`` for integers,
``'uint'`` for positive (unsigned) integers, ``'double'`` for real
numbers, and ``'bool'`` for logical values; 2) a ``Mesh`` object.
Alternatively, the constructor can take just a filename and initialize
the ``CellFunction`` from data in a file.

We start with creating a ``CellFunction`` whose values are non-negative
integers (``'uint'``) for numbering the subdomains.
The appropriate code for two subdomains then reads

.. code-block:: python

    materials = CellFunction('size_t', mesh)
    # Mark subdomains with numbers 0 and 1
    subdomain0 = Omega0()
    subdomain0.mark(materials, 0)
    subdomain1 = Omega1()
    subdomain1.mark(materials, 1)
    
    # Alternative
    materials.set_all(0)
    subdomain1.mark(materials, 1)

Calling ``materials.array()`` returns a ``numpy`` array of the
subdomain values. That is, ``materials.array()[i]`` is
the subdomain value of cell number ``i``. This array is used to
look up the subdomain or material number of a specific element.

We need a function ``k`` that is constant in each subdomain :math:`\Omega_0`
and :math:`\Omega_1`. Since we want ``k`` to be a finite element function, it
is natural to choose a space of functions that is constant over each
element.  The family of discontinuous Galerkin methods, in FEniCS
denoted by ``'DG'``, is suitable for this purpose. Since we want
functions that are piecewise constant, the value of the degree
parameter is zero:

.. code-block:: python

    V0 = FunctionSpace(mesh, 'DG', 0)
    k  = Function(V0)

To fill ``k`` with the right values in each element, we loop over
all cells (i.e., indices in ``materials.array()``),
extract the corresponding subdomain number of a cell,
and assign the corresponding :math:`k` value to the ``k.vector()`` array:

.. code-block:: python

    k_values = [1.5, 50]  # values of k in the two subdomains
    for cell_no in range(len(materials.array())):
        material_no = materials.array()[cell_no]
        k.vector()[cell_no] = k_values[material_no]

Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use *vectorized code*.
Normally this implies that the loop must be replaced by
calls to functions from the ``numpy`` library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
``materials.array()``, but where the value ``i`` of an entry
in ``materials.array()`` is replaced by ``k_values[i]``.
Such an operation is carried out by the ``numpy`` function ``choose``:

.. code-block:: python

    help = numpy.asarray(materials.array(), dtype=numpy.int32)
    k.vector()[:] = numpy.choose(help, k_values)

The ``help`` array is required since ``choose`` cannot work with
``materials.array()`` because this array has elements of
type ``uint32``. We must therefore transform this array to an array
``help`` with standard ``int32`` integers.

The next section exemplifies a complete solver with a piecewise
constant coefficient, like :math:`k`, defined through ``SubDomain`` objects,
combined with different types of boundary conditions.

.. index:: CompiledSubDomain

C++ strings for subdomain definitions
-------------------------------------

The ``SubDomain`` class in Python is convenient, but leads to lots of
function calls from C++ to Python, which are slow. In large problems,
the subdomains should be defined through C++ code. This is easy to achieve
using the ``CompiledSubDomain`` object. Consider the definition of
classes ``Omega0`` and ``Omega1`` above in Python.
The key strings that define these subdomain can be expressed in
C++ syntax and fed to ``CompiledSubDomain`` as follows:

.. code-block:: python

    tol = 1E-14  # Tolerance for coordinate comparisons
    
    subdomain0 = CompiledSubDomain(
                    'x[1] <= boundary+tol', tol=1E-14, boundary=0.5)
    subdomain1 = CompiledSubDomain(
                    'x[1] >= boundary-tol', tol=1E-14, boundary=0.5)

As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, ``subdomain0`` and ``subdomain1``, can be used
as ordinary ``SubDomain`` objects.

Compiled subdomain strings can be applied for specifying boundaries as
well, e.g.,

.. code-block:: python

    y_R = CompiledSubDomain('on_boundary && near(x[1], R, eps=tol)',
                            tol=1E-14, R=2)   # y=2

It is possible to feed the C++ string (without parameters) directly as
the third argument to ``DirichletBC`` without explicitly constructing a
``CompiledSubDomain`` object:

.. code-block:: python

    bc1 = DirichletBC(V, value, 'on_boundary && near(x[1], 2, 1E-14)')

.. index:: near

.. --- begin exercise ---

.. _ch:poisson0:exer:eff:expression:

Exercise 3: Efficiency of Python vs C++ expressions
---------------------------------------------------

Consider a cube mesh with :math:`N` cells in each spatial direction.
We want to define a ``Function`` on this mesh where the
values are given by the mathematical function :math:`f(x,y,z)=a\sin(bxyz)`,
where :math:`a` and :math:`b` are two parameters. Write a ``class SineXYZ``:

.. code-block:: python

    class SineXYZ(Expression):
        def __init__(self, a, b):
            self.a, self.b = a, b
    
        def eval(self, value, x):
            value[0] = self.a*sin(self.b*x[0]*x[1]*x[2])

Create an alternative ``Expression`` based on giving the formula for :math:`f(x,y,z)`
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using ``time.clock()`` to measure the CPU time).

The ``sin`` function used in class ``SineXYZ.eval`` can mean many things.
This is an advanced FEniCS function if imported from ``fenics``.
Much more efficient versions for sin of numbers are found in ``math.sin``
and ``numpy.sin``. Compare the use ``sin`` from ``fenics``, ``math``, ``numpy``, and
``sympy`` (note that ``sin`` from ``sympy`` is very slow).

.. --- begin solution of exercise ---

**Solution.**
Here is an appropriate program:

.. code-block:: python

    from __future__ import print_function
    from fenics import *
    import time
    
    def make_sine_Function(N, method):
        """Fill a Function with sin(x*y*z) values."""
        mesh = UnitCubeMesh(N, N, N)
        V = FunctionSpace(mesh, 'Lagrange', 2)
    
        if method.startswith('Python'):
            if method.endswith('fenics.sin'):
                # Need sin as local variable in this function
                from fenics import sin
            elif method.endswith('math.sin'):
                from math import sin
            elif method.endswith('numpy.sin'):
                from numpy import sin
            elif method.endswith('sympy.sin'):
                from sympy import sin
            else:
                raise NotImplementedError('method=%s' % method)
            print('sin:', sin, type(sin))
    
            class SineXYZ(Expression):
                def __init__(self, a, b):
                    self.a, self.b = a, b
    
                def eval(self, value, x):
                    value[0] = self.a*sin(self.b*x[0]*x[1]*x[2])
    
            expr = SineXYZ(a=1, b=2)
    
        elif method == 'C++':
            expr = Expression('a*sin(b*x[0]*x[1]*x[2])', a=1, b=2)
    
        t0 = time.clock()
        u = interpolate(expr, V)
        t1 = time.clock()
        return u, t1-t0
    
    def main(N):
        u, cpu_py_fenics  = make_sine_Function(N, 'Python-fenics.sin')
        u, cpu_py_math    = make_sine_Function(N, 'Python-math.sin')
        u, cpu_py_numpy   = make_sine_Function(N, 'Python-numpy.sin')
        u, cpu_py_sympy   = make_sine_Function(N, 'Python-sympy.sin')
        u, cpu_cpp = make_sine_Function(N, 'C++')
        print("""DOFs: %d
    Python:
    fenics.sin: %.2f
    math.sin:   %.2f
    numpy.sin:  %.2f
    sympy.sin:  %.2f
    C++:        %.2f
    Speed-up:   math: %.2f  sympy: %.2f""" %
              (u.function_space().dim(),
               cpu_py_fenics, cpu_py_math,
               cpu_py_numpy, cpu_py_sympy,
               cpu_cpp,
               cpu_py_math/float(cpu_cpp),
               cpu_py_sympy/float(cpu_cpp)))
    
    def profile():
        import cProfile
        prof = cProfile.Profile()
        prof.runcall(main)
        prof.dump_stats("tmp.profile")
        # http://docs.python.org/2/library/profile.html
    
    main(20)
    #profile()

Running the program shows that ``sin`` from ``math`` is the most efficient choice,
but a string C++ runs 40 times faster. Note that ``fenics.sin``, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the ``sin``
functions for numbers in ``math`` and ``numpy``.

.. --- end solution of exercise ---

Filename: ``Expression_efficiency``.

.. --- end exercise ---

.. _ch:poisson0:multi:bc:

Setting multiple Neumann, Robin, and Dirichlet conditions
=========================================================

.. index:: Dirichlet boundary conditions

.. index:: Neumann boundary conditions

.. index:: Robin boundary conditions

.. index:: boundary conditions

Consider the model problem from the section :ref:`ch:poisson0:multiple:Dirichlet` where we had both Dirichlet and
Neumann conditions.  The term ``v*g*ds`` in the expression for ``L``
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate ``v*g*ds`` only over the parts of the boundary where
we actually have Neumann conditions.  And more importantly, in other
problems one may have different Neumann conditions or other conditions
like the Robin type condition.  With the mesh function concept we can
mark different parts of the boundary and integrate over specific
parts.  The same concept can also be used to treat multiple Dirichlet
conditions.  The forthcoming text illustrates how this is done.

Three types of boundary conditions
----------------------------------

We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin.  Dirichlet conditions apply to some
parts :math:`\Gamma_{D,0}`, :math:`\Gamma_{D,1}`, :math:`...`, of the boundary:

.. math::
         u_{0,0}\hbox{ on }\Gamma_{D,0},\quad
        u_{0,1}\hbox{ on }\Gamma_{D,1}, \ldots

where :math:`u_{0,i}` are prescribed functions, :math:`i=0,1,\ldots`
On other parts, :math:`\Gamma_{N,0}`, :math:`\Gamma_{N,1}`, and so on, we have
Neumann conditions

.. math::
         -p{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{N,0},\quad
        -p{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{N,1},\quad \ldots
        

Finally, we have *Robin conditions*

.. _Eq:ch:poisson0:multi:bc:Robin:

.. math::

    \tag{72}
    -p{\partial u\over\partial n} = r(u-s),
        
        

where :math:`r` and :math:`s` are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, :math:`r` is a heat
transfer coefficient, and :math:`s` is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts :math:`\Gamma_{R,0}`, :math:`\Gamma_{R,1}`, and so forth:

.. math::
         -p{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\Gamma_{R,0},\quad
        -p{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\Gamma_{R,1},\quad \ldots
        

.. index:: Robin condition

A general model problem
-----------------------

With the notation above,
the model problem to be solved with multiple Dirichlet, Neumann, and
Robin conditions can formally be defined as

.. _Eq:ch:poisson0:2D:DN3:

.. math::

    \tag{73}
    -\nabla\cdot(p\nabla u) = -f, \mbox{ in } \Omega, 
        

.. _Eq:ch:poisson0:2D:DN3:bcD:

.. math::

    \tag{74}
    u = u_{0,i} \mbox{ on } \Gamma_{D,i},\quad i=0,1,\ldots
        
        

.. _Eq:ch:poisson0:2D:DN3:bcN:

.. math::

    \tag{75}
    -p{\partial u\over\partial n} = g_i \mbox{ on } \Gamma_{N,i},\quad
        i=0,1,\ldots
        
        

.. _Eq:ch:poisson0:2D:DN3:bcR:

.. math::

    \tag{76}
    -p{\partial u\over\partial n} = r_i(u-s_i) \mbox{ on } \Gamma_{R,i},\quad
        i=0,1,\ldots
        
        

Variational formulation          (7)
------------------------------------

Integration by parts of :math:`-\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}` becomes
as usual

.. math::
        
         -\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}
        = \int_\Omega p\nabla u\cdot \nabla v {\, \mathrm{d}x} -
        \int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}{\thinspace .}
        

The boundary integral does not apply to the parts of
the boundary where we have Dirichlet conditions (:math:`\Gamma_{D,i}`).
Moreover, on the remaining parts, we must split the boundary integral
into the parts where we have Neumann and Robin conditions such that we
insert the right conditions as integrands.
Specifically, we have

.. math::
        
        -\int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}
        &=
        -\sum_i\int_{\Gamma_{N,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}
        -\sum_i\int_{\Gamma_{R,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}\\ 
        &=
        \sum_i\int_{\Gamma_{N,i}}g_i {\, \mathrm{d}s} +
        \sum_i\int_{\Gamma_{R,i}}r_i(u-s_i) {\, \mathrm{d}s}{\thinspace .}
        

The variational formulation then becomes

.. _Eq:ch:poisson0:multi:bc:varform:

.. math::

    \tag{77}
    F = \int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x} +
        \sum_i\int_{\Gamma_{N,i}} g_iv {\, \mathrm{d}s} +
        \sum_i\int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
        - \int_{\Omega} fv {\, \mathrm{d}x} =0{\thinspace .}
        
        

We have been used to writing
this variational formulation in the standard notation
:math:`a(u,v)=L(v)`, which requires that we identify all integrals with
*both* :math:`u` and :math:`v`, and collect these in :math:`a(u,v)`, while the remaining
integrals with :math:`v` and not :math:`u` go into :math:`L(v)`.  The integral from the
Robin condition must of this reason be split in two parts:

.. math::
        
        \int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
        = \int_{\Gamma_{R,i}} r_iuv {\, \mathrm{d}s} - \int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}
        

We then have

.. _Eq:ch:poisson0:2D:DN3:var:a:

.. math::

    \tag{78}
    a(u, v) = \int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x}
        + \sum_i\int_{\Gamma_{R,i}}r_iuv {\, \mathrm{d}s},
        
        

.. _Eq:ch:poisson0:2D:DN3:var:L:

.. math::

    \tag{79}
    L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
        \sum_i\int_{\Gamma_{N,i}} g_i v {\, \mathrm{d}s} + \sum_i\int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}
        
        

FEniCS implementation          (8)
----------------------------------

Looking at our previous ``solver`` functions for solving the 2D Poisson equation,
the following new aspects must be taken care of:

 1. definition of a mesh function over the boundary,

 2. marking each side as a subdomain, using the mesh function,

 3. splitting a boundary integral into parts.

A general approach to the first task is to mark each of the desired
boundaries with markers 0, 1, 2, and so forth. Here we aim at
the four sides of the unit square, marked with
0 (:math:`x=0`), 1 (:math:`x=1`), 2 (:math:`y=0`), and 3 (:math:`y=1`).
The marking of boundaries makes use of a mesh function object, but contrary to
the section :ref:`ftut:possion:2D:2mat:impl`, this is not a function over
cells, but a function over cell facets. We apply the ``FacetFunction``
for this purpose:

.. code-block:: python

    boundary_parts = FacetFunction('size_t', mesh)

As in the section :ref:`ftut:possion:2D:2mat:impl` we use a subclass of
``SubDomain`` to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the :math:`x=0` boundary can be marked by

.. code-block:: python

    class BoundaryX0(SubDomain):
        def inside(self, x, on_boundary):
            return on_boundary and abs(x[0]) < tol
    
    bx0 = BoundaryX0()
    bx0.mark(boundary_parts, 0)

Similarly, we make the classes ``BoundaryX1`` for the :math:`x=1` boundary,
``BoundaryY0`` for the :math:`y=0` boundary, and ``BoundaryY1`` for the :math:`y=1`
boundary, and mark these as subdomains 1, 2, and 3, respectively.

For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

.. code-block:: text

    boundary_conditions = {
      0: {'Dirichlet': u_b},
      1: {'Robin': (r, s)},
      2: {'Neumann: g}},
      3: {'Neumann', 0}}

specifies

 * a Dirichlet condition, with values implemented by an ``Expression``
   or ``Constant`` object
   ``u_b``, on subdomain 0, i.e., the :math:`x=1` boundary;

 * a Robin condition :ref:`(72) <Eq:ch:poisson0:multi:bc:Robin>`
   on subdomain 1, :math:`x=1`, with ``Expression`` or ``Constant`` objects
   ``r`` and ``s`` specifying :math:`r` and :math:`s`;

 * a Neumann condition :math:`\partial u/\partial n=g` on subdomain 2, :math:`y=0`,
   where an ``Expression`` or ``Constant`` object ``g`` implements the value :math:`g`;

 * a homogeneous Neumann condition :math:`\partial u/\partial n=0` on
   subdomain 3, :math:`y=1`.

As explained in the section :ref:`ch:poisson0:multiple:Dirichlet`,
multiple Dirichlet conditions must be collected in a list of
``DirichletBC`` objects. Based on the ``boundary_conditions`` data
structure above, we can construct this list by the following snippet:

.. code-block:: python

    bcs = []  # List of Dirichlet conditions
    for n in boundary_conditions:
        if 'Dirichlet' in boundary_conditions[n]:
            bcs.append(
                DirichletBC(V, boundary_conditions[n]['Dirichlet'],
                            boundary_parts, n))

The new aspect of the variational problem is the two distinct
boundary integrals over :math:`\Gamma_{N,i}` and :math:`\Gamma_{R,i}`.
Having a mesh function over exterior cell facets (our
``boundary_parts`` object), where subdomains (boundary parts) are
numbered as :math:`0,1,2,\ldots`, the special symbol ``ds(0)``
implies integration over subdomain (part) 0, ``ds(1)`` denotes
integration over subdomain (part) 1, and so on.
The idea of multiple ``ds``-type objects generalizes to volume
integrals too: ``dx(0)``, ``dx(1)``, etc., are used to
integrate over subdomain 0, 1, etc.,  inside :math:`\Omega`.

Before we have ``ds(n)`` for integers ``n`` defined, we must do

.. code-block:: python

    ds = Measure('ds', domain=mesh, subdomain_data=boundaries_parts)

Similarly, if we want integration of different parts of the domain,
we redefine ``dx`` as

.. code-block:: python

    dx = Measure('dx', domain=mesh, subdomain_data=domains)

where ``domains`` is a ``CellFunction`` defining subdomains in :math:`\Omega`.

Suppose we have a Robin condition with values ``r`` and ``s`` on subdomain
``R``, a Neumann condition with value ``g`` on subdomain ``N``, the
variational form can be written

.. code-block:: python

    a = dot(grad(u), grad(v))*dx + r*u*v*ds(R)
    L = f*v*dx - g*v*ds(N) + r*s*v*ds(R)

In our case things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the ``boundary_conditions`` data structure. We can collect
all Neumann conditions by the code

.. code-block:: python

    u = TrialFunction(V)
    v = TestFunction(V)
    Neumann_integrals = []
    for n in boundary_conditions:
        if 'Neumann' in boundary_conditions[n]:
            if boundary_conditions[n]['Neumann'] != 0:
                g = boundary_conditions[n]['Neumann']
                Neumann_integrals.append(g*v*ds(n))

Applying ``sum(Nemann_integrals)`` will apply the ``+`` operator to
the variational forms in the ``Numeann_integrals`` list and result
in the integrals we need for the right-hand side ``L`` of the
variational form.

The integrals in the Robin condition can similarly be collected
in lists:

.. code-block:: python

    Robin_a_integrals = []
    Robin_L_integrals = []
    for n in boundary_conditions:
        if 'Robin' in boundary_conditions[n]:
            r, s = boundary_conditions[n]['Robin']
            Robin_a_integrals.append(r*u*v*ds(n))
            Robin_L_integrals.append(r*s*v*ds(n))

We are now in a position to define the ``a`` and ``L`` expressions
in the variational formulation:

.. code-block:: python

    a = dot(p*grad(u), grad(v))*dx + \ 
        sum(Robin_a_integrals)
    L = f*v*dx - sum(Neumann_integrals) + sum(Robin_L_integrals)

.. index:: lhs

.. index:: rhs

Simplified handling of the variational formulation
==================================================

We carefully ordered the terms in the variational formulation above
into the :math:`a` and :math:`L` parts. This requires a splitting of the Robin
condition and makes the ``a`` and ``L`` expressions less readable (still we
think understanding this splitting is key for any finite element programmer!).
Fortunately, UFL allows us to specify the complete variational form
:ref:`(77) <Eq:ch:poisson0:multi:bc:varform>` as one expression and offer tools to
extract what goes into the bilinear form :math:`a(u,v)` and the linear form
:math:`L(v)`:

.. code-block:: python

    F = dot(p*grad(u), grad(v))*dx + \ 
        sum(Robin_integrals) - f*v*dx + sum(Neumann_integrals)
    a, L = lhs(F), rhs(F)

This time we can more naturally define the integrals from the
Robin condition as ``r*(u-s)*v*ds(n)``:

.. code-block:: python

    Robin_integrals = []
    for n in boundary_conditions:
        if 'Robin' in boundary_conditions[n]:
            r, s = boundary_conditions[n]['Robin']
            Robin_integrals.append(r*(u-s)*v*ds(n))

The complete code is in the ``solver_bc`` function in the
``ft08_poisson_vc.py`` file.
[**hpl 32**: The code examples here are in a solver function, not a flat program, and solver functions are explained in the next chapter... The snippets here work well, though. It's just the last section here that really does something with ``solver_bc``. Can drop this as the topic is repeated later anyway (with other types of code). Also, the variable coefficient ``p`` does not need all the attention it gets - it was explained in the next chapter, so it would be easier here to just use the normal derivative.]

Test problem          (4)
-------------------------

Let us continue to use :math:`{u_{\small\mbox{e}}}=1+x^2+2y^2` as the exact solution, and
set :math:`p=1` and :math:`f=-6` in the PDE.  Our domain is the unit square, and
we assign Dirichlet conditions at :math:`x=0` and :math:`x=1`, a Neumann condition
at :math:`y=1`, and a Robin condition at :math:`y=0`. With the given :math:`{u_{\small\mbox{e}}}`, we
realize that the Neumann condition is :math:`-4y` (which means :math:`-4` at
:math:`y=1`), while the Robin
condition can be selected in many ways. Since :math:`\partial u/\partial
n=-\partial u/\partial y=0` at :math:`y=0`, we can select :math:`s=u` and have :math:`r`
arbitrary in the Robin condition.

The boundary parts are :math:`\Gamma_{D,0}`: :math:`x=0`, :math:`\Gamma_{D,1}`: :math:`x=1`,
:math:`\Gamma_{R,0}`: :math:`y=0`, and :math:`\Gamma_{N,0}`: :math:`y=1`.

When implementing this test problem (and especially other test
problems with more complicated expressions), it is advantageous to use
symbolic computing. Below we define the exact solution as a ``sympy``
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can be fed into ``Expression`` objects.

[**hpl 33**: Remove the function heading, indent -4, drop call to ``solver_bc``. Mimics flat program and is compatible with the rest.]

.. code-block:: python

    def application_bc_test():
        # Define manufactured solution in sympy and derive f, g, etc.
        import sympy as sym
        x, y = sym.symbols('x[0] x[1]')  # UFL needs x[0] for x etc.
        u = 1 + x**2 + 2*y**2
        f = -sym.diff(u, x, 2) - sym.diff(u, y, 2)  # -Laplace(u)
        f = sym.simplify(f)
        u_00 = u.subs(x, 0)  # x=0 boundary
        u_01 = u.subs(x, 1)  # x=1 boundary
        g = -sym.diff(u, y).subs(y, 1)  # x=1 boundary, du/dn=-du/dy
        r = 1000 # any function can go here
        s = u
    
        # Turn to C/C++ code for UFL expressions
        f = sym.printing.ccode(f)
        u_00 = sym.printing.ccode(u_00)
        u_01 = sym.printing.ccode(u_01)
        g = sym.printing.ccode(g)
        r = sym.printing.ccode(r)
        s = sym.printing.ccode(s)
        print('Test problem (C/C++):\nu = %s\nf = %s' % (u, f))
        print('u_00: %s\nu_01: %s\ng = %s\nr = %s\ns = %s' %
              (u_00, u_01, g, r, s))
    
        # Turn into FEniCS objects
        u_00 = Expression(u_00)
        u_01 = Expression(u_01)
        f = Expression(f)
        g = Expression(g)
        r = Expression(r)
        s = Expression(s)
        u_exact = Expression(sym.printing.ccode(u))
    
        boundary_conditions = {
            0: {'Dirichlet': u_00},   # x=0
            1: {'Dirichlet': u_01},   # x=1
            2: {'Robin': (r, s)},     # y=0
            3: {'Neumann': g}}        # y=1
    
        p = Constant(1)
        Nx = Ny = 2
        u, p = solver_bc(
            p, f, boundary_conditions, Nx, Ny, degree=1,
            linear_solver='direct',
            debug=2*Nx*Ny < 50,  # for small problems only
            )

This simple test problem is turned into a real unit test for different
function spaces in the function ``test_solver_bc``.

Debugging boundary conditions
-----------------------------

It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the ``SubDomain.inside`` method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the output.

.. code-block:: python

    if debug:
        # Print the vertices that are on the boundaries
        coor = mesh.coordinates()
        for x in coor:
            if bx0.inside(x, True): print('%s is on x=0' % x)
            if bx1.inside(x, True): print('%s is on x=1' % x)
            if by0.inside(x, True): print('%s is on y=0' % x)
            if by1.inside(x, True): print('%s is on y=1' % x)
        # Print the Dirichlet conditions
        print('No of Dirichlet conditions:', len(bcs))
        d2v = dof_to_vertex_map(V)
        for bc in bcs:
            bc_dict = bc.get_boundary_values()
            for dof in bc_dict:
                print('dof %2d: u=%g' % (dof, bc_dict[dof]))
                if V.ufl_element().degree() == 1:
                    print('   at point %s' %
                          (str(tuple(coor[d2v[dof]].tolist()))))

In addition, it is helpful to print the exact and the numerical solution
at all the vertices as shown in the section :ref:`ch:poisson0:verify1`.

FEniCS implementation of multiple subdomains
============================================

[**hpl 34**: Drop this, because the solver is wrapped in a function, or just present the snippets. Read through once more and have in mind that there is no ``solver_bc`` function for the reader, just snippets from a flat program.]

The section :ref:`ftut:possion:2D:2mat:impl` explains how to deal with
multiple subdomains of :math:`\Omega` and a piecewise constant coefficient
function :math:`p` that takes on different constant values in the different
subdomains. We can easily add this type of :math:`p` coefficient to the
``solver_bc`` function. The signature of the function is

.. code-block:: python

    def solver_bc(
        p, f,                   # Coefficients in the PDE
        boundary_conditions,    # Dict of boundary conditions
        Nx, Ny,                 # Cell division of the domain
        degree=1,               # Polynomial degree
        subdomains=[],          # List of SubDomain objects in domain
        linear_solver='Krylov', # Alt: 'direct'
        abs_tol=1E-5,           # Absolute tolerance in Krylov solver
        rel_tol=1E-3,           # Relative tolerance in Krylov solver
        max_iter=1000,          # Max no of iterations in Krylov solver
        log_level=PROGRESS,     # Amount of solver output
        dump_parameters=False,  # Write out parameter database?
        debug=False,
        ):
    ...
        return u, p   # p may be modified

If ``subdomain`` is an empty list, we assume there are no subdomains, and
:math:`p` is an ``Expression`` or ``Constant`` object specifying a formula for
:math:`p`. If not, ``subdomain`` is a list of ``SubDomain`` objects, defining
different parts of the domain. The first element is a dummy object,
defining "the rest" of the domain. The next elements define specific
geometries in the ``inside`` methods. We start by marking all elements
with subdomain number 0, this will then be "the rest" after marking
subdomains 1, 2, and so on. The next step is to define ``p`` as a
piecewise constant function over cells and fill it with values.
We assume that the user-argument ``p`` is an array (or list) holding
the values of :math:`p` in the different parts corresponding to ``subdomains``.
The returned ``p`` is needed for flux computations. If there are no
subdomains, the returned ``p`` is just the original ``p`` argument.

The appropriate code for computing ``p`` becomes

.. code-block:: python

    import numpy as np
    if subdomains:
        # subdomains is list of SubDomain objects,
        # p is array of corresponding constant values of p
        # in each subdomain
        materials = CellFunction('size_t', mesh)
        materials.set_all(0)  # "the rest"
        for m, subdomain in enumerate(subdomains[1:], 1):
            subdomain.mark(materials, m)
    
        p_values = p
        V0 = FunctionSpace(mesh, 'DG', 0)
        p  = Function(V0)
        help = np.asarray(materials.array(), dtype=np.int32)
        p.vector()[:] = np.choose(help, p_values)

We define :math:`p(x,y)=p_0` in :math:`\Omega_0` and :math:`k(x,y)=p_1` in :math:`\Omega_1`,
where :math:`p_0>0` and :math:`p_1>0` are given constants.
As boundary conditions, we choose :math:`u=0` at :math:`y=0`, :math:`u=1` at :math:`y=1`,
and :math:`\partial u/\partial n=0` at :math:`x=0` and :math:`x=1`.
One can show that the exact solution is now given by

.. _Eq:_auto21:

.. math::

    \tag{80}
    u(x, y) = \left\lbrace\begin{array}{ll}
        {2yp_1\over p_0+p_1}, & y \leq 1/2\\ 
        {(2y-1)p_0 + p_1\over p_0+p_1}, & y \geq 1/2
        \end{array}\right.
        
        

As long as the element boundaries coincide with the internal boundary
:math:`y=1/2`, this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We can use this property to verify
the implementation and make a unit test for a series of function
spaces:

.. code-block:: python

    def test_solvers_bc_2mat():
        tol = 2E-13  # Tolerance for comparisons
    
        class Omega0(SubDomain):
            def inside(self, x, on_boundary):
                return x[1] <= 0.5+tol
    
        class Omega1(SubDomain):
            def inside(self, x, on_boundary):
                return x[1] >= 0.5-tol
    
        subdomains = [Omega0(), Omega1()]
        p_values = [2.0, 13.0]
        boundary_conditions = {
            0: {'Neumann': 0},
            1: {'Neumann': 0},
            2: {'Dirichlet': Constant(0)}, # y=0
            3: {'Dirichlet': Constant(1)}, # y=1
            }
    
        f = Constant(0)
        u_exact = Expression(
            'x[1] <= 0.5? 2*x[1]*p_1/(p_0+p_1) : '
            '((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)',
            p_0=p_values[0], p_1=p_values[1])
    
        for Nx, Ny in [(2,2), (2,4), (8,4)]:
            for degree in 1, 2, 3:
                u, p = solver_bc(
                    p_values, f, boundary_conditions, Nx, Ny, degree,
                    linear_solver='direct', subdomains=subdomains,
                    debug=False)
    
                # Compute max error in infinity norm
                u_e = interpolate(u_exact, u.function_space())
                import numpy as np
                max_error = np.abs(u_e.vector().array() -
                               u.vector().array()).max()
                assert max_error < tol, 'max error: %g' % max_error

