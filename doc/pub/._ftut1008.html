<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,unit testing,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,linear algebra backend,PETSc,Trilinos,MTL4,uBLAS,UMFPACK,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,SLEPc,KrylovSolver,random start vector (linear systems),Poisson's equation with variable coefficient,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition">

<title>The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               1,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               1,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'New feature: vector function space', 3, None, '___sec70'),
              (u'New feature: constant vectors', 3, None, '___sec71'),
              (u'New feature: `nabla_grad`', 3, None, '___sec72'),
              (u'New feature: stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'A simple implementation', 2, None, '___sec78'),
              (u'Test problem', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Flow past a cylinder', 2, None, '___sec81'),
              (u'FEniCS implementation', 3, None, '___sec82'),
              (u'Mesh generation, subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Physical problem formulation', 1, None, '___sec84'),
              (u'Mathematical problem formulation', 1, None, '___sec85'),
              (u'Scaling the equation', 1, None, '___sec86'),
              (u'Finite element variational formulation',
               1,
               None,
               '___sec87'),
              (u'Mesh generation', 1, None, '___sec88'),
              (u'Subdomain markers', 1, None, '___sec89'),
              (u'The complete program', 1, None, '___sec90'),
              (u'Making more flexible PDE solvers',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactored implementation',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Plotting for the test problem', 3, None, '___sec94'),
              (u'Make a module!', 3, None, '___sec95'),
              (u'Verification and unit tests', 2, None, '___sec96'),
              (u'Writing out the discrete solution',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Generating a hypercube', 3, None, '___sec99'),
              (u'Exercise 2: Solve a Poisson problem', 2, None, '___sec100'),
              (u'Remarks', 3, None, '___sec101'),
              (u'Exercise 3: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec103'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Setting linear solver parameters', 3, None, '___sec105'),
              (u'Linear algebra backend', 3, None, '___sec106'),
              (u'The `parameters` database', 3, None, '___sec107'),
              (u'An extended solver function', 3, None, '___sec108'),
              (u'Remark regarding unit tests', 3, None, '___sec109'),
              (u'Linear solvers and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Creating the linear system explicitly',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'A variable-coefficient Poisson problem',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'Test problem', 3, None, '___sec114'),
              (u'Modifications of the PDE solver', 2, None, '___sec115'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec118'),
              (u'Finite difference approximations', 3, None, '___sec119'),
              (u'Surface plot', 3, None, '___sec120'),
              (u'Contour plot', 3, None, '___sec121'),
              (u'Curve plot through the mesh', 3, None, '___sec122'),
              (u'Curve plot of the flux', 3, None, '___sec123'),
              (u'Test problem', 3, None, '___sec124'),
              (u'Postprocessing computations', 1, None, '___sec125'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec127'),
              (u'Error functional', 3, None, '___sec128'),
              (u'Flux Functionals', 3, None, '___sec129'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Various ways of computing the error', 3, None, '___sec131'),
              (u'Computing convergence rates empirically',
               3,
               None,
               '___sec132'),
              (u'Test problem', 3, None, '___sec133'),
              (u'Experiments', 3, None, '___sec134'),
              (u'Multiple domains and boundaries', 1, None, '___sec135'),
              (u'Combining Dirichlet and Neumann conditions',
               2,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 3, None, '___sec137'),
              (u'Variational formulation', 3, None, '___sec138'),
              (u'FEniCS implementation', 3, None, '___sec139'),
              (u'Multiple Dirichlet conditions',
               2,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Working with subdomains',
               2,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 3, None, '___sec142'),
              (u'Mesh functions', 3, None, '___sec143'),
              (u'C++ strings for subdomain definitions',
               3,
               None,
               '___sec144'),
              (u'Exercise 4: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Multiple Neumann, Robin, and Dirichlet conditions',
               2,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 3, None, '___sec147'),
              (u'A general model problem', 3, None, '___sec148'),
              (u'Variational formulation', 3, None, '___sec149'),
              (u'FEniCS implementation of boundary conditions',
               2,
               None,
               '___sec150'),
              (u'Simplified handling of the variational formulation',
               3,
               None,
               '___sec151'),
              (u'Test problem', 3, None, '___sec152'),
              (u'Debugging the setting of boundary conditions',
               3,
               None,
               '___sec153'),
              (u'FEniCS implementation of multiple subdomains',
               2,
               None,
               '___sec154'),
              (u'Bibliography', 1, None, '___sec155')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\Vg}{V^{(\mbox{g})}} % vector space for grad(u)
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\dr}{\, \mathrm{d}r}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\ub}{u_{\mathrm{b}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
\newcommand{\WmK}{\mathrm{W}\cdot\mathrm{m}^{-1}\cdot\mathrm{K}^{-1}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">The FEniCS Tutorial - Writing State-of-the-Art Finite Element Solvers in Minutes</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: vector function space</a></li>
     <!-- navigation toc: --> <li><a href="#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: <code>nabla_grad</code></a></li>
     <!-- navigation toc: --> <li><a href="#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: stress computation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:subdomains" style="font-size: 80%;"><b>Mesh generation, subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Physical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Scaling the equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mesh generation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Subdomain markers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson" style="font-size: 80%;"><b>Making more flexible PDE solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactored implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting for the test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a module!</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing out the discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating a hypercube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting linear solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>parameters</code> database</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solvers and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating the linear system explicitly</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec115" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifications of the PDE solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec120" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various ways of computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates empirically</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple domains and boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec139" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Neumann, Robin, and Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A general model problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified handling of the variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging the setting of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1014.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation of multiple subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1015.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0008"></a>
<!-- !split -->

<center><h1 id="ch:gallery">A Gallery of finite element solvers</h1></center> <!-- chapter heading -->

<p>
<blockquote>
    The goal of this chapter is to demonstrate how a range of important PDEs
    from science and engineering can be quickly solved with a few lines of
    FEniCS code. We start with the heat equation and continue with a
    nonlinear Poisson equation, the equations for linear elasticity, and
    the Navier-Stokes equations. These problems illustrate how to solve
    time-dependent problems, nonlinear problems, vector-valued problems,
    and systems of PDE. For each problem, we derive the variational
    formulation and express the problem in Python in a way that closely
    resembles the mathematics.
</blockquote>


<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 4</b>: We say "systems of PDE" but we use a splitting method. We have not really taked about systems (using mixed function spaces).)</font>
<!-- end inline comment -->

<p>
<!-- Stand-alone notebook? -->

<h1 id="ch:fundamentals:diffusion">The heat equation</h1>

<p>
As a first extension of the Poisson problem from the previous chapter,
we consider the time-dependent heat equation, or time-dependent
diffusion equation. This is the natural extension of the Poisson
equation describing the stationary distribution of heat in a body to a
time-dependent problem.

<p>
We will see that by discretizing time into small time intervals and
applying standard time-stepping methods, we can solve the heat
equation by solving a sequence of variational problems, much like the
one we encountered for the Poisson equation.

<p>
<!-- The solution of -->
<!-- nonlinear problems, as we showed in Section -->
<!-- ref{ch:poisson0:nonlinear}, can also be automated (cf. Section -->
<!-- <a href="#ftut:nonlinear:Newton:auto">A simple FEniCS implementation</a>), but many scientists will prefer to -->
<!-- code the solution strategy of the nonlinear problem themselves and -->
<!-- experiment with various combinations of strategies in difficult -->
<!-- problems. Time-dependent problems are somewhat similar in this -->
<!-- respect: we have to add a time discretization scheme, which is often -->
<!-- quite simple, making it natural to explicitly code the details of the -->
<!-- scheme so that the programmer has full control. -->
<!-- We shall explain how -->
<!-- easily this is accomplished through examples. -->

<h2 id="___sec49">PDE problem </h2>

<p>
Our model problem for time-dependent PDEs reads

$$
\begin{align}
{\partial u\over\partial t} &= \nabla^2 u + f\hbox{ in }\Omega,
\tag{3.1}\\ 
u &= \ub\hbox{ on } \partial \Omega,
\tag{3.2}\\ 
u &= u_0 \mbox{ at } t=0\tp
\tag{3.3}
\end{align}
$$

Here, \( u \) varies with space and time, e.g., \( u=u(x,y,t) \) if the spatial
domain \( \Omega \) is two-dimensional. The source function \( f \) and the
boundary values \( \ub \) may also vary with space and time.
The initial condition \( u_0 \) is a function of space only.

<h2 id="ftut:timedep:diffusion1">Variational formulation</h2>

<p>
A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a sequence of
stationary problems, and then turn each stationary problem into a
variational formulation.

<p>
Let superscript \( n \) denote a quantity at time \( t_n \), where \( n \) is an
integer counting time levels. For example, \( u^n \) means \( u \) at time
level \( n \). A finite difference discretization in time first consists
of sampling the PDE at some time level, say \( t_n \):

$$
\begin{equation} {\partial \over\partial t}u^n = \nabla^2 u^n + f^n\tp
\tag{3.4}
\end{equation}
$$

The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons, we choose a
simple backward difference:

$$
\begin{equation} {\partial \over\partial t}u^n\approx {u^n - u^{n-1}\over{\dt}},
\tag{3.5}
\end{equation}
$$

where \( \dt \) is the time discretization parameter.
Inserting <a href="#mjx-eqn-3.5">(3.5)</a> in <a href="#mjx-eqn-3.4">(3.4)</a> yields

$$
\begin{equation}
{u^n - u^{n-1}\over{\dt}} = \nabla^2 u^n + f^n\tp
\tag{3.6}
\end{equation}
$$

This is our time-discrete version of the heat equation
<a href="#mjx-eqn-3.1">(3.1)</a>. This is a so-called <em>backward Euler</em> or
<em>implicit Euler</em> discretization. Alternatively, we may also view this
as a finite element discretization in time in the form of the first order
\( \mathrm{dG}(0) \) method, which here is identical to the backward Euler
method.

<p>
We may reorder <a href="#mjx-eqn-3.6">(3.6)</a> so
that the left-hand side contains the terms with the unknown \( u^n \) and
the right-hand side contains computed terms only. The result
is a sequence of spatial
(stationary) problems for \( u^n \) (assuming \( u^{n-1} \) is known from
computations at the previous time level):

$$
\begin{align}
u^0 &= u_0, \tag{3.7}\\ 
u^n - {\dt}\nabla^2 u^n &=  u^{n-1} + {\dt} f^n,\quad n=1,2,\ldots
\tag{3.8}
\end{align}
$$

Given \( u_0 \), we can solve for \( u^0 \), \( u^1 \), \( u^2 \), and so on.

<p>
An alternative to <a href="#mjx-eqn-3.8">(3.8)</a>, which can be
convenient in implementations, is to collect
all terms on one side of the equality sign:

$$
\begin{equation}
u^n - {\dt}\nabla^2 u^n -  u^{n-1} - {\dt} f^n = 0,\quad n=1,2,\ldots
\tag{3.9}
\end{equation}
$$

<p>
We use a finite element method to solve
<a href="#mjx-eqn-3.7">(3.7)</a> and either of the equations
<a href="#mjx-eqn-3.8">(3.8)</a> or <a href="#mjx-eqn-3.9">(3.9)</a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function \( v\in \hat V \) and integrate second-derivatives by
parts. Introducing the symbol \( u \) for \( u^n \) (which is natural in the
program), the resulting weak form arising from
formulation <a href="#mjx-eqn-3.8">(3.8)</a>
can be conveniently written in
the standard notation:

$$ a(u,v)=L_n(v),$$

where

$$
\begin{align}
a(u,v) &= \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v\right) \dx, \tag{3.10}\\ 
L_n(v) &= \int_\Omega \left(u^{n-1} + {\dt}  f^n\right)v \dx\tp
\tag{3.11}
\end{align}
$$

The alternative form <a href="#mjx-eqn-3.9">(3.9)</a> has an
abstract formulation

$$ F(u;v) = 0,$$

where

$$
\begin{equation}
F(u; v) = \int_\Omega  uv + {\dt}
\nabla u\cdot \nabla v -
(u^{n-1} + {\dt} f^n)v \dx\tp
\tag{3.12}
\end{equation}
$$

<p>
In addition to the variational problem to be solved in each time step,
we also need to approximate the initial condition
<a href="#mjx-eqn-3.7">(3.7)</a>. This equation can also be turned into a
variational problem:

$$ a_0(u,v)=L_0(v),$$

with

$$
\begin{align}
a_0(u,v) &= \int_\Omega uv \dx, \tag{3.13}\\ 
L_0(v) &= \int_\Omega u_0 v \dx\tp \tag{3.14}
\end{align}
$$

When solving this variational problem, \( u^0 \) becomes the
\( L^2 \) projection of the given initial value \( u_0 \) into the finite
element space. The alternative is to construct \( u^0 \) by just
interpolating the initial value \( u_0 \); that is,
if \( u^0=\sum_{j=1}^N U^0_j\phi_j \), we simply set \( U_j=u_0(x_j,y_j) \),
where \( (x_j,y_j) \) are the coordinates of node number \( j \). We refer to
these two strategies as computing the initial condition by either
projection or interpolation. Both operations are easy to
compute in FEniCS through one statement, using either the <code>project</code> or
<code>interpolate</code> function.

<p>
In summary, we thus need to solve the following sequence of variational
problems to compute the finite element solution to the heat equation:
find \( u^0\in V \) such that \( a_0(u^0,v)=L_0(v) \) holds for all \( v\in\hat V \),
and then find \( u^n\in V \)
such that \( a(u^n,v)=L_n(v) \) for all \( v\in\hat V \),
or alternatively, \( F(u^n,v)=0 \) for all \( v\in\hat V \),
for \( n=1,2,\ldots \).

<h2 id="ftut:timedep:diffusion1:impl">A simple FEniCS implementation</h2>

<p>
Our program needs to implement the time-stepping manually, but can
rely on FEniCS to easily compute \( a_0 \), \( L_0 \), \( F \), \( a \), and \( L \), and solve
the linear systems for the unknowns.

<h3 id="___sec52">Test problem </h3>

<p>
Just as for the Poisson problem from the previous chapter, we
construct a test problem that makes it easy to determine if the
calculations are correct. Since we know that our first-order
time-stepping scheme is exact for linear functions, we create a test
problem which has a linear variation in time. We combine this with a
quadratic variation in space. We thus take

$$
\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
\tag{3.15}
\end{equation}
$$

which yields a function whose computed values at the nodes will be
exact, regardless of the size of the elements and \( \dt \), as long as
the mesh is uniformly partitioned. By inserting
<a href="#mjx-eqn-3.15">(3.15)</a> into the heat equation
<a href="#mjx-eqn-3.1">(3.1)</a>, we find that the right-hand side \( f \) must
be given by \( f(x,y,t)=\beta - 2 - 2\alpha \). The boundary value
is \( \ub(x, y, t) = 1 + x^2 + \alpha y^2 + \beta t \) and the initial
value is \( u_0(x, y) = 1 + x^2 + \alpha y^2 \).

<h3 id="___sec53">FEniCS implementation </h3>

<p>
A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition \( \ub(x, y,
t) = 1 + x^2 + \alpha y^2 + \beta t \). A natural solution is to use a
FEniCS <code>Expression</code> with time \( t \) as a parameter, in addition to the
parameters \( \alpha \) and \( \beta \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u_b <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                 degree<span style="color: #666666">=2</span>, alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)
</pre></div>
<p>
This expression uses the components of <code>x</code> as independent
variables, while <code>alpha</code>, <code>beta</code>, and <code>t</code> are parameters.  The
parameters can later be updated as in

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_b<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
</pre></div>
<p>
The essential boundary conditions, along the entire boundary in this case,
are set in the usual way:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)
</pre></div>
<p>
We shall use <code>u</code> for the unknown \( u^n \) at the new time level and <code>u_p</code>
for \( u^{n-1} \) at the previous time level. The initial value of <code>u_p</code> can be
computed by either projection or interpolation of \( u_0 \). Since we set
<code>t = 0</code> for the boundary value <code>u_b</code>, we can use this also to specify
the initial condition. We can then do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_p <span style="color: #666666">=</span> project(u_b, V)
<span style="color: #408080; font-style: italic"># or</span>
u_p <span style="color: #666666">=</span> interpolate(u_b, V)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Projecting versus interpolating the initial condition.</b>
To actually recover the
exact solution <a href="#mjx-eqn-3.15">(3.15)</a> to machine precision,
it is important not to compute the discrete initial condition by
projecting \( u_0 \), but by interpolating \( u_0 \) so that the degrees of freedom have
exact values at \( t=0 \) (projection results in approximative values at the
nodes).
</div>


<p>
We may either define \( a \) or \( L \) according to the formulas above, or
we may just define \( F \) and ask FEniCS to figure out which terms that
go into the bilinear form \( a \) and which that go into the linear form
\( L \). The latter is convenient, especially in more complicated problems,
so we illustrate that construction of \( a \) and \( L \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
Finally, we perform the time-stepping in a loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> Function(V)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt
    u_b<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)


    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
In the last step of the time-stepping loop, we assign the values of
the variable <code>u</code> (the new computed solution) to the variable
containing the values at the previous time step. This must be done
using the <code>assign</code> member function. If we instead try to do <code>u_p = u</code>,
we will set the <code>u_p</code> Python variable to be the <em>same</em> variable as <code>u</code>
which is not what we want. (We need two variables, one for the values
at the previous time step and one for the values at the current time
step.)

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remember to update expression objects with the current time!</b>
Inside the time loop,
observe that <code>u_b.t</code> must be updated before the <code>solve</code> statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the <code>u_b</code> object
for values.)
</div>


<p>
The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in the Poisson equation example in
the section <a href="._ftut1006.html#ch:poisson0:impl:dissect">Dissection of the program</a>, we compute the
difference between the array of nodal values of <code>u</code> and the array
nodal values of
the interpolated exact solution. This may be done as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_e <span style="color: #666666">=</span> interpolate(u_b, V)
error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))
</pre></div>
<p>
The complete program code for this time-dependent case goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">10</span>     <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>          <span style="color: #408080; font-style: italic"># parameter alpha</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>         <span style="color: #408080; font-style: italic"># parameter beta</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">8</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
u_b <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                 degree<span style="color: #666666">=2</span>, alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_b, boundary)

<span style="color: #408080; font-style: italic"># Define initial value</span>
u_p <span style="color: #666666">=</span> interpolate(u_b, V)
<span style="color: #408080; font-style: italic">#u_p = project(u_b, V)</span>

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

<span style="color: #408080; font-style: italic"># Time-stepping</span>
u <span style="color: #666666">=</span> Function(V)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt
    u_b<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># Compute error at vertices</span>
    u_e <span style="color: #666666">=</span> interpolate(u_b, V)
    error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;t = </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
The code is available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/heat.py" target="_self"><tt>ft03_heat.py</tt></a>.

<h2 id="___sec54">Diffusion of a Gaussian function </h2>

<h3 id="___sec55">The mathematical problem </h3>

<p>
Now we want to solve a more relevant test problem, namely the diffusion of
a Gaussian hill. It means that the initial value is given by

$$ u_0(x,y)= e^{-ax^2 - ay^2}$$

on a domain \( [-2,2]\times [2,2] \). We will take \( a = 5 \). For this
problem we will use homogeneous Dirichlet boundary conditions (\( \ub = 0 \)).

<h3 id="___sec56">FEniCS implementation </h3>

<p>
Which are the required changes to our previous program? One major
change is that the domain is not a unit square anymore. We also want to
use much higher resolution. The new domain can
be created easily in FEniCS using <code>RectangleMesh</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">30</span>
mesh <span style="color: #666666">=</span> RectangleMesh(Point(<span style="color: #666666">-2</span>,<span style="color: #666666">-2</span>), Point(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), nx, ny)
</pre></div>
<p>
We also need to redefine the initial condition and boundary condition.
Both are easily changed by defining a new <code>Expression</code> and by setting
\( u = 0 \) on the boundary. We will also save the solution to file in VTK
format in each time step:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">vtkfile <span style="color: #666666">&lt;&lt;</span> (u, t)
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 5</b>: Remember to output as <code>(u, t)</code> also in other examples below.)</font>
<!-- end inline comment -->

<p>
The complete program appears below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">50</span>     <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">30</span>
mesh <span style="color: #666666">=</span> RectangleMesh(Point(<span style="color: #666666">-2</span>,<span style="color: #666666">-2</span>), Point(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)

<span style="color: #408080; font-style: italic"># Define initial value</span>
u_0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;exp(-a*pow(x[0],2) - a*pow(x[1],2))&#39;</span>,
                 degree<span style="color: #666666">=2</span>, a<span style="color: #666666">=5</span>)
u_p <span style="color: #666666">=</span> interpolate(u_0, V)
u_p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;initial value&#39;</span>)
vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;gaussian_diffusion.pvd&#39;</span>)
vtkfile <span style="color: #666666">&lt;&lt;</span> (u_p, <span style="color: #666666">0.0</span>)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;solution&#39;</span>)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># Save to file and plot solution</span>
    vtkfile <span style="color: #666666">&lt;&lt;</span> (u, <span style="color: #008000">float</span>(t))
    plot(u)
    time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.3</span>)

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
This program is also available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/gaussian_diffusion.py" target="_self"><tt>ft04_gaussian_diffusion.py</tt></a>.

<h3 id="___sec57">Visualization in ParaView </h3>

<p>
To visualize the diffusion of the Gaussian hill, start ParaView,
choose <b>File - Open</b>, open the file <code>gaussian_diffusion.pvd</code>, click
the green <b>Apply</b> button on the left to see the initial condition
being plotted. Choose <b>View - Animation View</b>. Click on the play
button or (better) the next frame button in the row of buttons at the
top of the GUI to see the evolution of the scalar field you have just
computed:

<p>
<br />
<br />

<p>
<center><p><img src="fig/paraview_animation_buttons.png" align="bottom" width=300></p></center>

<p>
<br />
<br />

<p>
The cross in the middle of the plot can be turned off by the <b>Show Center</b>
button:

<p>
<br />
<br />

<p>
<center><p><img src="fig/paraview_show_center_button.png" align="bottom" width=150></p></center>

<p>
<br />
<br />

<p>
Choose <b>File - Save Animation...</b> to save the animation to the AVI or OGG video format.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov/diffusion0.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<center><p><img src="fig/diffusion0_paraview_animation.png" align="bottom" width=600></p></center>

<p>
Once the animation has been saved to file, you can play the animation
offline using a player such as mplayer or VLC, or upload your
animation to YouTube. Below is a sequence of
snapshots of the solution.

<p>
<br />
<br />

<p>
<center><p><img src="fig/diffusion0_3snapshots.png" align="bottom" width=800></p></center>

<p>
<!-- Stand-alone notebook? -->

<h1 id="ftut1:gallery:nonlinearpoisson">A nonlinear Poisson equation</h1>

<p>
We shall now address how to solve nonlinear PDEs. We will see that
nonlinear problems can be solved just as easily as linear problems in
FEniCS, by simply defining a nonlinear variational problem and calling
the <code>solve</code> function. When doing so, we will encounter a subtle
difference in how the variational problem is defined.

<h2 id="___sec59">PDE problem </h2>

<p>
As a sample PDE for the implementation of nonlinear problems, we
take the following nonlinear Poisson equation:

$$
\begin{equation}
-\nabla\cdot\left( q(u)\nabla u\right) = f,
\tag{3.16}
\end{equation}
$$

in \( \Omega \), with \( u=\ub \) on the boundary \( \partial\Omega \).
The coefficient \( q(u) \) makes the equation nonlinear (unless \( q(u) \)
is constant in \( u \)).

<h2 id="___sec60">Variational formulation </h2>

<p>
As usual, we multiply our PDE by a test function \( v\in\hat V \),
integrate over the domain, and integrate the second-order derivatives
by parts.  The boundary integral arising from integration by parts
vanishes wherever we employ Dirichlet conditions.  The resulting
variational formulation of our model problem becomes: find \( u \in V \)
such that

$$
\begin{equation}
F(u; v) = 0 \quad \forall v \in \hat{V},
\tag{3.17}
\end{equation}
$$

where

$$
\begin{equation}
F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v + fv \dx,
\tag{3.18}
\end{equation}
$$

and

$$
\begin{align*}
     V      &= \{v \in H^1(\Omega) : v = \ub \mbox{ on } \partial\Omega\},\\ 
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}\tp
\end{align*}
$$

<p>
The discrete problem arises as usual by restricting \( V \) and \( \hat V \)
to a pair of discrete spaces. As before, we omit any subscript on
the discrete spaces and discrete solution.
The discrete nonlinear problem is then written as: find \( u\in V \) such that

$$
\begin{equation}
  F(u; v) = 0 \quad \forall v \in \hat{V},
\tag{3.19}
\end{equation}
$$

with \( u = \sum_{j=1}^N U_j \phi_j \). Since \( F \) is a nonlinear function
of \( u \), the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns \( U_1,\ldots,U_N \).

<h2 id="ftut:nonlinear:Newton:auto">A simple FEniCS implementation</h2>

<h3 id="___sec62">Test problem </h3>

<p>
To solve a test problem, we need to choose the right-hand side \( f \),
the coefficient \( q(u) \) and the boundary value \( \ub \).  Previously, we
have worked with manufactured solutions that can be reproduced without
approximation errors. This is more difficult in nonlinear problems,
and the algebra is more tedious. However, we may utilize SymPy for
symbolic computing and integrate such computations in the FEniCS
solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package. In particular, we will use the
SymPy functions <code>diff</code> for symbolic differentiation and <code>ccode</code> for
C/C++ code generation.

<p>
We try out a two-dimensional manufactured
solution that is linear in the unknowns:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Warning: from fenics import * will import both `sym` and</span>
<span style="color: #408080; font-style: italic"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span style="color: #408080; font-style: italic"># overwrite these objects.</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Use SymPy to compute f given manufactured solution u</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y
f <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">-</span> \ 
      sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to have valid syntax for
FEniCS <code>Expression</code> objects, we must use <code>x[0]</code> and <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expressions for <code>u</code> and <code>f</code> into C or C++ syntax for
FEniCS <code>Expression</code> objects needs two steps. First, we ask for the C
code of the expressions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
f_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
</pre></div>
<p>
Sometimes, we need some editing of the result to match the required
syntax of <code>Expression</code> objects, but not in this case. (The primary
example is that <code>M_PI</code> for \( \pi \) in C/C++ must be replaced by <code>pi</code> for
<code>Expression</code> objects.) In our case here, the output of <code>c_code</code> and
<code>f_code</code> is

<p>

<!-- code=c (!bc ccod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> <span style="color: #666666">1</span>
<span style="color: #666666">-10*</span>x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">10</span>
</pre></div>
<p>
After having defined the mesh, the function space, and the boundary,
we define the boundary value <code>u_b</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_b <span style="color: #666666">=</span> Expression(u_code)
</pre></div>
<p>
Similarly, we define the right-hand side function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> Expression(f_code)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Name clash between <code>fenics</code> and program variables.</b>
In a program like the one above, strange errors may occur due to
name clashes. If you define <code>sym</code> and <code>q</code> prior to doing
<code>from fenics import *</code>, the latter statement will also import
variables with the names <code>sym</code> and <code>q</code>, overwriting
the objects you have previously defined! This may lead to strange
errors. The safest solution is to do <code>import fenics as fe</code>
and then prefix all FEniCS
object names by <code>fe</code>. The next best solution is to do
<code>from fenics import *</code> first and then define your own variables
that overwrite those imported from <code>fenics</code>. This is acceptable
if we do not need <code>sym</code> and <code>q</code> from <code>fenics</code>.
</div>


<h3 id="___sec63">FEniCS implementation </h3>

<p>
A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is to state the formula for \( F \) and call
<code>solve(F == 0, u, bc)</code> instead of <code>solve(a == L, u, bc)</code> as we did
in the linear case. Here is a minimalistic code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">32</span>, <span style="color: #666666">32</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
u_b <span style="color: #666666">=</span> Expression(<span style="color: #666666">...</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_b, boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> Function(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Expression(<span style="color: #666666">...</span>)
F <span style="color: #666666">=</span> q(u)<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u, bc)
</pre></div>
<p>
The major difference from a linear problem is that the unknown function
<code>u</code> in the variational form in the nonlinear case
must be defined as a <code>Function</code>, not a <code>TrialFunction</code>. In some sense
this is a simplification from the linear case where we must define <code>u</code>
first as a <code>TrialFunction</code> and then as a <code>Function</code>.

<p>
The <code>solve</code> function takes the nonlinear equations, derives symbolically
the Jacobian matrix, and runs a Newton method to compute the solution.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 6</b>: Should we display all codes like this one?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 7</b>: Now experimenting with refernce to repo and in html and sphinx a button will fold out the code.)</font>
<!-- end inline comment -->

<p>
The complete code is found in the file
<a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/ft05_nlpoisson.py" target="_self"><tt>ft05_nlpoisson.py</tt></a>.

<p>

<!-- code=python (!bc pypro-h) typeset with pygments style "default" -->

<script type="text/javascript">
function show_hide_code63(){
  $("#code63").toggle();
}
</script>
<button type="button" onclick="show_hide_code63()">Show/hide code</button>
<div id="code63" style="display:none">
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">FEniCS tutorial demo program: Poisson equation with Dirichlet conditions.</span>
<span style="color: #BA2121; font-style: italic">Simplest example of computation and visualization with FEniCS.</span>

<span style="color: #BA2121; font-style: italic">-div(q(u)*grad(u)) = f on the unit square.</span>
<span style="color: #BA2121; font-style: italic">u = u0 on the boundary.</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function

<span style="color: #408080; font-style: italic"># Warning: from fenics import * will import both `sym` and</span>
<span style="color: #408080; font-style: italic"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span style="color: #408080; font-style: italic"># overwrite these objects.</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Use SymPy to compute f given manufactured solution u</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y
f <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">-</span> \
      sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
u_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
f_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u =&#39;</span>, u_code)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;f =&#39;</span>, f_code)

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">8</span>, <span style="color: #666666">8</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
u_b <span style="color: #666666">=</span> Expression(u_code, degree<span style="color: #666666">=2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_b, boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> Function(V) <span style="color: #408080; font-style: italic"># not TrialFunction!</span>
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Expression(f_code, degree<span style="color: #666666">=2</span>)
F <span style="color: #666666">=</span> q(u)<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution</span>
u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;solution&#39;</span>)
<span style="color: #408080; font-style: italic">#plot(u)</span>

<span style="color: #408080; font-style: italic"># Compute error at vertices</span>
u_e <span style="color: #666666">=</span> interpolate(u_b, V)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> error)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>

</div>
<p>
Running the code gives output that tells how the Newton iteration
progresses. With \( 2(6\times 4) \) cells we get convergence in 7
iterations with a tolerance of \( 10^{-9} \), and the error in the
numerical solution is about \( 10^{-11} \). With \( 2(3\times 3) \) and
\( 2(8\times 8) \) cells the error is identically zero.  Other resolutions
may bring the error up to the level of the tolerance in the Newton
iterations. These results bring evidence for a correct implementation.
Thinking in terms of finite differences on a uniform mesh, P1 elements
mimics standard second-order differences, which compute the derivative
of a linear function exactly, also a quadratic function. Here, \( \nabla
u \) is a constant vector, but then multiplied by \( (1+u^2) \), which is a
second-order polynomial in \( x \) and \( y \), which the divergence
&quot;difference operator&quot; should compute exactly.  We can therefore,
even with P1 elements, expect the manufactured \( u \) to be reproduced by
our method. With a nonlinearity like \( 1+u^4 \), this will not be the
case, and we would need to verify convergence rates instead.

<p>
The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on the numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much better manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter ref{ftut:nonlinear} in <a href="._ftut1015.html#ftut2">[24]</a> and show how we can implement our
own solution algorithms for nonlinear equations and also how we can
steer the parameters in the automated Newton method used above. You
will then see how easy it is to implement tailored solution
strategies for nonlinear problems in FEniCS.

<p>
<!-- Stand-alone notebook? -->

<h1 id="ftut:elast">The equations of linear elasticity</h1>

<p>
Analysis of structures is one of the major activities of modern
engineering, thus making the PDEs for deformation of elastic bodies
likely the most popular PDE model in the world.
It takes just one page of code to solve the equations of 2D or 3D
elasticity in FEniCS, and the details follow below.

<h2 id="___sec65">PDE problem </h2>

<p>
The equations governing small elastic deformations of a body \( \Omega \)
can be written as

$$
\begin{align}
-\nabla\cdot\sigma &= f\hbox{ in }\Omega,
\tag{3.20}\\ 
\sigma &= \lambda\,\hbox{tr}\,\varepsilon I + 2\mu\varepsilon,
\tag{3.21}\\ 
\varepsilon &= \frac{1}{2}\left(\nabla u + (\nabla u)^{\top}\right),
\tag{3.22}
\end{align}
$$

where \( \sigma \) is the stress tensor, \( f \) is the body force per unit
volume, \( \lambda \) and \( \mu \) are Lame's elasticity parameters for the
material in \( \Omega \), \( I \) is the identity tensor, \( \mathrm{tr} \) is the
trace operator on a tensor, \( \varepsilon \) is the strain tensor
(symmetric gradient), and \( u \) is the displacement vector field.
We have here assumed isotropic elastic conditions.

<p>
We combine <a href="#mjx-eqn-3.21">(3.21)</a> and
<a href="#mjx-eqn-3.22">(3.22)</a> to obtain

$$
\begin{equation}
\sigma = \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top})\tp
\tag{3.23}
\end{equation}
$$

Note that <a href="#mjx-eqn-3.20">(3.20)</a>-<a href="#mjx-eqn-3.22">(3.22)</a>
can easily be transformed to a single vector PDE for \( u \), which is the governing
PDE for the unknown \( u \) (Navier's equation).
In the derivation of the variational formulation,
however, it is convenient to keep the splitting of the equations as above.

<h2 id="ftut:elast:varform">Variational formulation</h2>

<p>
The variational formulation of
<a href="#mjx-eqn-3.20">(3.20)</a>--<a href="#mjx-eqn-3.22">(3.22)</a>
consists of forming the inner product of
<a href="#mjx-eqn-3.20">(3.20)</a> and a <em>vector</em> test function
\( v\in \hat{V} \), where \( \hat{V} \) is a test vector function space, and
integrating over the domain \( \Omega \):

$$ -\int_\Omega (\nabla\cdot\sigma) \cdot v \dx =
\int_\Omega f\cdot v\dx\tp$$

Since \( \nabla\cdot\sigma \) contains second-order derivatives of the primary
unknown \( u \), we integrate this term by parts:

$$ -\int_\Omega (\nabla\cdot\sigma) \cdot v \dx
= \int_\Omega \sigma : \nabla v\dx - \int_{\partial\Omega}
(\sigma\cdot n)\cdot v \ds,$$

where the colon operator is the inner product between tensors
(summed pairwise product of all elements), and \( n \)
is the outward unit normal at the boundary. The quantity \( \sigma\cdot n \)
is known as the <em>traction</em> or stress vector at the boundary, and is often
prescribed as a boundary condition. We assume that it is prescribed
at a part \( \partial\Omega_T \) of the boundary and set \( T = \sigma\cdot
n \). On the remaining part of the boundary, we assume that the value of
the displacement is given as a Dirichlet condition.
We then have

$$
\int_\Omega \sigma : \nabla v \dx =
\int_\Omega f\cdot v \dx
+ \int_{\partial\Omega_T} T\cdot v\ds\tp$$

Inserting the expression <a href="#mjx-eqn-3.23">(3.23)</a> for
\( \sigma \) gives the variational form with \( u \) as unknown. Note that the
boundary integral on the remaining part
\( \partial\Omega\setminus\Omega_T \) vanishes due to the Dirichlet
condition (\( v = 0 \)).

<p>
We can now summarize the variational formulation as: find \( u\in V \) such that

$$
\begin{equation}
a(u,v) = L(v)\quad\forall v\in\hat{V},
\tag{3.24}
\end{equation}
$$

where

$$
\begin{align}
a(u,v) &= \int_\Omega\sigma(u) :\nabla v \dx,
\tag{3.25}
\\ 
\sigma(u) &= \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top}),
\tag{3.26}\\ 
L(v) &= \int_\Omega f\cdot v\dx + \int_{\partial\Omega_T}
T\cdot v\ds\tp
\tag{3.27}
\end{align}
$$

<p>
One can show that the inner product of a symmetric tensor \( A \) and a
non-symmetric tensor \( B \) vanishes. If we express \( \nabla v \) as a sum
of its symmetric and non-symmetric parts, only the symmetric part will
survive in the product \( \sigma :\nabla v \) since \( \sigma \) is a
symmetric tensor. Thus replacing \( \nabla u \) by the symmetric gradient
\( \epsilon(u) \) gives rise to the slightly different variational form

$$
\begin{equation}
a(u,v) = \int_\Omega\sigma(u) :\varepsilon(v) \dx,
\tag{3.28}
\end{equation}
$$

where \( \varepsilon(v) \) is the symmetric part of \( \nabla v \):

$$ \varepsilon(v) = \frac{1}{2}\left(\nabla v + (\nabla v)^{\top}\right)\tp$$

The formulation <a href="#mjx-eqn-3.28">(3.28)</a> is what naturally
arises from minimization of elastic potential energy is a more
popular formulation than <a href="#mjx-eqn-3.25">(3.25)</a>.

<h2 id="___sec67">A simple FEniCS implementation </h2>

<h3 id="___sec68">Test problem </h3>

<p>
As a test example, we may look at a clamped beam deformed under its
own weight. Then \( f=(0,0,-\varrho g) \) is the body force per unit
volume with \( \varrho \) the
density of the beam and \( g \) the acceleration of gravity. The beam is
box-shaped with length \( L \) and square cross section of width \( W \). We
set \( u=(0,0,0) \) at the clamped end, \( x=0 \). The rest of the boundary is
traction free; that is, we set \( T = 0 \).

<h3 id="___sec69">The code </h3>

<p>
We first list the code and then comment upon the new constructions
compared to the Poisson equation case.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Scaled variables</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1</span>; W <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
lambda_ <span style="color: #666666">=</span> <span style="color: #666666">1</span>
rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>
delta <span style="color: #666666">=</span> W<span style="color: #666666">/</span>L
gamma <span style="color: #666666">=</span> <span style="color: #666666">0.25*</span>delta<span style="color: #666666">**2</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
mu <span style="color: #666666">=</span> beta
g <span style="color: #666666">=</span> gamma

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> BoxMesh(Point(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>), Point(L,W,W), <span style="color: #666666">10</span>, <span style="color: #666666">3</span>, <span style="color: #666666">3</span>)
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">clamped_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> tol)

bc <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>)), clamped_boundary)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.5*</span>(nabla_grad(u) <span style="color: #666666">+</span> nabla_grad(u)<span style="color: #666666">.</span>T)
    <span style="color: #408080; font-style: italic">#return sym(nabla_grad(u))</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> lambda_<span style="color: #666666">*</span>nabla_div(u)<span style="color: #666666">*</span>Identity(d) <span style="color: #666666">+</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
d <span style="color: #666666">=</span> u<span style="color: #666666">.</span>geometric_dimension()  <span style="color: #408080; font-style: italic"># no of space dim</span>
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,rho<span style="color: #666666">*</span>g))
T <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>))
a <span style="color: #666666">=</span> inner(sigma(u), epsilon(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> <span style="color: #666666">-</span>dot(f, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(T, v)<span style="color: #666666">*</span>ds

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Displacement&#39;</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;displacement&#39;</span>)

s <span style="color: #666666">=</span> sigma(u) <span style="color: #666666">-</span> (<span style="color: #666666">1./3</span>)<span style="color: #666666">*</span>tr(sigma(u))<span style="color: #666666">*</span>Identity(d)  <span style="color: #408080; font-style: italic"># deviatoric stress</span>
von_Mises <span style="color: #666666">=</span> sqrt(<span style="color: #666666">3./2*</span>inner(s, s))

V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
von_Mises <span style="color: #666666">=</span> project(von_Mises, V)
plot(von_Mises, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Stress intensity&#39;</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;displacement&#39;</span>)
u_magnitude <span style="color: #666666">=</span> sqrt(dot(u,u))
u_magnitude <span style="color: #666666">=</span> project(u_magnitude, V)
plot(u_magnitude, <span style="color: #BA2121">&#39;Displacement magnitude&#39;</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;displacement&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;min/max u:&#39;</span>, u_magnitude<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>min(),
      u_magnitude<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max())
</pre></div>

<h3 id="___sec70">New feature: vector function space </h3>

<p>
The primary unknown is now a vector field \( u \) and not a scalar field,
so we need to work with a vector function space:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
With <code>u = Function(V)</code> we get <code>u</code> as a vector finite element function.

<h3 id="___sec71">New feature: constant vectors </h3>

<p>
In the boundary condition \( u=0 \), we must set a vector value to zero, not just
a scalar, and a constant zero vector is specified as <code>Constant((0,0,0))</code> in
FEniCS. The corresponding 2D code would use <code>Constant((0,0))</code>.
Later in the code, we also need <code>f</code> as a vector and specify it
as <code>Constant(0,0,rho*g))</code>.

<h3 id="___sec72">New feature: <code>nabla_grad</code> </h3>

<p>
The gradient and divergence operators now have a prefix <code>nabla_</code>.
This is strictly not necessary in the present problem, but
recommended in general for vector PDEs arising from continuum mechanics,
if you interpret \( \nabla \) as a vector in the PDE notation,
see the box about <code>nabla_grad</code> in the section <a href="#ftut1:NS:varform">Variational formulation</a>.

<h3 id="___sec73">New feature: stress computation </h3>

<p>
As soon as <code>u</code> is computed, we can compute various stress measures, here
the von Mises stress defined as \( \sigma_M = \sqrt{\frac{3}{2}s:s} \)
where \( s \) is a component of the deviatoric stress tensor

$$ s = \sigma - \frac{1}{3}\mathrm{tr}(\sigma)I\tp$$

There is a one to one mapping between these formulas and the FEniCS code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">s <span style="color: #666666">=</span> sigma(u) <span style="color: #666666">-</span> (<span style="color: #666666">1./3</span>)<span style="color: #666666">*</span>tr(sigma(u))<span style="color: #666666">*</span>Identity(d)
von_Mises <span style="color: #666666">=</span> sqrt(<span style="color: #666666">3./2*</span>inner(s, s))
</pre></div>
<p>
The <code>von_Mises</code> variable is now an expression that must be projected to
a finite element space before we can visualize it.

<h3 id="___sec74">Scaling </h3>

<p>
Before doing simulations, it is often advantageous to scale the problem
as it reduces the need for setting physical parameters, and one obtains
dimensionsless numbers that reflect the competition of parameters and
physical effects. These numbers are often easy to assign values for
scientific investigations.

<p>
In Navier's equation for \( u \), arising from inserting
<a href="#mjx-eqn-3.21">(3.21)</a> and
<a href="#mjx-eqn-3.22">(3.22)</a> in
<a href="#mjx-eqn-3.20">(3.20)</a>,

$$ \nabla\cdot(\lambda\nabla\cdot u) + \mu\nabla^2 u = f,$$

we insert coordinates made dimensionless by \( L \), and \( \bar u=u/U \),
which results in the dimensionless governing equation

$$
\bar\nabla\cdot(\bar\nabla\cdot \bar u) + \beta\bar\nabla^2 \bar u =
\bar f,\quad \bar f = (0,0,\gamma),$$

where \( \beta = \mu/\lambda \) is a dimensionless elasticity parameter and

$$ \gamma = \frac{\varrho gL^2}{U\lambda}$$

is also a dimensionless variable reflecting the ratio of the load
\( \varrho g \) and the term \( \lambda\nabla(\nabla u))\sim \lambda U/L^2 \)
in the PDE.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 8</b>: Need to change above scaling argument now that \( \varrho \) is not part of the equation?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 9</b>: No, we just inserted our particular \( f \) which is \( \varrho g \).)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 10</b>: \( W \) not defined below. Width?)</font>
<!-- end inline comment -->
 
<!-- begin inline comment -->
<font color="red">(<b>hpl 11</b>: Defined in the test problem in the intro. But a comment what \( L/W \) is, is now inserted.)</font>
<!-- end inline comment -->

<p>
Sometimes, one will argue to chose \( U \) to make \( \gamma \) unity (\( U
= \varrho gL^2/\lambda \)). However, in elasticity, this leads us
to displacements of the size of the geometry, which makes plots look
very strange. We therefore want the characteristic displacement to be a
small fraction of the characteristic length of the geometry.
Actually, for a clamped beam, one has a deflection formula which gives
\( U = \frac{3}{2}\varrho gL^2\delta^2/E \), where \( \delta = L/W \) is
a parameter reflecting how slender the beam is.
Thus, the dimensionless parameter \( \delta \) is very important in the
problem (as expected, since \( \delta\gg 1 \) is what gives beam theory!).
Taking \( E \) to be of the same order as \( \lambda \), we realize that
\( \gamma \sim \delta^{-2} \).  Experiments with the code point to \( \gamma
= 0.25\delta^{-2} \) as an appropriate choice of \( \gamma \).

<p>
The simulation code implements the problem with dimensions and
physical parameters \( \lambda \), \( \mu \), \( \varrho \), \( g \), \( L \), and \( W \).
However, we can usually easily reuse this code for a scaled problem.
In the present case, we just set \( \lambda = \varrho = L = 1 \), \( W \) as
\( W/L \), \( g=\gamma \), and \( \mu=\beta \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 12</b>: I find this somewhat confusing. First we talk about a rescaled equation but then we solve the unscaled equation, but we choose the parameters so that it is somehow related to the scaled problem...?)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 13</b>: Need to look at code again once I have understood the scaling.)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 14</b>: This is the way to do it ;-) Implement with dimensions to have the code as general as possible. Then scale a particular problem &ndash; and the scaling is restricted to this problem.  It makes it much easier to set parameters for numerical investigations and to understand the model and what the competing effects are. You can run the scaled model with the original program by a proper choice of parameters.)</font>
<!-- end inline comment -->

<p>
<center>  <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 7:  Gravity-induced deformation of a clamped beam: deflection (left) and stress intensity (right). </p></center>
<p><img src="fig/beam1.png" align="bottom" width=800></p>
</center>

<p>
<!-- Stand-alone notebook? -->

<h1 id="___sec75">The Navier&ndash;Stokes equations </h1>
<div id="ftut1:NS"></div>

<p>
As our final example in this chapter, we will solve the incompressible
Navier-Stokes equations. This problem combines many of the challenges
from our previously studied problems: time-dependence, nonlinearity,
and vector-valued variables.

<h2 id="___sec76">PDE problem </h2>

<p>
The incompressible Navier-Stokes equations are a system of equations
for the velocity \( u \) and pressure \( p \) in an incompressible fluid:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 15</b>: Quite uncommon to write \( \dot u \) for the time-derivative in the N-S equations. Only Claes Johnson comes to my mind... In mechanics, the dot is reserved for ODEs. I suggest the more common notation \( \partial u/\partial t \), also since we use this elsewhere in the books.)</font>
<!-- end inline comment -->


$$
\begin{align}
\tag{3.29}
  \varrho(\dot{u} + u \cdot \nabla u) &= \nabla\cdot\sigma(u, p) + f, \\ 
\tag{3.30}
  \nabla \cdot u &= 0.
\end{align}
$$

The right-hand side \( f \) is a given force per unit volume and
just as for the equations of linear elasticity,
\( \sigma(u, p) \) denotes the stress tensor which for a Newtonian fluid
is given by

$$
\begin{equation}
  \sigma(u, p) = 2\mu\epsilon(u) - pI,
\tag{3.31}
\end{equation}
$$

where \( \epsilon(u) \) is the strain-rate tensor

$$ \epsilon(u) = \frac{1}{2}(nabla u + (nabla u)^T))\tp$$

The parameter \( \mu \) is the dynamic viscosity. Note that the momentum
equation <a href="#mjx-eqn-3.29">(3.29)</a> is very similar to the elasticity
equation <a href="#mjx-eqn-3.20">(3.20)</a>. The difference is the
two additional terms \( \varrho(\dot{u} + u \cdot \nabla u) \) and the different
expression for the stress tensor. The two extra terms express the
acceleration \( \rho \ddot{x} \) balanced by the force \( F = f +
\nabla\cdot\sigma \) per unit volume in Newton's second law of motion.

<h2 id="ftut1:NS:varform">Variational formulation</h2>

<p>
The Navier&ndash;Stokes equations are different from
the time-dependent heat equation in that we need to solve a system of
equations and this system is of a special type. If we apply the same
technique as for the heat equation; that is, replacing the time
derivative with a simple difference quotient, we face two
challenges. First, we obtain a nonlinear system of equations. This in
itself is not a problem for FEniCS as we saw in the section <a href="#ftut1:gallery:nonlinearpoisson">A nonlinear Poisson equation</a>, but the system has a so-called
<em>saddle point structure</em> and requires special techniques
(preconditioners and iterative methods) to be solved efficiently.

<p>
Instead, we will apply a simpler and often very efficient approach
which is to use a <em>splitting method</em>. In a splitting method, we
consider the two equations <a href="#mjx-eqn-3.29">(3.29)</a> and
<a href="#mjx-eqn-3.30">(3.30)</a> separately. There exist many splitting
strategies for the incompressible Navier-Stokes equations. One of the
oldest is the method proposed by Chorin <a href="._ftut1015.html#Chorin1968">[25]</a> and
Temam <a href="._ftut1015.html#Temam1969">[26]</a>, often referred to as <em>Chorin's method</em>. We will
use a modified version of Chorin's method, the so-called incremental
pressure correction scheme (IPCS) due to <a href="._ftut1015.html#Goda1979">[27]</a> which gives
improved accuracy compared to the original scheme at little extra
cost.

<p>
The IPCS scheme involves three steps. First, we compute a <em>tentative
velocity</em> \( u^{\bigstar} \) by advancing the momentum equation
<a href="#mjx-eqn-3.29">(3.29)</a> using the pressure \( p^{n-1} \) from the
previous time interval. We will also be using the velocity \( u^{n-1} \)
in the nonlinear term \( u\cdot\nabla u \). The variational problem for
this first step is:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 16</b>: This equation applies <code>textit</code>, <code>multiline</code> and <code>renni</code> in math. At least <code>textit</code> does not work in MathJax. Must test what works in Sphinx.)</font>
<!-- end inline comment -->


$$
  \begin{multline} \tag{3.32}
      \text{\textit{Step 1: Tentative velocity step}}
      \\ 
      \renni{v}{(u^{\bigstar} - u^{n-1}) / \dt}
      + \renni{v}{u^{n-1} \cdot \nabla u^{n-1}}
      + \renni{\epsilon(v)}{\sigma(u^{n-\frac{1}{2}}, p^{n-1})}
      \\ 
      + \renni{v}{p^{n-1} n}_{\partial\Omega}
      - \renni{v}{\mu \nabla u^{n-\frac{1}{2}}\cdot n}_{\partial\Omega}
      = \renni{v}{f^n}
  \end{multline}
$$


<!-- begin inline comment -->
<font color="red">(<b>hpl 17</b>: Here a boundary term \( (\mu n\cdot \nabla u^{n-\frac{1}{2}},v) \) is missing. This is the intricate discussions we had back in 2009-2010 with Harish on using N-S with \( \sigma \) or \( \nabla^2 u \).)</font>
<!-- end inline comment -->

This notation requires some explanation. First, we use the short-hand
notation

$$
  \inner{v}{w} = \int_{\Omega} vw \dx, \quad
  \inner{v}{w}_{\partial\Omega} = \int_{\partial\Omega} vw \ds.
$$

This allows us to express the variational problem in a more compact
way. Second, we use the notation \( u^{n-\frac{1}{2}} \). This notation
means the value of \( u \) at the midpoint of the interval, usually approximated
by an arithmetic mean

$$
  u^{n-\frac{1}{2}} \approx (u^{n-1} + u^n) / 2.
$$

Third, we notice that the variational problem <a href="#mjx-eqn-3.32">(3.32)</a>
arises from the integration by parts of the term
\( \inner{-\nabla\cdot\sigma}{v} \). Just as for the elasticity problem in
Section (<a href="#ftut:elast">The equations of linear elasticity</a>), we obtain

$$
  \inner{-\nabla\cdot\sigma}{v}
  = \inner{\sigma}{\epsilon(v)}
  - \inner{T}{v}_{\partial\Omega},
$$

where \( T = \sigma\cdot n \) is the boundary traction. If we solve a
problem with a free boundary, we can take \( T = 0 \) on the
boundary. However, if we compute the flow through a channel or a pipe
and want to model e flow that continues into an &quot;imaginary channel&quot; at
the outflow, we need to treat this term with some care. The assumption
we then make is that the derivative of the velocity in the direction
of the channel is zero at the outflow, corresponding to a flow that is
&quot;fully developed&quot; or doesn't change significantly downstream of the
outflow. Doing so, the remaining boundary term at the outflow becomes
\( pn - \nu \nabla u \cdot n \) which is the term appearing in the
variational problem (\ref{ftut1:ipcs1}).

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 18</b>: Apostrophes like "these" don't look like what I would expect in LaTeX.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 19</b>: No, double quotes must be written as in LaTeX &quot;quotes&quot;. They become the right double quotes then in various output formats.)</font>
<!-- end inline comment -->

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b><code>grad(u)</code> vs. <code>nabla_grad(u)</code>.</b>
For scalar functions \( \nabla u \) has a clear meaning as the vector
\( \nabla u =
(\frac{\partial u}{\partial x},
 \frac{\partial u}{\partial y},
 \frac{\partial u}{\partial z}) \).
However, if \( u \) is vector-valued, the meaning is less clear.
Some sources define \( \nabla u \) as the matrix with elements
\( \partial u_j / \partial x_i \) while other sources prefer
\( \partial u_i / \partial x_j \). In FEniCS, <code>grad(u)</code> is defined as the
matrix with elements \( \partial u_i / \partial x_j \), which is the
natural definition of \( \nabla u \) if we think of this as the <em>gradient</em> or
<em>derivative</em> of \( u \). This way, the matrix \( \nabla u \) can be applied to
a differential \( \dx \) to give an increment \( \mathrm{d}u = \nabla u \,
\dx \). Since the alternative interpretation of \( \nabla u \) as the matrix
with elements \( \partial u_j / \partial x_i \) is very common, in
particular in continuum mechanics, FEniCS
provides the operator <code>nabla_grad</code> for this purpose.
For the Navier-Stokes equations, it is important to consider the
term \( u \cdot \nabla u \) which should be interpreted as the vector
\( w \) with elements
\( w_i = \sum_j \left(u_j \frac{\partial}{\partial x_j}\right) u_i
     = \sum_j u_j \frac{\partial u_i}{\partial x_j} \).
This term can be implemented in FEniCS either as
<code>grad(u)*u</code>, since this is expression becomes
\( \sum_j \partial u_i/\partial x_j u_j \), or as
<code>dot(u, nabla_grad(u))</code> since this expression becomes
\( \sum_i u_i \partial u_j/\partial x_i \). We will use the notation
<code>dot(u, nabla_grad(u))</code> below since it corresponds more closely
to the standard notation \( u \cdot \nabla u \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 20</b>: I like the straightforward formulation above, but it should be complemented by the arguments below since it is not a matter of taste in the end, but dictated by derivation of the PDE and what \( \nabla \) was meant to be there.)</font>
<!-- end inline comment -->

<p>
To be more precise, there are different notations used for PDEs.
One employs \( \mathrm{grad}\, u \), \( \mathrm{div}\, u \), and
\( \mathrm{curl}\, u \) operators; another employs \( \nabla u \)
as a synonym for \( \mathrm{grad}\, u \), \( \nabla\cdot u \) means \( \mathrm{div}\, u \),
and \( \nabla\times u \) is the notation for \( \mathrm{curl}\, u \); while the
third operates with \( \nabla u \), \( \nabla\cdot u \), and \( \nabla\times u \)
in which \( \nabla \) is a <em>vector</em> and, e.g., \( \nabla u \) is a dyadic
expression (\( (\nabla u)_{i,j} = \partial u_j/\partial x_i =
(\mathrm{grad} u)^T \)).
The latter notation, with \( \nabla \) as a vector operator,
is often handy when deriving equations in continuum mechanics, and if
this interpretation of \( \nabla \) is the foundation of your PDE, you must
use <code>nabla_grad</code>, <code>nabla_div</code>, and <code>nabla_curl</code> in FEniCS code.
These operators are compatible with dyadic computations.
From the Navier-Stokes equations we can easily see what \( \nabla \) means:
if the convective term has the form \( u\cdot \nabla u \) (actually meaning
\( (u\cdot\nabla) u \)), \( \nabla \) is a vector operator, reading
<code>dot(u, nabla_grad(u))</code> in FEniCS, but if we see
\( \nabla u\cdot u \) or \( (\mathrm{grad} u)\cdot u \), the
corresponding FEniCS
expression is <code>dot(grad(u), u)</code>.
</div>


<p>
We now move on to the second step in our splitting scheme for the
incompressible Navier-Stokes equations. In the first step, we computed
the tentative velocity \( u^{\star} \) based on the pressure from the
previous time step. We may now use the computed tentative velocity to
compute the new pressure \( p^n \):

$$
\begin{multline} \tag{3.33}
  \text{\textit{Step 2: Pressure correction step}} \\ 
  \renni{\nabla q}{\nabla p^n}
  = \renni{\nabla q}{\nabla p^{n-1}} - \dt^{-1}\renni{q}{\nabla \cdot u^{\bigstar}}.
\end{multline}
$$

Note here that \( q \) is a scalar-valued test function from the pressure
space, whereas the test function \( v \) in <a href="#mjx-eqn-3.32">(3.32)</a> is a
vector-valued test function from the velocity space.

<p>
One way to think about this step is to subtract the Navier-Stokes
momentum equation <a href="#mjx-eqn-3.29">(3.29)</a> expressed in terms of the
tentative velocity \( u^{\star} \) and the pressure \( p^{n-1} \) from the
momentum equation expressed in terms of the velocity \( u^n \) and
pressure \( p^n \). This results in the equation

$$
\begin{equation} \tag{3.34}
  (u^n - u^{\star}) / \dt + \nabla p^n - \nabla p^{n-1} = 0.
\end{equation}
$$

Taking the divergence and requiring that \( \nabla \cdot u^n = 0 \) by the
Navier-Stokes continuity equation <a href="#mjx-eqn-3.30">(3.30)</a>, we
obtain the equation \( -\nabla\cdot u^{\star} / \dt + \nabla^2 p^n -
\nabla p^{n-1} \), which is a Poisson problem for the pressure \( p^n \)
resulting in the variational problem <a href="#mjx-eqn-3.33">(3.33)</a>.

<p>
Finally, we compute the corrected velocity \( u^n \) from the equation
<a href="#mjx-eqn-3.34">(3.34)</a>. Multiplying this equation by a test function
\( v \), we obtain

$$
\begin{multline} \tag{3.35}
  \text{\textit{Step 3: Velocity correction step}}\nonumber \\ 
  \renni{v}{u^n} =
  \renni{v}{u^{\bigstar}} - \dt\renni{v}{\nabla(p^n-p^{n-1})}.
\end{multline}
$$

<p>
In summary, we may thus solve the incompressible Navier-Stokes
equations efficiently by solving a sequence of three linear variational
problems (steps 1, 2, 3) in each time step.

<h2 id="___sec78">A simple implementation </h2>

<h3 id="___sec79">Test problem </h3>

<p>
As a first test problem, we compute the flow between two infinite plates,
so-called channel or Poiseuille flow, since this problem has a known
analytical solution. Let \( H \) be the distance between the plates and \( L \)
the length of the channel. There are no body forces.

<p>
We may scale the problem first to get rid
of seemingly independent physical parameters. The physics of this problem
is governed by viscous effects only, in the direction perpendicular to
the flow, so a time scale should be based in diffusion accross
the channel: \( t_c = H^2/\nu \). We let \( U \), some characteristic inflow,
be the velocity scale and \( H \) the spatial scale. The pressure scale
is taken as the characteristic shear stress, \( \mu U/H \), since this is
a primary example of shear flow.
Inserting
\( \bar x = x/H \), \( \bar y = y/H \), \( \bar z = z/H \), \( \bar u =u/U \),
\( \bar p = Hp/(\mu U) \), and
\( \bar t = L^/\nu \) in the equations results in the scaled
Navier-Stokes equations (dropping bars after the scaling):

$$
\begin{align*}
\frac{partial u}{\partial t} + \mathrm{Re}\, u\cdot\nabla u
&= -\nabla p + \mu\nabla^2 u + \mu\nabla(\nabla\cdot u),\\ 
\nabla\cdot u &= 0\tp
\end{align*}
$$

Here, Re is the Reynolds number \( \rho UH/\mu \). Because of the time and
pressure scale, which are different from convection-dominated fluid flow,
the Reynolds number is associated with the convective term and not the
viscosity term (as usual).

<p>
The exact solution is derived by assuming \( u=(u_x(x,y,z),0,0) \), with
the \( x \) axis pointing along the channel. Since \( \nabla\cdot u=0 \), \( u \)
cannot depend on \( x \). The physics of channel flow is also
two-dimensional so we can omit the \( z \) coordinate (more precisely:
\( \partial/\partial z=0 \)). Inserting \( u=(u_x,0,0) \) in the (scaled)
governing equations gives \( u_x''(y) = \partial p/\partial x \).
Differentiating this equation with respect to \( x \) shows that \( \partial
p/\partial x \) is a constant, here called \( -\beta \). This is the driving
force of the flow and specified as known in the problem.  Integrating
\( u_x''(y)=-\beta \) over the width of the channel, \( [0,1] \), and
requiring \( u=0 \) at the channel walls, results in \( u_x=\frac{1}{2}\beta
y(1-y) \). The characteristic inlet flow in the channel, \( U \), can be
taken as the maximum inflow at \( x=1/2 \), implying that \( \beta = 8 \).
The length of the channel, \( L/H \) in the scaled model, has no impact on
the result, so for simplicity we just compute on the unit square.  The
pressure can then be set to \( p=0 \) at the outlet \( x=1 \), giving
\( p(x)=8(1-x) \) and \( u_x=4y(1-y) \).

<p>
The scaled model is not so easy to simulate using a standard Navier-Stokes
solver with dimensions. However, we can argue that the convection term
is zero, so the Re coefficient in front of this term in the scaled PDEs
is not important and can be set to unity. In that case, \( \rho = \mu = 1 \)
in the original Navier-Stokes equations resemble the scaled model.

<h3 id="___sec80">FEniCS implementation </h3>

<p>
Our previous examples have all started out with the creation of a
mesh and then the definition of a <code>FunctionSpace</code> on the mesh. For the
splitting scheme we will use to solve the Navier-Stokes equations we
need to define two function spaces, one for the velocity and one for
the pressure:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The first space <code>V</code> is a vector-valued function space for the velocity
and the second space <code>P</code> is a scalar-valued function space for the
pressure. We use piecewise quadratic elements for the velocity and
piecewise linear elements for the pressure. When creating a
<code>VectorFunctionSpace</code> in FEniCS, the value-dimension (the length of
the vectors) will be set equal to the geometric dimension of the
finite element mesh. One can easily create vector-valued function
spaces with other dimensions in FEniCS by adding the keyword parameter
<code>dim</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>, dim<span style="color: #666666">=10</span>)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Stable finite element spaces for the Navier-Stokes equations.</b>
It is well-known that certain finite element spaces are not <em>stable</em>
for the Navier-Stokes equations, or even for the simpler Stokes
equations. The prime example of an unstable pair of finite element
spaces is to use continuous piecewise polynomials for both the
velocity and the pressure. Using an
unstable pair of spaces typically results in a solution with
<em>spurious</em> (unwanted, non-physical) oscillations in the pressure
solution. The simple remedy is to use piecewise continuous piecewise
quadratic elements for the velocity and continuous piecewise linear
elements for the pressure. Together, these elements form the so-called
<em>Taylor-Hood</em> element. Spurious oscillations may occur also for
splitting methods if an unstable element pair is used.
</div>


<p>
Since we have two different function spaces, we need to create two sets
of trial and test functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)
</pre></div>
<p>
As we have seen in previous examples, boundaries may be defined in
FEniCS by defining Python functions that return <code>True</code> or <code>False</code>
depending on whether a point should be considered part of the
boundary, for example

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>)
</pre></div>
<p>
This function defines the boundary to be all points with
\( x \)-coordinate equal to (near) zero. Alternatively, we may give the boundary
definition as a string of C++ code, much like we have previously
defined expressions such as <code>u0 = Expression('1 + x[0]*x[0] +
2*x[1]*x[1]')</code>. The above definition of the boundary in terms of a
Python function may thus be replaced by a simple C++ string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">boundary <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
</pre></div>
<p>
This has the advantage of moving the computation of which nodes
belong to boundary to C++ from Python, which improves the efficiency
of the program.
For the current example, we will set three different boundary
conditions. First, we will set \( u = 0 \) at the walls of the channel;
that is, at \( y = 0 \) and \( y = 1 \). Second, we will set \( p = 1 \) at the
inflow (\( x = 0 \)) and, finally, \( p = 0 \) at the outflow (\( x = 1 \)). This
will result in a pressure gradient that will accelerate the flow from an
initial stationary state. These
boundary conditions may be defined as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 1)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_noslip  <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcp_inflow  <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">1</span>), inflow)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_noslip]
bcp <span style="color: #666666">=</span> [bcp_inflow, bcp_outflow]
</pre></div>
<p>
At the end, we collect the boundary conditions for the velocity and
pressure in Python lists so we can easily access them in the
following computation.

<p>
We now move on to the definition of the variational forms. There are
three variational problems to be defined, one for each step in the
IPCS scheme. Let's look at the definition of the first variational
problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">U  <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u0 <span style="color: #666666">+</span> u)
F1 <span style="color: #666666">=</span> dot((u <span style="color: #666666">-</span> u0) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(dot(u0, nabla_grad(u0)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p0), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p0<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(nu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)
</pre></div>
<p>
This is very similar to the mathematical definition
<a href="#mjx-eqn-3.32">(3.32)</a>. Since the variational problem contains a mix of
known and unknown quantities &ndash; the unknown \( u^n \) (which we name <code>u</code>
in the variational problem) and the known value \( u^{n-1} \) (which we
name <code>u0</code>) &ndash; it is convenient to use the FEniCS functions <code>lhs</code> and
<code>rhs</code> to extract the left- and right-hand sides of the variational
problem.

<p>
In the definition of the variational problem, we take advantage of the
Python programming language to define our own operators <code>sigma</code> and
<code>epsilon</code>. Using Python this way makes it easy to extend the
mathematical language of FEniCS with special operators and
constitutive laws:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>nu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))
</pre></div>
<p>
The splitting scheme requires the solution of a sequence of three
variational problems in each time step. We have previously used the
built-in FEniCS function <code>solve</code> to solve variational problems. Under
the hood, when a user calls <code>solve(a == L, u, bc)</code>, FEniCS will
perform the following steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A <span style="color: #666666">=</span> assemble(A)
b <span style="color: #666666">=</span> assemble(L)
bc<span style="color: #666666">.</span>apply(A, b)
solve(A, u<span style="color: #666666">.</span>vector(), b)
</pre></div>
<p>
In the last step, FEniCS uses the overloaded <code>solve</code> function to solve
the linear system <code>AU = b</code> where <code>U</code> is the vector of degrees of
freedom for the function \( u(x) = \sum_{j=1} U_j \phi_j(x) \).

<p>
In our implementation of the splitting scheme, we will make use of
these low-level commands to first assemble and then call solve. This
has the advantage that we may control when we assemble and when we
solve the linear system. In particular, since the matrices for the
three variational problems are all time-independent, it makes sense to
assemble them once and for all outside of the time-stepping loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)
</pre></div>
<p>
Within the time-stepping loop, we may then assemble only the
right-hand side vectors, apply boundary conditions, and call the solve
function as here for the first of the three steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">b1 <span style="color: #666666">=</span> assemble(L1)
[bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
solve(A1, u1<span style="color: #666666">.</span>vector(), b1)
</pre></div>
<p>
Notice the Python <em>list comprehension</em> <code>[bc.apply(b1) for bc in bcu]</code>
which iterates over all <code>bc</code> in the list <code>bcu</code>. This is a convenient
way to apply all boundary conditions in a single line and makes it
possible to reuse the same code if we later decide to apply more
boundary conditions.

<p>
Finally, let's look at an important detail in how we use parameters
such as the time step <code>dt</code> and kinematic viscosity <code>nu</code> in the
definition of our variational problems. Since we might want to change
these later, for example if we want to experiment with smaller or
larger time steps, we wrap these using a FEniCS <code>Constant</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k <span style="color: #666666">=</span> Constant(dt)
nu <span style="color: #666666">=</span> Constant(nu)
</pre></div>
<p>
The assembly of matrices and vectors in FEniCS is based on code
generation. This means that whenever we change a variational problem,
FEniCS will have to generate new code, which may take a little
time. New code will also be generated when a float value for the time
step or viscosity is changed. By wrapping these parameters using
<code>Constant</code>, FEniCS will treat these parameters as generic constants and
not specific numerical values, which prevents repeated code
generation. In the case of the time step, we choose a new name <code>k</code>
instead of <code>dt</code> for the <code>Constant</code> since we also want to use the
variable <code>dt</code> as a Python float as part of the time-stepping.

<p>
The complete code for simulating Poiseuille flow with FEniCS looks as
follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>           <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">500</span>    <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>           <span style="color: #408080; font-style: italic"># kinematic viscosity</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function spaces</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">16</span>, <span style="color: #666666">16</span>)
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 1)&#39;</span>
walls   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_noslip <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcp_inflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">1</span>), inflow)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_noslip]
bcp <span style="color: #666666">=</span> [bcp_inflow, bcp_outflow]

<span style="color: #408080; font-style: italic"># Define trial and test functions</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)

<span style="color: #408080; font-style: italic"># Define functions for solutions at previous and current time steps</span>
u0 <span style="color: #666666">=</span> Function(V)
u1 <span style="color: #666666">=</span> Function(V)
p0 <span style="color: #666666">=</span> Function(Q)
p1 <span style="color: #666666">=</span> Function(Q)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u0 <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
nu  <span style="color: #666666">=</span> Constant(nu)

<span style="color: #408080; font-style: italic"># Define symmetric gradient</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>nu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> dot((u <span style="color: #666666">-</span> u0) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(dot(u0, nabla_grad(u0)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p0), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p0<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(nu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)

<span style="color: #408080; font-style: italic"># Define variational problem for step 2</span>
a2 <span style="color: #666666">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color: #666666">*</span>dx
L2 <span style="color: #666666">=</span> dot(nabla_grad(p0), nabla_grad(q))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (<span style="color: #666666">1/</span>k)<span style="color: #666666">*</span>div(u1)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Define variational problem for step 3</span>
a3 <span style="color: #666666">=</span> dot(u, v)<span style="color: #666666">*</span>dx
L3 <span style="color: #666666">=</span> dot(u1, v)<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dot(nabla_grad(p1 <span style="color: #666666">-</span> p0), v)<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Assemble matrices</span>
A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)

<span style="color: #408080; font-style: italic"># Apply boundary conditions to matrices</span>
[bc<span style="color: #666666">.</span>apply(A1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
[bc<span style="color: #666666">.</span>apply(A2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u1<span style="color: #666666">.</span>vector(), b1)

    <span style="color: #408080; font-style: italic"># Step 2: Pressure correction step</span>
    b2 <span style="color: #666666">=</span> assemble(L2)
    [bc<span style="color: #666666">.</span>apply(b2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]
    solve(A2, p1<span style="color: #666666">.</span>vector(), b2)

    <span style="color: #408080; font-style: italic"># Step 3: Velocity correction step</span>
    b3 <span style="color: #666666">=</span> assemble(L3)
    solve(A3, u1<span style="color: #666666">.</span>vector(), b3)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    plot(u1)

    <span style="color: #408080; font-style: italic"># Compute error at vertices</span>
    u_e <span style="color: #666666">=</span> Expression((<span style="color: #BA2121">&#39;x[1]*(1.0 - x[1])&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>), degree<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> interpolate(u_e, V)
    error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u1<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;t = </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u0<span style="color: #666666">.</span>assign(u1)
    p0<span style="color: #666666">.</span>assign(p1)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
We compute the error at the nodes as we have done before to verify
that our implementation is correct. Our Navier-Stokes solver computes
the solution to the time-dependent incompressible Navier-Stokes
equations, starting from the initial condition \( u = (0, 0) \). We have
not specified the initial condition explicitly in our solver which
means that FEniCS will initialize all variables, in particular the
previous and current velocities <code>u0</code> and <code>u1</code>, to zero. Since the
exact solution is quadratic, we expect the solution to be exact to
within machine precision at the nodes at the final time. For our
implementation, the error quickly approaches zero and is approximately
\( 10^{-9} \) at final time \( T = 10 \).

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_poisseuille"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 8:  Plot of the velocity profile at the final time for the Navier-Stokes Poiseuille flow example.  <!-- caption label: ftut1:fig:navier_stokes_poisseuille --> </p></center>
<p><img src="fig/navier_stokes_poiseuille.png" align="bottom" width=600></p>
</center>

<h2 id="___sec81">Flow past a cylinder </h2>

<p>
We now turn our attention to a more interesting example: flow past a
circular cylinder. The geometry and parameters are taken from problem
DFG 2D-2 in the <a href="http://www.featflow.de/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark2_re100.html" target="_self">FEATFLOW/1995-DFG benchmark suite</a>
and is illustrated in Figure
<a href="#ftut1:navier_stokes_cylinder:geometry">9</a>. The kinematic viscosity is
given by \( \nu = 0.001 \) and the inflow velocity
profile is specified as

$$
  u(x, y, t) = \left(1.5 \cdot \frac{4y(1-y)}{0.41^2}, 0\right),
$$

which has a maximum magnitude of \( 1.5 \) at \( y = 0.41/2 \).

<p>
<center> <!-- figure label: --> <div id="ftut1:navier_stokes_cylinder:geometry"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  Geometry for the flow past a cylinder test problem. Notice the slightly perturbed and unsymmetric geometry.  <!-- caption label: ftut1:navier_stokes_cylinder:geometry -->. </p></center>
<p><img src="fig/navier_stokes_cylinder_geometry.png" align="bottom" width=600></p>
</center>

<p>
For the previous test problem, scaling with the characteristic mean
velocity \( U = \int_0^1 x (1 - x) \dx = 1/6 = 2/3 \cdot 0.25 \) and \( L = 1 \) gives a small
Reynolds number of size \( L = UL/\nu = \frac{1}{6}/0.5 = 1/3 \). For the
current problem, the characteristic length is \( L = 0.1 \) (the diameter
of the cylinder) and the mean velocity is \( 2/3 \cdot 1.5 = 1 \)
which gives a Reynolds number of size \( \mathrm{Re} = 1 \cdot 0.1 /
0.001 = 100 \). At this Reynolds number the flow develops into a
periodic flow with vortex shedding behind the cylinder.

<h3 id="___sec82">FEniCS implementation </h3>

<p>
So far all our domains have been simple shapes such as a unit square or
a rectangular box. A number of such simple meshes may be created in
FEniCS using the built-in meshes
<code>UnitIntervalMesh</code> (1D),
<code>UnitSquareMesh</code> (2D),
<code>UnitCubeMesh</code> (3D),
<code>IntervalMesh</code> (1D),
<code>RectangleMesh</code> (2D),
<code>BoxMesh</code> (3D), and
<code>UnitDiscMesh</code> (2D).
FEniCS supports the creation of more complex meshes via a technique
called <em>constructive solid geometry</em> (CSG), which lets us define
geometries in terms of simple shapes (primitives) and set operations:
union, intersection, and set difference. The set operations are
encoded in FEniCS using the operators <code>+</code> (union), <code>*</code> (intersection),
and <code>-</code> (set difference). To access the CSG functionality in FEniCS,
one must import the FEniCS module <code>mshr</code> which provides the
extended meshing functionality of FEniCS.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 21</b>: Need to cite mshr.)</font>
<!-- end inline comment -->

<p>
The geometry for the cylinder flow test problem can be defined easily
by first defining the rectangular channel and then subtracting the
circle:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">channel <span style="color: #666666">=</span> Rectangle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">2.2</span>, <span style="color: #666666">0.41</span>))
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.2</span>, <span style="color: #666666">0.2</span>), <span style="color: #666666">0.05</span>)
geometry <span style="color: #666666">=</span> channel <span style="color: #666666">-</span> cylinder
</pre></div>
<p>
We may then create the mesh by calling the function <code>generate_mesh</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mesh <span style="color: #666666">=</span> generate_mesh(geometry, <span style="color: #666666">64</span>)
</pre></div>
<p>
To solve the cylinder test problem, we only need to make a few minor
changes to the code we wrote for the Poiseuille flow test
case. Besides defining the new mesh, the only change we need to make
is to modify the boundary conditions and the time step size. The
boundaries are specified as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 2.2)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
cylinder <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 22</b>: We set \( p = 0 \) at the outflow. This seems to be necessary, but we should really not need to specify the pressure at all.)</font>
<!-- end inline comment -->

<p>
In addition to these essential changes, we will make a number of small
changes to improve our solver. First, since we need to choose a
relatively small time step to compute the solution (a time step that
is too large will make the solution blow up) we add a progress bar so
that we can follow the progress of our computation. This can be done
as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">progress <span style="color: #666666">=</span> Progress(<span style="color: #BA2121">&#39;Time-stepping&#39;</span>)
set_log_level(PROGRESS)

t <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Place computation here</span>

    <span style="color: #408080; font-style: italic"># Update progress bar</span>
    progress<span style="color: #666666">.</span>update(t <span style="color: #666666">/</span> T)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Log levels and printing in FEniCS.</b>
Notice the call to <code>set_log_level(PROGRESS)</code> which is essential to
make FEniCS actually display the progress bar. FEniCS is actually
quite informative about what is going on during a computation but the
amount of information printed to screen depends on the current log
level. Only messages with a priority higher than or equal to the
current log level will be displayed. The predefined log levels in
FEniCS are
<code>DBG</code>,
<code>TRACE</code>,
<code>PROGRESS</code>,
<code>INFO</code>,
<code>WARNING</code>,
<code>ERROR</code>, and
<code>CRITICAL</code>. By default, the log level is set to <code>INFO</code> which means
that messages at level <code>DBG</code>, <code>TRACE</code>, and <code>PROGRESS</code> will not be
printed. Users may print messages using the FEniCS functions <code>info</code>,
<code>warning</code>, and <code>error</code> which will print messages at the obvious log
level (and in the case of <code>error</code> also throw an exception and
exit). One may also use the call <code>log(level, message)</code> to print a
message at a specific log level.
</div>


<p>
Since the system(s) of linear equations are significantly larger than
for the simple Poiseuille flow test problem, we choose to use an
iterative method instead of the default direct (sparse) solver used by
FEniCS when calling <code>solve</code>. Efficient solution of linear systems
arising from the discretization of PDEs requires the choice of both a
good iterative (Krylov subspace) method and a good
preconditioner. For this problem, we will simply use the biconjugate
gradient stabilized method (BiCGSTAB). This can be done by adding the
keyword <code>bicgstab</code> in the call to <code>solve</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solve(A1, u1<span style="color: #666666">.</span>vector(), b1, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)
solve(A2, p1<span style="color: #666666">.</span>vector(), b2, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)
solve(A3, u1<span style="color: #666666">.</span>vector(), b3, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)
</pre></div>
<p>
Finally, to be able to postprocess the computed solution in Paraview,
we store the solution to file in each time step. To avoid cluttering
our working directory with a large number of solution
files, we make sure to store the solution in a subdirectory:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">vtkfile_u <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/velocity.pvd&#39;</span>)
vtkfile_p <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/pressure.pvd&#39;</span>)
</pre></div>
<p>
Note that one does not need to create the directory before running the
program. It will be created automatically by FEniCS.

<p>
Figures <a href="#ftut1:fig:navier_stokes_cylinder:velocity">10</a> and
<a href="#ftut1:fig:navier_stokes_cylinder:pressure">11</a> show the velocity and
pressure at final time visualized in Paraview. For the visualization
of the velocity, we have used the <b>Glyph</b> filter to visualize the
vector velocity field. For the visualization of the pressure, we have
used the <b>Warp By Scalar</b> filter.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_cylinder:velocity"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Plot of the velocity for the cylinder test problem at final time.  <!-- caption label: ftut1:fig:navier_stokes_cylinder:velocity --> </p></center>
<p><img src="fig/navier_stokes_cylinder_velocity.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_cylinder:pressure"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 11:  Plot of the pressure for the cylinder test problem at final time.  <!-- caption label: ftut1:fig:navier_stokes_cylinder:pressure --> </p></center>
<p><img src="fig/navier_stokes_cylinder_pressure.png" align="bottom" width=600></p>
</center>

<p>
The complete code for the cylinder test problem looks as
follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">5.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">5000</span>   <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>         <span style="color: #408080; font-style: italic"># scaled kinematic viscosity</span>

<span style="color: #408080; font-style: italic"># Create mesh</span>
channel <span style="color: #666666">=</span> Rectangle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">2.2</span>, <span style="color: #666666">0.41</span>))
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.2</span>, <span style="color: #666666">0.2</span>), <span style="color: #666666">0.05</span>)
geometry <span style="color: #666666">=</span> channel <span style="color: #666666">-</span> cylinder
mesh <span style="color: #666666">=</span> generate_mesh(geometry, <span style="color: #666666">64</span>)

<span style="color: #408080; font-style: italic"># Define function spaces</span>
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 2.2)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
cylinder <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>

<span style="color: #408080; font-style: italic"># Define inflow profile</span>
inflow_profile <span style="color: #666666">=</span> (<span style="color: #BA2121">&#39;4.0*1.5*x[1]*(0.41 - x[1]) / pow(0.41, 2)&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_inflow <span style="color: #666666">=</span> DirichletBC(V, Expression(inflow_profile, degree<span style="color: #666666">=2</span>), inflow)
bcu_walls <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcu_cylinder <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), cylinder)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_inflow, bcu_walls, bcu_cylinder]
bcp <span style="color: #666666">=</span> [bcp_outflow]

<span style="color: #408080; font-style: italic"># Define trial and test functions</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)

<span style="color: #408080; font-style: italic"># Define functions for solutions at previous and current time steps</span>
u0 <span style="color: #666666">=</span> Function(V)
u1 <span style="color: #666666">=</span> Function(V)
p0 <span style="color: #666666">=</span> Function(Q)
p1 <span style="color: #666666">=</span> Function(Q)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u0 <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
nu  <span style="color: #666666">=</span> Constant(nu)

<span style="color: #408080; font-style: italic"># Define symmetric gradient</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>nu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> dot((u <span style="color: #666666">-</span> u0) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(dot(u0, nabla_grad(u0)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p0), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p0<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(nu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)

<span style="color: #408080; font-style: italic"># Define variational problem for step 2</span>
a2 <span style="color: #666666">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color: #666666">*</span>dx
L2 <span style="color: #666666">=</span> dot(nabla_grad(p0), nabla_grad(q))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (<span style="color: #666666">1/</span>k)<span style="color: #666666">*</span>div(u1)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Define variational problem for step 3</span>
a3 <span style="color: #666666">=</span> dot(u, v)<span style="color: #666666">*</span>dx
L3 <span style="color: #666666">=</span> dot(u1, v)<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dot(nabla_grad(p1 <span style="color: #666666">-</span> p0), v)<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Assemble matrices</span>
A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)

<span style="color: #408080; font-style: italic"># Apply boundary conditions to matrices</span>
[bc<span style="color: #666666">.</span>apply(A1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
[bc<span style="color: #666666">.</span>apply(A2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]

<span style="color: #408080; font-style: italic"># Create VTK files for saving solution</span>
vtkfile_u <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/velocity.pvd&#39;</span>)
vtkfile_p <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/pressure.pvd&#39;</span>)

<span style="color: #408080; font-style: italic"># Create progress bar</span>
progress <span style="color: #666666">=</span> Progress(<span style="color: #BA2121">&#39;Time-stepping&#39;</span>)
set_log_level(PROGRESS)

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u1<span style="color: #666666">.</span>vector(), b1, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)

    <span style="color: #408080; font-style: italic"># Step 2: Pressure correction step</span>
    b2 <span style="color: #666666">=</span> assemble(L2)
    [bc<span style="color: #666666">.</span>apply(b2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]
    solve(A2, p1<span style="color: #666666">.</span>vector(), b2, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)

    <span style="color: #408080; font-style: italic"># Step 3: Velocity correction step</span>
    b3 <span style="color: #666666">=</span> assemble(L3)
    solve(A3, u1<span style="color: #666666">.</span>vector(), b3, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    plot(u1, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Velocity&#39;</span>)
    plot(p1, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Pressure&#39;</span>)

    <span style="color: #408080; font-style: italic"># Save solution to file</span>
    vtkfile_u <span style="color: #666666">&lt;&lt;</span> u1
    vtkfile_p <span style="color: #666666">&lt;&lt;</span> p1

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u0<span style="color: #666666">.</span>assign(u1)
    p0<span style="color: #666666">.</span>assign(p1)

    <span style="color: #408080; font-style: italic"># Update progress bar</span>
    progress<span style="color: #666666">.</span>update(t <span style="color: #666666">/</span> T)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1007.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="._ftut1001.html">2</a></li>
  <li><a href="._ftut1002.html">3</a></li>
  <li><a href="._ftut1003.html">4</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li class="active"><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li><a href="._ftut1010.html">11</a></li>
  <li><a href="._ftut1011.html">12</a></li>
  <li><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1014.html">15</a></li>
  <li><a href="._ftut1015.html">16</a></li>
  <li><a href="._ftut1009.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

