<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,unit testing,compute vertex values,vertex values,vertex to dof map,dof to vertex map,dimension-independent code,linear algebra backend,PETSc,Eigen,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,KrylovSolver,random start vector (linear systems),SLEPc,Poisson's equation with variable coefficient,Postprocessing,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot,functionals,energy functional,error functional,flux functional">

<title>Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Variational form', 2, None, '___sec41'),
              (u'Visualization', 2, None, '___sec42'),
              (u'Curve plots through the domain', 2, None, '___sec43'),
              (u'Running ParaView', 2, u'ftut:paraview', u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'A simple FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'New feature: vector function space', 3, None, '___sec70'),
              (u'New feature: constant vectors', 3, None, '___sec71'),
              (u'New feature: `nabla_grad`', 3, None, '___sec72'),
              (u'New feature: stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'A simple FEniCS implementation', 2, None, '___sec78'),
              (u'Test problem 1: Channel flow', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Verification', 3, None, '___sec81'),
              (u'Exercise 2: Simulate channel flow in a 3D geometry',
               2,
               None,
               '___sec82'),
              (u'Flow past a cylinder', 2, None, '___sec83'),
              (u'FEniCS implementation', 3, None, '___sec84'),
              (u'A system of advection--diffusion--reaction equations',
               1,
               u'ftut1:reactionsystem',
               u'ftut1:reactionsystem'),
              (u'PDE problem', 2, None, '___sec86'),
              (u'Variational formulation', 2, None, '___sec87'),
              (u'A simple FEniCS implementation', 2, None, '___sec88'),
              (u'Setting initial conditions for mixed systems',
               2,
               None,
               '___sec89'),
              (u'Setting boundary conditions for mixed systems',
               2,
               None,
               '___sec90'),
              (u'Accessing components of mixed systems', 2, None, '___sec91'),
              (u'Subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Combining Dirichlet and Neumann conditions',
               1,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 2, None, '___sec94'),
              (u'Variational formulation', 2, None, '___sec95'),
              (u'FEniCS implementation', 2, None, '___sec96'),
              (u'Setting multiple Dirichlet conditions',
               1,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Working with subdomains',
               1,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Expression objects with if test', 2, None, '___sec99'),
              (u'Mesh functions', 2, None, '___sec100'),
              (u'Vectorized version of subdomain definitions',
               2,
               None,
               '___sec101'),
              (u'C++ strings for subdomain definitions',
               2,
               None,
               '___sec102'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Setting multiple Neumann, Robin, and Dirichlet conditions',
               1,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 2, None, '___sec105'),
              (u'PDE problem', 2, None, '___sec106'),
              (u'Variational formulation', 2, None, '___sec107'),
              (u'FEniCS implementation', 2, None, '___sec108'),
              (u'Test problem', 2, None, '___sec109'),
              (u'Debugging boundary conditions', 2, None, '___sec110'),
              (u'Generating meshes with subdomains', 1, None, '___sec111'),
              (u'PDE problem', 2, None, '___sec112'),
              (u'Variational formulation', 2, None, '___sec113'),
              (u'FEniCS implementation', 2, None, '___sec114'),
              (u'Extensions: Improving the Poisson solver',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactoring the Poisson solver',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Writing the solver as a Python module',
               2,
               None,
               '___sec118'),
              (u'Verification and unit tests', 2, None, '___sec119'),
              (u'Examining the degrees of freedom',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Exercise 4: Solve a Poisson problem', 2, None, '___sec122'),
              (u'Remarks', 3, None, '___sec123'),
              (u'Exercise 5: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec125'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Choosing a linear solver and preconditioner',
               3,
               None,
               '___sec127'),
              (u'Choosing a linear algebra backend', 3, None, '___sec128'),
              (u'Setting solver parameters', 3, None, '___sec129'),
              (u'An extended solver function', 3, None, '___sec130'),
              (u'A remark regarding unit tests', 3, None, '___sec131'),
              (u'List of linear solver methods and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Explicit assembly and solve',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'Examining matrix and vector values', 2, None, '___sec135'),
              (u'Postprocessing computations',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'A variable-coefficient Poisson problem',
               2,
               None,
               '___sec137'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec140'),
              (u'Finite difference approximations', 3, None, '___sec141'),
              (u'Surface plot', 3, None, '___sec142'),
              (u'Contour plot', 3, None, '___sec143'),
              (u'Curve plot through the mesh', 3, None, '___sec144'),
              (u'Curve plot of the flux', 3, None, '___sec145'),
              (u'Test problem', 3, None, '___sec146'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec148'),
              (u'Error functional', 3, None, '___sec149'),
              (u'Flux Functional', 3, None, '___sec150'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Computing error norms', 3, None, '___sec152'),
              (u'Computing convergence rates', 3, None, '___sec153'),
              (u'Test problem', 3, None, '___sec154'),
              (u'Experiments', 3, None, '___sec155'),
              (u'Bibliography', 1, None, '___sec156')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\ub}{u_{_\mathrm{D}}}
\newcommand{\GD}{\Gamma_{_\mathrm{D}}}
\newcommand{\GN}{\Gamma_{_\mathrm{N}}}
\newcommand{\GR}{\Gamma_{_\mathrm{R}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1001.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: vector function space</a></li>
     <!-- navigation toc: --> <li><a href="#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: <code>nabla_grad</code></a></li>
     <!-- navigation toc: --> <li><a href="#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New feature: stress computation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem 1: Channel flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Simulate channel flow in a 3D geometry</a></li>
     <!-- navigation toc: --> <li><a href="#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ftut1:reactionsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A system of advection--diffusion--reaction equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting initial conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting boundary conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessing components of mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:subdomains" style="font-size: 80%;"><b>Subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression objects with if test</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized version of subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ strings for subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Neumann, Robin, and Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generating meshes with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1010.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson" style="font-size: 80%;"><b>Extensions: Improving the Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactoring the Poisson solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing the solver as a Python module</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear solver and preconditioner</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec131" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List of linear solver methods and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit assembly and solve</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining matrix and vector values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Surface plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec143" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contour plot</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot through the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curve plot of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing error norms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec156" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0008"></a>
<!-- !split -->

<center><h1 id="ch:gallery" class="anchor">A Gallery of finite element solvers</h1></center> <!-- chapter heading -->

<p>
<blockquote>
    The goal of this chapter is to demonstrate how a range of important PDEs
    from science and engineering can be quickly solved with a few lines of
    FEniCS code. We start with the heat equation and continue with a
    nonlinear Poisson equation, the equations for linear elasticity, and
    the Navier-Stokes equations. These problems illustrate how to solve
    time-dependent problems, nonlinear problems, vector-valued problems,
    and systems of PDE. For each problem, we derive the variational
    formulation and express the problem in Python in a way that closely
    resembles the mathematics.
</blockquote>


<p>
<!-- Stand-alone notebook? -->

<h1 id="ch:fundamentals:diffusion" class="anchor">The heat equation</h1>

<p>
As a first extension of the Poisson problem from the previous chapter,
we consider the time-dependent heat equation, or time-dependent
diffusion equation. This is the natural extension of the Poisson
equation describing the stationary distribution of heat in a body to a
time-dependent problem.

<p>
We will see that by discretizing time into small time intervals and
applying standard time-stepping methods, we can solve the heat
equation by solving a sequence of variational problems, much like the
one we encountered for the Poisson equation.

<p>
<!-- The solution of -->
<!-- nonlinear problems, as we showed in Section -->
<!-- ref{ch:poisson0:nonlinear}, can also be automated (cf. Section -->
<!-- <a href="#ftut:nonlinear:Newton:auto">A simple FEniCS implementation</a>), but many scientists will prefer to -->
<!-- code the solution strategy of the nonlinear problem themselves and -->
<!-- experiment with various combinations of strategies in difficult -->
<!-- problems. Time-dependent problems are somewhat similar in this -->
<!-- respect: we have to add a time discretization scheme, which is often -->
<!-- quite simple, making it natural to explicitly code the details of the -->
<!-- scheme so that the programmer has full control. -->
<!-- We shall explain how -->
<!-- easily this is accomplished through examples. -->

<h2 id="___sec49" class="anchor">PDE problem </h2>

<p>
Our model problem for time-dependent PDEs reads

$$
\begin{align}
{\partial u\over\partial t} &= \nabla^2 u + f\hbox{ in }\Omega,
\tag{3.1}\\ 
u &= \ub\hbox{ on } \partial \Omega,
\tag{3.2}\\ 
u &= u_0 \mbox{ at } t=0\tp
\tag{3.3}
\end{align}
$$

Here, \( u \) varies with space and time, e.g., \( u=u(x,y,t) \) if the spatial
domain \( \Omega \) is two-dimensional. The source function \( f \) and the
boundary values \( \ub \) may also vary with space and time.
The initial condition \( u_0 \) is a function of space only.

<h2 id="ftut:timedep:diffusion1" class="anchor">Variational formulation</h2>

<p>
A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a sequence of
stationary problems, and then turn each stationary problem into a
variational formulation.

<p>
Let superscript \( n \) denote a quantity at time \( t_n \), where \( n \) is an
integer counting time levels. For example, \( u^n \) means \( u \) at time
level \( n \). A finite difference discretization in time first consists
of sampling the PDE at some time level, say \( t_n \):

$$
\begin{equation} {\partial \over\partial t}u^n = \nabla^2 u^n + f^n\tp
\tag{3.4}
\end{equation}
$$

The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons, we choose a
simple backward difference:

$$
\begin{equation} {\partial \over\partial t}u^n\approx {u^n - u^{n-1}\over{\dt}},
\tag{3.5}
\end{equation}
$$

where \( \dt \) is the time discretization parameter.
Inserting <a href="#mjx-eqn-3.5">(3.5)</a> in <a href="#mjx-eqn-3.4">(3.4)</a> yields

$$
\begin{equation}
{u^n - u^{n-1}\over{\dt}} = \nabla^2 u^n + f^n\tp
\tag{3.6}
\end{equation}
$$

This is our time-discrete version of the heat equation
<a href="#mjx-eqn-3.1">(3.1)</a>. This is a so-called <em>backward Euler</em> or
<em>implicit Euler</em> discretization. Alternatively, we may also view this
as a finite element discretization in time in the form of the first order
\( \mathrm{dG}(0) \) method, which here is identical to the backward Euler
method.

<p>
We may reorder <a href="#mjx-eqn-3.6">(3.6)</a> so
that the left-hand side contains the terms with the unknown \( u^n \) and
the right-hand side contains computed terms only. The result
is a sequence of spatial
(stationary) problems for \( u^n \) (assuming \( u^{n-1} \) is known from
computations at the previous time level):

$$
\begin{align}
u^0 &= u_0, \tag{3.7}\\ 
u^n - {\dt}\nabla^2 u^n &=  u^{n-1} + {\dt} f^n,\quad n=1,2,\ldots
\tag{3.8}
\end{align}
$$

Given \( u_0 \), we can solve for \( u^0 \), \( u^1 \), \( u^2 \), and so on.

<p>
An alternative to <a href="#mjx-eqn-3.8">(3.8)</a>, which can be
convenient in implementations, is to collect
all terms on one side of the equality sign:

$$
\begin{equation}
u^n - {\dt}\nabla^2 u^n -  u^{n-1} - {\dt} f^n = 0,\quad n=1,2,\ldots
\tag{3.9}
\end{equation}
$$

<p>
We use a finite element method to solve
<a href="#mjx-eqn-3.7">(3.7)</a> and either of the equations
<a href="#mjx-eqn-3.8">(3.8)</a> or <a href="#mjx-eqn-3.9">(3.9)</a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function \( v\in \hat V \) and integrate second-derivatives by
parts. Introducing the symbol \( u \) for \( u^n \) (which is natural in the
program), the resulting weak form arising from
formulation <a href="#mjx-eqn-3.8">(3.8)</a>
can be conveniently written in
the standard notation:

$$ a(u,v)=L_n(v),$$

where

$$
\begin{align}
a(u,v) &= \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v\right) \dx, \tag{3.10}\\ 
L_n(v) &= \int_\Omega \left(u^{n-1} + {\dt}  f^n\right)v \dx\tp
\tag{3.11}
\end{align}
$$

The alternative form <a href="#mjx-eqn-3.9">(3.9)</a> has an
abstract formulation

$$ F(u;v) = 0,$$

where

$$
\begin{equation}
F(u; v) = \int_\Omega  uv + {\dt}
\nabla u\cdot \nabla v -
(u^{n-1} + {\dt} f^n)v \dx\tp
\tag{3.12}
\end{equation}
$$

<p>
In addition to the variational problem to be solved in each time step,
we also need to approximate the initial condition
<a href="#mjx-eqn-3.7">(3.7)</a>. This equation can also be turned into a
variational problem:

$$ a_0(u,v)=L_0(v),$$

with

$$
\begin{align}
a_0(u,v) &= \int_\Omega uv \dx, \tag{3.13}\\ 
L_0(v) &= \int_\Omega u_0 v \dx\tp \tag{3.14}
\end{align}
$$

When solving this variational problem, \( u^0 \) becomes the
\( L^2 \) projection of the given initial value \( u_0 \) into the finite
element space. The alternative is to construct \( u^0 \) by just
interpolating the initial value \( u_0 \); that is,
if \( u^0=\sum_{j=1}^N U^0_j\phi_j \), we simply set \( U_j=u_0(x_j,y_j) \),
where \( (x_j,y_j) \) are the coordinates of node number \( j \). We refer to
these two strategies as computing the initial condition by either
projection or interpolation. Both operations are easy to
compute in FEniCS through one statement, using either the <code>project</code> or
<code>interpolate</code> function. The most common choice is <code>project</code>, which computes an
approximation to \( u_0 \), but in some
applications where we want to verify the code by reproducing exact solutions,
one must use <code>interpolate</code> (and we use such a test problem!).

<p>
In summary, we thus need to solve the following sequence of variational
problems to compute the finite element solution to the heat equation:
find \( u^0\in V \) such that \( a_0(u^0,v)=L_0(v) \) holds for all \( v\in\hat V \),
and then find \( u^n\in V \)
such that \( a(u^n,v)=L_n(v) \) for all \( v\in\hat V \),
or alternatively, \( F(u^n,v)=0 \) for all \( v\in\hat V \),
for \( n=1,2,\ldots \).

<h2 id="ftut:timedep:diffusion1:impl" class="anchor">A simple FEniCS implementation</h2>

<p>
Our program needs to implement the time-stepping manually, but can
rely on FEniCS to easily compute \( a_0 \), \( L_0 \), \( F \), \( a \), and \( L \), and solve
the linear systems for the unknowns.

<h3 id="___sec52" class="anchor">Test problem </h3>

<p>
Just as for the Poisson problem from the previous chapter, we
construct a test problem that makes it easy to determine if the
calculations are correct. Since we know that our first-order
time-stepping scheme is exact for linear functions, we create a test
problem which has a linear variation in time. We combine this with a
quadratic variation in space. We thus take

$$
\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
\tag{3.15}
\end{equation}
$$

which yields a function whose computed values at the nodes will be
exact, regardless of the size of the elements and \( \dt \), as long as
the mesh is uniformly partitioned. By inserting
<a href="#mjx-eqn-3.15">(3.15)</a> into the heat equation
<a href="#mjx-eqn-3.1">(3.1)</a>, we find that the right-hand side \( f \) must
be given by \( f(x,y,t)=\beta - 2 - 2\alpha \). The boundary value
is \( \ub(x, y, t) = 1 + x^2 + \alpha y^2 + \beta t \) and the initial
value is \( u_0(x, y) = 1 + x^2 + \alpha y^2 \).

<h3 id="___sec53" class="anchor">FEniCS implementation </h3>

<p>
A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition \( \ub(x, y,
t) = 1 + x^2 + \alpha y^2 + \beta t \). A natural solution is to use a
FEniCS <code>Expression</code> with time \( t \) as a parameter, in addition to the
parameters \( \alpha \) and \( \beta \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>; beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
u_b <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                 degree<span style="color: #666666">=2</span>, alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)
</pre></div>
<p>
This expression uses the components of <code>x</code> as independent
variables, while <code>alpha</code>, <code>beta</code>, and <code>t</code> are parameters.  The
parameters can later be updated as in

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_b<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t
</pre></div>
<p>
The essential boundary conditions, along the entire boundary in this case,
are set in the usual way:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u0, boundary)
</pre></div>
<p>
We shall use <code>u</code> for the unknown \( u^n \) at the new time level and <code>u_p</code>
for \( u^{n-1} \) at the previous time level. The initial value of <code>u_p</code> can be
computed by either projection or interpolation of \( u_0 \). Since we set
<code>t = 0</code> for the boundary value <code>u_b</code>, we can use this also to specify
the initial condition. We can then do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_p <span style="color: #666666">=</span> project(u_b, V)
<span style="color: #408080; font-style: italic"># or</span>
u_p <span style="color: #666666">=</span> interpolate(u_b, V)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Projecting versus interpolating the initial condition.</b>
To actually recover the
exact solution <a href="#mjx-eqn-3.15">(3.15)</a> to machine precision,
it is important not to compute the discrete initial condition by
projecting \( u_0 \), but by interpolating \( u_0 \) so that the degrees of freedom have
exact values at \( t=0 \) (projection results in approximative values at the
nodes).
</div>


<p>
We may either define \( a \) or \( L \) according to the formulas above, or
we may just define \( F \) and ask FEniCS to figure out which terms that
go into the bilinear form \( a \) and which that go into the linear form
\( L \). The latter is convenient, especially in more complicated problems,
so we illustrate that construction of \( a \) and \( L \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
Finally, we perform the time-stepping in a loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> Function(V)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt
    u_b<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)


    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
In the last step of the time-stepping loop, we assign the values of
the variable <code>u</code> (the new computed solution) to the variable
containing the values at the previous time step. This must be done
using the <code>assign</code> member function. If we instead try to do <code>u_p = u</code>,
we will set the <code>u_p</code> Python variable to be the <em>same</em> variable as <code>u</code>
which is not what we want. (We need two variables, one for the values
at the previous time step and one for the values at the current time
step.)

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remember to update expression objects with the current time!</b>
Inside the time loop,
observe that <code>u_b.t</code> must be updated before the <code>solve</code> statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the <code>u_b</code> object
for values.)
</div>


<p>
The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in the Poisson equation example in
the section <a href="._ftut1006.html#ch:poisson0:impl:dissect">Dissection of the program</a>, we compute the
difference between the array of nodal values of <code>u</code> and the array
nodal values of
the interpolated exact solution. This may be done as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_e <span style="color: #666666">=</span> interpolate(u_b, V)
error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error, t=</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%-10.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))
</pre></div>
<p>
The complete program code for this time-dependent case goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">10</span>     <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
alpha <span style="color: #666666">=</span> <span style="color: #666666">3</span>          <span style="color: #408080; font-style: italic"># parameter alpha</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>         <span style="color: #408080; font-style: italic"># parameter beta</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">8</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
u_D <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span>,
                 degree<span style="color: #666666">=2</span>, alpha<span style="color: #666666">=</span>alpha, beta<span style="color: #666666">=</span>beta, t<span style="color: #666666">=0</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_D, boundary)

<span style="color: #408080; font-style: italic"># Define initial value</span>
u_p <span style="color: #666666">=</span> interpolate(u_D, V)
<span style="color: #408080; font-style: italic">#u_p = project(u_D, V)</span>

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(beta <span style="color: #666666">-</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>alpha)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

<span style="color: #408080; font-style: italic"># Time-stepping</span>
u <span style="color: #666666">=</span> Function(V)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt
    u_D<span style="color: #666666">.</span>t <span style="color: #666666">=</span> t <span style="color: #408080; font-style: italic"># update for bc</span>

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># Compute error at vertices</span>
    u_e <span style="color: #666666">=</span> interpolate(u_D, V)
    error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;t = </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
The code is available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/heat.py" target="_self"><tt>ft03_heat.py</tt></a>.

<h2 id="___sec54" class="anchor">Diffusion of a Gaussian function </h2>

<h3 id="___sec55" class="anchor">The mathematical problem </h3>

<p>
Now we want to solve a more relevant test problem, namely the diffusion of
a Gaussian hill. It means that the initial value is given by

$$ u_0(x,y)= e^{-ax^2 - ay^2}$$

on a domain \( [-2,2]\times [2,2] \). We will take \( a = 5 \). For this
problem we will use homogeneous Dirichlet boundary conditions (\( \ub = 0 \)).

<h3 id="___sec56" class="anchor">FEniCS implementation </h3>

<p>
Which are the required changes to our previous program? One major
change is that the domain is not a unit square anymore. We also want to
use much higher resolution. The new domain can
be created easily in FEniCS using <code>RectangleMesh</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">30</span>
mesh <span style="color: #666666">=</span> RectangleMesh(Point(<span style="color: #666666">-2</span>,<span style="color: #666666">-2</span>), Point(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), nx, ny)
</pre></div>
<p>
We also need to redefine the initial condition and boundary condition.
Both are easily changed by defining a new <code>Expression</code> and by setting
\( u = 0 \) on the boundary. We will also save the solution to file in VTK
format in each time step:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>vtkfile <span style="color: #666666">&lt;&lt;</span> (u, t)
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 5</b>: Remember to output as <code>(u, t)</code> also in other examples below.)</font>
<!-- end inline comment -->

<p>
The complete program appears below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">50</span>     <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
nx <span style="color: #666666">=</span> ny <span style="color: #666666">=</span> <span style="color: #666666">30</span>
mesh <span style="color: #666666">=</span> RectangleMesh(Point(<span style="color: #666666">-2</span>,<span style="color: #666666">-2</span>), Point(<span style="color: #666666">2</span>,<span style="color: #666666">2</span>), nx, ny)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)

<span style="color: #408080; font-style: italic"># Define initial value</span>
u_0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;exp(-a*pow(x[0],2) - a*pow(x[1],2))&#39;</span>,
                 degree<span style="color: #666666">=2</span>, a<span style="color: #666666">=5</span>)
u_p <span style="color: #666666">=</span> interpolate(u_0, V)
u_p<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;initial value&#39;</span>)
vtkfile <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;gaussian_diffusion.pvd&#39;</span>)
vtkfile <span style="color: #666666">&lt;&lt;</span> (u_p, <span style="color: #666666">0.0</span>)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

F <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (u_p <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;solution&#39;</span>)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Solve variational problem</span>
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># Save to file and plot solution</span>
    vtkfile <span style="color: #666666">&lt;&lt;</span> (u, <span style="color: #008000">float</span>(t))
    plot(u)
    time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.3</span>)

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
This program is also available in the
file <a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/gaussian_diffusion.py" target="_self"><tt>ft04_gaussian_diffusion.py</tt></a>.

<h3 id="___sec57" class="anchor">Visualization in ParaView </h3>

<p>
To visualize the diffusion of the Gaussian hill, start ParaView,
choose <b>File - Open</b>, open the file <code>gaussian_diffusion.pvd</code>, click
the green <b>Apply</b> button on the left to see the initial condition
being plotted. Choose <b>View - Animation View</b>. Click on the play
button or (better) the next frame button in the row of buttons at the
top of the GUI to see the evolution of the scalar field you have just
computed:

<p>
<br /><br /><center><p><img src="fig/paraview_animation_buttons.png" align="bottom" width=300></p></center><br /><br />

<p>
The cross in the middle of the plot can be turned off by the <b>Show Center</b>
button:

<p>
<br /><br /><center><p><img src="fig/paraview_show_center_button.png" align="bottom" width=150></p></center><br /><br />

<p>
Choose <b>File - Save Animation...</b> to save the animation to the AVI or OGG video format.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov/diffusion0.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<br /><br /><center><p><img src="fig/diffusion0_paraview_animation.png" align="bottom" width=600></p></center><br /><br />

<p>
Once the animation has been saved to file, you can play the animation
offline using a player such as mplayer or VLC, or upload your
animation to YouTube. Below is a sequence of
snapshots of the solution.

<p>
<br /><br /><center><p><img src="fig/diffusion0_3snapshots.png" align="bottom" width=800></p></center><br /><br />

<p>
<!-- Stand-alone notebook? -->

<h1 id="ftut1:gallery:nonlinearpoisson" class="anchor">A nonlinear Poisson equation</h1>

<p>
We shall now address how to solve nonlinear PDEs. We will see that
nonlinear problems can be solved just as easily as linear problems in
FEniCS, by simply defining a nonlinear variational problem and calling
the <code>solve</code> function. When doing so, we will encounter a subtle
difference in how the variational problem is defined.

<h2 id="___sec59" class="anchor">PDE problem </h2>

<p>
As a sample PDE for the implementation of nonlinear problems, we
take the following nonlinear Poisson equation:

$$
\begin{equation}
-\nabla\cdot\left( q(u)\nabla u\right) = f,
\tag{3.16}
\end{equation}
$$

in \( \Omega \), with \( u=\ub \) on the boundary \( \partial\Omega \).
The coefficient \( q(u) \) makes the equation nonlinear (unless \( q(u) \)
is constant in \( u \)).

<h2 id="___sec60" class="anchor">Variational formulation </h2>

<p>
As usual, we multiply our PDE by a test function \( v\in\hat V \),
integrate over the domain, and integrate the second-order derivatives
by parts.  The boundary integral arising from integration by parts
vanishes wherever we employ Dirichlet conditions.  The resulting
variational formulation of our model problem becomes: find \( u \in V \)
such that

$$
\begin{equation}
F(u; v) = 0 \quad \forall v \in \hat{V},
\tag{3.17}
\end{equation}
$$

where

$$
\begin{equation}
F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v + fv \dx,
\tag{3.18}
\end{equation}
$$

and

$$
\begin{align*}
     V      &= \{v \in H^1(\Omega) : v = \ub \mbox{ on } \partial\Omega\},\\ 
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}\tp
\end{align*}
$$

<p>
The discrete problem arises as usual by restricting \( V \) and \( \hat V \)
to a pair of discrete spaces. As before, we omit any subscript on
the discrete spaces and discrete solution.
The discrete nonlinear problem is then written as: find \( u\in V \) such that

$$
\begin{equation}
  F(u; v) = 0 \quad \forall v \in \hat{V},
\tag{3.19}
\end{equation}
$$

with \( u = \sum_{j=1}^N U_j \phi_j \). Since \( F \) is a nonlinear function
of \( u \), the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns \( U_1,\ldots,U_N \).

<h2 id="ftut:nonlinear:Newton:auto" class="anchor">A simple FEniCS implementation</h2>

<h3 id="___sec62" class="anchor">Test problem </h3>

<p>
To solve a test problem, we need to choose the right-hand side \( f \),
the coefficient \( q(u) \) and the boundary value \( \ub \).  Previously, we
have worked with manufactured solutions that can be reproduced without
approximation errors. This is more difficult in nonlinear problems,
and the algebra is more tedious. However, we may utilize SymPy for
symbolic computing and integrate such computations in the FEniCS
solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package. In particular, we will use the
SymPy functions <code>diff</code> for symbolic differentiation and <code>ccode</code> for
C/C++ code generation.

<p>
We try out a two-dimensional manufactured
solution that is linear in the unknowns:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Warning: from fenics import * will import both `sym` and</span>
<span style="color: #408080; font-style: italic"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span style="color: #408080; font-style: italic"># overwrite these objects.</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Use SymPy to compute f given manufactured solution u</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y
f <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">-</span> \ 
      sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Define symbolic coordinates as required in <code>Expression</code> objects.</b>
Note that we would normally write <code>x, y = sym.symbols('x y')</code>, but
if we want the resulting expressions to have valid syntax for
FEniCS <code>Expression</code> objects, we must use <code>x[0]</code> and <code>x[1]</code>.
This is easily accomplished with <code>sympy</code> by defining the names of <code>x</code> and
<code>y</code> as <code>x[0]</code> and <code>x[1]</code>: <code>x, y = sym.symbols('x[0] x[1]')</code>.
</div>


<p>
Turning the expressions for <code>u</code> and <code>f</code> into C or C++ syntax for
FEniCS <code>Expression</code> objects needs two steps. First, we ask for the C
code of the expressions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
f_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
</pre></div>
<p>
Sometimes, we need some editing of the result to match the required
syntax of <code>Expression</code> objects, but not in this case. (The primary
example is that <code>M_PI</code> for \( \pi \) in C/C++ must be replaced by <code>pi</code> for
<code>Expression</code> objects.) In our case here, the output of <code>c_code</code> and
<code>f_code</code> is

<p>

<!-- code=c (!bc ccod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>x[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> <span style="color: #666666">1</span>
<span style="color: #666666">-10*</span>x[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> <span style="color: #666666">10</span>
</pre></div>
<p>
After having defined the mesh, the function space, and the boundary,
we define the boundary value <code>u_b</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_b <span style="color: #666666">=</span> Expression(u_code)
</pre></div>
<p>
Similarly, we define the right-hand side function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>f <span style="color: #666666">=</span> Expression(f_code)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Name clash between <code>fenics</code> and program variables.</b>
In a program like the one above, strange errors may occur due to
name clashes. If you define <code>sym</code> and <code>q</code> prior to doing
<code>from fenics import *</code>, the latter statement will also import
variables with the names <code>sym</code> and <code>q</code>, overwriting
the objects you have previously defined! This may lead to strange
errors. The safest solution is to do <code>import fenics as fe</code>
and then prefix all FEniCS
object names by <code>fe</code>. The next best solution is to do
<code>from fenics import *</code> first and then define your own variables
that overwrite those imported from <code>fenics</code>. This is acceptable
if we do not need <code>sym</code> and <code>q</code> from <code>fenics</code>.
</div>


<h3 id="___sec63" class="anchor">FEniCS implementation </h3>

<p>
A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is to state the formula for \( F \) and call
<code>solve(F == 0, u, bc)</code> instead of <code>solve(a == L, u, bc)</code> as we did
in the linear case. Here is a minimalistic code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">32</span>, <span style="color: #666666">32</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
u_b <span style="color: #666666">=</span> Expression(<span style="color: #666666">...</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_b, boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> Function(V)
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Expression(<span style="color: #666666">...</span>)
F <span style="color: #666666">=</span> q(u)<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u, bc)
</pre></div>
<p>
The major difference from a linear problem is that the unknown function
<code>u</code> in the variational form in the nonlinear case
must be defined as a <code>Function</code>, not a <code>TrialFunction</code>. In some sense
this is a simplification from the linear case where we must define <code>u</code>
first as a <code>TrialFunction</code> and then as a <code>Function</code>.

<p>
The <code>solve</code> function takes the nonlinear equations, derives symbolically
the Jacobian matrix, and runs a Newton method to compute the solution.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 6</b>: Should we display all codes like this one?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 7</b>: Now experimenting with refernce to repo and in html and sphinx a button will fold out the code.)</font>
<!-- end inline comment -->

<p>
The complete code is found in the file
<a href="https://github.com/hplgit/fenics-tutorial/blob/master/src/ft05_nlpoisson.py" target="_self"><tt>ft05_nlpoisson.py</tt></a>.

<p>

<!-- code=python (!bc pypro-h) typeset with pygments style "default" -->

<script type="text/javascript">
function show_hide_code63(){
  $("#code63").toggle();
}
</script>
<button type="button" onclick="show_hide_code63()">Show/hide code</button>
<div id="code63" style="display:none">
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">FEniCS tutorial demo program: Poisson equation with Dirichlet conditions.</span>
<span style="color: #BA2121; font-style: italic">Simplest example of computation and visualization with FEniCS.</span>

<span style="color: #BA2121; font-style: italic">-div(q(u)*grad(u)) = f on the unit square.</span>
<span style="color: #BA2121; font-style: italic">u = u0 on the boundary.</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function

<span style="color: #408080; font-style: italic"># Warning: from fenics import * will import both `sym` and</span>
<span style="color: #408080; font-style: italic"># `q` from FEniCS. We therefore import FEniCS first and then</span>
<span style="color: #408080; font-style: italic"># overwrite these objects.</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(u):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> u<span style="color: #666666">**2</span>

<span style="color: #408080; font-style: italic"># Use SymPy to compute f given manufactured solution u</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y
f <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x), x) <span style="color: #666666">-</span> \
      sym<span style="color: #666666">.</span>diff(q(u)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, y), y)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)
u_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(u)
f_code <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u =&#39;</span>, u_code)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;f =&#39;</span>, f_code)

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">8</span>, <span style="color: #666666">8</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
u_b <span style="color: #666666">=</span> Expression(u_code, degree<span style="color: #666666">=2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary

bc <span style="color: #666666">=</span> DirichletBC(V, u_b, boundary)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> Function(V) <span style="color: #408080; font-style: italic"># not TrialFunction!</span>
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Expression(f_code, degree<span style="color: #666666">=2</span>)
F <span style="color: #666666">=</span> q(u)<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Compute solution</span>
solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution</span>
u<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;solution&#39;</span>)
<span style="color: #408080; font-style: italic">#plot(u)</span>

<span style="color: #408080; font-style: italic"># Compute error at vertices</span>
u_e <span style="color: #666666">=</span> interpolate(u_b, V)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> error)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>

</div>
<p>
Running the code gives output that tells how the Newton iteration
progresses. With \( 2(6\times 4) \) cells we get convergence in 7
iterations with a tolerance of \( 10^{-9} \), and the error in the
numerical solution is about \( 10^{-11} \). With \( 2(3\times 3) \) and
\( 2(8\times 8) \) cells the error is identically zero.  Other resolutions
may bring the error up to the level of the tolerance in the Newton
iterations. These results bring evidence for a correct implementation.
Thinking in terms of finite differences on a uniform mesh, P1 elements
mimic standard second-order differences, which compute the derivative
of a linear or quadratic function exactly. Here, \( \nabla
u \) is a constant vector, but then multiplied by \( (1+u^2) \), which is a
second-order polynomial in \( x \) and \( y \), which the divergence
&quot;difference operator&quot; should compute exactly.  We can therefore,
even with P1 elements, expect the manufactured \( u \) to be reproduced by
the numerical method. With a nonlinearity like \( 1+u^4 \), this will not be the
case, and we would need to verify convergence rates instead.

<p>
The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on the numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much better manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter
"Implementing solvers for nonlinear PDEs": "" <a href="._ftut1013.html#ftut2">[25]</a>
and show how we can implement our
own solution algorithms for nonlinear equations and also how we can
steer the parameters in the automated Newton method used above. You
will then see how easy it is to implement tailored solution
strategies for nonlinear problems in FEniCS.

<p>
<!-- Stand-alone notebook? -->

<h1 id="ftut:elast" class="anchor">The equations of linear elasticity</h1>

<p>
Analysis of structures is one of the major activities of modern
engineering, thus making the PDEs for deformation of elastic bodies
likely the most popular PDE model in the world.
It takes just one page of code to solve the equations of 2D or 3D
elasticity in FEniCS, and the details follow below.

<h2 id="___sec65" class="anchor">PDE problem </h2>

<p>
The equations governing small elastic deformations of a body \( \Omega \)
can be written as

$$
\begin{align}
-\nabla\cdot\sigma &= f\hbox{ in }\Omega,
\tag{3.20}\\ 
\sigma &= \lambda\,\hbox{tr}\,\varepsilon I + 2\mu\varepsilon,
\tag{3.21}\\ 
\varepsilon &= \frac{1}{2}\left(\nabla u + (\nabla u)^{\top}\right),
\tag{3.22}
\end{align}
$$

where \( \sigma \) is the stress tensor, \( f \) is the body force per unit
volume, \( \lambda \) and \( \mu \) are Lame's elasticity parameters for the
material in \( \Omega \), \( I \) is the identity tensor, \( \mathrm{tr} \) is the
trace operator on a tensor, \( \varepsilon \) is the strain tensor
(symmetric gradient), and \( u \) is the displacement vector field.
We have here assumed isotropic elastic conditions.

<p>
We combine <a href="#mjx-eqn-3.21">(3.21)</a> and
<a href="#mjx-eqn-3.22">(3.22)</a> to obtain

$$
\begin{equation}
\sigma = \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top})\tp
\tag{3.23}
\end{equation}
$$

Note that <a href="#mjx-eqn-3.20">(3.20)</a>-<a href="#mjx-eqn-3.22">(3.22)</a>
can easily be transformed to a single vector PDE for \( u \), which is the governing
PDE for the unknown \( u \) (Navier's equation).
In the derivation of the variational formulation,
however, it is convenient to keep the splitting of the equations as above.

<h2 id="ftut:elast:varform" class="anchor">Variational formulation</h2>

<p>
The variational formulation of
<a href="#mjx-eqn-3.20">(3.20)</a>--<a href="#mjx-eqn-3.22">(3.22)</a>
consists of forming the inner product of
<a href="#mjx-eqn-3.20">(3.20)</a> and a <em>vector</em> test function
\( v\in \hat{V} \), where \( \hat{V} \) is a test vector function space, and
integrating over the domain \( \Omega \):

$$ -\int_\Omega (\nabla\cdot\sigma) \cdot v \dx =
\int_\Omega f\cdot v\dx\tp$$

Since \( \nabla\cdot\sigma \) contains second-order derivatives of the primary
unknown \( u \), we integrate this term by parts:

$$ -\int_\Omega (\nabla\cdot\sigma) \cdot v \dx
= \int_\Omega \sigma : \nabla v\dx - \int_{\partial\Omega}
(\sigma\cdot n)\cdot v \ds,$$

where the colon operator is the inner product between tensors
(summed pairwise product of all elements), and \( n \)
is the outward unit normal at the boundary. The quantity \( \sigma\cdot n \)
is known as the <em>traction</em> or stress vector at the boundary, and is often
prescribed as a boundary condition. We assume that it is prescribed
at a part \( \partial\Omega_T \) of the boundary and set \( T = \sigma\cdot
n \). On the remaining part of the boundary, we assume that the value of
the displacement is given as a Dirichlet condition.
We then have

$$
\int_\Omega \sigma : \nabla v \dx =
\int_\Omega f\cdot v \dx
+ \int_{\partial\Omega_T} T\cdot v\ds\tp$$

Inserting the expression <a href="#mjx-eqn-3.23">(3.23)</a> for
\( \sigma \) gives the variational form with \( u \) as unknown. Note that the
boundary integral on the remaining part
\( \partial\Omega\setminus\Omega_T \) vanishes due to the Dirichlet
condition (\( v = 0 \)).

<p>
We can now summarize the variational formulation as: find \( u\in V \) such that

$$
\begin{equation}
a(u,v) = L(v)\quad\forall v\in\hat{V},
\tag{3.24}
\end{equation}
$$

where

$$
\begin{align}
a(u,v) &= \int_\Omega\sigma(u) :\nabla v \dx,
\tag{3.25}
\\ 
\sigma(u) &= \lambda(\nabla\cdot u)I + \mu(\nabla u + (\nabla u)^{\top}),
\tag{3.26}\\ 
L(v) &= \int_\Omega f\cdot v\dx + \int_{\partial\Omega_T}
T\cdot v\ds\tp
\tag{3.27}
\end{align}
$$

<p>
One can show that the inner product of a symmetric tensor \( A \) and a
non-symmetric tensor \( B \) vanishes. If we express \( \nabla v \) as a sum
of its symmetric and non-symmetric parts, only the symmetric part will
survive in the product \( \sigma :\nabla v \) since \( \sigma \) is a
symmetric tensor. Thus replacing \( \nabla u \) by the symmetric gradient
\( \epsilon(u) \) gives rise to the slightly different variational form

$$
\begin{equation}
a(u,v) = \int_\Omega\sigma(u) :\varepsilon(v) \dx,
\tag{3.28}
\end{equation}
$$

where \( \varepsilon(v) \) is the symmetric part of \( \nabla v \):

$$ \varepsilon(v) = \frac{1}{2}\left(\nabla v + (\nabla v)^{\top}\right)\tp$$

The formulation <a href="#mjx-eqn-3.28">(3.28)</a> is what naturally
arises from minimization of elastic potential energy and is a more
popular formulation than <a href="#mjx-eqn-3.25">(3.25)</a>.

<h2 id="___sec67" class="anchor">A simple FEniCS implementation </h2>

<h3 id="___sec68" class="anchor">Test problem </h3>

<p>
As a test example, we may look at a clamped beam deformed under its
own weight. Then \( f=(0,0,-\varrho g) \) is the body force per unit
volume with \( \varrho \) the
density of the beam and \( g \) the acceleration of gravity. The beam is
box-shaped with length \( L \) and square cross section of width \( W \). We
set \( u=(0,0,0) \) at the clamped end, \( x=0 \). The rest of the boundary is
traction free; that is, we set \( T = 0 \).

<h3 id="___sec69" class="anchor">The code </h3>

<p>
We first list the code and then comment upon the new constructions
compared to the Poisson equation case.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># Scaled variables</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1</span>; W <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
mu <span style="color: #666666">=</span> <span style="color: #666666">1</span>
rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>
delta <span style="color: #666666">=</span> W<span style="color: #666666">/</span>L
gamma <span style="color: #666666">=</span> <span style="color: #666666">0.4*</span>delta<span style="color: #666666">**2</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">1.25</span>
lambda_ <span style="color: #666666">=</span> beta
g <span style="color: #666666">=</span> gamma

<span style="color: #408080; font-style: italic"># Create mesh and define function space</span>
mesh <span style="color: #666666">=</span> BoxMesh(Point(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>), Point(L,W,W), <span style="color: #666666">10</span>, <span style="color: #666666">3</span>, <span style="color: #666666">3</span>)
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">clamped_boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> tol)

bc <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>)), clamped_boundary)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.5*</span>(nabla_grad(u) <span style="color: #666666">+</span> nabla_grad(u)<span style="color: #666666">.</span>T)
    <span style="color: #408080; font-style: italic">#return sym(nabla_grad(u))</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> lambda_<span style="color: #666666">*</span>nabla_div(u)<span style="color: #666666">*</span>Identity(d) <span style="color: #666666">+</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
u <span style="color: #666666">=</span> TrialFunction(V)
d <span style="color: #666666">=</span> u<span style="color: #666666">.</span>geometric_dimension()  <span style="color: #408080; font-style: italic"># no of space dim</span>
v <span style="color: #666666">=</span> TestFunction(V)
f <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,rho<span style="color: #666666">*</span>g))
T <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0</span>))
a <span style="color: #666666">=</span> inner(sigma(u), epsilon(v))<span style="color: #666666">*</span>dx
L <span style="color: #666666">=</span> <span style="color: #666666">-</span>dot(f, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(T, v)<span style="color: #666666">*</span>ds

<span style="color: #408080; font-style: italic"># Compute solution</span>
u <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, u, bc)

<span style="color: #408080; font-style: italic"># Plot solution and mesh</span>
plot(u, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Displacement&#39;</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;displacement&#39;</span>)

s <span style="color: #666666">=</span> sigma(u) <span style="color: #666666">-</span> (<span style="color: #666666">1./3</span>)<span style="color: #666666">*</span>tr(sigma(u))<span style="color: #666666">*</span>Identity(d)  <span style="color: #408080; font-style: italic"># deviatoric stress</span>
von_Mises <span style="color: #666666">=</span> sqrt(<span style="color: #666666">3./2*</span>inner(s, s))

V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
von_Mises <span style="color: #666666">=</span> project(von_Mises, V)
plot(von_Mises, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Stress intensity&#39;</span>)
u_magnitude <span style="color: #666666">=</span> sqrt(dot(u,u))
u_magnitude <span style="color: #666666">=</span> project(u_magnitude, V)
plot(u_magnitude, <span style="color: #BA2121">&#39;Displacement magnitude&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;min/max u:&#39;</span>, u_magnitude<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>min(),
      u_magnitude<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max())
</pre></div>

<h3 id="___sec70" class="anchor">New feature: vector function space </h3>

<p>
The primary unknown is now a vector field \( u \) and not a scalar field,
so we need to work with a vector function space:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
With <code>u = Function(V)</code> we get <code>u</code> as a vector finite element function.

<h3 id="___sec71" class="anchor">New feature: constant vectors </h3>

<p>
In the boundary condition \( u=0 \), we must set a vector value to zero, not just
a scalar, and a constant zero vector is specified as <code>Constant((0,0,0))</code> in
FEniCS. The corresponding 2D code would use <code>Constant((0,0))</code>.
Later in the code, we also need <code>f</code> as a vector and specify it
as <code>Constant(0,0,rho*g))</code>.

<h3 id="___sec72" class="anchor">New feature: <code>nabla_grad</code> </h3>

<p>
The gradient and divergence operators now have a prefix <code>nabla_</code>.
This is strictly not necessary in the present problem, but
recommended in general for vector PDEs arising from continuum mechanics,
if you interpret \( \nabla \) as a vector in the PDE notation,
see the box about <code>nabla_grad</code> in the section <a href="#ftut1:NS:varform">Variational formulation</a>.

<h3 id="___sec73" class="anchor">New feature: stress computation </h3>

<p>
As soon as <code>u</code> is computed, we can compute various stress measures, here
the von Mises stress defined as \( \sigma_M = \sqrt{\frac{3}{2}s:s} \)
where \( s \) is the deviatoric stress tensor

$$ s = \sigma - \frac{1}{3}\mathrm{tr}\,\sigma\,I\tp$$

There is a one to one mapping between these formulas and the FEniCS code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>s <span style="color: #666666">=</span> sigma(u) <span style="color: #666666">-</span> (<span style="color: #666666">1./3</span>)<span style="color: #666666">*</span>tr(sigma(u))<span style="color: #666666">*</span>Identity(d)
von_Mises <span style="color: #666666">=</span> sqrt(<span style="color: #666666">3./2*</span>inner(s, s))
</pre></div>
<p>
The <code>von_Mises</code> variable is now an expression that must be projected to
a finite element space before we can visualize it.

<h3 id="___sec74" class="anchor">Scaling </h3>

<p>
Before doing simulations for a specific problem, it is often
advantageous to scale the problem as it reduces the need for setting
physical parameters, and one obtains dimensionsless numbers that
reflect the competition of parameters and physical effects. We develop
the code for the original model with dimensions, and run the scaled
problem by tweaking parameters appropriately. Scaling reduces the
number of active parameters from 6 to 2 in the present application.

<p>
In Navier's equation for \( u \), arising from inserting
<a href="#mjx-eqn-3.21">(3.21)</a> and
<a href="#mjx-eqn-3.22">(3.22)</a> in
<a href="#mjx-eqn-3.20">(3.20)</a>,

$$ \nabla\cdot(\lambda\nabla\cdot u) + \mu\nabla^2 u = f,$$

we insert coordinates made dimensionless by \( L \), and \( \bar u=u/U \),
which results in the dimensionless governing equation

$$
\beta\bar\nabla\cdot(\bar\nabla\cdot \bar u) + \bar\nabla^2 \bar u =
\bar f,\quad \bar f = (0,0,\gamma),$$

where \( \beta = \lambda/\mu \) is a dimensionless elasticity parameter and

$$ \gamma = \frac{\varrho gL^2}{\mu U}$$

is also a dimensionless variable reflecting the ratio of the load
\( \varrho g \) and the shear stress
term \( \mu\nabla^2 u\sim \mu U/L^2 \) in the PDE.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 8</b>: Need to change above scaling argument now that \( \varrho \) is not part of the equation?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 9</b>: No, we just inserted our particular \( f \) which is \( \varrho g \).)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 10</b>: \( W \) not defined below. Width?)</font>
<!-- end inline comment -->
 
<!-- begin inline comment -->
<font color="red">(<b>hpl 11</b>: Defined in the test problem in the intro. But a comment what \( L/W \) is, is now inserted.)</font>
<!-- end inline comment -->

<p>
Sometimes, one will argue to chose \( U \) to make \( \gamma \) unity (\( U =
\varrho gL^2/\mu \)). However, in elasticity, this leads us to
displacements of the size of the geometry, which makes plots look very
strange. We therefore want the characteristic displacement to be a
small fraction of the characteristic length of the geometry.  This can
be achieved by choosing \( U \) equal to the maximum deflection of a
clamped beam, for which there actually exists an formula: \( U =
\frac{3}{2}\varrho gL^2\delta^2/E \), where \( \delta = L/W \) is a
parameter reflecting how slender the beam is, and \( E \) is the modulus
of elasticity.  Thus, the dimensionless parameter \( \delta \) is very
important in the problem (as expected, since \( \delta\gg 1 \) is what
gives beam theory!).  Taking \( E \) to be of the same order as \( \mu \),
which is common for a lot of materials, we realize that \( \gamma \sim
\delta^{-2} \) is an appropriate choice.  Doing experiments with the
code to find a displacement that &quot;looks right&quot; in plots of the
deformed geometry, points to \( \gamma = 0.4\delta^{-2} \) as our final
choice of \( \gamma \).

<p>
The simulation code implements the problem with dimensions and
physical parameters \( \lambda \), \( \mu \), \( \varrho \), \( g \), \( L \), and \( W \).
However, we can easily reuse this code for a scaled problem: just set
\( \mu = \varrho = L = 1 \), \( W \) as \( W/L \) (\( \delta^{-1} \)), \( g=\gamma \), and
\( \lambda=\beta \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 12</b>: I find this somewhat confusing. First we talk about a rescaled equation but then we solve the unscaled equation, but we choose the parameters so that it is somehow related to the scaled problem...?)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 13</b>: Rewrote the sequence of topics to make all this clearer. First, implement non-scaled orginal problem, then for each problem in problems, scale this problem, run scaled problem with non-scaled code.)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 14</b>: Need to look at code again once I have understood the scaling.)</font>
<!-- end inline comment -->

<p>
<center>  <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 8:  Gravity-induced deformation of a clamped beam: deflection (left) and stress intensity seen from below (right). </p></center>
<p><img src="fig/beam2.png" align="bottom" width=800></p>
</center>

<p>
<!-- Stand-alone notebook? -->

<h1 id="___sec75" class="anchor">The Navier&ndash;Stokes equations </h1>
<div id="ftut1:NS"></div>

<p>
As our next example in this chapter, we will solve the incompressible
Navier-Stokes equations. This problem combines many of the challenges
from our previously studied problems: time-dependence, nonlinearity,
and vector-valued variables. We shall touch a number of FEniCS topics,
many of them quite advanced, so the exposition has the flavor of being
a teaser of what can be easily achieved in FEniCS, while later
chapters will dive into more detail with the most fundamental new
topics touched upon here. Do not expect to understand every detail of
this section &ndash; the point is rather to show how a quite complex PDE
problem is broken down to an implementation that still can be defended
to be carried out in minutes rather than hours or days.

<h2 id="___sec76" class="anchor">PDE problem </h2>

<p>
The incompressible Navier-Stokes equations are a system of equations
for the velocity \( u \) and pressure \( p \) in an incompressible fluid:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 15</b>: Quite uncommon to write \( \dot u \) for the time-derivative in the N-S equations. Only Claes Johnson comes to my mind... In mechanics, the dot is reserved for ODEs. I suggest the more common notation \( \partial u/\partial t \), also since we use this elsewhere in the books.  One can also argue that \( \nabla^2 u \) is a much more common form for the viscosity term (and compatible with your boundary conditions at outlets now), but the stress formulation has many advantages, especially if stress is a boundary condition.)</font>
<!-- end inline comment -->


$$
\begin{align}
\tag{3.29}
  \varrho(\frac{\partial u}{\partial t} +
  u \cdot \nabla u) &= \nabla\cdot\sigma(u, p) + f, \\ 
\tag{3.30}
  \nabla \cdot u &= 0.
\end{align}
$$

The right-hand side \( f \) is a given force per unit volume and
just as for the equations of linear elasticity,
\( \sigma(u, p) \) denotes the stress tensor which for a Newtonian fluid
is given by

$$
\begin{equation}
  \sigma(u, p) = 2\mu\epsilon(u) - pI,
\tag{3.31}
\end{equation}
$$

where \( \epsilon(u) \) is the strain-rate tensor

$$ \epsilon(u) = \frac{1}{2}(\nabla u + (\nabla u)^T))\tp$$

The parameter \( \mu \) is the dynamic viscosity. Note that the momentum
equation <a href="#mjx-eqn-3.29">(3.29)</a> is very similar to the elasticity
equation <a href="#mjx-eqn-3.20">(3.20)</a>. The difference is the
two additional terms \( \varrho(\dot{u} + u \cdot \nabla u) \) and the different
expression for the stress tensor. The two extra terms express the
acceleration balanced by the force \( F = f +
\nabla\cdot\sigma \) per unit volume in Newton's second law of motion.
However, the differences from the elasticity are big enough to call for
a much more complicated solution procedure.

<h2 id="ftut1:NS:varform" class="anchor">Variational formulation</h2>

<p>
The Navier&ndash;Stokes equations are different from
the time-dependent heat equation in that we need to solve a system of
equations and this system is of a special type. If we apply the same
technique as for the heat equation; that is, replacing the time
derivative with a simple difference quotient, we get a nonlinear
system of equations. This in
itself is not a problem for FEniCS as we saw in the section <a href="#ftut1:gallery:nonlinearpoisson">A nonlinear Poisson equation</a>, but the system has a so-called
<em>saddle point structure</em> and requires special techniques
(preconditioners and iterative methods) to be solved efficiently.

<p>
Instead, we will apply a simpler and often very efficient approach,
known as a <em>splitting method</em>. The idea is to
consider the two equations <a href="#mjx-eqn-3.29">(3.29)</a> and
<a href="#mjx-eqn-3.30">(3.30)</a> separately. There exist many splitting
strategies for the incompressible Navier-Stokes equations. One of the
oldest is the method proposed by Chorin <a href="._ftut1013.html#Chorin1968">[26]</a> and
Temam <a href="._ftut1013.html#Temam1969">[27]</a>, often referred to as <em>Chorin's method</em>. We will
use a modified version of Chorin's method, the so-called incremental
pressure correction scheme (IPCS) due to <a href="._ftut1013.html#Goda1979">[28]</a> which gives
improved accuracy compared to the original scheme at little extra
cost.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 16</b>: I changed the sampling point in time to \( n+1/2 \) instead of \( n-1/2 \) because the former gives the same type as formulas as we use elsewhere in time-dependent problems (\( n+1 \) is the new level, \( n \), \( n-1 \) etc are old levels) and it fits the naming convention that we agreed upon.  This is also widely used in the FDM/FEM/FVM literature. Backward Euler for the heat equation is the only example where one often applies \( n \) and \( n-1 \), if the theta scheme is not mentioned.)</font>
<!-- end inline comment -->

<p>
The IPCS scheme involves three steps. First, we compute a <em>tentative
velocity</em> \( u^{\star} \) by advancing the momentum equation
<a href="#mjx-eqn-3.29">(3.29)</a> by a midpoint finite difference scheme in
time, but using the pressure \( p^{n} \) from the
previous time interval. We will also linearize the nonlinear convective
term by using the known velocity \( u^{n} \): \( u^{n}\cdot\nabla u^{n} \).
The variational problem for this first step is:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 17</b>: It's somewhat strange that we are inconsistent with the convective term, it should be linearized as \( u^{n-1}\cdot\nabla u^{n-1/2} \), but we just have to follow the IPCS formulas...)</font>
<!-- end inline comment -->


$$
\begin{align}
\tag{3.32}
      &  \renni{v}{\rho(u^{\star} - u^{n}) / \dt}
      + \renni{v}{\rho u^{n} \cdot \nabla u^{n}}
      + \nonumber\\ 
      & \renni{\epsilon(v)}{\sigma(u^{n+\frac{1}{2}}, p^{n})}
      + \renni{v}{p^{n} n}_{\partial\Omega}
      - \nonumber\\ 
      &\renni{v}{\mu \nabla u^{n+\frac{1}{2}}\cdot n}_{\partial\Omega}
      = \renni{v}{\rho f^{n+1}}
\tag{3.33}
\end{align}
$$

This notation, suitable for problems with many terms in the variational
formulations, requires some explanation. First, we use the short-hand
notation

$$
  \inner{v}{w} = \int_{\Omega} vw \dx, \quad
  \inner{v}{w}_{\partial\Omega} = \int_{\partial\Omega} vw \ds.
$$

This allows us to express the variational problem in a more compact
way. Second, we use the notation \( u^{n+\frac{1}{2}} \). This notation
means the value of \( u \) at the midpoint of the interval, usually approximated
by an arithmetic mean

$$
  u^{n+\frac{1}{2}} \approx (u^{n+1} + u^n) / 2.
$$

Third, we notice that the variational problem <a href="#mjx-eqn-3.32">(3.32)</a>
arises from the integration by parts of the term
\( \inner{-\nabla\cdot\sigma}{v} \). Just as for the elasticity problem in
the section <a href="#ftut:elast">The equations of linear elasticity</a>, we obtain

$$
  \inner{-\nabla\cdot\sigma}{v}
  = \inner{\sigma}{\epsilon(v)}
  - \inner{T}{v}_{\partial\Omega},
$$

where \( T = \sigma\cdot n \) is the boundary traction. If we solve a
problem with a free boundary, we can take \( T = 0 \) on the
boundary. However, if we compute the flow through a channel or a pipe
and want to model flow that continues into an &quot;imaginary channel&quot; at
the outflow, we need to treat this term with some care. The assumption
we then make is that the derivative of the velocity in the direction
of the channel is zero at the outflow, corresponding to a flow that is
&quot;fully developed&quot; or doesn't change significantly downstream of the
outflow. Doing so, the remaining boundary term at the outflow becomes
\( pn - \mu\nabla u \cdot n \) which is the term appearing in the
variational problem <a href="#mjx-eqn-3.32">(3.32)</a>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 18</b>: Here a boundary term \( (\mu n\cdot \nabla u^{n+\frac{1}{2}},v) \) is missing. This is the intricate discussions we had back in 2009-2010 with Harish on using N-S with \( \nabla\cdot\sigma \) or \( \nabla^2 u \).)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 19</b>: Apostrophes like "these" don't look like what I would expect in LaTeX.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 20</b>: No, double quotes must be written as in LaTeX &quot;quotes&quot;. Two backticks and two forward ticks become the right double quotes in various output formats.)</font>
<!-- end inline comment -->

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b><code>grad(u)</code> vs. <code>nabla_grad(u)</code>.</b>
For scalar functions \( \nabla u \) has a clear meaning as the vector

$$ \nabla u =(\frac{\partial u}{\partial x}, \frac{\partial u}{\partial y},
\frac{\partial u}{\partial z})\tp$$

However, if \( u \) is vector-valued, the meaning is less clear.
Some sources define \( \nabla u \) as the matrix with elements
\( \partial u_j / \partial x_i \) while other sources prefer
\( \partial u_i / \partial x_j \). In FEniCS, <code>grad(u)</code> is defined as the
matrix with elements \( \partial u_i / \partial x_j \), which is the
natural definition of \( \nabla u \) if we think of this as the <em>gradient</em> or
<em>derivative</em> of \( u \). This way, the matrix \( \nabla u \) can be applied to
a differential \( \dx \) to give an increment \( \mathrm{d}u = \nabla u \,
\dx \). Since the alternative interpretation of \( \nabla u \) as the matrix
with elements \( \partial u_j / \partial x_i \) is very common, in
particular in continuum mechanics, FEniCS
provides the operator <code>nabla_grad</code> for this purpose.
For the Navier-Stokes equations, it is important to consider the
term \( u \cdot \nabla u \) which should be interpreted as the vector
\( w \) with elements
\( w_i = \sum_j \left(u_j \frac{\partial}{\partial x_j}\right) u_i
     = \sum_j u_j \frac{\partial u_i}{\partial x_j} \).
This term can be implemented in FEniCS either as
<code>grad(u)*u</code>, since this is expression becomes
\( \sum_j \partial u_i/\partial x_j u_j \), or as
<code>dot(u, nabla_grad(u))</code> since this expression becomes
\( \sum_i u_i \partial u_j/\partial x_i \). We will use the notation
<code>dot(u, nabla_grad(u))</code> below since it corresponds more closely
to the standard notation \( u \cdot \nabla u \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 21</b>: I like the straightforward formulation above, but it should be complemented by the arguments below since it is not a matter of taste in the end, but dictated by derivation of the PDE and what \( \nabla \) was meant to be there.)</font>
<!-- end inline comment -->

<p>
To be more precise, there are three different notations used for PDEs
involving gradient, divergence, and curl operators.
One employs \( \mathrm{grad}\, u \), \( \mathrm{div}\, u \), and
\( \mathrm{curl}\, u \) operators. Another employs \( \nabla u \)
as a synonym for \( \mathrm{grad}\, u \), \( \nabla\cdot u \) means \( \mathrm{div}\, u \),
and \( \nabla\times u \) is the name for \( \mathrm{curl}\, u \). The
third operates with \( \nabla u \), \( \nabla\cdot u \), and \( \nabla\times u \)
in which \( \nabla \) is a <em>vector</em> and, e.g., \( \nabla u \) is a dyadic
expression (\( (\nabla u)_{i,j} = \partial u_j/\partial x_i =
(\mathrm{grad} u)^T \)).
The latter notation, with \( \nabla \) as a vector operator,
is often handy when deriving equations in continuum mechanics, and if
this interpretation of \( \nabla \) is the foundation of your PDE, you must
use <code>nabla_grad</code>, <code>nabla_div</code>, and <code>nabla_curl</code> in FEniCS code as
these operators are compatible with dyadic computations.
From the Navier-Stokes equations we can easily see what \( \nabla \) means:
if the convective term has the form \( u\cdot \nabla u \) (actually meaning
\( (u\cdot\nabla) u \)), \( \nabla \) is a vector operator, reading
<code>dot(u, nabla_grad(u))</code> in FEniCS, but if we see
\( \nabla u\cdot u \) or \( (\mathrm{grad} u)\cdot u \), the
corresponding FEniCS
expression is <code>dot(grad(u), u)</code>.
</div>


<p>
We now move on to the second step in our splitting scheme for the
incompressible Navier-Stokes equations. In the first step, we computed
the tentative velocity \( u^{\star} \) based on the pressure from the
previous time step. We may now use the computed tentative velocity to
compute the new pressure \( p^n \):

$$
\begin{equation}
\tag{3.34}
  \renni{\nabla q}{\nabla p^n}
  = \renni{\nabla q}{\nabla p^{n-1}} - \dt^{-1}\renni{q}{\nabla \cdot u^{\star}}.
\end{equation}
$$

Note here that \( q \) is a scalar-valued test function from the pressure
space, whereas the test function \( v \) in <a href="#mjx-eqn-3.32">(3.32)</a> is a
vector-valued test function from the velocity space.

<p>
One way to think about this step is to subtract the Navier-Stokes
momentum equation <a href="#mjx-eqn-3.29">(3.29)</a> expressed in terms of the
tentative velocity \( u^{\star} \) and the pressure \( p^{n-1} \) from the
momentum equation expressed in terms of the velocity \( u^n \) and
pressure \( p^n \). This results in the equation

$$
\begin{equation} \tag{3.35}
  (u^n - u^{\star}) / \dt + \nabla p^n - \nabla p^{n-1} = 0.
\end{equation}
$$

Taking the divergence and requiring that \( \nabla \cdot u^n = 0 \) by the
Navier-Stokes continuity equation <a href="#mjx-eqn-3.30">(3.30)</a>, we
obtain the equation \( -\nabla\cdot u^{\star} / \dt + \nabla^2 p^n -
\nabla p^{n-1} \), which is a Poisson problem for the pressure \( p^n \)
resulting in the variational problem <a href="#mjx-eqn-3.34">(3.34)</a>.

<p>
Finally, we compute the corrected velocity \( u^n \) from the equation
<a href="#mjx-eqn-3.35">(3.35)</a>. Multiplying this equation by a test function
\( v \), we obtain

$$
\begin{equation}
\tag{3.36}
  \renni{v}{u^n} =
  \renni{v}{u^{\star}} - \dt\renni{v}{\nabla(p^n-p^{n-1})}.
\end{equation}
$$

<p>
In summary, we may thus solve the incompressible Navier-Stokes
equations efficiently by solving a sequence of three linear variational
problems in each time step.

<h2 id="___sec78" class="anchor">A simple FEniCS implementation </h2>

<h3 id="___sec79" class="anchor">Test problem 1: Channel flow </h3>

<p>
As a first test problem, we compute the flow between two infinite plates,
so-called channel or Poiseuille flow, since this problem has a known
analytical solution. Let \( H \) be the distance between the plates and \( L \)
the length of the channel. There are no body forces.

<p>
We may scale the problem first to get rid of seemingly independent
physical parameters. The physics of this problem is governed by
viscous effects only, in the direction perpendicular to the flow, so a
time scale should be based in diffusion accross the channel: \( t_c =
H^2/\nu \). We let \( U \), some characteristic inflow, be the velocity
scale and \( H \) the spatial scale. The pressure scale is taken as the
characteristic shear stress, \( \mu U/H \), since this is a primary
example of shear flow.  Inserting \( \bar x = x/H \), \( \bar y = y/H \),
\( \bar z = z/H \), \( \bar u =u/U \), \( \bar p = Hp/(\mu U) \), and \( \bar t =
H^2/\nu \) in the equations results in the scaled Navier-Stokes equations
(dropping bars after the scaling):

$$
\begin{align*}
\frac{\partial u}{\partial t} + \mathrm{Re}\, u\cdot\nabla u
&= -\nabla p + \mu\nabla^2 u + \mu\nabla(\nabla\cdot u),\\ 
\nabla\cdot u &= 0\tp
\end{align*}
$$

Here, Re is the Reynolds number \( \rho UH/\mu \). Because of the time and
pressure scale, which are different from convection-dominated fluid
flow, the Reynolds number is associated with the convective term and
not the viscosity term. Note that the last term in the first equation
is zero, but we included this term as it arises naturally from the
original \( \nabla\cdot\sigma \) term.

<p>
The exact solution is derived by assuming \( u=(u_x(x,y,z),0,0) \), with
the \( x \) axis pointing along the channel. Since \( \nabla\cdot u=0 \), \( u \)
cannot depend on \( x \). The physics of channel flow is also
two-dimensional so we can omit the \( z \) coordinate (more precisely:
\( \partial/\partial z=0 \)). Inserting \( u=(u_x,0,0) \) in the (scaled)
governing equations gives \( u_x''(y) = \partial p/\partial x \).
Differentiating this equation with respect to \( x \) shows that \( \partial
p/\partial x \) is a constant, here called \( -\beta \). This is the driving
force of the flow and can be specified as a known parameter in the
problem.  Integrating \( u_x''(y)=-\beta \) over the width of the channel,
\( [0,1] \), and requiring \( u=0 \) at the channel walls, results in
\( u_x=\frac{1}{2}\beta y(1-y) \). The characteristic inlet flow in the
channel, \( U \), can be taken as the maximum inflow at \( x=1/2 \), implying
that \( \beta = 8 \).  The length of the channel, \( L/H \) in the scaled
model, has no impact on the result, so for simplicity we just compute
on the unit square.  Mathematically, the pressure must be prescribed
at a point, but since \( p \) does not depend on \( y \), we can set \( p \) to a
known value, e.g. zero, along the outlet boundary \( x=1 \).  The result
is \( p(x)=8(1-x) \) and \( u_x=4y(1-y) \).

<p>
The boundary conditions can be set as \( p=1 \) on \( x=0 \), \( p=0 \) on \( x=1 \)
and \( u=0 \) on the walls \( y=0,1 \). This defines the pressure drop and
should result in unit maximum velocity at the inlet and outlet and a
parabolic velocity profile without further specifications.  Note that
it is only meaningful to solve the Navier-Stokes equations in 2D or 3D
geometries, although the underlying mathematical problem collapses to
two 1D problems, one for \( u_x(y) \) and one for \( p(x) \).

<p>
The scaled model is not so easy to simulate using a standard
Navier-Stokes solver with dimensions. However, one can argue that the
convection term is zero, so the Re coefficient in front of this term
in the scaled PDEs is not important and can be set to unity. In that
case, setting \( \rho = \mu = 1 \) in the original Navier-Stokes equations
resembles the scaled model.

<h3 id="___sec80" class="anchor">FEniCS implementation </h3>

<p>
Our previous examples have all started out with the creation of a
mesh and then the definition of a <code>FunctionSpace</code> on the mesh. For the
splitting scheme we will use to solve the Navier-Stokes equations we
need to define two function spaces, one for the velocity and one for
the pressure:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The first space <code>V</code> is a vector-valued function space for the velocity
and the second space <code>Q</code> is a scalar-valued function space for the
pressure. We use piecewise quadratic elements for the velocity and
piecewise linear elements for the pressure. When creating a
<code>VectorFunctionSpace</code> in FEniCS, the value-dimension (the length of
the vectors) will be set equal to the geometric dimension of the
finite element mesh. One can easily create vector-valued function
spaces with other dimensions in FEniCS by adding the keyword parameter
<code>dim</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>, dim<span style="color: #666666">=10</span>)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Stable finite element spaces for the Navier-Stokes equations.</b>
It is well-known that certain finite element spaces are not <em>stable</em>
for the Navier-Stokes equations, or even for the simpler Stokes
equations. The prime example of an unstable pair of finite element
spaces is to use continuous piecewise polynomials for both the
velocity and the pressure. Using an
unstable pair of spaces typically results in a solution with
<em>spurious</em> (unwanted, non-physical) oscillations in the pressure
solution. The simple remedy is to use piecewise continuous piecewise
quadratic elements for the velocity and continuous piecewise linear
elements for the pressure. Together, these elements form the so-called
<em>Taylor-Hood</em> element. Spurious oscillations may occur also for
splitting methods if an unstable element pair is used.
</div>


<p>
Since we have two different function spaces, we need to create two sets
of trial and test functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)
</pre></div>
<p>
As we have seen in previous examples, boundaries may be defined in
FEniCS by defining Python functions that return <code>True</code> or <code>False</code>
depending on whether a point should be considered part of the
boundary, for example

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>)
</pre></div>
<p>
This function defines the boundary to be all points with
\( x \)-coordinate equal to (near) zero. The <code>near</code> function comes from
FEniCS and performs a test with tolerance: <code>abs(x[0]-0) &lt; 3E-16</code> so
we do not run into rounding troubles.
Alternatively, we may give the boundary
definition as a string of C++ code, much like we have previously
defined expressions such as <code>u0 = Expression('1 + x[0]*x[0] +
2*x[1]*x[1]')</code>. The above definition of the boundary in terms of a
Python function may thus be replaced by a simple C++ string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>boundary <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
</pre></div>
<p>
This has the advantage of moving the computation of which nodes
belong to boundary to C++ from Python, which improves the efficiency
of the program.

<p>
For the current example, we will set three different boundary
conditions. First, we will set \( u = 0 \) at the walls of the channel;
that is, at \( y = 0 \) and \( y = 1 \). Second, we will set \( p = 1 \) at the
inflow (\( x = 0 \)) and, finally, \( p = 0 \) at the outflow (\( x = 1 \)). This
will result in a pressure gradient that will accelerate the flow from an
initial stationary state. These
boundary conditions may be defined as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 1)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_noslip  <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcp_inflow  <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">8</span>), inflow)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_noslip]
bcp <span style="color: #666666">=</span> [bcp_inflow, bcp_outflow]
</pre></div>
<p>
At the end, we collect the boundary conditions for the velocity and
pressure in Python lists so we can easily access them in the
following computation.

<p>
We now move on to the definition of the variational forms. There are
three variational problems to be defined, one for each step in the
IPCS scheme. Let us look at the definition of the first variational
problem. We start with some constants:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u_n <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
mu  <span style="color: #666666">=</span> Constant(mu)
rho <span style="color: #666666">=</span> Constant(rho)
</pre></div>
<p>
The next step now is to set up the variational form for the first step
<a href="#mjx-eqn-3.32">(3.32)</a> in the solution process.
Since the variational problem contains a mix of
known and unknown quantities we have introduced a naming convention to
be used throughout the book: <code>u</code> is the unknown (mathematically \( u^{n+1} \))
as a trial function in the variational form, <code>u_</code> is the most recently
computed approximation to <code>u</code> (\( u^{n+1} \) available as a finite element
FEniCS <code>Function</code> object), <code>u_n</code> is \( u^n \), and the same convention
goes for <code>p</code>. <code>p_</code>, and <code>p_n</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> rho<span style="color: #666666">*</span>dot((u <span style="color: #666666">-</span> u_n) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
     rho<span style="color: #666666">*</span>dot(dot(u_n, nabla_grad(u_n)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p_n), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p_n<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(mu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> rho<span style="color: #666666">*</span>dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)
</pre></div>
<p>
Note that we, in the definition of the variational problem,
take advantage of the
Python programming language to define our own operators <code>sigma</code> and
<code>epsilon</code>. Using Python this way makes it easy to extend the
mathematical language of FEniCS with special operators and
constitutive laws.

<p>
Also note that FEniCS can sort out the (matrix) \( a(u,v) \) and
(right-hand side) \( L(v) \) forms by the <code>lhs</code>
and <code>rhs</code> functions. This is particularly convenient in longer and
more complicated variational forms.

<p>
The splitting scheme requires the solution of a sequence of three
variational problems in each time step. We have previously used the
built-in FEniCS function <code>solve</code> to solve variational problems. Under
the hood, when a user calls <code>solve(a == L, u, bc)</code>, FEniCS will
perform the following steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A <span style="color: #666666">=</span> assemble(A)
b <span style="color: #666666">=</span> assemble(L)
bc<span style="color: #666666">.</span>apply(A, b)
solve(A, u<span style="color: #666666">.</span>vector(), b)
</pre></div>
<p>
In the last step, FEniCS uses the overloaded <code>solve</code> function to solve
the linear system <code>AU = b</code> where <code>U</code> is the vector of degrees of
freedom for the function \( u(x) = \sum_{j=1} U_j \phi_j(x) \).

<p>
In our implementation of the splitting scheme, we will make use of
these low-level commands to first assemble and then call solve. This
has the advantage that we may control when we assemble and when we
solve the linear system. In particular, since the matrices for the
three variational problems are all time-independent, it makes sense to
assemble them once and for all outside of the time-stepping loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)
</pre></div>
<p>
Within the time-stepping loop, we may then assemble only the
right-hand side vectors, apply boundary conditions, and call the solve
function as here for the first of the three steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u_<span style="color: #666666">.</span>vector(), b1)
</pre></div>
<p>
Notice the Python <em>list comprehension</em> <code>[bc.apply(b1) for bc in bcu]</code>
which iterates over all <code>bc</code> in the list <code>bcu</code>. This is a convenient
and compact way to construct a loop that applies
all boundary conditions in a single line. Also, the code works if
we add more Dirichlet boundary conditions in the future.

<p>
Finally, let us look at an important detail in how we use parameters
such as the time step <code>dt</code> in the definition of our variational
problems. Since we might want to change these later, for example if we
want to experiment with smaller or larger time steps, we wrap these
using a FEniCS <code>Constant</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>k <span style="color: #666666">=</span> Constant(dt)
</pre></div>
<p>
The assembly of matrices and vectors in FEniCS is based on code
generation. This means that whenever we change a variational problem,
FEniCS will have to generate new code, which may take a little
time. New code will also be generated when a float value for the time
step is changed. By wrapping this parameter using
<code>Constant</code>, FEniCS will treat the parameter as a generic constant and
not a specific numerical value, which prevents repeated code
generation. In the case of the time step, we choose a new name <code>k</code>
instead of <code>dt</code> for the <code>Constant</code> since we also want to use the
variable <code>dt</code> as a Python float as part of the time-stepping.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 22</b>: Some pure fluid mechanics guys will think of Poiseulle as 1D, so they get confused why you need to launch 2D/3D code when it's about \( u''=4 \) and can be done in Matlab... Renamed file to <code>navier_stokes_channel.py</code>. :smiley:)</font>
<!-- end inline comment -->

<p>
The complete code for simulating 2D channel flow with FEniCS looks as
follows:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 23</b>: The names <code>u0</code>, <code>u1</code>, <code>p0</code>, <code>p1</code> are odd compared to the rest of the book. I changed to <code>u_</code>, <code>u_n</code>, <code>p_</code>, <code>p_n</code>, with <code>u</code> and <code>p</code> reserved for <code>TrialFunction</code>. The we encourage users to use a consistent naming &ndash; and this naming works for multiple time levels too.)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>           <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">500</span>    <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
mu <span style="color: #666666">=</span> <span style="color: #666666">1</span>             <span style="color: #408080; font-style: italic"># kinematic viscosity</span>
rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>            <span style="color: #408080; font-style: italic"># density</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function spaces</span>
mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">16</span>, <span style="color: #666666">16</span>)
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 1)&#39;</span>
walls   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_noslip <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcp_inflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">8</span>), inflow)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_noslip]
bcp <span style="color: #666666">=</span> [bcp_inflow, bcp_outflow]

<span style="color: #408080; font-style: italic"># Define trial and test functions</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)

<span style="color: #408080; font-style: italic"># Define functions for solutions at previous and current time steps</span>
u_n <span style="color: #666666">=</span> Function(V)
u_  <span style="color: #666666">=</span> Function(V)
p_n <span style="color: #666666">=</span> Function(Q)
p_  <span style="color: #666666">=</span> Function(Q)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u_n <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
mu  <span style="color: #666666">=</span> Constant(mu)
rho <span style="color: #666666">=</span> Constant(rho)

<span style="color: #408080; font-style: italic"># Define strain-rate tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> rho<span style="color: #666666">*</span>dot((u <span style="color: #666666">-</span> u_n) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
     rho<span style="color: #666666">*</span>dot(dot(u_n, nabla_grad(u_n)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p_n), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p_n<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(mu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> rho<span style="color: #666666">*</span>dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)

<span style="color: #408080; font-style: italic"># Define variational problem for step 2</span>
a2 <span style="color: #666666">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color: #666666">*</span>dx
L2 <span style="color: #666666">=</span> dot(nabla_grad(p_n), nabla_grad(q))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (<span style="color: #666666">1/</span>k)<span style="color: #666666">*</span>div(u_)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Define variational problem for step 3</span>
a3 <span style="color: #666666">=</span> dot(u, v)<span style="color: #666666">*</span>dx
L3 <span style="color: #666666">=</span> dot(u_, v)<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dot(nabla_grad(p_ <span style="color: #666666">-</span> p_n), v)<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Assemble matrices</span>
A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)

<span style="color: #408080; font-style: italic"># Apply boundary conditions to matrices</span>
[bc<span style="color: #666666">.</span>apply(A1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
[bc<span style="color: #666666">.</span>apply(A2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u_<span style="color: #666666">.</span>vector(), b1)

    <span style="color: #408080; font-style: italic"># Step 2: Pressure correction step</span>
    b2 <span style="color: #666666">=</span> assemble(L2)
    [bc<span style="color: #666666">.</span>apply(b2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]
    solve(A2, p_<span style="color: #666666">.</span>vector(), b2)

    <span style="color: #408080; font-style: italic"># Step 3: Velocity correction step</span>
    b3 <span style="color: #666666">=</span> assemble(L3)
    solve(A3, u_<span style="color: #666666">.</span>vector(), b3)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    plot(u_)

    <span style="color: #408080; font-style: italic"># Compute error</span>
    u_e <span style="color: #666666">=</span> Expression((<span style="color: #BA2121">&#39;4*x[1]*(1.0 - x[1])&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>), degree<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> interpolate(u_e, V)
    error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u_<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;t = </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max u:&#39;</span>, u_<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max())

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_n<span style="color: #666666">.</span>assign(u_)
    p_n<span style="color: #666666">.</span>assign(p_)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>

<h3 id="___sec81" class="anchor">Verification </h3>

<p>
We compute the error at the nodes as we have done before to verify
that our implementation is correct. Our Navier-Stokes solver computes
the solution to the time-dependent incompressible Navier-Stokes
equations, starting from the initial condition \( u = (0, 0) \). We have
not specified the initial condition explicitly in our solver which
means that FEniCS will initialize all variables, in particular the
previous and current velocities <code>u0</code> and <code>u1</code>, to zero. Since the
exact solution is quadratic, we expect the solution to be exact to
within machine precision at the nodes at the final time. For our
implementation, the error quickly approaches zero and is approximately
\( 10^{-9} \) at time \( T = 10 \).

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_poisseuille"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  Plot of the velocity profile at the final time for the Navier-Stokes Poiseuille flow example.  <!-- caption label: ftut1:fig:navier_stokes_poisseuille --> </p></center>
<p><img src="fig/navier_stokes_poiseuille.png" align="bottom" width=600></p>
</center>

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec82" class="anchor">Exercise 2: Simulate channel flow in a 3D geometry </h2>

<p>
FEniCS solvers typically have the number of space dimensions
parameterized, so a 1D, 2D, and 3D code all look the same.
We shall demonstrate what this means by extending the 2D solver
<code>navier_stokes_channel.py</code> to a simulator where the domain is a box
(the unit cube in the scaled model).

<p>
<b>a)</b>
Set up boundary conditions for \( u \) at all points on the boundary.
Set up boundary conditions for \( p \) at all points on the boundary as
this is required by our Poisson equation for \( p \) (but not in the
original mathematical model &ndash; there, knowing \( p \) at one point throughout
time is sufficient).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
At the inlet \( x=0 \) we have the velocity completely described: \( (u_x,0,0) \).
At the channel walls, \( y=0 \) and \( y=1 \), we also have the velocity
completely described: \( u=(0,0,0) \) because of no-slip.
At the outlet x=1 we do not specify anything. This means that the
boundary integrals in Step 1 vanish and that \( p=0 \) and
\( \partial u/\partial n = 0 \), with \( n \) as the \( x \) direction,
implying &quot;no change&quot; with \( x \), which is reasonable (since we know
that \( \partial/\partial x=0 \) because of incompressibility).
For the pressure we set \( p=8 \) at \( x=0 \) and \( p=0 \) at \( x=1 \) to
represent a scaled pressure gradient equal to 8 (which leads to
a unit maximum velocity). At \( y=0 \) and \( y=1 \) we do not specify anything,
which implies \( \partial p/\partial y=0 \). This is a condition much
discussed in the literature, but it works perfectly in channel flow
with straight walls.

<p>
The two remaining boundaries, \( z=0 \) and \( z=1 \), requires attention.
For the pressure, &quot;nothing happens&quot; in the \( z \) direction so
\( \partial p/\partial z=\partial p/\partial n=0 \) is the condition.
This is automatically implemented by the finite element method.
For the velocity we also have a &quot;nothing happens&quot; criterion in the
3rd direction, and we can in addition use the assumption of \( u_z=0 \),
if needed.
The derivative criterion means \( \partial u/\partial z=\partial u/\partial n=0 \)
in the boundary integrals. There is also an integral involving \( pn_z \)
in a component PDE with \( u_z \) in all terms.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Modify the <code>navier_stokes_channel.py</code> file so it computes 3D channel flow.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_2">

<p>
We must switch the domain from <code>UnitSquareMesh</code> to <code>UnitCubeMesh</code>.
We must also switch all 3-vectors to 2-vectors, such as
replacing going from <code>(0,0)</code> to <code>(0,0,0)</code> in <code>bcu_noslip</code>. Similarly,
<code>f</code> and <code>u_e</code> must extend their 2-vectors to 3-vectors.

<p>

<!-- code=python (!bc pypro-h) typeset with pygments style "default" -->

<script type="text/javascript">
function show_hide_code80(){
  $("#code80").toggle();
}
</script>
<button type="button" onclick="show_hide_code80()">Show/hide code</button>
<div id="code80" style="display:none">
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>           <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">500</span>    <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
mu <span style="color: #666666">=</span> <span style="color: #666666">1</span>             <span style="color: #408080; font-style: italic"># kinematic viscosity</span>
rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>            <span style="color: #408080; font-style: italic"># density</span>

<span style="color: #408080; font-style: italic"># Create mesh and define function spaces</span>
mesh <span style="color: #666666">=</span> UnitCubeMesh(<span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">4</span>)
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 1)&#39;</span>
walls   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 1)&#39;</span>

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_noslip <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcp_inflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">8</span>), inflow)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_noslip]
bcp <span style="color: #666666">=</span> [bcp_inflow, bcp_outflow]

<span style="color: #408080; font-style: italic"># Define trial and test functions</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)

<span style="color: #408080; font-style: italic"># Define functions for solutions at previous and current time steps</span>
u0 <span style="color: #666666">=</span> Function(V)
u1 <span style="color: #666666">=</span> Function(V)
p0 <span style="color: #666666">=</span> Function(Q)
p1 <span style="color: #666666">=</span> Function(Q)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u0 <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
mu  <span style="color: #666666">=</span> Constant(mu)
rho <span style="color: #666666">=</span> Constant(rho)

<span style="color: #408080; font-style: italic"># Define strain-rate tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> rho<span style="color: #666666">*</span>dot((u <span style="color: #666666">-</span> u0) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
     rho<span style="color: #666666">*</span>dot(dot(u0, nabla_grad(u0)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p0), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p0<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(mu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> rho<span style="color: #666666">*</span>dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)

<span style="color: #408080; font-style: italic"># Define variational problem for step 2</span>
a2 <span style="color: #666666">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color: #666666">*</span>dx
L2 <span style="color: #666666">=</span> dot(nabla_grad(p0), nabla_grad(q))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (<span style="color: #666666">1/</span>k)<span style="color: #666666">*</span>div(u1)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Define variational problem for step 3</span>
a3 <span style="color: #666666">=</span> dot(u, v)<span style="color: #666666">*</span>dx
L3 <span style="color: #666666">=</span> dot(u1, v)<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dot(nabla_grad(p1 <span style="color: #666666">-</span> p0), v)<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Assemble matrices</span>
A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)

<span style="color: #408080; font-style: italic"># Apply boundary conditions to matrices</span>
[bc<span style="color: #666666">.</span>apply(A1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
[bc<span style="color: #666666">.</span>apply(A2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u1<span style="color: #666666">.</span>vector(), b1)

    <span style="color: #408080; font-style: italic"># Step 2: Pressure correction step</span>
    b2 <span style="color: #666666">=</span> assemble(L2)
    [bc<span style="color: #666666">.</span>apply(b2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]
    solve(A2, p1<span style="color: #666666">.</span>vector(), b2)

    <span style="color: #408080; font-style: italic"># Step 3: Velocity correction step</span>
    b3 <span style="color: #666666">=</span> assemble(L3)
    solve(A3, u1<span style="color: #666666">.</span>vector(), b3)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    plot(u1)

    <span style="color: #408080; font-style: italic"># Compute error</span>
    u_e <span style="color: #666666">=</span> Expression((<span style="color: #BA2121">&#39;4*x[1]*(1.0 - x[1])&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>), degree<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> interpolate(u_e, V)
    error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_e<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array() <span style="color: #666666">-</span> u1<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array())<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;t = </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">: error = </span><span style="color: #BB6688; font-weight: bold">%.3g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, error))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;max u:&#39;</span>, u1<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max())

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u0<span style="color: #666666">.</span>assign(u1)
    p0<span style="color: #666666">.</span>assign(p1)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>

</div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2 id="___sec83" class="anchor">Flow past a cylinder </h2>

<p>
We now turn our attention to a more challenging physical example: flow
past a circular cylinder. The geometry and parameters are taken from
problem DFG 2D-2 in the <a href="http://www.featflow.de/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark2_re100.html" target="_self">FEATFLOW/1995-DFG benchmark suite</a>
and is illustrated in Figure
<a href="#ftut1:navier_stokes_cylinder:geometry">10</a>. The kinematic viscosity is
given by \( \nu = 0.001 = \mu/\rho \) and the inflow velocity profile is
specified as

$$
  u(x, y, t) = \left(1.5 \cdot \frac{4y(1-y)}{0.41^2}, 0\right),
$$

which has a maximum magnitude of \( 1.5 \) at \( y = 0.41/2 \). We do not
scale anything in this benchmark since exact parameters in the case
we want to simulate are known.

<p>
<center> <!-- figure label: --> <div id="ftut1:navier_stokes_cylinder:geometry"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Geometry for the flow past a cylinder test problem. Notice the slightly perturbed and unsymmetric geometry.  <!-- caption label: ftut1:navier_stokes_cylinder:geometry -->. </p></center>
<p><img src="fig/navier_stokes_cylinder_geometry.png" align="bottom" width=600></p>
</center>

<h3 id="___sec84" class="anchor">FEniCS implementation </h3>

<p>
So far all our domains have been simple shapes such as a unit square or
a rectangular box. A number of such simple meshes may be created in
FEniCS using the built-in meshes
(<code>UnitIntervalMesh</code>,
<code>UnitSquareMesh</code>,
<code>UnitCubeMesh</code>,
<code>Interval</code>,
<code>RectangleMesh</code>, and
<code>BoxMesh</code>).
FEniCS supports the creation of more complex meshes via a technique
called <em>constructive solid geometry</em> (CSG), which lets us define
geometries in terms of simple shapes (primitives) and set operations:
union, intersection, and set difference. The set operations are
encoded in FEniCS using the operators <code>+</code> (union), <code>*</code> (intersection),
and <code>-</code> (set difference). To access the CSG functionality in FEniCS,
one must import the FEniCS module <code>mshr</code> which provides the
extended meshing functionality of FEniCS.

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 24</b>: Need to cite mshr.)</font>
<!-- end inline comment -->

<p>
The geometry for the cylinder flow test problem can be defined easily
by first defining the rectangular channel and then subtracting the
circle:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>channel <span style="color: #666666">=</span> Rectangle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">2.2</span>, <span style="color: #666666">0.41</span>))
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.2</span>, <span style="color: #666666">0.2</span>), <span style="color: #666666">0.05</span>)
geometry <span style="color: #666666">=</span> channel <span style="color: #666666">-</span> cylinder
</pre></div>
<p>
We may then create the mesh by calling the function <code>generate_mesh</code>:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 25</b>: Should do some refinement of the boundary layer? Can we mark elements in a distance from the cylinder and ask these elements to be refine a given number of times?)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> generate_mesh(geometry, <span style="color: #666666">64</span>)
</pre></div>
<p>
To solve the cylinder test problem, we only need to make a few minor
changes to the code we wrote for the Poiseuille flow test
case. Besides defining the new mesh, the only change we need to make
is to modify the boundary conditions and the time step size. The
boundaries are specified as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 2.2)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
cylinder <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>
</pre></div>
<p>
The last line may seem cryptic before you catch the idea: we want to pick
out all boundary points (<code>on_boundary</code>) that also lie within the 2D
domain \( [0.1,0.3]\times [0.1,0.3] \), see Figure <a href="#ftut1:navier_stokes_cylinder:geometry">10</a>. The only possible points are then the points on the
circular boundary!

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 26</b>: We set \( p = 0 \) at the outflow. This seems to be necessary, but we should really not need to specify the pressure at all.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 27</b>: Need to specify the pressure at one point, mathematically.)</font>
<!-- end inline comment -->

<p>
In addition to these essential changes, we will make a number of small
changes to improve our solver. First, since we need to choose a
relatively small time step to compute the solution (a time step that
is too large will make the solution blow up) we add a progress bar so
that we can follow the progress of our computation. This can be done
as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>progress <span style="color: #666666">=</span> Progress(<span style="color: #BA2121">&#39;Time-stepping&#39;</span>)
set_log_level(PROGRESS)

t <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Place computation here</span>

    <span style="color: #408080; font-style: italic"># Update progress bar</span>
    progress<span style="color: #666666">.</span>update(t <span style="color: #666666">/</span> T)
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Log levels and printing in FEniCS.</b>
Notice the call to <code>set_log_level(PROGRESS)</code> which is essential to
make FEniCS actually display the progress bar. FEniCS is actually
quite informative about what is going on during a computation but the
amount of information printed to screen depends on the current log
level. Only messages with a priority higher than or equal to the
current log level will be displayed. The predefined log levels in
FEniCS are
<code>DBG</code>,
<code>TRACE</code>,
<code>PROGRESS</code>,
<code>INFO</code>,
<code>WARNING</code>,
<code>ERROR</code>, and
<code>CRITICAL</code>. By default, the log level is set to <code>INFO</code> which means
that messages at level <code>DBG</code>, <code>TRACE</code>, and <code>PROGRESS</code> will not be
printed. Users may print messages using the FEniCS functions <code>info</code>,
<code>warning</code>, and <code>error</code> which will print messages at the obvious log
level (and in the case of <code>error</code> also throw an exception and
exit). One may also use the call <code>log(level, message)</code> to print a
message at a specific log level.
</div>


<p>
Since the system(s) of linear equations are significantly larger than
for the simple Poiseuille flow test problem, we choose to use an
iterative method instead of the default direct (sparse) solver used by
FEniCS when calling <code>solve</code>. Efficient solution of linear systems
arising from the discretization of PDEs requires the choice of both a
good iterative (Krylov subspace) method and a good
preconditioner. For this problem, we will simply use the biconjugate
gradient stabilized method (BiCGSTAB). This can be done by adding the
keyword <code>bicgstab</code> in the call to <code>solve</code>. We also add a preconditioner,
<code>ilu</code> to further speed up the computations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>solve(A1, u1<span style="color: #666666">.</span>vector(), b1, <span style="color: #BA2121">&#39;bicgstab&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
solve(A2, p1<span style="color: #666666">.</span>vector(), b2, <span style="color: #BA2121">&#39;bicgstab&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)
solve(A3, u1<span style="color: #666666">.</span>vector(), b3, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)
</pre></div>
<p>
Finally, to be able to postprocess the computed solution in Paraview,
we store the solution to file in each time step. To avoid cluttering
our working directory with a large number of solution
files, we make sure to store the solution in a subdirectory:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>vtkfile_u <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/velocity.pvd&#39;</span>)
vtkfile_p <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;solutions/pressure.pvd&#39;</span>)
</pre></div>
<p>
Note that one does not need to create the directory before running the
program. It will be created automatically by FEniCS.

<p>
We also store the solution using a FEniCS <code>TimeSeries</code>. This allows us
to store the solution not for visualization (as when using VTK
files), but for later reuse in a computation as we will see in the
next section. Using a <code>TimeSeries</code> it is easy and efficient to read in
solutions from certain points in time during a simulation. The
<code>TimeSeries</code> class uses a binary HDF5 file for efficient storage and
access to data.

<p>
Figures <a href="#ftut1:fig:navier_stokes_cylinder:velocity">11</a> and
<a href="#ftut1:fig:navier_stokes_cylinder:pressure">12</a> show the velocity and
pressure at final time visualized in Paraview. For the visualization
of the velocity, we have used the <b>Glyph</b> filter to visualize the
vector velocity field. For the visualization of the pressure, we have
used the <b>Warp By Scalar</b> filter.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_cylinder:velocity"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 11:  Plot of the velocity for the cylinder test problem at final time.  <!-- caption label: ftut1:fig:navier_stokes_cylinder:velocity --> </p></center>
<p><img src="fig/navier_stokes_cylinder_velocity.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:navier_stokes_cylinder:pressure"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 12:  Plot of the pressure for the cylinder test problem at final time.  <!-- caption label: ftut1:fig:navier_stokes_cylinder:pressure --> </p></center>
<p><img src="fig/navier_stokes_cylinder_pressure.png" align="bottom" width=600></p>
</center>

<p>
The complete code for the cylinder test problem looks as
follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

T <span style="color: #666666">=</span> <span style="color: #666666">5.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">5000</span>   <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
mu <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>         <span style="color: #408080; font-style: italic"># dynamic viscosity</span>
rho <span style="color: #666666">=</span> <span style="color: #666666">1</span>            <span style="color: #408080; font-style: italic"># density</span>

<span style="color: #408080; font-style: italic"># Create mesh</span>
channel <span style="color: #666666">=</span> Rectangle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), Point(<span style="color: #666666">2.2</span>, <span style="color: #666666">0.41</span>))
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0.2</span>, <span style="color: #666666">0.2</span>), <span style="color: #666666">0.05</span>)
geometry <span style="color: #666666">=</span> channel <span style="color: #666666">-</span> cylinder
mesh <span style="color: #666666">=</span> generate_mesh(geometry, <span style="color: #666666">64</span>)

<span style="color: #408080; font-style: italic"># Define function spaces</span>
V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundaries</span>
inflow   <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 0)&#39;</span>
outflow  <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[0], 2.2)&#39;</span>
walls    <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;near(x[1], 0) || near(x[1], 0.41)&#39;</span>
cylinder <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#39;</span>

<span style="color: #408080; font-style: italic"># Define inflow profile</span>
inflow_profile <span style="color: #666666">=</span> (<span style="color: #BA2121">&#39;4.0*1.5*x[1]*(0.41 - x[1]) / pow(0.41, 2)&#39;</span>, <span style="color: #BA2121">&#39;0&#39;</span>)

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
bcu_inflow <span style="color: #666666">=</span> DirichletBC(V, Expression(inflow_profile, degree<span style="color: #666666">=2</span>), inflow)
bcu_walls <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), walls)
bcu_cylinder <span style="color: #666666">=</span> DirichletBC(V, Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>)), cylinder)
bcp_outflow <span style="color: #666666">=</span> DirichletBC(Q, Constant(<span style="color: #666666">0</span>), outflow)
bcu <span style="color: #666666">=</span> [bcu_inflow, bcu_walls, bcu_cylinder]
bcp <span style="color: #666666">=</span> [bcp_outflow]

<span style="color: #408080; font-style: italic"># Define trial and test functions</span>
u <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
p <span style="color: #666666">=</span> TrialFunction(Q)
q <span style="color: #666666">=</span> TestFunction(Q)

<span style="color: #408080; font-style: italic"># Define functions for solutions at previous and current time steps</span>
u_n <span style="color: #666666">=</span> Function(V)
u_  <span style="color: #666666">=</span> Function(V)
p_n <span style="color: #666666">=</span> Function(Q)
p_  <span style="color: #666666">=</span> Function(Q)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(u_n <span style="color: #666666">+</span> u)
n   <span style="color: #666666">=</span> FacetNormal(mesh)
f   <span style="color: #666666">=</span> Constant((<span style="color: #666666">0</span>, <span style="color: #666666">0</span>))
k   <span style="color: #666666">=</span> Constant(dt)
mu  <span style="color: #666666">=</span> Constant(mu)

<span style="color: #408080; font-style: italic"># Define symmetric gradient</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">epsilon</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym(nabla_grad(u))

<span style="color: #408080; font-style: italic"># Define stress tensor</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigma</span>(u, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>mu<span style="color: #666666">*</span>epsilon(u) <span style="color: #666666">-</span> p<span style="color: #666666">*</span>Identity(<span style="color: #008000">len</span>(u))

<span style="color: #408080; font-style: italic"># Define variational problem for step 1</span>
F1 <span style="color: #666666">=</span> rho<span style="color: #666666">*</span>dot((u <span style="color: #666666">-</span> u_n) <span style="color: #666666">/</span> k, v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> rho<span style="color: #666666">*</span>dot(dot(u_n, nabla_grad(u_n)), v)<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> inner(sigma(U, p_n), epsilon(v))<span style="color: #666666">*</span>dx \ 
   <span style="color: #666666">+</span> dot(p_n<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds <span style="color: #666666">-</span> dot(mu<span style="color: #666666">*</span>nabla_grad(U)<span style="color: #666666">*</span>n, v)<span style="color: #666666">*</span>ds \ 
   <span style="color: #666666">-</span> rho<span style="color: #666666">*</span>dot(f, v)<span style="color: #666666">*</span>dx
a1 <span style="color: #666666">=</span> lhs(F1)
L1 <span style="color: #666666">=</span> rhs(F1)

<span style="color: #408080; font-style: italic"># Define variational problem for step 2</span>
a2 <span style="color: #666666">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color: #666666">*</span>dx
L2 <span style="color: #666666">=</span> dot(nabla_grad(p_n), nabla_grad(q))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> (<span style="color: #666666">1/</span>k)<span style="color: #666666">*</span>div(u_)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Define variational problem for step 3</span>
a3 <span style="color: #666666">=</span> dot(u, v)<span style="color: #666666">*</span>dx
L3 <span style="color: #666666">=</span> dot(u_, v)<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dot(nabla_grad(p_ <span style="color: #666666">-</span> p_n), v)<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Assemble matrices</span>
A1 <span style="color: #666666">=</span> assemble(a1)
A2 <span style="color: #666666">=</span> assemble(a2)
A3 <span style="color: #666666">=</span> assemble(a3)

<span style="color: #408080; font-style: italic"># Apply boundary conditions to matrices</span>
[bc<span style="color: #666666">.</span>apply(A1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
[bc<span style="color: #666666">.</span>apply(A2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]

<span style="color: #408080; font-style: italic"># Save mesh to file for later</span>
File(<span style="color: #BA2121">&#39;channel.xml.gz&#39;</span>) <span style="color: #666666">&lt;&lt;</span> mesh
<span style="color: #008000">exit</span>(<span style="color: #666666">0</span>)

<span style="color: #408080; font-style: italic"># Create VTK files for visualization output</span>
vtkfile_u <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;ns/velocity.pvd&#39;</span>)
vtkfile_p <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;ns/pressure.pvd&#39;</span>)

<span style="color: #408080; font-style: italic"># FIXME: mpi_comm_world should not be needed here, fix in FEniCS!</span>

<span style="color: #408080; font-style: italic"># Create time series for saving solution for later</span>
timeseries_u <span style="color: #666666">=</span> TimeSeries(mpi_comm_world(), <span style="color: #BA2121">&#39;ns/velocity&#39;</span>)
timeseries_p <span style="color: #666666">=</span> TimeSeries(mpi_comm_world(), <span style="color: #BA2121">&#39;ns/pressure&#39;</span>)

<span style="color: #408080; font-style: italic"># Save mesh to file for later</span>
File(<span style="color: #BA2121">&#39;cylinder.xml.gz&#39;</span>) <span style="color: #666666">&lt;&lt;</span> mesh

<span style="color: #408080; font-style: italic"># Create progress bar</span>
progress <span style="color: #666666">=</span> Progress(<span style="color: #BA2121">&#39;Time-stepping&#39;</span>)
set_log_level(PROGRESS)

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Step 1: Tentative velocity step</span>
    b1 <span style="color: #666666">=</span> assemble(L1)
    [bc<span style="color: #666666">.</span>apply(b1) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcu]
    solve(A1, u_<span style="color: #666666">.</span>vector(), b1, <span style="color: #BA2121">&#39;bicgstab&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)

    <span style="color: #408080; font-style: italic"># Step 2: Pressure correction step</span>
    b2 <span style="color: #666666">=</span> assemble(L2)
    [bc<span style="color: #666666">.</span>apply(b2) <span style="color: #008000; font-weight: bold">for</span> bc <span style="color: #AA22FF; font-weight: bold">in</span> bcp]
    solve(A2, p_<span style="color: #666666">.</span>vector(), b2, <span style="color: #BA2121">&#39;bicgstab&#39;</span>, <span style="color: #BA2121">&#39;ilu&#39;</span>)

    <span style="color: #408080; font-style: italic"># Step 3: Velocity correction step</span>
    b3 <span style="color: #666666">=</span> assemble(L3)
    solve(A3, u_<span style="color: #666666">.</span>vector(), b3, <span style="color: #BA2121">&#39;bicgstab&#39;</span>)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    plot(u_, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Velocity&#39;</span>)
    plot(p_, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Pressure&#39;</span>)

    <span style="color: #408080; font-style: italic"># Save solution to file</span>
    vtkfile_u <span style="color: #666666">&lt;&lt;</span> (u_, t)
    vtkfile_p <span style="color: #666666">&lt;&lt;</span> (p_, t)

    <span style="color: #408080; font-style: italic"># Save solution to file (HDF5)</span>
    timeseries_u<span style="color: #666666">.</span>store(u_<span style="color: #666666">.</span>vector(), t)
    timeseries_p<span style="color: #666666">.</span>store(p_<span style="color: #666666">.</span>vector(), t)

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_n<span style="color: #666666">.</span>assign(u_)
    p_n<span style="color: #666666">.</span>assign(p_)

    <span style="color: #408080; font-style: italic"># Update progress bar</span>
    progress<span style="color: #666666">.</span>update(t <span style="color: #666666">/</span> T)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u max:&#39;</span>, u_<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>array()<span style="color: #666666">.</span>max())

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
<!-- Stand-alone notebook? -->

<h1 id="___sec85" class="anchor">A system of advection&ndash;diffusion&ndash;reaction equations </h1>
<div id="ftut1:reactionsystem"></div>

<p>
The problems we have encountered so far&mdash;with the notable exception
of the Navier&ndash;Stokes equations&mdash;all share a common feature: they all
involve models expressed by a <em>single</em> scalar or vector PDE. In many
situations the model is instead expressed as a system of PDEs,
describing different quantities and with possibly (very) different
physics.  As we saw for the Navier&ndash;Stokes equations, one way to solve
a system of PDEs in FEniCS is to use a splitting method where we solve
one equation at a time and feed the solution from one equation into
the next. However, one of the strengths with FEniCS is the ease by
which one can instead define variational problems that couple several
PDEs into one compound system. In this section, we will look at how to use
FEniCS to write solvers for such systems of coupled PDEs.
The goal is to demonstrate how easy it is to deal with fully implicit,
also known as monolithic, solvers in FEniCS.

<h2 id="___sec86" class="anchor">PDE problem </h2>

<p>
Our model problem is the following system of
advection&ndash;diffusion&ndash;reaction equations:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 28</b>: I replaced \( \beta \) by \( w \) since \( w \) was used everywhere after a page...)</font>
<!-- end inline comment -->


$$
\begin{align}
\tag{3.37}
  \frac{\partial u_1}{\partial t} +
  w \cdot \nabla u_1 - \nabla\cdot(\epsilon\nabla u_1)
    &= f_1 -K u_1 u_2, \\ 
\tag{3.38}
  \frac{\partial u_2}{\partial t} +
  w \cdot \nabla u_2 - \nabla\cdot(\epsilon\nabla u_2)
    &= f_2 -K u_1 u_2, \\ 
\tag{3.39}
  \frac{\partial u_3}{\partial t} +
  w \cdot \nabla u_3 - \nabla\cdot(\epsilon\nabla u_3)
    &= f_3 + K u_1 u_2 - K u_3.
\end{align}
$$

<p>
This system models the chemical reaction between two species \( A \) and
\( B \) in some domain \( \Omega \):

$$
  A + B \rightarrow C.
$$

<p>
We assume that the equation is <em>first-order</em>, meaning that the
reaction rate is proportional to the concentrations \( [A] \) and \( [B] \) of
the two species \( A \) and \( B \):

$$
  \frac{\mathrm{d}}{\mathrm{d}t} [C] = K [A] [B].
$$

We also assume that the formed species \( C \) spontaneously decays with a
rate proportional to the concentration \( [C] \). In the PDE system
<a href="#mjx-eqn-3.37">(3.37)</a>--<a href="#mjx-eqn-3.39">(3.39)</a>,
we use the variables \( u_1 \), \( u_2 \), and \( u_3 \) to denote the
concentrations of the three species:

$$
  u_1 = [A], \quad u_2 = [B], \quad u_3 = [C].
$$

We see that the chemical reactions are accounted for in the
right-hand sides of the PDE system <a href="#mjx-eqn-3.37">(3.37)</a>--<a href="#mjx-eqn-3.39">(3.39)</a>.

<p>
The chemical reactions take part at each point in the domain
\( \Omega \). In addition, we assume that the species \( A \), \( B \), and \( C \)
diffuse throughout the domain with diffusivity \( \epsilon \) (the terms
\( -\nabla\cdot(\epsilon\nabla u_i) \)) and are advected with velocity
\( w \) (terms like \( w\cdot\nabla u_i \)).

<p>
To make things visually and physically interesting, we shall let the
chemical reaction take place in the velocity field computed from the
solution of the incompressible Navier&ndash;Stokes equations around a
cylinder from the previous section.  In summary, we will thus be
solving the following coupled system of nonlinear PDEs:

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 29</b>: I used full time derivatives, not the dot notation, of two reasons: 1) it is used elsewhere in the tutorial, and 2) it is not used much in continuum mechanics systems unless time is the only variable. It is not much used in the PDE world either compared to the full notation, so for the reader to feel more at home, I suggest to use to most familiar notation.)</font>
<!-- end inline comment -->


$$
\begin{align}
\tag{3.40}
  \varrho(\frac{\partial w}{\partial t} +
  w \cdot \nabla w) &= \nabla\cdot\sigma(w, p) + f, \\ 
  \nabla \cdot u &= 0, 
\tag{3.41}\\ 
  \frac{\partial u_1}{\partial t} +
  w \cdot \nabla u_1 - \nabla\cdot(\epsilon\nabla u_1)
    &= f_1 - K u_1 u_2, 
\tag{3.42}\\ 
  \frac{\partial u_2}{\partial t} +
  w \cdot \nabla u_2 - \nabla\cdot(\epsilon\nabla u_2)
    &= f_2 - K u_1 u_2, 
\tag{3.43}\\ 
  \frac{partial u_3}{\partial t} +
  w \cdot \nabla u_3 - \nabla\cdot(\epsilon\nabla u_3)
    &= f_3 + K u_1 u_2 - K u_3.
\tag{3.44}
\end{align}
$$

We assume that \( u_1 = u_2 = u_3 = 0 \) at \( t = 0 \) and inject the species
\( A \) and \( B \) into the system by specifying nonzero source terms \( f_1 \)
and \( f_2 \) close to the corners at the inflow, and take \( f_3 = 0 \). The
result will be that \( A \) and \( B \) are convected by advection and
diffusion throughout the channel, and when they mix the species \( C \)
will be formed.

<p>
Since the system is one-way coupled from the Navier&ndash;Stokes subsystem
to the advection&ndash;diffusion&ndash;reaction subsystem, we do not need to
recompute the solution to the Navier&ndash;Stokes equations, but can just
read back the previously computed velocity field \( w \) and feed it into
our equations. But we <em>do</em> need to learn how to read and write
solutions from time-dependent PDE problems.

<h2 id="___sec87" class="anchor">Variational formulation </h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 30</b>: Variational formulation of systems of PDEs is not well explained in the literature. Different methods are used, while in FEniCS it is best to think of a scalar/inner product of the vector PDE and a vector trial function. Also, we need to do the time discretization. Here it is relatively easy to use the \( \theta \) rule, but one must be very consistent to evaluate each term at \( t_{n+\theta} \). This is difficult for the reader, I think, and it is explained in detail later in the chapter on the heat equation, so I suggest using just the Backward Euler method for maximum simplicity and emphasis on the programming here. A full \( \theta \) rule increases the cognitive load without giving much stronger tools at hand &ndash; and \( \theta=1 \) was used anyway in the program...)</font>
<!-- end inline comment -->

<p>
We obtain the variational formulation of our system by multiplying
each equation by a test function, integrating the second-order terms
\( -\nabla\cdot(\epsilon\nabla u_i) \) by parts, and summing up the
equations. When working with FEniCS it is convenient to think of the
PDE system as a vector of equations. The test functions are collected in
a vector too, and the variational formulation is the inner product of
the vector PDE and the vector trial function.

<p>
We also need introduce some discretization in time. The simplest idea is
to use a finite difference that goes backward in time:

$$ \frac{\partial}{\partial t} u_1(x,t_{n+1}) \approx
\frac{u_1(x,t_{n+1}-u(x,t_n}{\Delta t},$$

where \( \Delta t =t_{n+1}-t_n \) is the time step. Assuming quantities at time
level \( n \) to be known, we are left with \( u_1(x,t_{n+1}) \) as unknown function
to be computed. To fully understand this reasoning, the reader needs some
basic knowledge about finite differences.

<p>
Let \( v_1 \), \( v_2 \), and \( v_3 \) be the test functions, or the components of
the trial vector function. The inner product results in

$$
\begin{align}
\tag{3.45}
  & \int_{\Omega}
  (\dt^{-1} (u_1^{n+1} - u_1^n) v_1 + w \cdot \nabla u^{n+1}_1 \, v_1
  + \epsilon \nabla u^{n+1}_1 \cdot \nabla v_1) \dx \\ 
  + & \int_{\Omega} (\dt^{-1} (u_2^{n+1} - u_2^n) v_2
  + w \cdot \nabla u^{n+1}_2 \, v_2
  + \epsilon \nabla u^{n+1}_2 \cdot \nabla v_2) \dx 
\tag{3.46}\\ 
  + & \int_{\Omega} \dt^{-1} (u_3^{n+1} - u_3^n) (v_3
  + w \cdot \nabla u^{n+1}_3 \, v_3
  + \epsilon \nabla u^{n+1}_3 \cdot \nabla v_3) \dx 
\tag{3.47}\\ 
  & \quad + \int_{\Omega} (f_1 v_1 + f_2 v_2 + f_3 v_3) \dx 
\tag{3.48}\\ 
  & \quad + \int_{\Omega} (K u^{n+1}_1 u^{n+1}_2 v_1 + K u^{n+1}_1 u^{n+1}_2 v_2
  - K u^{n+1}_1 u^{n+1}_2 v_3 + K u^{n+1}_3 v_3) \dx = 0.
\tag{3.49}
\end{align}
$$

For this problem it is natural to assume homogeneous Neumann boundary
conditions on the entire boundary for \( u_1 \), \( u_2 \), and \( u_3 \); that
is, \( \partial u_i/\partial n = 0 \) for \( i = 1, 2, 3 \). This means that
the boundary terms vanish when we integrate by parts.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 31</b>: Old comment, but expains why I simplified. If you use \( \theta=1 \) anyway, I would simplify already here. The problem is that you need to consistently evaluate the other terms (including the reaction and \( w \) terms) also at the weighted time point \( \theta t_n + (1-\theta)t_{n+1} \), and besides giving very long formulas, this brings up some nontrivial FEniCS issues that I now deal with in detail in the time-dependent solver chapter in volume II &ndash; in a simpler context.  It is very easy to make mistakes here as the code works and converges, but Crank-Nicolson/midpoint method does not give increased convergence rate. It may work here as you have a stationary velocity field etc., but the \( \theta \) rule is a tricky thing that when generalized from this example easily goes wrong, unless we really emphasize the \( \theta \) weighting of all terms. The example is complicated enough for the FEniCS beginnner...)</font>
<!-- end inline comment -->

<h2 id="___sec88" class="anchor">A simple FEniCS implementation </h2>

<p>
The first step is to read the mesh from file. Luckily, we made sure to
save the mesh to file in the Navier&ndash;Stokes example and can now easily
read it back from file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> Mesh(<span style="color: #BA2121">&#39;channel.xml.gz&#39;</span>)
</pre></div>
<p>
The mesh is stored in the native FEniCS XML format (with additional
gzipping to decrease the file size).

<p>
Next, we need to define the finite element function space. For this
problem, we need to define several spaces. The first space we create
is the space for the velocity field \( w \) from the Navier&ndash;Stokes
simulation. We call this space \( W \) and define the space by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>W <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
It is important that this space is exactly the same as the space we
used for the velocity field in the Navier&ndash;Stokes solver. To read the
values for the velocity field, we use a <code>TimeSeries</code>

<p>

<!-- begin inline comment -->
<font color="red">(<b>AL 32</b>: Check if we can remove <code>mpi_comm_world</code>)</font>
<!-- end inline comment -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>timeseries_w <span style="color: #666666">=</span> TimeSeries(mpi_comm_world(), <span style="color: #BA2121">&#39;navier_stokes/velocity&#39;</span>)
</pre></div>
<p>
This will initialize the object <code>timeseries_w</code> which we will call
later in the time-stepping loop to retrieve values from the
file <code>velocity.h5</code> (in binary HDF5 format).

<p>
For the three concentrations \( u_1 \), \( u_2 \), and \( u_3 \), we want to
create a <em>mixed space</em> with functions that represent the full system
\( (u_1, u_2, u_3) \) as a single entity. To do this, we need to define a
<code>MixedElement</code> as the product space of three simple finite elements
and then used the mixed element to define the function space:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>P1 <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #BA2121">&#39;triangle&#39;</span>, <span style="color: #666666">1</span>)
element <span style="color: #666666">=</span> MixedElement([P1, P1, P1])
V <span style="color: #666666">=</span> FunctionSpace(mesh, element)
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Mixed elements as products of elements.</b>
FEniCS also allows finite elements to be defined as products of simple
elements (or mixed elements). For example, the well-known Taylor&ndash;Hood
element, with quadratic velocity components and linear pressure functions,
may be defined as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>P2 <span style="color: #666666">=</span> VectorElement(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #BA2121">&#39;triangle&#39;</span>, <span style="color: #666666">2</span>)
P1 <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #BA2121">&#39;triangle&#39;</span>, <span style="color: #666666">1</span>)
TH <span style="color: #666666">=</span> P2 <span style="color: #666666">*</span> P1
</pre></div>
<p>
This syntax works great for two elements, but for three or more
elements we meet a subtle issue of how the Python interpreter handles
the <code>*</code> operator. For the reaction system, we create the mixed element
by <code>element = MixedElement([P1, P1, P1])</code> and one would be tempted to
write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>element <span style="color: #666666">=</span> P1 <span style="color: #666666">*</span> P1 <span style="color: #666666">*</span> P1
</pre></div>
<p>
However, this is equivalent to writing <code>element = (P1 * P1) * P1</code> so
the result will be a mixed element consisting of two subsystems, the
first of which in turn consists of two scalar subsystems.

<p>
Finally, we remark that for the simple case of a mixed system
consisting of three scalar elements as for the reaction system, the
definition is in fact equivalent to using a standard vector-valued
element:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>element <span style="color: #666666">=</span> VectorElement(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #BA2121">&#39;triangle&#39;</span>, <span style="color: #666666">1</span>, dim<span style="color: #666666">=3</span>)
V <span style="color: #666666">=</span> FunctionSpace(mesh, element)
</pre></div>
<p>
or we can even write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>V <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>, dim<span style="color: #666666">=3</span>)
</pre></div>
<p>
if that is found simpler.
</div>


<p>
Once the space has been created, we need to define our test functions
and finite element functions. Test functions for a mixed function
space can be created by replacing <code>TestFunction</code> by <code>TestFunctions</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>v_1, v_2, v_3 <span style="color: #666666">=</span> TestFunctions(V)
</pre></div>
<p>
Since the problem is nonlinear, we need to work with functions rather
than trial functions for the unknowns. This can be done by using the
corresponding <code>Functions</code> construction in FEniCS. However, as we will
need to access the <code>Function</code> for the entire system itself, we first
need to create that function and then access its components:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> Function(V)
u_1, u_2, u_3 <span style="color: #666666">=</span> split(u)
</pre></div>
<p>
These functions will be used to represent the unknowns \( u_1 \), \( u_2 \), and \( u_3 \)
and the new time level \( n+1 \). The corresponding values at the previous
time level \( n \) are denoted by <code>u_n1</code>, <code>u_n2</code>, and <code>u_n3</code> in our program.
(Any value
in between may be obtained by interpolation, for instance by a weight
\( \theta \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>U_1 <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> Constant(theta))<span style="color: #666666">*</span>u_n1 <span style="color: #666666">+</span> Constant(theta)<span style="color: #666666">*</span>u_1
</pre></div>
<p>
with similar expressions for the other components. We shall use a
simple Backward Euler scheme in time in this computational example and
hence only make use of <code>u_1</code> in the variational formulation. For a
potentially more accurate centered finite difference scheme, however, we could
make use of <code>U_1</code> and \( \theta=\frac{1}{2} \).)

<p>
When now all functions and test functions have been defined, we can
express the nonlinear variational problem
<a href="#mjx-eqn-3.45">(3.45)</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>F <span style="color: #666666">=</span> ((u_1 <span style="color: #666666">-</span> u_p1) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(u_1))<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(u_1), grad(v_1))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>u_1<span style="color: #666666">*</span>u_2<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx  \ 
  <span style="color: #666666">+</span> ((u_2 <span style="color: #666666">-</span> u_p2) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(u_2))<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(u_2), grad(v_2))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>u_1<span style="color: #666666">*</span>u_2<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx  \ 
  <span style="color: #666666">+</span> ((u_3 <span style="color: #666666">-</span> u_p3) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(u_3))<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(u_3), grad(v_3))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> K<span style="color: #666666">*</span>u_1<span style="color: #666666">*</span>u_2<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>u_3<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">-</span> f_1<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f_2<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f_3<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx
</pre></div>
<p>
The time-stepping simply consists of solving this variational problem
in each time step by a call to the <code>solve</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):
    t <span style="color: #666666">+=</span> dt
    timeseries_w<span style="color: #666666">.</span>retrieve(w<span style="color: #666666">.</span>vector(), t <span style="color: #666666">-</span> (<span style="color: #666666">1.0</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>dt)
    solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u)
    u_p<span style="color: #666666">.</span>assign(u)
</pre></div>
<p>
In each time step, we first read the current value for the velocity
field from the time series we have previously stored. We then solve
the nonlinear system, and assign the computed values to the left-hand
side values for the next time interval.

<p>
The solution at the final time is shown in Figure
<a href="#ftut1:fig:reactionsystem:solution">13</a>. We
clearly see the advection of the species \( A \) and \( B \) and the formation
of \( C \) along the center of the channel where \( A \) and \( B \) meet.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:reactionsystem:solution"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  Plot of the concentrations of the three species \( A \), \( B \), and \( C \) (from top to bottom) at final time.  <!-- caption label: ftut1:fig:reactionsystem:solution --> </p></center>
<p><img src="fig/reaction_system.png" align="bottom" width=600></p>
</center>

<p>
The complete code is presented below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

T <span style="color: #666666">=</span> <span style="color: #666666">5.0</span>            <span style="color: #408080; font-style: italic"># final time</span>
num_steps <span style="color: #666666">=</span> <span style="color: #666666">500</span>    <span style="color: #408080; font-style: italic"># number of time steps</span>
dt <span style="color: #666666">=</span> T <span style="color: #666666">/</span> num_steps <span style="color: #408080; font-style: italic"># time step size</span>
eps <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>         <span style="color: #408080; font-style: italic"># diffusion coefficient</span>
K <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>           <span style="color: #408080; font-style: italic"># reaction rate</span>
theta <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>        <span style="color: #408080; font-style: italic"># implicitness parameter for time-stepping</span>

<span style="color: #408080; font-style: italic"># Read mesh from file</span>
mesh <span style="color: #666666">=</span> Mesh(<span style="color: #BA2121">&#39;channel.xml.gz&#39;</span>)

<span style="color: #408080; font-style: italic"># Define function space for velocity</span>
W <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)

<span style="color: #408080; font-style: italic"># Define function space for system of concentrations</span>
P1 <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #BA2121">&#39;triangle&#39;</span>, <span style="color: #666666">1</span>)
element <span style="color: #666666">=</span> MixedElement([P1, P1, P1])
V <span style="color: #666666">=</span> FunctionSpace(mesh, element)

<span style="color: #408080; font-style: italic"># Define test functions</span>
v_1, v_2, v_3 <span style="color: #666666">=</span> TestFunctions(V)

<span style="color: #408080; font-style: italic"># Define functions for velocity and concentrations</span>
w <span style="color: #666666">=</span> Function(W)
u <span style="color: #666666">=</span> Function(V)
u_p <span style="color: #666666">=</span> Function(V)

<span style="color: #408080; font-style: italic"># Split system functions to access components</span>
u_1, u_2, u_3 <span style="color: #666666">=</span> split(u)
u_p1, u_p2, u_p3 <span style="color: #666666">=</span> split(u_p)

<span style="color: #408080; font-style: italic"># Define source terms</span>
f_1 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;pow(x[0]-0.1,2)+pow(x[1]-0.1,2)&lt;0.05*0.05 ? 0.1 : 0&#39;</span>,
                 degree<span style="color: #666666">=1</span>)
f_2 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;pow(x[0]-0.1,2)+pow(x[1]-0.3,2)&lt;0.05*0.05 ? 0.1 : 0&#39;</span>,
                 degree<span style="color: #666666">=1</span>)
f_3 <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)

<span style="color: #408080; font-style: italic"># Define expressions used in variational forms</span>
U_1 <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> Constant(theta))<span style="color: #666666">*</span>u_p1 <span style="color: #666666">+</span> Constant(theta)<span style="color: #666666">*</span>u_1
U_2 <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> Constant(theta))<span style="color: #666666">*</span>u_p2 <span style="color: #666666">+</span> Constant(theta)<span style="color: #666666">*</span>u_2
U_3 <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> Constant(theta))<span style="color: #666666">*</span>u_p3 <span style="color: #666666">+</span> Constant(theta)<span style="color: #666666">*</span>u_3
k <span style="color: #666666">=</span> Constant(dt)
K <span style="color: #666666">=</span> Constant(K)
eps <span style="color: #666666">=</span> Constant(eps)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
F <span style="color: #666666">=</span> ((u_1 <span style="color: #666666">-</span> u_p1) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(U_1))<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(U_1), grad(v_1))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>U_1<span style="color: #666666">*</span>U_2<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx  \ 
  <span style="color: #666666">+</span> ((u_2 <span style="color: #666666">-</span> u_p2) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(U_2))<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(U_2), grad(v_2))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>U_1<span style="color: #666666">*</span>U_2<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx  \ 
  <span style="color: #666666">+</span> ((u_3 <span style="color: #666666">-</span> u_p3) <span style="color: #666666">/</span> k)<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> dot(w, grad(U_3))<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">+</span> eps<span style="color: #666666">*</span>dot(grad(U_3), grad(v_3))<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> K<span style="color: #666666">*</span>U_1<span style="color: #666666">*</span>U_2<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> K<span style="color: #666666">*</span>U_3<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx \ 
  <span style="color: #666666">-</span> f_1<span style="color: #666666">*</span>v_1<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f_2<span style="color: #666666">*</span>v_2<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> f_3<span style="color: #666666">*</span>v_3<span style="color: #666666">*</span>dx

<span style="color: #408080; font-style: italic"># Create time series for reading velocity data</span>
timeseries_w <span style="color: #666666">=</span> TimeSeries(mpi_comm_world(), <span style="color: #BA2121">&#39;ns/velocity&#39;</span>)

<span style="color: #408080; font-style: italic"># FIXME: mpi_comm_world should not be needed here, fix in FEniCS!</span>

<span style="color: #408080; font-style: italic"># Create VTK files for visualization output</span>
vtkfile_u_1 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;reaction_system/u_1.pvd&#39;</span>)
vtkfile_u_2 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;reaction_system/u_2.pvd&#39;</span>)
vtkfile_u_3 <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;reaction_system/u_3.pvd&#39;</span>)

<span style="color: #408080; font-style: italic"># Create progress bar</span>
progress <span style="color: #666666">=</span> Progress(<span style="color: #BA2121">&#39;Time-stepping&#39;</span>)
set_log_level(PROGRESS)

<span style="color: #408080; font-style: italic"># Time-stepping</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(num_steps):

    <span style="color: #408080; font-style: italic"># Update current time</span>
    t <span style="color: #666666">+=</span> dt

    <span style="color: #408080; font-style: italic"># Read velocity from file</span>
    timeseries_w<span style="color: #666666">.</span>retrieve(w<span style="color: #666666">.</span>vector(), t <span style="color: #666666">-</span> (<span style="color: #666666">1.0</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>dt)

    <span style="color: #408080; font-style: italic"># Solve variational problem for time step</span>
    solve(F <span style="color: #666666">==</span> <span style="color: #666666">0</span>, u)

    <span style="color: #408080; font-style: italic"># Plot solution</span>
    _u_1, _u_2, _u_3 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>split()
    plot(_u_1, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_1&#39;</span>, key<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_1&#39;</span>)
    plot(_u_2, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_2&#39;</span>, key<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_2&#39;</span>)
    plot(_u_3, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_3&#39;</span>, key<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u_3&#39;</span>)

    <span style="color: #408080; font-style: italic"># Save solution to file (VTK)</span>
    vtkfile_u_1 <span style="color: #666666">&lt;&lt;</span> _u_1
    vtkfile_u_2 <span style="color: #666666">&lt;&lt;</span> _u_2
    vtkfile_u_3 <span style="color: #666666">&lt;&lt;</span> _u_3

    <span style="color: #408080; font-style: italic"># Update previous solution</span>
    u_p<span style="color: #666666">.</span>assign(u)

    <span style="color: #408080; font-style: italic"># Update progress bar</span>
    progress<span style="color: #666666">.</span>update(t <span style="color: #666666">/</span> T)

<span style="color: #408080; font-style: italic"># Hold plot</span>
interactive()
</pre></div>
<p>
Finally, we comment on three important techniques that are very useful
when working with systems of PDEs: setting initial conditions, setting
boundary conditions, and extracting components of the system for
plotting or postprocessing.

<h2 id="___sec89" class="anchor">Setting initial conditions for mixed systems </h2>

<p>
In our example, we did not need to worry about setting an initial
condition, since we start with \( u_1 = u_2 = u_3 = 0 \). This happens
automatically in the code when we set <code>u_p = Function(V)</code>. This
creates a <code>Function</code> for the whole system and all degrees of freedom
are set to zero.

<p>
If we wanted to set initial conditions for the components of the
system separately, the easiest solution is to define the initial
conditions as a vector-valued <code>Expression</code> and then
project this to the <code>Function</code> representing the whole system. For
example,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_0 <span style="color: #666666">=</span> Expression((<span style="color: #BA2121">&#39;sin(x[0])&#39;</span>, <span style="color: #BA2121">&#39;cos(x[0]*x[1])&#39;</span>, <span style="color: #BA2121">&#39;exp(x[1])&#39;</span>), degree<span style="color: #666666">=1</span>)
u_p <span style="color: #666666">=</span> project(u_0, V)
</pre></div>
<p>
This defines \( u_1 \), \( u_2 \), and \( u_2 \) to be the projections of \( \sin
x \), \( \cos (xy) \), and \( \exp(y) \), respectively.

<h2 id="___sec90" class="anchor">Setting boundary conditions for mixed systems </h2>

<p>
In our example, we also did not need to worry about setting boundary
conditions since we used a natural Neumann condition. If we want to set
Dirichlet conditions for individual components of the system, this can
be done as usual by the class <code>DirichletBC</code>, but we must specify for
which subsystem we set the boundary condition. For example, to specify
that \( u_2 \) should be equal to \( xy \) on the boundary defined by
<code>boundary</code>, we do

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_b = Expression(&#39;x[0]*x[1]&#39;, degree=1)
bc = DirichletBC(V.sub(1), u_b, boundary)
</pre></div>
<p>
The object <code>bc</code> or a list of such objects containing different
boundary conditions, can then be passed to the <code>solve</code> function as usual.
Note that numbering starts at \( 0 \) in FEniCS so the subspace
corresponding to \( u_2 \) is <code>V.sub(1)</code>.

<h2 id="___sec91" class="anchor">Accessing components of mixed systems </h2>

<p>
If <code>u</code> is a <code>Function</code> defined on a mixed function space in FEniCS,
there are several ways in which <code>u</code> can be <em>split</em> into components.
Above we already saw an example of the first of these:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_1, u_2, u_3 <span style="color: #666666">=</span> split(u)
</pre></div>
<p>
This extracts the components of <code>u</code> as <em>symbols</em> that can be used in a
variational problem. The above statement is in fact equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_1 <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>]
u_2 <span style="color: #666666">=</span> u[<span style="color: #666666">1</span>]
u_3 <span style="color: #666666">=</span> u[<span style="color: #666666">2</span>]
</pre></div>
<p>
Note that <code>u[0]</code> is not really a <code>Function</code> object, but merely a
symbolic expression, just like <code>grad(u)</code> in FEniCS is a symbolic
expression and not a <code>Function</code> representing the gradient.  This means
that <code>u_1</code>, <code>u_2</code>, <code>u_3</code> can be used in a variational problem, but
cannot be used for plotting or postprocessing.

<p>
To access the components of <code>u</code> for plotting and saving the solution
to file, we need to use a different variant of the <code>split</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>_u_1, _u_2, _u_3 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>split()
</pre></div>
<p>
This returns three subfunctions as actual objects with access to the
common underlying data stored in <code>u</code>, which makes plotting and saving
to file possible. Alternatively, we can do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>_u_1, _u_2, _u_3 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>split(deepcopy<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
which will create <code>_u_1</code>, <code>_u_2</code>, and <code>u_3</code> as stand-alone <code>Function</code>
objects, each holding a copy of the subfunction data extracted from
<code>u</code>. This is useful in many situations but is not necessary for
plotting and saving solutions to file.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1007.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="._ftut1001.html">2</a></li>
  <li><a href="._ftut1002.html">3</a></li>
  <li><a href="._ftut1003.html">4</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li class="active"><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li><a href="._ftut1010.html">11</a></li>
  <li><a href="._ftut1011.html">12</a></li>
  <li><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1009.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

