<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Visualization</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Postprocessing computations" href="._ftut007.html" />
    <link rel="prev" title="Useful extensions" href="._ftut005.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut005.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut007.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="visualization">
<h1>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h1>
<p>Perhaps you are not particularly amazed by viewing the simple surface
of <span class="math">\(u\)</span> in the test problem used in the previous sections.  However,
solving a real physical problem with a more interesting and amazing
solution on the screen is only a matter of specifying a more exciting
domain, boundary condition, and/or right-hand side <span class="math">\(f\)</span>.  The present
chapter starts with the solver for a membrane deflection, where the
geometry is a circle instead of the unit square, and where the
involved functions have more exciting shapes. We then go on with
explaining how the membrane deflection and the pressure load can be
visualized, using both the built-in FEniCS visualization tool and the
powerful application Paraview. Finally, we return to box-shaped
domains with uniform partition and show how the unstructured data in
FEniCS finite element solvers can be transformed to structured mesh
representations like those commonly used for finite difference
methods. The structured mesh representation, whenever possible,
gives greater flexibility
with respect to visualization and data analysis.</p>
<div class="section" id="deflection-of-a-circular-membrane">
<span id="tut-poisson-membrane"></span><h2>Deflection of a circular membrane<a class="headerlink" href="#deflection-of-a-circular-membrane" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-problem">
<h3>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h3>
<p>One possible physical problem regards the deflection <span class="math">\(D(x,y)\)</span> of an
elastic circular membrane with radius <span class="math">\(R\)</span>, subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is</p>
<div class="math" id="eq-auto13">
\[\tag{25}
-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},\]</div>
<p>with</p>
<div class="math" id="eq-auto14">
\[\tag{26}
p(x,y) = {A\over 2\pi\sigma}\exp{\left(
    - {1\over2}\left( {x-x_0\over\sigma}\right)^2
    - {1\over2}\left( {y-y_0\over\sigma}\right)^2
    \right)}\, .\]</div>
<p>Here, <span class="math">\(T\)</span> is the tension in the membrane (constant), <span class="math">\(p\)</span> is the external
pressure load,
<span class="math">\(A\)</span> the amplitude of the pressure, <span class="math">\((x_0,y_0)\)</span> the localization of
the Gaussian pressure function, and <span class="math">\(\sigma\)</span> the &#8220;width&#8221; of this
function. The boundary of the membrane has no
deflection, implying <span class="math">\(D=0\)</span> as boundary condition.</p>
</div>
<div class="section" id="scaling">
<h3>Scaling<a class="headerlink" href="#scaling" title="Permalink to this headline">¶</a></h3>
<p>The localization of the pressure, <span class="math">\((x_0,y_0)\)</span>, is for simplicity
set to <span class="math">\((0, R_0)\)</span>.
There are many physical parameters in this problem, and we can benefit
from grouping them by means of scaling. Let us introduce dimensionless
coordinates <span class="math">\(\bar x = x/R\)</span>, <span class="math">\(\bar y = y/R\)</span>, and a dimensionless
deflection <span class="math">\(w=D/D_c\)</span>, where <span class="math">\(D_c\)</span> is a characteristic size of the
deflection. Introducing <span class="math">\(\bar R_0=R_0/R\)</span>, we get</p>
<div class="math">
\[\begin{split}\frac{\partial^2 w}{\partial\bar x^2} +
\frac{\partial^2 w}{\partial\bar y^2}= \alpha
\exp{\left(
- \beta^2(\bar x^2
+ (\bar y-\bar R_0)^2)\right)}\hbox{ for } \bar x^2 + \bar y^2 &lt; 1,\end{split}\]</div>
<p>where</p>
<div class="math">
\[\alpha = \frac{R^2A}{2\pi T D_c\sigma},\quad\beta = \frac{R}{\sqrt{2}\sigma}{\thinspace .}\]</div>
<p>With an appropriate scaling, <span class="math">\(\bar w\)</span> and its derivatives are of size
unity, so the left-hand side of the scaled PDE is about unity in size,
while the right-hand side has <span class="math">\(\alpha\)</span> as its characteristic size.
This suggest choosing <span class="math">\(\alpha\)</span> to be unity, or around unit.
We shall in particular choose <span class="math">\(\alpha=4\)</span>. With this value,
the solution is <span class="math">\(w(\bar x,\bar y) = 1-\bar x^2 - \bar y^2\)</span>.
(One can also find the analytical solution in scaled coordinates and show
that the maximum deflection <span class="math">\(D(0,0)\)</span> is <span class="math">\(D_c\)</span> if we choose <span class="math">\(\alpha=4\)</span>
to determine <span class="math">\(D_c\)</span>.)
With <span class="math">\(D_c=AR^2/(8\pi\sigma T)\)</span>
and dropping the bars we get the scaled problem</p>
<div class="math" id="eq-tut-poisson1-membrane-scaled-eq">
\[\tag{27}
\nabla^2w = 4\exp{\left(
    - \beta^2(x^2
    + (y-R_0)^2)\right)},\]</div>
<p>to be solved over the unit circle with <span class="math">\(w=0\)</span> on the boundary.
Now there are only two parameters to vary: the dimensionless extent
of the pressure, <span class="math">\(\beta\)</span>, and the localization of the pressure peak, <span class="math">\(R_0\in [0,1]\)</span>.
As <span class="math">\(\beta\rightarrow 0\)</span>, we
have a special case with solution <span class="math">\(w=1-x^2-y^2\)</span>.</p>
<p>Given a computed <span class="math">\(w\)</span>, the physical deflection is given by</p>
<div class="math">
\[D = \frac{AR^2}{8\pi\sigma T}w{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-1">
<h3>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h3>
<p>Very few modifications of the software in
<code class="docutils literal"><span class="pre">p2D_iter.py</span></code> are required. Actually, the <code class="docutils literal"><span class="pre">solver</span></code> function
can be reused, except that the domain is now a circle and not a
square. We change the <code class="docutils literal"><span class="pre">solver</span></code> function by letting the mesh be
an argument <code class="docutils literal"><span class="pre">mesh</span></code> (instead of <code class="docutils literal"><span class="pre">Nx</span></code> and <code class="docutils literal"><span class="pre">Ny</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="o">...</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>A mesh over the unit circle can be created by the <code class="docutils literal"><span class="pre">mshr</span></code> tool in
FEniCS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Circle</span></code> shape from <code class="docutils literal"><span class="pre">mshr</span></code> takes the center and radius of the circle
as the two first arguments, while <code class="docutils literal"><span class="pre">n</span></code> is the resolution, here the
suggested number of cells per radius.</p>
<span class="target" id="index-0"></span><p id="index-1">The right-hand side pressure function
is represented by an <code class="docutils literal"><span class="pre">Expression</span></code> object. There
are two physical parameters in the formula for <span class="math">\(f\)</span> that enter the
expression string and these parameters must have their values set
by keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
    <span class="s">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span><span class="p">,</span>
    <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="n">R0</span><span class="p">)</span>
</pre></div>
</div>
<p>The coordinates in <code class="docutils literal"><span class="pre">Expression</span></code> objects <em>must</em> be a vector
with indices 0, 1, and 2, and with the name <code class="docutils literal"><span class="pre">x</span></code>. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">f</span><span class="o">.</span><span class="n">R0</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p id="index-2">It would be of interest to visualize <span class="math">\(p\)</span> along with <span class="math">\(w\)</span> so that we can
examine the pressure force and the membrane&#8217;s response.  We must then transform
the formula (<code class="docutils literal"><span class="pre">Expression</span></code>) to a finite element function
(<code class="docutils literal"><span class="pre">Function</span></code>).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from <span class="math">\(p\)</span>. That is, we interpolate <span class="math">\(p\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">plot(p)</span></code> will produce a plot of <span class="math">\(p\)</span>. Note that the assignment
to <code class="docutils literal"><span class="pre">p</span></code> destroys the previous <code class="docutils literal"><span class="pre">Expression</span></code> object <code class="docutils literal"><span class="pre">p</span></code>, so if
it is of interest to still have access to this object, another name must be used
for the <code class="docutils literal"><span class="pre">Function</span></code> object returned by <code class="docutils literal"><span class="pre">interpolate</span></code>.</p>
<p>We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case <span class="math">\(\beta =0\)</span>.</p>
<p>The final program is found in the file <code class="docutils literal"><span class="pre">membrane.py</span></code>, located
in the <code class="docutils literal"><span class="pre">poisson</span></code> directory. The key function to simulate
membrane deflection is named <code class="docutils literal"><span class="pre">application</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u)=f on given mesh with Lagrange elements</span>
<span class="sd">    of specified degree and u=u0 (Expresssion) on the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>


<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">):</span>
    <span class="c"># Scaled pressure function</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="n">R0</span><span class="p">)</span>

    <span class="c"># Generate mesh over the unit circle</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># set name and label (description)</span>

    <span class="c"># Plot scaled solution, mesh and pressure</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
</pre></div>
</div>
<p>Choosing a very peak-formed pressure with large <span class="math">\(\beta\)</span> (e.g., <span class="math">\(\beta
\geq 20\)</span>) and a location <span class="math">\(R_0\)</span> toward the circular boundary (e.g.,
<span class="math">\(R_0=0.5\)</span>), may produce an exciting visual demonstrations of the very
smoothed elastic response to a peak force (or mathematically, the
smoothing properties of the inverse of the Laplace operator).  One
needs to experiment with the mesh resolution to get a smooth visual
representation of <span class="math">\(p\)</span>.  You are strongly encouraged to play around
with the plots and different mesh resolutions:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import membrane as m; m.application()&#39; \
          membrane.py
</pre></div>
</div>
</div>
</div>
<div class="section" id="quick-visualization-with-vtk">
<span id="tut-quickviz"></span><h2>Quick visualization with VTK<a class="headerlink" href="#quick-visualization-with-vtk" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">As we go along with examples it is fun to play around with
<code class="docutils literal"><span class="pre">plot</span></code> commands and visualize what is computed. This section explains
some useful visualization features.</p>
<p>The <code class="docutils literal"><span class="pre">plot</span></code> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.</p>
<p id="index-6">We have made a program <code class="docutils literal"><span class="pre">membrane.py</span></code> for the membrane deflection
problem in the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a> and added various
demonstrations of plotting capabilities. You are encouraged to play around with
<code class="docutils literal"><span class="pre">membrane.py</span></code> and modify the code as you read about various features.</p>
<p id="index-7">The <code class="docutils literal"><span class="pre">plot</span></code> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Finite element mesh&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">wireframe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Axes can be turned on by the <code class="docutils literal"><span class="pre">axes=True</span></code> argument, while
<code class="docutils literal"><span class="pre">interactive=True</span></code> makes the program hang at the plot command - you have
to type <code class="docutils literal"><span class="pre">q</span></code> in the plot window to terminate the plot and continue execution.</p>
<p>The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <code class="docutils literal"><span class="pre">Help</span></code> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,</p>
<blockquote>
<div><ul class="simple">
<li>pressing <code class="docutils literal"><span class="pre">m</span></code> turns visualization of the mesh on and off,</li>
<li>pressing <code class="docutils literal"><span class="pre">b</span></code> turns on and off a bounding box,</li>
<li>pressing <code class="docutils literal"><span class="pre">p</span></code> dumps the plot to a PNG file,</li>
<li>pressing <code class="docutils literal"><span class="pre">P</span></code> dumps the plot to a PDF file,</li>
<li>pressing <cite>Ctrl +&#8217; stretches the surface in the :math:`z</cite> direction,</li>
<li>pressing <cite>Ctrl -&#8216; shrinks++ the surface in the :math:`z</cite> direction,</li>
<li>pressing <a href="#id1"><span class="problematic" id="id2">`</span></a>Ctrl w&#8217; closes the plot window,</li>
<li>pressing <a href="#id3"><span class="problematic" id="id4">`</span></a>Ctrl q&#8217; closes all plot windows.</li>
</ul>
</div></blockquote>
<p>The plots created by pressing <code class="docutils literal"><span class="pre">p</span></code> or <code class="docutils literal"><span class="pre">P</span></code> are stored in files with
names <code class="docutils literal"><span class="pre">dolfin_plot_X.png</span></code> or <code class="docutils literal"><span class="pre">dolfin_plot_X.pdf</span></code>,
where <code class="docutils literal"><span class="pre">X</span></code> is an integer that is increase by one from the last plot
that was made. The file stem <code class="docutils literal"><span class="pre">dolfin_plot_</span></code> can be set to something
more suitable through the <code class="docutils literal"><span class="pre">hardcopy_prefix</span></code> keyword argument to the
<code class="docutils literal"><span class="pre">plot</span></code> function,
for instance, <code class="docutils literal"><span class="pre">plot(f,</span> <span class="pre">hardcopy_prefix='pressure')</span></code>.</p>
<span class="target" id="index-8"></span><p id="index-9">Plots stored in PDF format need to be rotated 90 degrees before
inclusion in documents. This can be done by the <code class="docutils literal"><span class="pre">convert</span> <span class="pre">-rotate</span> <span class="pre">90</span></code>
command (from the ImageMagick utility), but the resulting file has
then no more high-resolution PDF vector graphics. A better solution
is therefore to use <code class="docutils literal"><span class="pre">pdftk</span></code> to preserve the vector graphics:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; pdftk dolfin_plot_1.pdf cat 1-endnorth output out.pdf
</pre></div>
</div>
<p>For making plots in batch, we can do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># adjust (lift) camera from the default view</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>       <span class="c"># bring new settings into action</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># make deflection.png</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># make deflection.pdf</span>
<span class="c"># Rotate pdf file (right) from landscape to portrait</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;pdftk deflection.pdf cat 1-endnorth output w.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The commands above appear in the <code class="docutils literal"><span class="pre">application2</span></code>
function in the <code class="docutils literal"><span class="pre">membrane.py</span></code> file.</p>
<div class="figure" id="id5">
<span id="tut-poisson-2d-fig1"></span><a class="reference internal image-reference" href="_images/membrane_deflection.png"><img alt="_images/membrane_deflection.png" src="_images/membrane_deflection.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the deflection of a membrane</em></span></p>
</div>
</div>
<div class="section" id="paraview">
<h2>Paraview<a class="headerlink" href="#paraview" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="taking-advantage-of-structured-mesh-data">
<span id="tut-structviz"></span><h2>Taking advantage of structured mesh data<a class="headerlink" href="#taking-advantage-of-structured-mesh-data" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.</p>
<p id="index-13">A necessary first step is to transform our <code class="docutils literal"><span class="pre">mesh</span></code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.
The second step is to
transform the one-dimensional array of nodal values to a
two-dimensional array holding the values at the corners of the cells
in the structured mesh. We want to access a value by
its <span class="math">\(i\)</span> and <span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span> direction, and
<span class="math">\(j\)</span> counting cells in the <span class="math">\(y\)</span> direction.  This transformation is in
principle straightforward, yet it frequently leads to obscure indexing
errors, so using software tools to ease the work is advantageous.</p>
<p>In the directory <code class="docutils literal"><span class="pre">src/modules</span></code>, associated with this booklet,
we have included a Python module <code class="docutils literal"><span class="pre">BoxField</span></code> that can take a finite
element function <code class="docutils literal"><span class="pre">u</span></code> computed by a FEniCS software and represent
it on a structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code class="docutils literal"><span class="pre">[i]</span></code> in 1D, <code class="docutils literal"><span class="pre">[i,j]</span></code> in 2D, and
<code class="docutils literal"><span class="pre">[i,j,k]</span></code> in 3D. Given a finite element function <code class="docutils literal"><span class="pre">u</span></code>,
the following function returns a <code class="docutils literal"><span class="pre">BoxField</span></code> object that represents
<code class="docutils literal"><span class="pre">u</span></code> on a structured mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">divisions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span class="c"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
         <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">BoxField</span> <span class="kn">import</span> <span class="n">dolfin_function2BoxField</span>
    <span class="n">u_box</span> <span class="o">=</span> <span class="n">dolfin_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">divisions</span><span class="p">,</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_box</span>
</pre></div>
</div>
<p>Note that we can only turn functions on meshes with P1 elements into
<code class="docutils literal"><span class="pre">BoxField</span></code> objects, so if <code class="docutils literal"><span class="pre">u</span></code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code class="docutils literal"><span class="pre">divisions</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">u_box</span></code> object contains several useful data structures:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u_box.grid</span></code>: object for the structured mesh</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">X=0</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Y=1</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Z=2</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[X]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>
(for vectorized computations or surface plotting)</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Y]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Z]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.values</span></code>: <code class="docutils literal"><span class="pre">numpy</span></code> array holding the <code class="docutils literal"><span class="pre">u</span></code> values;
<code class="docutils literal"><span class="pre">u_box.values[i,j]</span></code> holds <code class="docutils literal"><span class="pre">u</span></code> at the mesh point with coordinates</li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">(u_box.grid.coor[X],</span> <span class="pre">u_box.grid.coor[Y])</span></code></div>
</div>
<div class="section" id="iterating-over-points-and-values">
<h3>Iterating over points and values<a class="headerlink" href="#iterating-over-points-and-values" title="Permalink to this headline">¶</a></h3>
<p>Let us go back to the <code class="docutils literal"><span class="pre">solver</span></code> function in the
<code class="docutils literal"><span class="pre">p2D_vc.py</span></code> code from
the section <a class="reference internal" href="._ftut005.html#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient Poisson problem</span></a>, compute <code class="docutils literal"><span class="pre">u</span></code>, map it onto a
<code class="docutils literal"><span class="pre">BoxField</span></code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span>       <span class="c"># numpy array</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c"># for indexing in x and y direction</span>

<span class="c"># Iterate over 2D mesh points (i,j)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;u_ is defined on a structured mesh with </span><span class="si">%s</span><span class="s"> points&#39;</span> <span class="o">%</span>
      <span class="nb">str</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;u[</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">]=u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
               <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
               <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="finite-difference-approximations">
<h3>Finite difference approximations<a class="headerlink" href="#finite-difference-approximations" title="Permalink to this headline">¶</a></h3>
<p>Note that with <code class="docutils literal"><span class="pre">u_</span></code>, we can easily express finite difference approximation
of derivatives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u_xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="surface-plot">
<span id="index-14"></span><h3>Surface plot<a class="headerlink" href="#surface-plot" title="Permalink to this headline">¶</a></h3>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper left):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span>  <span class="c"># vectorized mesh coordinates</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span>
                <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Surface plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The key issue is to know that the coordinates needed for the surface
plot is in <code class="docutils literal"><span class="pre">u_box.grid.coorv</span></code> and that the values are in <code class="docutils literal"><span class="pre">u_</span></code>.</p>
<div class="figure" id="id6">
<span id="tut-structviz-fig1"></span><a class="reference internal image-reference" href="_images/p2D_vc_structmesh2.png"><img alt="_images/p2D_vc_structmesh2.png" src="_images/p2D_vc_structmesh2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Various plots of the solution on a structured mesh</em></span></p>
</div>
</div>
<div class="section" id="contour-plot">
<span id="index-15"></span><h3>Contour plot<a class="headerlink" href="#contour-plot" title="Permalink to this headline">¶</a></h3>
<p>A contour plot can also be made by Matplotlib:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>  <span class="c"># add labels to contour lines</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Contour plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result appears in Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper right).</p>
</div>
<div class="section" id="curve-plot-through-the-mesh">
<h3>Curve plot through the mesh<a class="headerlink" href="#curve-plot-through-the-mesh" title="Permalink to this headline">¶</a></h3>
<p>A handy feature of <code class="docutils literal"><span class="pre">BoxField</span></code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot <span class="math">\(u\)</span> along
the line <span class="math">\(y=0.4\)</span>. The mesh points, <code class="docutils literal"><span class="pre">x</span></code>, and the <span class="math">\(u\)</span> values
along this line, <code class="docutils literal"><span class="pre">u_val</span></code>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal"><span class="pre">snapped</span></code> is true if the line had to be snapped onto a
gridline and in that case <code class="docutils literal"><span class="pre">y_fixed</span></code> holds the snapped
(altered) <span class="math">\(y\)</span> value. To avoid interpolation in the structured mesh,
<code class="docutils literal"><span class="pre">snapped</span></code> is in fact <em>always</em> true.</p>
<p>A comparison of the numerical and exact solution along the line
<span class="math">\(y=0.5\)</span> (snapped from <span class="math">\(y=0.4\)</span>) is made by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">u_e_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">u0</span><span class="p">((</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">))</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e_val</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (lower left) for the resulting curve plot.</p>
</div>
<div class="section" id="curve-plot-of-the-flux">
<h3>Curve plot of the flux<a class="headerlink" href="#curve-plot-of-the-flux" title="Permalink to this headline">¶</a></h3>
<p>Let us also compare the numerical and
exact flux <span class="math">\(-p\partial u/\partial x\)</span> along the same line as above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_u</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">flux_u_x</span><span class="p">,</span> <span class="n">flux_u_y</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Plot the numerical and exact flux along the same line</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_u_x</span> <span class="k">if</span> <span class="n">flux_u_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> \
          <span class="k">else</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span>
               <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span>
                             <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_u_x_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">flux_u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
<span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
   <span class="n">flux_u_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_x_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">),</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Flux along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The second <code class="docutils literal"><span class="pre">plt.plot</span></code> command
requires a Python function <code class="docutils literal"><span class="pre">flux_u_x_exact(x,y)</span></code> to be
available for the exact flux expression.</p>
<p>Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a class="reference external" href="https://github.com/hplgit/scitools">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.</p>
</div>
<div class="section" id="test-problem-2">
<span id="index-16"></span><h3>Test problem<a class="headerlink" href="#test-problem-2" title="Permalink to this headline">¶</a></h3>
<p>The graphics referred to in Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> correspond to
a test problem with prescribed solution <span class="math">\({u_{\small\mbox{e}}} = H(x)H(y)\)</span>, where</p>
<div class="math">
\[H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x){\thinspace .}\]</div>
<p>We just fit a function <span class="math">\(f(x,y)\)</span> in the PDE (can choose <span class="math">\(p=1\)</span>),
and notice that <span class="math">\(u=0\)</span> along the
boundary of the unit square. Although it is easy to carry out the
differentiation of <span class="math">\(f\)</span> by hand and hardcode the resulting expressions
in an <code class="docutils literal"><span class="pre">Expression</span></code> object, a more reliable habit is to use Python&#8217;s
symbolic computing engine, <code class="docutils literal"><span class="pre">sympy</span></code>, to perform mathematics and
automatically turn formulas into C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects.
The following text assumes some familiarity with <code class="docutils literal"><span class="pre">sympy</span></code> and illustrates
how FEniCS programmers may take advantage of symbolic computing.</p>
<p>We start out with defining the exact solution in <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>  <span class="c"># for use in math formulas</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">H</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0], x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">H</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-define-symbolic-coordinates-as-required-in-expression-objects admonition">
<p class="first admonition-title">Define symbolic coordinates as required in <code class="docutils literal"><span class="pre">Expression</span></code> objects</p>
<p class="last">Note that we would normally write <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x</span> <span class="pre">y')</span></code>, but
if we want the resulting expressions to be have valid syntax for
<code class="docutils literal"><span class="pre">Expression</span></code> objects, and then <span class="math">\(x\)</span> reads <code class="docutils literal"><span class="pre">x[0]</span></code> and <span class="math">\(y\)</span> must be <code class="docutils literal"><span class="pre">x[1]</span></code>.
This is easily accomplished with <code class="docutils literal"><span class="pre">sympy</span></code> by defining the names of <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">x[0]</span></code> and <code class="docutils literal"><span class="pre">x[1]</span></code>: <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x[0]</span> <span class="pre">x[1]')</span></code>.</p>
</div>
<p>Turning the expression for <code class="docutils literal"><span class="pre">u</span></code> into C or C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects
needs two steps. First we ask for the C code of the expression,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we do some editing of <code class="docutils literal"><span class="pre">u_c</span></code> to match the required syntax of
<code class="docutils literal"><span class="pre">Expression</span></code> objects. Printing <code class="docutils literal"><span class="pre">u_c</span></code> gives (here manually broken up as
two lines)</p>
<div class="highlight-text"><div class="highlight"><pre>-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
</div>
<p>The necessary syntax adjustment is replacing
the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> for <span class="math">\(\pi\)</span> in C/C++ by <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_c</span> <span class="o">=</span> <span class="n">u_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;DOLFIN_PI&#39;</span><span class="p">)</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_c</span><span class="p">)</span>
</pre></div>
</div>
<p>Thereafter, we can progress with the computation of <span class="math">\(f = -\nabla\cdot(p\nabla u)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">f_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;DOLFIN_PI&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_c</span><span class="p">)</span>
</pre></div>
</div>
<p>We also need a Python function for the exact flux <span class="math">\(-p\partial u/\partial x\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_u_x_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                              <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It remains to define <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Constant(1)</span></code> and set <code class="docutils literal"><span class="pre">nx</span></code> and <code class="docutils literal"><span class="pre">ny</span></code> before calling
<code class="docutils literal"><span class="pre">solver</span></code> to compute the finite element solution of this problem.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>