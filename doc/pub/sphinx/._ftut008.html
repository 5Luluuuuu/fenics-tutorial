<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A General \(d\)-Dimensional multi-material test problem</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="More Examples" href="._ftut009.html" />
    <link rel="prev" title="Handling domains with different materials" href="._ftut007.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut007.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut009.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-general-dimensional-multi-material-test-problem">
<span id="tut-possion-nd-nmat"></span><h1>A General <span class="math">\(d\)</span>-Dimensional multi-material test problem<a class="headerlink" href="#a-general-dimensional-multi-material-test-problem" title="Permalink to this headline">¶</a></h1>
<p><strong>This section is in a preliminary state!</strong></p>
<p>The purpose of the present section is to generalize the basic
ideas from the previous section to a problem involving
an arbitrary number of materials in 1D, 2D, or 3D domains.
The example also highlights how to build more general and flexible
FEniCS applications.</p>
<p>More to be done:</p>
<blockquote>
<div><ul class="simple">
<li>Batch compilation of subdomains, see mailinglist.txt, lots of
useful stuff in Hake&#8217;s example with &#8220;pointwise&#8221;, see what the
bcs are etc.</li>
<li>Use of <code class="docutils literal"><span class="pre">near</span></code> or similar function (better: user-adjusted tolerance)</li>
</ul>
</div></blockquote>
<div class="section" id="the-pde-problem">
<span id="tut-possion-nd-nmat-pde"></span><h2>The PDE problem<a class="headerlink" href="#the-pde-problem" title="Permalink to this headline">¶</a></h2>
<p>We generalize the problem in the section <a class="reference internal" href="._ftut007.html#tut-possion-2d-2mat-problem"><span class="std std-ref">Working with two subdomains</span></a>
to the case where there are <span class="math">\(s\)</span> materials <span class="math">\(\Omega_0,\ldots,\Omega_{s-1}\)</span>,
with associated constant <span class="math">\(k\)</span> values <span class="math">\(k_0,k_1,\ldots,k_{s-1}\)</span>,
as illustrated in Figure <a class="reference internal" href="#tut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a>.</p>
<div class="figure" id="id1">
<span id="tut-possion-nd-nmat-fig1"></span><a class="reference internal image-reference" href="_images/layers.sh"><img alt="_images/layers.sh" src="_images/layers.sh" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a multi-material problem</em></span></p>
</div>
<p>Although the sketch of the domain is in two dimensions, we can easily
define this problem in any number of dimensions, using
the ideas of the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>, but the layer
boundaries are planes <span class="math">\(x_0=\hbox{const}\)</span> and <span class="math">\(u\)</span> varies with
<span class="math">\(x_0\)</span> only.</p>
<p>The PDE reads</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff2">
\[\tag{99}
\nabla\cdot (k\nabla u) =0 {\thinspace .}\]</div>
<p>To construct a problem where we can find an analytical solution that can
be computed to machine precision regardless of the element size,
we choose <span class="math">\(\Omega\)</span> as a hypercube <span class="math">\([0,1]^d\)</span>, and the materials as
layers in the <span class="math">\(x_0\)</span> direction, as depicted in
Figure <a class="reference internal" href="#tut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a> for a 2D case with four materials.
The boundaries <span class="math">\(x_0=0\)</span> and <span class="math">\(x_0=1\)</span> have Dirichlet conditions
<span class="math">\(u=0\)</span> and <span class="math">\(u=1\)</span>, respectively, while Neumann conditions
<span class="math">\(\partial u/\partial n=0\)</span> are set on the remaining boundaries.
The complete boundary-value problem is then</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff3">
\[\begin{split}\tag{100}
\begin{array}{rcll}
        \nabla\cdot \left(k(x_0)\nabla u(x_0,\ldots,x_{d-1})\right)
          &amp;= 0 &amp;\mbox{in } \Omega, \\
        u &amp;= 0 &amp;\mbox{on } \Gamma_0,\\
        u &amp;= 1 &amp;\mbox{on } \Gamma_1,\\
        {\partial u\over\partial n} &amp;= 0 &amp;\mbox{on } \Gamma_N{\thinspace .}
      \end{array}\end{split}\]</div>
<p>The domain <span class="math">\(\Omega\)</span> is divided into <span class="math">\(s\)</span> materials <span class="math">\(\Omega_i\)</span>, <span class="math">\(i=0,\ldots,s-1\)</span>,
where</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i \leq x_0 &lt; L_{i+1}\}\end{split}\]</div>
<p>for given <span class="math">\(x_0\)</span> values <span class="math">\(0=L_0&lt;L_1&lt;\cdots&lt; L_s=1\)</span>
of the material (subdomain) boundaries.
The <span class="math">\(k(x_0)\)</span> function takes on the value <span class="math">\(k_i\)</span> in <span class="math">\(\Omega_i\)</span>.</p>
<p>The exact solution of the basic PDE
in <a class="reference internal" href="#eq-tut-poisson-2d-varcoeff3"><span class="std std-ref">(100)</span></a></p>
<div class="math">
\[u(x_0,\ldots,x_{d-1}) =
{\int_0^{x_0} (k(\tau ))^{-1}d\tau\over
\int_0^1 (k(\tau ))^{-1}d\tau}{\thinspace .}\]</div>
<p>For a piecewise constant <span class="math">\(k(x_0)\)</span> as explained, we get</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff2-exact">
\[\tag{101}
u(x_0,\ldots,x_{d-1}) =
    {(x_0-L_i)k_i^{-1} + \sum_{j=0}^{i-1} (L_{j+1}-L_j)k_j^{-1}\over
    \sum_{j=0}^{s-1} (L_{j+1}-L_j)k_j^{-1}},\quad L_i\leq x_0 \leq L_{i+1}{\thinspace .}\]</div>
<p>That is, <span class="math">\(u(x_0,\ldots,x_{d-1})\)</span> is piecewise linear in <span class="math">\(x_0\)</span> and
constant in all other directions.
If <span class="math">\(L_i\)</span>
coincides with the element boundaries, Lagrange elements will
reproduce this exact solution to machine precision, which is ideal
for a test case.</p>
</div>
<div class="section" id="preparing-a-mesh-with-subdomains">
<span id="tut-possion-nd-nmat-prepro"></span><h2>Preparing a mesh with subdomains<a class="headerlink" href="#preparing-a-mesh-with-subdomains" title="Permalink to this headline">¶</a></h2>
<p>Our first task is to generate a mesh for <span class="math">\(\Omega = [0,1]^d\)</span> and divide
it into subdomains</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i&lt;x_0&lt;L_{i+1}\}\end{split}\]</div>
<p>for given subdomain boundaries <span class="math">\(x_0=L_i\)</span>, <span class="math">\(i=0,\ldots,s\)</span>, <span class="math">\(L_0=0\)</span>, <span class="math">\(L_s=1\)</span>.
Note that the boundaries <span class="math">\(x_0=L_i\)</span> are points in 1D, lines in 2D, and
planes in 3D.</p>
<p>Let us, on the command line, specify the polynomial degree of Lagrange
elements and the number of element divisions in the various space
directions, as explained in detail in
the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>. This results in an object <code class="docutils literal"><span class="pre">mesh</span></code>
representing the interval <span class="math">\([0,1]\)</span> in 1D, the unit square in 2D, or the
unit cube in 3D.</p>
<p>Specification of subdomains (and boundary parts, if desired) is
done using a user-defined subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code>, as
explained in the section <a class="reference internal" href="._ftut007.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Implementation</span></a>.
We could, in principle,
introduce one subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code> for each subdomain, and
this would be feasible if one has a small and fixed number of
subdomains as in the example in the section <a class="reference internal" href="._ftut007.html#tut-possion-2d-2mat-problem"><span class="std std-ref">Working with two subdomains</span></a> with
two subdomains. Our present case is more general as we
have <span class="math">\(s\)</span> subdomains. It then makes sense to create one
subclass <code class="docutils literal"><span class="pre">Material</span></code> of <code class="docutils literal"><span class="pre">SubDomain</span></code> and have an attribute
to reflect the subdomain (material) number. We use this number
in the test whether a spatial point <code class="docutils literal"><span class="pre">x</span></code> is inside a subdomain or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Material</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define material (subdomain) no. i.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomain_number</span><span class="p">,</span> <span class="n">subdomain_boundaries</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">subdomain_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">subdomain_boundaries</span>
        <span class="n">SubDomain</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span>         <span class="c"># short form (cf. the math)</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&lt;=</span></code> in the test if a point is inside a subdomain is important as
<code class="docutils literal"><span class="pre">x</span></code> will equal vertex coordinates in the cells, and all vertices
of a cell must lead to a <code class="docutils literal"><span class="pre">True</span></code> return value from the <code class="docutils literal"><span class="pre">inside</span></code>
method
for the cell to be a part of the actual subdomain. That is, the
more mathematically natural test <code class="docutils literal"><span class="pre">L[i]</span> <span class="pre">&lt;=</span> <span class="pre">x[0]</span> <span class="pre">&lt;</span> <span class="pre">L[i+1]</span></code> fails to
include elements with <span class="math">\(x=L_{i+1}\)</span> as boundary in subdomain <span class="math">\(\Omega_i\)</span>.</p>
<p>The marking and numbering of all subdomains
goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cell_entity_dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c"># = d</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">cell_entity_dim</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers i=0,1,\ldots,s (=len(L)-1)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">material_i</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">material_i</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>We have now all the geometric information about subdomains in
a <code class="docutils literal"><span class="pre">MeshFunction</span></code> object <code class="docutils literal"><span class="pre">subdomains</span></code>. The subdomain number
of mesh entity number <code class="docutils literal"><span class="pre">e</span></code>, here cell <code class="docutils literal"><span class="pre">e</span></code>, is given
by <code class="docutils literal"><span class="pre">subdomains.array()[e]</span></code>.</p>
<p id="index-0">The code presented so far had the purpose of preparing a mesh and
a mesh function defining the subdomain. It is smart to put this code
in a separate file, say <code class="docutils literal"><span class="pre">define_layers.py</span></code>,
and view the code as a preprocessing step.
We must then store the computed mesh and mesh function in files.
Another program may load the files and perform the actually
solve the boundary-value problem.</p>
<p>Storing the mesh itself and the mesh function in XML format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">subdomains</span>
</pre></div>
</div>
<p>This preprocessing code knows about the layer geometries and
the corresponding <span class="math">\(k\)</span>, which
must be propagated to the solver code. One idea is to let the
preprocessing code write a Python module containing
the <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">k</span></code> lists as well as an implementation of a
function that evaluates the exact solution.
The solver code can import this module to get access to <code class="docutils literal"><span class="pre">L</span></code>,
<code class="docutils literal"><span class="pre">k</span></code>, and the exact solution (for comparison).
The relevant Python code for generating a Python module may take
the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;u_layered.py&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">import numpy</span>
<span class="s">L = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">k = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">s = len(L)-1</span>

<span class="s">def u_e(x):</span>
<span class="s">    # First find which subdomain x0 is located in</span>
<span class="s">    for i in range(len(L)-1):</span>
<span class="s">        if L[i] &lt;= x &lt;= L[i+1]:</span>
<span class="s">            break</span>

<span class="s">    # Vectorized implementation of summation:</span>
<span class="s">    s2 = sum((L[1:s+1] - L[0:s])*(1.0/k[:]))</span>
<span class="s">    if i == 0:</span>
<span class="s">        u = (x - L[i])*(1.0/k[0])/s2</span>
<span class="s">    else:</span>
<span class="s">        s1 = sum((L[1:i+1] - L[0:i])*(1.0/k[0:i]))</span>
<span class="s">        u = ((x - L[i])*(1.0/k[i]) + s1)/s2</span>
<span class="s">    return u</span>

<span class="s">if __name__ == &#39;__main__&#39;:</span>
<span class="s">    # Plot the exact solution</span>
<span class="s">    from scitools.std import linspace, plot, array</span>
<span class="s">    x = linspace(0, 1, 101)</span>
<span class="s">    u = array([u_e(xi) for xi in x])</span>
<span class="s">    print(u)</span>
<span class="s">    plot(x, u)</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># (L, k))</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-the-pde-problem">
<span id="tut-possion-nd-nmat-solve"></span><h2>Solving the PDE problem<a class="headerlink" href="#solving-the-pde-problem" title="Permalink to this headline">¶</a></h2>
<p>The solver program starts with loading a prepared mesh with a mesh
function representing the subdomains:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the <span class="math">\(k\)</span> function as a finite element function.
As we recall from the section <a class="reference internal" href="._ftut007.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Implementation</span></a>, a <span class="math">\(k\)</span> that
is constant in each element is suitable.
We then follow the recipe from the section <a class="reference internal" href="._ftut007.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Implementation</span></a>
to compute <span class="math">\(k\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>

<span class="c"># Vectorized calculation</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The essential boundary conditions are defined in the same way is
in <code class="docutils literal"><span class="pre">dn2_p2D.py</span></code> from the section <a class="reference internal" href="._ftut003.html#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>
and therefore not repeated here.
The variational problem is defined and solved in a standard manner,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">VariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Plotting the discontinuous <code class="docutils literal"><span class="pre">k</span></code> is often desired. Just a <code class="docutils literal"><span class="pre">plot(k)</span></code>
makes a continuous function out of <code class="docutils literal"><span class="pre">k</span></code>, which is not what we want.
Making a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells and filling in the right <span class="math">\(k\)</span>
values results in an object that can be displayed as a discontinuous field.
A relevant code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_meshfunc</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;double&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>

<span class="c"># Scalar version</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]]</span>

<span class="c"># Vectorized version</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">k_meshfunc</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;k as mesh function&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <code class="docutils literal"><span class="pre">Poisson_layers.py</span></code> contains the complete code.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>