<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Multiple domain and boundaries</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Time-dependent problems" href="._ftut009.html" />
    <link rel="prev" title="Postprocessing computations" href="._ftut007.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut007.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut009.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="multiple-domain-and-boundaries">
<h1>Multiple domain and boundaries<a class="headerlink" href="#multiple-domain-and-boundaries" title="Permalink to this headline">¶</a></h1>
<p>[<strong>hpl 3</strong>: Need a little intro.]</p>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h2>Combining Dirichlet and Neumann conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="._ftut002.html#tut-poisson1-bvp"><span class="std std-ref">The Poisson equation</span></a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition <span class="math">\(u=u_0\)</span> at the left and right sides, <span class="math">\(x=0\)</span> and
<span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).</p>
<div class="section" id="pde-problem">
<span id="index-0"></span><h3>PDE problem<a class="headerlink" href="#pde-problem" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span> denote the parts of <span class="math">\(\partial\Omega\)</span>
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as</p>
<div class="math" id="eq-auto15">
\[\tag{31}
- \nabla^2 u = f \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-auto16">
\[\tag{32}
u = u_0 \mbox{ on } \Gamma_D,\]</div>
<div class="math" id="eq-auto17">
\[\tag{33}
- {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2{\thinspace .}\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y{\thinspace .}\]</div>
</div>
<div class="section" id="variational-formulation-2">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-2" title="Permalink to this headline">¶</a></h3>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_N}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.
The resulting weak form reads</p>
<div class="math" id="eq-tut-poisson-2d-dn-weak">
\[\tag{34}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
    \int_{\Gamma_N} gv {\, \mathrm{d}s}
    = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="eq-tut-poisson2-vard-a">
\[\tag{35}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-poisson2-vard-l">
\[\tag{36}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-2">
<h3>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code class="docutils literal"><span class="pre">p2D_plain.py</span></code>, from
the section <a class="reference internal" href="._ftut002.html#tut-poisson1-impl-code"><span class="std std-ref">A simple Poisson solver</span></a>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <code class="docutils literal"><span class="pre">L</span></code>.</li>
</ul>
</div></blockquote>
<p>The first adjustment can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-never-use-for-comparing-real-numbers admonition">
<p class="first admonition-title">Never use <code class="docutils literal"><span class="pre">==</span></code> for comparing real numbers</p>
<p>A list like <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should never be used if <code class="docutils literal"><span class="pre">x[0]</span></code> is a real number,
because rounding errors in <code class="docutils literal"><span class="pre">x[0]</span></code> may make the test fail even when it is
mathematically correct. Consider</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span>
<span class="go">0.30000000000000004</span>
</pre></div>
</div>
<p>Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="go">5.551115123125783e-17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1.1</span><span class="o">+</span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">2.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10.1</span><span class="o">+</span><span class="mf">10.2</span> <span class="o">-</span> <span class="mf">20.3</span><span class="p">)</span>
<span class="go">3.552713678800501e-15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">100.1</span><span class="o">+</span><span class="mf">100.2</span> <span class="o">-</span> <span class="mf">200.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1000.1</span><span class="o">+</span><span class="mf">1000.2</span> <span class="o">-</span> <span class="mf">2000.3</span><span class="p">)</span>
<span class="go">2.2737367544323206e-13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10000.1</span><span class="o">+</span><span class="mf">10000.2</span> <span class="o">-</span> <span class="mf">20000.3</span><span class="p">)</span>
<span class="go">3.637978807091713e-12</span>
</pre></div>
</div>
<p>For numbers around unity, tolerances as low as <span class="math">\(3\cdot 10^{-16}\)</span> can be used
(in fact, this tolerance is known as <code class="docutils literal"><span class="pre">DOLFIN_EPS</span></code> in the <code class="docutils literal"><span class="pre">dolfin</span></code> package),
otherwise an appropriate tolerance must be found.</p>
<p>Testing for <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should therefore be implemented as</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<p>Here is a new boundary function using tolerances in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <code class="docutils literal"><span class="pre">L</span></code>,
where we have to add a boundary integral and a definition of the <span class="math">\(g\)</span>
function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ds</span></code> variable implies a boundary integral, while <code class="docutils literal"><span class="pre">dx</span></code>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No more modifications are necessary.</p>
</div>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h2>Multiple Dirichlet conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>The PDE problem from the previous section applies a function <span class="math">\(u_0(x,y)\)</span>
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have <span class="math">\(m\)</span> functions for
setting Dirichlet conditions on <span class="math">\(m\)</span> parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.</p>
<p>Let us return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a> and define
two separate functions for the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N {\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while <span class="math">\(\Gamma_1\)</span> corresponds
to the boundary <span class="math">\(x=1\)</span>.  We have that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 +
2y^2\)</span>, and <span class="math">\(g=-4y\)</span>.</p>
<div class="section" id="functions-for-marking-dirichlet-boundaries">
<h3>Functions for marking Dirichlet boundaries<a class="headerlink" href="#functions-for-marking-dirichlet-boundaries" title="Permalink to this headline">¶</a></h3>
<p>For the left boundary <span class="math">\(\Gamma_0\)</span> we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code class="docutils literal"><span class="pre">DirichletBC</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list
and used in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part of the
boundary, we may use a simple <code class="docutils literal"><span class="pre">Constant</span></code> object instead of an
<code class="docutils literal"><span class="pre">Expression</span></code> object.</p>
</div>
<div class="section" id="classes-for-marking-dirichlet-boundaries">
<h3>Classes for marking Dirichlet boundaries<a class="headerlink" href="#classes-for-marking-dirichlet-boundaries" title="Permalink to this headline">¶</a></h3>
<p>Instead of using a function like <code class="docutils literal"><span class="pre">left_boundary(x,</span> <span class="pre">on_boundary)</span></code> to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class <code class="docutils literal"><span class="pre">SubDomain</span></code> and has a method <code class="docutils literal"><span class="pre">inside(self,</span> <span class="pre">x,</span> <span class="pre">on_boundary)</span></code> for the code that returns whether the <code class="docutils literal"><span class="pre">point</span></code> is on the
boundary in question or not. Our previous <code class="docutils literal"><span class="pre">left_boundary</span></code> function
takes this form in its class version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LeftBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">left_boundary</span> <span class="o">=</span> <span class="n">LeftBoundary</span><span class="p">()</span>
<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="debugging-dirichlet-conditions">
<h3>Debugging Dirichlet conditions<a class="headerlink" href="#debugging-dirichlet-conditions" title="Permalink to this headline">¶</a></h3>
<p>Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <code class="docutils literal"><span class="pre">get_boundary_values</span></code> method in the <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding essential conditions as values. In the present problem
we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">],</span>
              <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Lagrange_1st_order</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">Lagrange_1st_order</span><span class="p">:</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
        <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">])),</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The output for a mesh made by <code class="docutils literal"><span class="pre">UnitSquareMesh(3,</span> <span class="pre">2)</span></code> becomes</p>
<div class="highlight-text"><div class="highlight"><pre>dof  0: u=1      at point (0.0, 0.0)
dof  8: u=3      at point (0.0, 1.0)
dof  4: u=1.5    at point (0.0, 0.5)
dof  3: u=2      at point (1.0, 0.0)
dof 11: u=4      at point (1.0, 1.0)
dof  7: u=2.5    at point (1.0, 0.5)
</pre></div>
</div>
<p>An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the <em>mesh function</em> concept and is therefore
left to the section <a class="reference internal" href="#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.</p>
</div>
</div>
<div class="section" id="working-with-two-subdomains">
<span id="tut-possion-2d-2mat-problem"></span><h2>Working with two subdomains<a class="headerlink" href="#working-with-two-subdomains" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent the
various materials. We can thereafter define material properties through
functions, known in FEniCS as <em>mesh functions</em>,
that are piecewise constant in each subdomain.
A simple example with
two materials (subdomains) in 2D will
demonstrate the basic steps in the process.</p>
<div class="figure" id="id1">
<span id="tut-possion-2d-2mat-fig1"></span><a class="reference internal image-reference" href="_images/layered_medium_2.png"><img alt="_images/layered_medium_2.png" src="_images/layered_medium_2.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Medium with discontinuous material properties</em></span></p>
</div>
<div class="section" id="mathematical-problem">
<h3>Mathematical problem<a class="headerlink" href="#mathematical-problem" title="Permalink to this headline">¶</a></h3>
<p>Suppose we want to solve</p>
<div class="math" id="eq-tut-poisson-2d-2mat-varcoeff2">
\[\tag{37}
\nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,\]</div>
<p>in a domain <span class="math">\(\Omega\)</span> consisting of two subdomains where <span class="math">\(k\)</span> takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> and divide it into two equal
subdomains,
as depicted in Figure <a class="reference internal" href="#tut-possion-2d-2mat-fig1"><span class="std std-ref">Medium with discontinuous material properties</span></a>,</p>
<div class="math">
\[\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]{\thinspace .}\]</div>
<p>We define <span class="math">\(k(x,y)=k_0\)</span> in <span class="math">\(\Omega_0\)</span> and <span class="math">\(k(x,y)=k_1\)</span> in <span class="math">\(\Omega_1\)</span>,
where <span class="math">\(k_0&gt;0\)</span> and <span class="math">\(k_1&gt;0\)</span> are given constants.
As boundary conditions, we choose <span class="math">\(u=0\)</span> at <span class="math">\(y=0\)</span>, <span class="math">\(u=1\)</span> at <span class="math">\(y=1\)</span>,
and <span class="math">\(\partial u/\partial n=0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>.
One can show that the exact solution is now given by</p>
<div class="math" id="eq-auto18">
\[\begin{split}\tag{38}
u(x, y) = \left\lbrace\begin{array}{ll}
    {2yk_1\over k_0+k_1}, &amp; y \leq 1/2\\
    {(2y-1)k_0 + k_1\over k_0+k_1}, &amp; y \geq 1/2
    \end{array}\right.\end{split}\]</div>
<p>As long as the element boundaries coincide with the internal boundary
<span class="math">\(y=1/2\)</span>, this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We use this property to verify
the implementation.</p>
<p>Physically, the present problem may correspond to heat conduction, where
the heat conduction in <span class="math">\(\Omega_1\)</span> is more efficient than
in <span class="math">\(\Omega_0\)</span>. An alternative interpretation is flow in porous media
with two geological layers, where the layers&#8217; ability to transport
the fluid differs by a factor of 10.</p>
</div>
<div class="section" id="implementation-3">
<span id="tut-possion-2d-2mat-impl"></span><span id="index-3"></span><h3>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h3>
<p>The new functionality in this subsection regards how to define the
subdomains <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. For this purpose we need to use
subclasses of class <code class="docutils literal"><span class="pre">SubDomain</span></code>, not only plain functions as we have
used so far for specifying boundaries. Consider the boundary function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>for defining the boundary <span class="math">\(x=0\)</span>. Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code>,
which implements the <code class="docutils literal"><span class="pre">inside</span></code> method as an alternative to the
<code class="docutils literal"><span class="pre">boundary</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>A word about computer science terminology may be used here:
The term <em>instance</em>
means a Python object of a particular type (such as <code class="docutils literal"><span class="pre">SubDomain</span></code>,
<code class="docutils literal"><span class="pre">Function</span></code>
<code class="docutils literal"><span class="pre">FunctionSpace</span></code>, etc.).
Many use <em>instance</em> and <em>object</em>
as interchangeable terms. In other computer programming languages one may
also use the term <em>variable</em> for the same thing.
We mostly use the well-known  term <em>object</em> in this text.</p>
<p>A subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code> with an <code class="docutils literal"><span class="pre">inside</span></code> method offers
functionality for marking parts of the domain or
the boundary. Now we need to define one class for the
subdomain <span class="math">\(\Omega_0\)</span>
where <span class="math">\(y\leq 1/2\)</span> and another for the subdomain <span class="math">\(\Omega_1\)</span> where <span class="math">\(y\geq 1/2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>

<span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span> <span class="k">else</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">-</span><span class="n">tol</span> <span class="k">else</span> <span class="bp">False</span>
</pre></div>
</div>
<p>Notice the use of <code class="docutils literal"><span class="pre">&lt;=</span></code> and <code class="docutils literal"><span class="pre">&gt;=</span></code> in both tests. For a cell to
belong to, e.g., <span class="math">\(\Omega_1\)</span>, the <code class="docutils literal"><span class="pre">inside</span></code> method must return
<code class="docutils literal"><span class="pre">True</span></code> for all the vertices <code class="docutils literal"><span class="pre">x</span></code> of the cell. So to make the
cells at the internal boundary <span class="math">\(y=1/2\)</span> belong to <span class="math">\(\Omega_1\)</span>, we need
the test <code class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">0.5</span></code>. However,
because of potential rounding errors in the coordinates <code class="docutils literal"><span class="pre">x[1]</span></code>, we
use a tolerance in the comparisons: <code class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">0.5-tol</span></code>.</p>
<p>The next task is to use a <code class="docutils literal"><span class="pre">MeshFunction</span></code> to mark all
cells in <span class="math">\(\Omega_0\)</span> with the subdomain number 0 and all cells in <span class="math">\(\Omega_1\)</span>
with the subdomain number 1.
Our convention is to number subdomains as <span class="math">\(0,1,2,\ldots\)</span>.</p>
<p>A <code class="docutils literal"><span class="pre">MeshFunction</span></code> is a discrete function that can be evaluated at a set
of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells is suitable to
represent subdomains (materials), while a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous fields.</p>
<p>Since we need to define subdomains of <span class="math">\(\Omega\)</span>
in the present example, we must make use
of a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells. The
<code class="docutils literal"><span class="pre">MeshFunction</span></code> constructor is fed with three arguments: 1) the type
of value: <code class="docutils literal"><span class="pre">'int'</span></code> for integers, <code class="docutils literal"><span class="pre">'uint'</span></code> for positive
(unsigned) integers, <code class="docutils literal"><span class="pre">'double'</span></code> for real numbers, and
<code class="docutils literal"><span class="pre">'bool'</span></code> for logical values; 2) a <code class="docutils literal"><span class="pre">Mesh</span></code> object, and 3)
the topological dimension of the mesh entity in question: cells
have topological dimension equal to the number of space dimensions in
the PDE problem, and facets have one dimension lower.
Alternatively, the constructor can take just a filename
and initialize the <code class="docutils literal"><span class="pre">MeshFunction</span></code> from data in a file.</p>
<p>We start with creating a <code class="docutils literal"><span class="pre">MeshFunction</span></code> whose
values are non-negative integers (<code class="docutils literal"><span class="pre">'uint'</span></code>)
for numbering the subdomains.
The mesh entities of interest are the cells, which have dimension 2
in a two-dimensional problem (1 in 1D, 3 in 3D). The appropriate code for
defining the <code class="docutils literal"><span class="pre">MeshFunction</span></code> for two subdomains then reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers 0 and 1</span>
<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">Omega0</span><span class="p">()</span>
<span class="n">subdomain0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">Omega1</span><span class="p">()</span>
<span class="n">subdomain1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">subdomains.array()</span></code> returns a <code class="docutils literal"><span class="pre">numpy</span></code> array of the
subdomain values. That is, <code class="docutils literal"><span class="pre">subdomain.array()[i]</span></code> is
the subdomain value of cell number <code class="docutils literal"><span class="pre">i</span></code>. This array is used to
look up the subdomain or material number of a specific element.</p>
<p>We need a function <code class="docutils literal"><span class="pre">k</span></code> that is constant in
each subdomain <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. Since we want <code class="docutils literal"><span class="pre">k</span></code>
to be a finite element function, it is natural to choose
a space of functions that is constant over each element.
The family of discontinuous Galerkin methods, in FEniCS
denoted by <code class="docutils literal"><span class="pre">'DG'</span></code>, is suitable for this purpose. Since we
want functions that are piecewise constant, the value of
the degree parameter is zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
</pre></div>
</div>
<p>To fill <code class="docutils literal"><span class="pre">k</span></code> with the right values in each element, we loop over
all cells (i.e., indices in <code class="docutils literal"><span class="pre">subdomain.array()</span></code>),
extract the corresponding subdomain number of a cell,
and assign the corresponding <span class="math">\(k\)</span> value to the <code class="docutils literal"><span class="pre">k.vector()</span></code> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>  <span class="c"># values of k in the two subdomains</span>
<span class="k">for</span> <span class="n">cell_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">subdomain_no</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span>
    <span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomain_no</span><span class="p">]</span>
</pre></div>
</div>
<p>Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <code class="docutils literal"><span class="pre">numpy</span></code> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<code class="docutils literal"><span class="pre">subdomain.array()</span></code>, but where the value <code class="docutils literal"><span class="pre">i</span></code> of an entry
in <code class="docutils literal"><span class="pre">subdomain.array()</span></code> is replaced by <code class="docutils literal"><span class="pre">k_values[i]</span></code>.
Such an operation is carried out by the <code class="docutils literal"><span class="pre">numpy</span></code> function <code class="docutils literal"><span class="pre">choose</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">help</span></code> array is required since <code class="docutils literal"><span class="pre">choose</span></code> cannot work with
<code class="docutils literal"><span class="pre">subdomain.array()</span></code> because this array has elements of
type <code class="docutils literal"><span class="pre">uint32</span></code>. We must therefore transform this array to an array
<code class="docutils literal"><span class="pre">help</span></code> with standard <code class="docutils literal"><span class="pre">int32</span></code> integers.</p>
<p>Having the <code class="docutils literal"><span class="pre">k</span></code> function ready for finite element computations, we
can proceed in the normal manner with defining essential boundary
conditions, as in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>,
and the <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> forms, as in
the section <a class="reference internal" href="._ftut005.html#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient Poisson problem</span></a>.</p>
</div>
</div>
<div class="section" id="multiple-neumann-robin-and-dirichlet-condition">
<span id="tut-poisson-multi-bc"></span><h2>Multiple Neumann, Robin, and Dirichlet condition<a class="headerlink" href="#multiple-neumann-robin-and-dirichlet-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><span class="target" id="index-5"></span><span class="target" id="index-6"></span><p id="index-7">Let us go back to the model problem from the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a> where we had both Dirichlet and
Neumann conditions.  The term <code class="docutils literal"><span class="pre">v*g*ds</span></code> in the expression for <code class="docutils literal"><span class="pre">L</span></code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate <code class="docutils literal"><span class="pre">v*g*ds</span></code> only over the parts of the boundary where
we actually have Neumann conditions.  And more importantly, in other
problems one may have different Neumann conditions or other conditions
like the Robin type condition.  With the mesh function concept we can
mark different parts of the boundary and integrate over specific
parts.  The same concept can also be used to treat multiple Dirichlet
conditions.  The forthcoming text illustrates how this is done.</p>
<div class="section" id="three-types-of-boundary-conditions">
<h3>Three types of boundary conditions<a class="headerlink" href="#three-types-of-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin.  Dirichlet conditions apply to some
parts <span class="math">\(\Gamma_{D,0}\)</span>, <span class="math">\(\Gamma_{D,1}\)</span>, <span class="math">\(...\)</span>, of the boundary:</p>
<div class="math">
\[u_{0,0}\hbox{ on }\Gamma_{D,0},\quad
u_{0,1}\hbox{ on }\Gamma_{D,1}, \ldots\]</div>
<p>where <span class="math">\(u_{0,i}\)</span> are prescribed functions, <span class="math">\(i=0,1,\ldots\)</span>
On other parts, <span class="math">\(\Gamma_{N,0}\)</span>, <span class="math">\(\Gamma_{N,1}\)</span>, and so on, we have
Neumann conditions</p>
<div class="math">
\[-p{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{N,0},\quad
-p{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{N,1},\quad \ldots\]</div>
<p>Finally, we have some parts <span class="math">\(\Gamma_{R,0}\)</span>, <span class="math">\(\Gamma_{R,1}\)</span>, and so forth,
with <em>Robin conditions</em>:</p>
<div class="math" id="eq-tut-poisson-multi-bc-robin">
<span id="index-8"></span>\[\tag{39}
-p{\partial u\over\partial n} = r(u-s),\]</div>
<p>where <span class="math">\(r\)</span> and <span class="math">\(s\)</span> are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton&#8217;s cooling law. In that case, <span class="math">\(r\)</span> is a heat
transfer coefficient, and <span class="math">\(s\)</span> is the temperature of the
surroundings. Both can be space and time-dependent.</p>
</div>
<div class="section" id="model-problem">
<h3>Model problem<a class="headerlink" href="#model-problem" title="Permalink to this headline">¶</a></h3>
<p>The model problem to be solved with multiple Dirichlet, Neumann, and
Robin conditions can formally be defined as</p>
<div class="math" id="eq-tut-poisson-2d-dn3">
\[\tag{40}
-\nabla\cdot(p\nabla u) = -f, \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcd">
\[\tag{41}
u = u_{0,i} \mbox{ on } \Gamma_{D,i},\quad i=0,1,\ldots\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcn">
\[\tag{42}
-p{\partial u\over\partial n} = g_i \mbox{ on } \Gamma_{N,i},\quad
    i=0,1,\ldots\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcr">
\[\tag{43}
-p{\partial u\over\partial n} = r_i(u-s_i) \mbox{ on } \Gamma_{R,i},\quad
    i=0,1,\ldots\]</div>
</div>
<div class="section" id="variational-formulation-3">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-3" title="Permalink to this headline">¶</a></h3>
<p>Integration by parts of <span class="math">\(-\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}\)</span> becomes
as usual</p>
<div class="math">
\[ -\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}
= \int_\Omega p\nabla u\cdot \nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>The boundary integral does not apply to the parts of
the boundary where we have Dirichlet conditions (<span class="math">\(\Gamma_{D,i}\)</span>).
Moreover, on the remaining parts, we must split the boundary integral
into the parts where we have Neumann and Robin conditions such that we
insert the right conditions as integrands.
Specifically, we have</p>
<div class="math">
\[-\int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}
=
-\sum_i\int_{\Gamma_{N,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}
-\sum_i\int_{\Gamma_{R,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}
=
\sum_i\int_{\Gamma_{N,i}}g_i {\, \mathrm{d}s}
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i) {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>The variational formulation then becomes</p>
<div class="math" id="eq-tut-poisson-multi-bc-varform">
\[\tag{44}
\int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x} +
    \sum_i\int_{\Gamma_{N,i}} g_iv {\, \mathrm{d}s} + \int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
    = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>We want to write this variational formulation in the standard notation
<span class="math">\(a(u,v)=L(v)\)</span>, which requires that we identify all integrals with
<em>both</em> <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, and collect these in <span class="math">\(a(u,v)\)</span>, while the remaining
integrals with <span class="math">\(v\)</span> and not <span class="math">\(u\)</span> go into <span class="math">\(L(v)\)</span>.  The integral from the
Robin condition must of this reason be split in two parts:</p>
<div class="math">
\[\int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
= \int_{\Gamma_{R,i}} r_iuv {\, \mathrm{d}s} - \int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>We then have</p>
<div class="math" id="eq-tut-poisson-2d-dn3-var-a">
\[\tag{45}
a(u, v) = \int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x}
    + sum_i\int_{\Gamma_{R,i}}r_iuv {\, \mathrm{d}s},\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-var-l">
\[\tag{46}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    sum_i\int_{\Gamma_{N,i}} g_i v {\, \mathrm{d}s} + \sum_i\int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-4">
<h3>Implementation<a class="headerlink" href="#implementation-4" title="Permalink to this headline">¶</a></h3>
<p>Looking at our previous <code class="docutils literal"><span class="pre">solver</span></code> functions for solving the 2D Poisson equation,
the following new aspects must be taken care of:</p>
<blockquote>
<div><ol class="arabic simple">
<li>definition of a mesh function over the boundary,</li>
<li>marking each side as a subdomain, using the mesh function,</li>
<li>splitting a boundary integral into parts.</li>
</ol>
</div></blockquote>
<p>A general approach to the first task is to mark each of the four sides
of the square with markers 1, 2, 3, and 4.
To this end, we make use of the mesh function object, but contrary to
the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><span class="std std-ref">Implementation</span></a>, this is not a function over
cells, but a function over cell facets. We apply the <code class="docutils literal"><span class="pre">FacetFunction</span></code>
for this purpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">boundary_parts</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><span class="std std-ref">Implementation</span></a> we use a subclass of
<code class="docutils literal"><span class="pre">SubDomain</span></code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the <span class="math">\(x=0\)</span> boundary can be marked by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BoundaryX0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">bx0</span> <span class="o">=</span> <span class="n">BoundaryX0</span><span class="p">()</span>
<span class="n">bx0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we make the classes <code class="docutils literal"><span class="pre">BoundaryX1</span></code> for the <span class="math">\(x=1\)</span> boundary,
<code class="docutils literal"><span class="pre">BoundaryY0</span></code> for the <span class="math">\(y=0\)</span> boundary, and <code class="docutils literal"><span class="pre">BoundaryY1</span></code> for the <span class="math">\(y=1\)</span>
boundary, and mark these as subdomains 1, 2, and 3, respectively.</p>
<p>For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,</p>
<div class="highlight-text"><div class="highlight"><pre>boundary_conditions = {
  0: {&#39;Dirichlet&#39;: u0},
  1: {&#39;Robin&#39;: (r, s)},
  2: {&#39;Neumann: g}},
  3: {&#39;Neumann&#39;, 0}}
</pre></div>
</div>
<p>specifies</p>
<blockquote>
<div><ul class="simple">
<li>a Dirichlet condition, with values implemented by an <code class="docutils literal"><span class="pre">Expression</span></code>
or <code class="docutils literal"><span class="pre">Constant</span></code> object
<code class="docutils literal"><span class="pre">u0</span></code>, on subdomain 0, i.e., the <span class="math">\(x=1\)</span> boundary;</li>
<li>a Robin condition <a class="reference internal" href="#eq-tut-poisson-multi-bc-robin"><span class="std std-ref">(39)</span></a>
on subdomain 1, <span class="math">\(x=1\)</span>, with <code class="docutils literal"><span class="pre">Expression</span></code> or <code class="docutils literal"><span class="pre">Constant</span></code> objects
<code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code> specifying <span class="math">\(r\)</span> and <span class="math">\(s\)</span>;</li>
<li>a Neumann condition <span class="math">\(\partial u/\partial n=g\)</span> on subdomain 2, <span class="math">\(y=0\)</span>,
where an <code class="docutils literal"><span class="pre">Expression</span></code> or <code class="docutils literal"><span class="pre">Constant</span></code> object <code class="docutils literal"><span class="pre">g</span></code> implements the value <span class="math">\(g\)</span>;</li>
<li>a homogeneous Neumann condition <span class="math">\(\partial u/\partial n=0\)</span> on
subdomain 3, <span class="math">\(y=1\)</span>.</li>
</ul>
</div></blockquote>
<p>As explained in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>,
multiple Dirichlet conditions must be collected in a list of
<code class="docutils literal"><span class="pre">DirichletBC</span></code> objects. Based on the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data
structure above, we can construct this list by the following snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># List of Dirichlet conditions</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Dirichlet&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">],</span>
                        <span class="n">boundary_parts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>The new aspect of the variational problem is the two distinct
boundary integrals over <span class="math">\(\Gamma_{N,i}\)</span> and <span class="math">\(\Gamma_{R,i}\)</span>.
Having a mesh function over exterior cell facets (our
<code class="docutils literal"><span class="pre">boundary_parts</span></code> object), where subdomains (boundary parts) are
numbered as <span class="math">\(0,1,2,\ldots\)</span>, the special symbol <code class="docutils literal"><span class="pre">ds(0)</span></code>
implies integration over subdomain (part) 0, <code class="docutils literal"><span class="pre">ds(1)</span></code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code class="docutils literal"><span class="pre">ds</span></code>-type objects generalizes to volume
integrals too: <code class="docutils literal"><span class="pre">dx(0)</span></code>, <code class="docutils literal"><span class="pre">dx(1)</span></code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside <span class="math">\(\Omega\)</span>.</p>
<p>Before we have <code class="docutils literal"><span class="pre">ds(n)</span></code> for integers <code class="docutils literal"><span class="pre">n</span></code> defined, we must do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries_parts</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, if we want integration of different parts of the domain,
we redefine <code class="docutils literal"><span class="pre">dx</span></code> as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">domains</span></code> is a <code class="docutils literal"><span class="pre">CellFunction</span></code> defining subdomains in <span class="math">\(\Omega\)</span>.</p>
<p>Suppose we have a Robin condition with values <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code> on subdomain
<code class="docutils literal"><span class="pre">R</span></code>, a Neumann condition with value <code class="docutils literal"><span class="pre">g</span></code> on subdomain <code class="docutils literal"><span class="pre">N</span></code>, the
variational form can be written</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>In our case things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data structure. We can collect
all Neumann conditions by the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">Neumann_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Neumann&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span>
            <span class="n">Neumann_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>Applying <code class="docutils literal"><span class="pre">sum(Nemann_integrals)</span></code> will apply the <code class="docutils literal"><span class="pre">+</span></code> operator to
the variational forms in the <code class="docutils literal"><span class="pre">Numeann_integrals</span></code> list and result
in the integrals we need for the right-hand side <code class="docutils literal"><span class="pre">L</span></code> of the
variational form.</p>
<p>The integrals in the Robin condition can similarly be collected
in lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Robin_a_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Robin_L_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">Robin_a_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">Robin_L_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>We are now in a position to define the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> expressions
in the variational formulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_a_integrals</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_L_integrals</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="simplified-handling-of-the-variational-formulation">
<h3>Simplified handling of the variational formulation<a class="headerlink" href="#simplified-handling-of-the-variational-formulation" title="Permalink to this headline">¶</a></h3>
<p>We carefully ordered the terms in the variational formulation above
into the <span class="math">\(a\)</span> and <span class="math">\(L\)</span> parts. This requires a splitting of the Robin
condition and makes the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> expressions less readable (still we
think understanding this splitting is key for any finite element programmer!).
Fortunately, UFL allow us to specify the complete variational form
<a class="reference internal" href="#eq-tut-poisson-multi-bc-varform"><span class="std std-ref">(44)</span></a> as <em>one expression</em> and offer tools to
extract what goes into the bilinear form <span class="math">\(a(u,v)\)</span> and the linear form
<span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_integrals</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>This time we can more naturally define the integrals from the
Robin condition as <code class="docutils literal"><span class="pre">r*(u-s)*v*ds(n)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Robin_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">Robin_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete code is in the <code class="docutils literal"><span class="pre">solver_bc</span></code> function in the
<code class="docutils literal"><span class="pre">p2D_vc.py</span></code> file.</p>
</div>
<div class="section" id="test-problem-4">
<h3>Test problem<a class="headerlink" href="#test-problem-4" title="Permalink to this headline">¶</a></h3>
<p>Let us continue to use <span class="math">\({u_{\small\mbox{e}}}=1+x^2+2y^2\)</span> as the exact solution, and
set <span class="math">\(p=1\)</span> and <span class="math">\(f=-6\)</span> in the PDE.  Our domain is the unit square, and
we assign Dirichlet conditions at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, a Neumann condition
at <span class="math">\(y=1\)</span>, and a Robin condition at <span class="math">\(y=0\)</span>. With the given <span class="math">\({u_{\small\mbox{e}}}\)</span>, we
realize that the Neumann condition is <span class="math">\(-4y\)</span> (which means <span class="math">\(-4\)</span> at
<span class="math">\(y=1\)</span>), while the Robin
condition can be selected in many ways. Since <span class="math">\(\partial u/\partial
n=-\partial u/\partial y=0\)</span> at <span class="math">\(y=0\)</span>, we can select <span class="math">\(s=u\)</span> and have <span class="math">\(r\)</span>
arbitrary in the Robin condition.</p>
<p>The boundary parts are <span class="math">\(\Gamma_{D,0}\)</span>: <span class="math">\(x=0\)</span>, <span class="math">\(\Gamma_{D,1}\)</span>: <span class="math">\(x=1\)</span>,
<span class="math">\(\Gamma_{R,0}\)</span>: <span class="math">\(y=0\)</span>, and <span class="math">\(\Gamma_{N,0}\)</span>: <span class="math">\(y=1\)</span>.</p>
<p>When implementing this test problem (and especially other test problems
with more complicated expressions), it is advantageous to use
symbolic computing. Below we define <span class="math">\({u_{\small\mbox{e}}}\)</span> as a <code class="docutils literal"><span class="pre">sympy</span></code> expression
and derive other functions from their mathematical definitions.
Then we turn these expressions into C/C++ code, which can be
fed into <code class="docutils literal"><span class="pre">Expression</span></code> objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application_bc_test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># x=0 boundary</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c"># arbitrary function can go here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Turn to C/C++ code for UFL expressions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Test problem (C/C++):</span><span class="se">\n</span><span class="s">u = </span><span class="si">%s</span><span class="se">\n</span><span class="s">f = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_00: </span><span class="si">%s</span><span class="se">\n</span><span class="s">u_01: </span><span class="si">%s</span><span class="se">\n</span><span class="s">g = </span><span class="si">%s</span><span class="se">\n</span><span class="s">r = </span><span class="si">%s</span><span class="se">\n</span><span class="s">s = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

    <span class="c"># Turn into FEniCS objects</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Robin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">}}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="o">*</span><span class="n">Ny</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>

    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                       <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>

    <span class="c"># Print numerical and exact solution at the vertices</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">u_e_at_vertices</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%2d</span><span class="s"> (</span><span class="si">%9g</span><span class="s">,</span><span class="si">%9g</span><span class="s">): error=</span><span class="si">%g</span><span class="s"> </span><span class="si">%g</span><span class="s"> vs </span><span class="si">%g</span><span class="s">&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">test_solvers_bc</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to with different solvers.&quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">3E-12</span>  <span class="c"># Appropriate tolerance for these tests (P2, 20x20 mesh)</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># x=0 boundary</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c"># arbitrary function can go here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Turn to C/C++ code for UFL expressions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Test problem (C/C++):</span><span class="se">\n</span><span class="s">u = </span><span class="si">%s</span><span class="se">\n</span><span class="s">f = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_00: </span><span class="si">%s</span><span class="se">\n</span><span class="s">u_01: </span><span class="si">%s</span><span class="se">\n</span><span class="s">g = </span><span class="si">%s</span><span class="se">\n</span><span class="s">r = </span><span class="si">%s</span><span class="se">\n</span><span class="s">s = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

    <span class="c"># Turn into FEniCS objects</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Robin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">}}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">linear_solver</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;direct&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">solver_func</span> <span class="ow">in</span> <span class="p">[</span><span class="n">solver_bc</span><span class="p">]:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">x) mesh with P</span><span class="si">%d</span><span class="s"> elements&#39;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)),</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39; </span><span class="si">%s</span><span class="s"> solver, </span><span class="si">%s</span><span class="s"> function&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">linear_solver</span><span class="p">,</span> <span class="n">solver_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">solver_func</span><span class="p">(</span>
                         <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                         <span class="n">linear_solver</span><span class="o">=</span><span class="n">linear_solver</span><span class="p">,</span>
                         <span class="n">abs_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
                         <span class="n">rel_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
                         <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="c"># Make a finite element function of the exact u0</span>
                    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
                    <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># exact solution</span>
                    <span class="c"># Check that dof arrays are equal</span>
                    <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
                    <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s"> for 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh, degree=</span><span class="si">%d</span><span class="s">,&#39;</span>\
                          <span class="s">&#39; </span><span class="si">%s</span><span class="s"> solver, </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                      <span class="p">(</span><span class="n">max_error</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">linear_solver</span><span class="p">,</span>
                       <span class="n">solver_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>This simple test problem is turned into a real unit test for different
function spaces in the function <code class="docutils literal"><span class="pre">test_solver_bc</span></code>.</p>
</div>
<div class="section" id="debugging-the-setting-of-boundary-conditions">
<h3>Debugging the setting of boundary conditions<a class="headerlink" href="#debugging-the-setting-of-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code class="docutils literal"><span class="pre">SubDomain.inside</span></code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the output.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="c"># Print the vertices that are on the boundaries</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bx0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bx1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
    <span class="c"># Print the Dirichlet conditions</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;No of Dirichlet conditions:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcs</span><span class="p">))</span>
    <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
        <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;   at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>In addition, it is helpful to print the exact and the numerical solution
at all the vertices as shown in the section <a class="reference internal" href="._ftut005.html#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a>.</p>
</div>
</div>
<div class="section" id="handy-methods-in-key-fenics-objects">
<h2>Handy methods in key FEniCS objects<a class="headerlink" href="#handy-methods-in-key-fenics-objects" title="Permalink to this headline">¶</a></h2>
<p id="index-9">In general,
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.X</span></code> shows the documentation of any DOLFIN name <code class="docutils literal"><span class="pre">X</span></code>
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.</p>
<div class="section" id="mesh">
<h3>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">mesh</span></code> be a <code class="docutils literal"><span class="pre">Mesh</span></code> object.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns an array of the coordinates of</dt>
<dd><p class="first last">the vertices in the mesh.</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_cells()</span></code> returns the number of cells (triangles)
in the mesh,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_vertices()</span></code> returns the number of vertices in
the mesh (with our choice of linear Lagrange elements this equals the
number of nodes, <code class="docutils literal"><span class="pre">len(u_array)</span></code>, or dimension of the space <code class="docutils literal"><span class="pre">V.dim()</span></code>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.cells()</span></code> returns the vertex numbers of the vertices in
each cell as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape
(<em>number of cells</em>, <em>number of vertices in a cell</em>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmin()</span></code> returns the minimum cell diameter (&#8220;smallest cell&#8221;),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmax()</span></code> returns the maximum cell diameter (&#8220;largest cell&#8221;).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.topology().dim()</span></code> returns the number of physical dimensions of
the mesh.</p>
</li>
</ul>
</div></blockquote>
<p>Writing <code class="docutils literal"><span class="pre">print(mesh)</span></code> dumps a short, pretty-print description
of the mesh (<code class="docutils literal"><span class="pre">print(mesh)</span></code> actually displays the result of <code class="docutils literal"><span class="pre">str(mesh)</span></code>,
which defines the pretty print):</p>
<div class="highlight-text"><div class="highlight"><pre>&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>
</div>
</div>
<div class="section" id="function-space">
<h3>Function space<a class="headerlink" href="#function-space" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">V</span></code> be a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">V.mesh()</span></code> returns the associated mesh.</li>
<li><code class="docutils literal"><span class="pre">V.dim()</span></code> returns the dimension (number of degrees of freedom).</li>
<li><code class="docutils literal"><span class="pre">V.ufl_element()</span></code> returns the associated finite element.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="function">
<h3>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">u</span></code> be a <code class="docutils literal"><span class="pre">Function</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u.function_space()</span></code> returns the associated function space.</li>
<li><code class="docutils literal"><span class="pre">u.vector()</span></code> returns the DOLFIN vector of degrees of freedom.</li>
<li><code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a copy of the degrees of freedom
in a <code class="docutils literal"><span class="pre">numpy</span></code> array.</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>