.. !split

Postprocessing computations
===========================

.. _tut:poisson1:functionals:

Computing functionals
---------------------

.. index:: functionals

After the solution :math:`u` of a PDE is computed, we occasionally want to compute
functionals of :math:`u`, for example,

.. _Eq:tut:poisson1:functionals:energy:

.. math::

    \tag{28}
    {1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},
        
        

which often reflects some energy quantity.
Another frequently occurring functional is the error

.. _Eq:tut:poisson1:functionals:error:

.. math::

    \tag{29}
    ||{u_{\small\mbox{e}}}-u|| = \left(\int_\Omega ({u_{\small\mbox{e}}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},
        
        

where :math:`{u_{\small\mbox{e}}}` is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part :math:`\Gamma` of
the boundary :math:`\partial\Omega`,

.. _Eq:tut:poisson1:functionals:flux:

.. math::

    \tag{30}
    F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},
        
        

where :math:`\boldsymbol{n}` is an outward unit normal at :math:`\Gamma` and :math:`p` is a
coefficient (see the problem in the section :ref:`tut:possion:2D:varcoeff`
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.

.. index:: energy functional

Energy functional
~~~~~~~~~~~~~~~~~

The integrand of the
energy functional
:ref:`(28) <Eq:tut:poisson1:functionals:energy>`
is described in the UFL language in the same manner as we describe
weak forms:

.. code-block:: python

        energy = 0.5*inner(grad(u), grad(u))*dx
        E = assemble(energy)

The ``assemble`` call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section :ref:`tut:poisson:mat:neumann`.

.. index:: error functional

Error functional
~~~~~~~~~~~~~~~~

Computation of :ref:`(29) <Eq:tut:poisson1:functionals:error>` is typically done
by

.. code-block:: python

        error = (u - u_exact)**2*dx
        E = sqrt(abs(assemble(error)))

The exact solution :math:`{u_{\small\mbox{e}}}` is here in a ``Function`` or
``Expression`` object ``u_exact``, while ``u`` is the
finite element approximation.
(Sometimes, for very small error values, the result of
``assemble(error)`` can be a (very small) negative number, so we have
used ``abs`` in the expression for ``E`` above to ensure a positive value
for the ``sqrt`` function.)

As will be explained and demonstrate in the section :ref:`tut:poisson1:convrates`, the integration of ``(u - u_exact)**2*dx``
can result in too optimistic convergence rates unless one is careful
how ``u_exact`` is transferred onto a mesh. The general recommendation
for reliable error computation is to use the ``errornorm`` function
(see ``pydoc dolfin.errornorm`` and the section :ref:`tut:poisson1:convrates`
for more information):

.. code-block:: python

        E = errornorm(u_exact, u)

.. index:: flux functional

Flux Functionals
~~~~~~~~~~~~~~~~

To compute flux integrals like :math:`F = -\int_\Gamma p\nabla
u\cdot\boldsymbol{n} {\, \mathrm{d}s}` we need to define the :math:`\boldsymbol{n}` vector,
referred to as *facet normal* in FEniCS. If the surface domain
:math:`\Gamma` in the flux integral is the complete
boundary we can perform the flux computation by

.. code-block:: python

        n = FacetNormal(mesh)
        flux = -p*dot(nabla_grad(u), n)*ds
        total_flux = assemble(flux)

Although ``nabla_grad(u)`` and ``grad(u)`` are interchangeable
in the above expression when ``u`` is a scalar function, we have
chosen to write ``nabla_grad(u)`` because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With ``grad(u)`` we must in that
case write ``dot(n, grad(u))``.

It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section :ref:`tut:poisson:mat:neumann`. Assuming that the
part corresponds to subdomain number ``i``, the relevant syntax for
the variational formulation of the
flux is ``-p*inner(grad(u), n)*ds(i)``.

.. _tut:poisson1:convrates:

Computing convergence rates
---------------------------

To illustrate error computations and convergence of finite element
solutions, we have included a function ``convergence_rate`` in
the ``p2D_vc.py`` program. This is a tool that is very
handy when verifying finite element codes and will therefore be explained in
detail here.

The :math:`L^2` norm of the error in a finite element approximation :math:`u`,
:math:`{u_{\small\mbox{e}}}` being the exact solution, is given by

Various ways of computing the error
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. math::
         E = \left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2},

and implemented in FEniCS by

.. code-block:: python

        error = (u - u_e)**2*dx
        E = sqrt(abs(assemble(error)))

Sometimes, for very small error values, the result of
``assemble(error)`` can be a (very small) negative number, so we have
used ``abs`` in the expression for ``E`` above to ensure a positive value
for the ``sqrt`` function.

We remark that ``u_e`` will, in the expression
above, be interpolated onto the function space ``V`` before ``assemble``
can perform the integration over the domain. This implies that the
exact solution used in the integral will vary linearly over the cells,
and not as a sine function, if ``V`` corresponds to linear Lagrange
elements.  This situation may yield a smaller error ``u - u_e`` than
what is actually true.  More accurate representation of the exact
solution is easily achieved by interpolating the formula onto a space
defined by higher-order elements, say of third degree:

.. code-block:: python

        Ve = FunctionSpace(mesh, 'Lagrange', degree=3)
        u_e_Ve = interpolate(u_e, Ve)
        error = (u - u_e_Ve)**2*dx
        E = sqrt(assemble(error))

To achieve complete mathematical control of which function space the
computations are carried out in, we can explicitly interpolate ``u`` to
the same space:

.. code-block:: python

        u_Ve = interpolate(u, Ve)
        error = (u_Ve - u_e_Ve)**2*dx

The square in the expression for ``error`` will be expanded and lead to
a lot of terms that almost cancel when the error is small, with the
potential of introducing significant rounding errors.  The function
``errornorm`` is available for avoiding this effect by first
interpolating ``u`` and ``u_exact`` to a space with higher-order elements,
then subtracting the degrees of freedom, and then performing the
integration of the error field. The usage is simple:

.. code-block:: python

        E = errornorm(u_exact, u, normtype='L2', degree=3)

It is illustrative to look at the short implementation of ``errornorm``:

.. code-block:: python

        def errornorm(u_exact, u, Ve):
            u_Ve = interpolate(u, Ve)
            u_e_Ve = interpolate(u_exact, Ve)
            e_Ve = Function(Ve)
            # Subtract degrees of freedom for the error field
            e_Ve.vector()[:] = u_e_Ve.vector().array() - \ 
                               u_Ve.vector().array()
            error = e_Ve**2*dx
            return sqrt(assemble(error))

The ``errornorm`` procedure turns out to be identical to computing
the expression ``(u_e - u)**2*dx`` directly in
the present test case.

Sometimes it is of interest to compute the error of the
gradient field: :math:`||\nabla (u-{u_{\small\mbox{e}}})||`
(often referred to as the :math:`H^1` seminorm of the error).
Given the error field ``e_Ve`` above, we simply write

.. code-block:: python

        H1seminorm = sqrt(assemble(inner(grad(e_Ve), grad(e_Ve))*dx))

All the various types of error computations here are placed in a
function ``compute_errors`` in ``p2D_vc.py``:
[**hpl 7**: Necessary to repeat code? New info is essentiall the return dict.]
[**hpl 8**: Anders, I (in 2010...) ran into problems with ``dolfin.errornorm``, see comments in the code below, and made the version below. We should check out these problems again and adjust ``dolfin.errornorm`` if necessary.]

.. code-block:: python

        def compute_errors(u, u_exact):
            """Compute various measures of the error u - u_exact, where
            u is a finite element Function and u_exact is an Expression."""
        
            # Compute error norm (for very small errors, the value can be
            # negative so we run abs(assemble(error)) to avoid failure in sqrt
        
            V = u.function_space()
        
            # Function - Expression
            error = (u - u_exact)**2*dx
            E1 = sqrt(abs(assemble(error)))
        
            # Explicit interpolation of u_e onto the same space as u:
            u_e = interpolate(u_exact, V)
            error = (u - u_e)**2*dx
            E2 = sqrt(abs(assemble(error)))
        
            # Explicit interpolation of u_exact to higher-order elements,
            # u will also be interpolated to the space Ve before integration
            Ve = FunctionSpace(V.mesh(), 'Lagrange', 5)  # mesh here: BUG, module mesh in dolfin...make warning box
            u_e = interpolate(u_exact, Ve)
            error = (u - u_e)**2*dx
            E3 = sqrt(abs(assemble(error)))
        
            # dolfin.errornorm interpolates u and u_e to a space with
            # given degree, and creates the error field by subtracting
            # the degrees of freedom, then the error field is integrated
            # TEMPORARY BUG - doesn't accept Expression for u_e
            #E4 = errornorm(u_e, u, normtype='l2', degree=3)
            # Manual implementation errornorm to get around the bug:
            def errornorm(u_exact, u, Ve):
                u_Ve = interpolate(u, Ve)
                u_e_Ve = interpolate(u_exact, Ve)
                e_Ve = Function(Ve)
                # Subtract degrees of freedom for the error field
                e_Ve.vector()[:] = u_e_Ve.vector().array() - u_Ve.vector().array()
                # More efficient computation (avoids the rhs array result above)
                #e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve
                #e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve
                error = e_Ve**2*dx(Ve.mesh())
                return sqrt(abs(assemble(error))), e_Ve
            E4, e_Ve = errornorm(u_exact, u, Ve)
        
            # Infinity norm based on nodal values
            u_e = interpolate(u_exact, V)
            E5 = abs(u_e.vector().array() - u.vector().array()).max()
        
            # H1 seminorm
            error = inner(grad(e_Ve), grad(e_Ve))*dx
            E6 = sqrt(abs(assemble(error)))
        
            # Collect error measures in a dictionary with self-explanatory keys
            errors = {'u - u_exact': E1,
                      'u - interpolate(u_exact,V)': E2,
                      'interpolate(u,Ve) - interpolate(u_exact,Ve)': E3,
                      'errornorm': E4,
                      'infinity norm (of dofs)': E5,
                      'grad(error) H1 seminorm': E6}
        
            return errors

Computing convergence rates empirically
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Calling the ``solver`` function for finer and finer meshes enables us to
study the convergence rate. Define the element size :math:`h=1/n`, where :math:`n`
is the number of cell divisions in :math:`x` and :math:`y` direction (``n=Nx=Ny`` in
the code). We perform experiments with :math:`h_0>h_1>h_2\cdots` and compute
the corresponding errors :math:`E_0, E_1, E_3` and so forth.  Assuming
:math:`E_i=Ch_i^r` for unknown constants :math:`C` and :math:`r`, we can compare two
consecutive experiments, :math:`E_i=Ch_i^r` and :math:`E_{i-1}=Ch_{i-1}^r`, and
solve for :math:`r`:

.. math::
        
        r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace .}
        

The :math:`r` values should approach the expected convergence
rate ``degree+1`` as :math:`i` increases.

The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by ``compute_errors``:

.. code-block:: python

        def convergence_rate(u_exact, f, u0, p, degrees,
                             n=[2**(k+3) for k in range(5)]):
            """
            Compute convergence rates for various error norms for a
            sequence of meshes with Nx=Ny=b and P1, P2, ...,
            Pdegrees elements. Return rates for two consecutive meshes:
            rates[degree][error_type] = r0, r1, r2, ...
            """
        
            h = {}  # Discretization parameter, h[degree][experiment]
            E = {}  # Error measure(s), E[degree][experiment][error_type]
            P_degrees = 1,2,3,4
            num_meshes = 5
        
            # Perform experiments with meshes and element types
            for degree in P_degrees:
                n = 4   # Coarsest mesh division
                h[degree] = []
                E[degree] = []
                for i in range(num_meshes):
                    n *= 2
                    h[degree].append(1.0/n)
                    u = solver(p, f, u0, n, n, degree,
                               linear_solver='direct')
                    errors = compute_errors(u, u_exact)
                    E[degree].append(errors)
                    print('2*(%dx%d) P%d mesh, %d unknowns, E1=%g' %
                          (n, n, degree, u.function_space().dim(),
                           errors['u - u_exact']))
            # Convergence rates
            from math import log as ln  # log is a dolfin name too
            error_types = list(E[1][0].keys())
            rates = {}
            for degree in P_degrees:
                rates[degree] = {}
                for error_type in sorted(error_types):
                    rates[degree][error_type] = []
                    for i in range(num_meshes):
                        Ei   = E[degree][i][error_type]
                        Eim1 = E[degree][i-1][error_type]
                        r = ln(Ei/Eim1)/ln(h[degree][i]/h[degree][i-1])
                        rates[degree][error_type].append(round(r,2))
            return rates
        
        def convergence_rate_sin():
            """Compute convergence rates for u=sin(x)*sin(y) solution."""
            omega = 1.0
            u_exact = Expression('sin(omega*pi*x[0])*sin(omega*pi*x[1])',
                                 omega=omega)
            f = 2*omega**2*pi**2*u_exact
            u0 = Constant(0)
            p = Constant(1)
            # Note: P4 for n>=128 seems to break down
            rates = convergence_rates(u_exact, f, u0, p, degrees=4,
                                      n=[2**(k+3) for k in range(5)])
            # Print rates
            print('\n\n')
            for error_type in error_types:
                print(error_type)
                for degree in P_degrees:
                    print('P%d: %s' %
                          (degree, str(rates[degree][error_type])[1:-1]))

Note how make a complete general function ``convergence_rate``, aimed at
any 2D Poisson problem in the class we now can solve, and then call
this general function in ``convergence_rate_sin`` for a special test
case.

Test problem          (3)
~~~~~~~~~~~~~~~~~~~~~~~~~

The section :ref:`tut:poisson:gradu` and specify a more complicated solution,

.. math::
        
        u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)
        

on the unit square.
This choice implies :math:`f(x,y)=2\omega^2\pi^2 u(x,y)`.
With :math:`\omega` restricted to an integer
it follows that :math:`u_0=0`.

We need to define the
appropriate boundary conditions, the exact solution, and the :math:`f` function
in the code:

.. code-block:: python

        def boundary(x, on_boundary):
            return on_boundary
        
        bc = DirichletBC(V, Constant(0.0), boundary)
        
        omega = 1.0
        u_e = Expression('sin(omega*pi*x[0])*sin(omega*pi*x[1])',
                         omega=omega)
        
        f = 2*pi**2*omega**2*u_e

Experiments
~~~~~~~~~~~

Calling ``convergence_rate_sin()`` gives some interesting results.
Using the error measure ``E5`` based on the infinity norm of the
difference of the degrees of freedom, we have

=======  ===========  ============  ============  ============  =============  
element  :math:`n=8`  :math:`n=16`  :math:`n=32`  :math:`n=64`  :math:`n=128`  
=======  ===========  ============  ============  ============  =============  
P1              1.99          1.97          1.99           2.0            2.0  
P2              3.99          3.96          3.99           4.0           3.99  
P3              3.96          3.89          3.96          3.99            4.0  
P4              3.75          4.99           5.0           5.0                 
=======  ===========  ============  ============  ============  =============  

The computations with P4 elements on a :math:`128\times 128` with a
direct solver (UMFPACK) on a small laptop broke down.
Otherwise we achieve expected results: the error goes like
:math:`h^{d+1}` for elements of degree :math:`d`. Also :math:`L^2` norms based
on the ``errornorm`` gives the expected :math:`h^{d+1}` rate for
:math:`u` and :math:`h^d` for :math:`\nabla u`.

However, using ``(u - u_exact)**2`` for the error computation, which implies
interpolating ``u_exact`` onto the same space as ``u``, results in :math:`h^4`
convergence for P2 elements.

=======  ===========  ============  ============  ============  =============  
element  :math:`n=8`  :math:`n=16`  :math:`n=32`  :math:`n=64`  :math:`n=128`  
=======  ===========  ============  ============  ============  =============  
P1              1.98          1.94          1.98           2.0            2.0  
P2              3.98          3.95          3.99          3.99           3.99  
P3              3.69          4.03          4.01          3.95           2.77  
=======  ===========  ============  ============  ============  =============  

This is an example where it is important to interpolate ``u_exact`` to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.

.. Problems with interpolate(u,Ve) - interpolate(u_exact,Ve) for

.. high degree and large meshes. Rounding errors? errornorm is the

.. remedy?

.. interpolate(u,Ve) - interpolate(u_exact,Ve)

.. P1: 1.98, 1.96, 1.99, 2.0, 2.0

.. P2: 3.01, 3.03, 3.01, 3.0, 3.02

.. P3: 2.7, 4.02, 4.0, 2.63, 0.17

.. P4: 1.54, 5.11, 0.91, 0.15, -0.01

Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section :ref:`tut:poisson1:verify1` and many other places in this tutorial).

