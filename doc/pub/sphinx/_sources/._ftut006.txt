.. !split

Visualization
=============

Perhaps you are not particularly amazed by viewing the simple surface
of :math:`u` in the test problem used in the previous sections.  However,
solving a real physical problem with a more interesting and amazing
solution on the screen is only a matter of specifying a more exciting
domain, boundary condition, and/or right-hand side :math:`f`.  The present
chapter starts with the solver for a membrane deflection, where the
geometry is a circle instead of the unit square, and where the
involved functions have more exciting shapes. We then go on with
explaining how the membrane deflection and the pressure load can be
visualized, using both the built-in FEniCS visualization tool and the
powerful application Paraview. Finally, we return to box-shaped
domains with uniform partition and show how the unstructured data in
FEniCS finite element solvers can be transformed to structured mesh
representations like those commonly used for finite difference
methods. The structured mesh representation, whenever possible,
gives greater flexibility
with respect to visualization and data analysis.

.. _tut:poisson:membrane:

Deflection of a circular membrane
---------------------------------

The problem
~~~~~~~~~~~

One possible physical problem regards the deflection :math:`D(x,y)` of an
elastic circular membrane with radius :math:`R`, subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is

.. _Eq:_auto13:

.. math::

    \tag{25}
    -T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},
        
        

with

.. _Eq:_auto14:

.. math::

    \tag{26}
    p(x,y) = {A\over 2\pi\sigma}\exp{\left(
        - {1\over2}\left( {x-x_0\over\sigma}\right)^2
        - {1\over2}\left( {y-y_0\over\sigma}\right)^2
        \right)}\, .
        
        

Here, :math:`T` is the tension in the membrane (constant), :math:`p` is the external
pressure load,
:math:`A` the amplitude of the pressure, :math:`(x_0,y_0)` the localization of
the Gaussian pressure function, and :math:`\sigma` the "width" of this
function. The boundary of the membrane has no
deflection, implying :math:`D=0` as boundary condition.

.. For scaling and verification it is convenient to simplify the problem

.. to find an analytical solution. In the limit :math:`\sigma\rightarrow\infty`,

.. :math:`p\rightarrow A/(2\pi\sigma)` (constant pressure throughout :math:`\Omega`),

.. and we can easily find an analytical solution

.. of the problem by integrating the Poisson equation in the

.. radial coordinate: :math:`r\in [0,R]`. The result becomes

.. :math:`D(r)=(r^2-R^2)A/(8\pi\sigma T)`.

Scaling
~~~~~~~

The localization of the pressure, :math:`(x_0,y_0)`, is for simplicity
set to :math:`(0, R_0)`.
There are many physical parameters in this problem, and we can benefit
from grouping them by means of scaling. Let us introduce dimensionless
coordinates :math:`\bar x = x/R`, :math:`\bar y = y/R`, and a dimensionless
deflection :math:`w=D/D_c`, where :math:`D_c` is a characteristic size of the
deflection. Introducing :math:`\bar R_0=R_0/R`, we get

.. math::
         \frac{\partial^2 w}{\partial\bar x^2} +
        \frac{\partial^2 w}{\partial\bar y^2}= \alpha
        \exp{\left(
        - \beta^2(\bar x^2
        + (\bar y-\bar R_0)^2)\right)}\hbox{ for } \bar x^2 + \bar y^2 < 1,

where

.. math::
         \alpha = \frac{R^2A}{2\pi T D_c\sigma},\quad\beta = \frac{R}{\sqrt{2}\sigma}{\thinspace .}

With an appropriate scaling, :math:`\bar w` and its derivatives are of size
unity, so the left-hand side of the scaled PDE is about unity in size,
while the right-hand side has :math:`\alpha` as its characteristic size.
This suggest choosing :math:`\alpha` to be unity, or around unit.
We shall in particular choose :math:`\alpha=4`. With this value,
the solution is :math:`w(\bar x,\bar y) = 1-\bar x^2 - \bar y^2`.
(One can also find the analytical solution in scaled coordinates and show
that the maximum deflection :math:`D(0,0)` is :math:`D_c` if we choose :math:`\alpha=4`
to determine :math:`D_c`.)
With :math:`D_c=AR^2/(8\pi\sigma T)`
and dropping the bars we get the scaled problem

.. _Eq:tut:poisson1:membrane:scaled:eq:

.. math::

    \tag{27}
    \nabla^2w = 4\exp{\left(
        - \beta^2(x^2
        + (y-R_0)^2)\right)},
        
        

to be solved over the unit circle with :math:`w=0` on the boundary.
Now there are only two parameters to vary: the dimensionless extent
of the pressure, :math:`\beta`, and the localization of the pressure peak, :math:`R_0\in [0,1]`.
As :math:`\beta\rightarrow 0`, we
have a special case with solution :math:`w=1-x^2-y^2`.

Given a computed :math:`w`, the physical deflection is given by

.. math::
         D = \frac{AR^2}{8\pi\sigma T}w{\thinspace .}

Implementation          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Very few modifications of the software in
``p2D_iter.py`` are required. Actually, the ``solver`` function
can be reused, except that the domain is now a circle and not a
square. We change the ``solver`` function by letting the mesh be
an argument ``mesh`` (instead of ``Nx`` and ``Ny``):

.. code-block:: python

        def solver(
            f, u0, mesh, degree=1,
            linear_solver='Krylov', # Alt: 'direct'
            ...):
            V = FunctionSpace(mesh, 'Lagrange', degree)
            ...

A mesh over the unit circle can be created by the ``mshr`` tool in
FEniCS:

.. code-block:: python

        from mshr import *
        domain = Circle(Point(0.0, 0.0), 1.0)
        mesh = generate_mesh(domain, n)

The ``Circle`` shape from ``mshr`` takes the center and radius of the circle
as the two first arguments, while ``n`` is the resolution, here the
suggested number of cells per radius.

.. index:: Expresion

.. index:: Expression with parameters

The right-hand side pressure function
is represented by an ``Expression`` object. There
are two physical parameters in the formula for :math:`f` that enter the
expression string and these parameters must have their values set
by keyword arguments:

.. code-block:: python

        p = Expression(
            '4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))',
            beta=beta, R0=R0)

The coordinates in ``Expression`` objects *must* be a vector
with indices 0, 1, and 2, and with the name ``x``. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set

.. code-block:: python

        f.beta = 12
        f.R0 = 0.3

.. index:: interpolation

It would be of interest to visualize :math:`p` along with :math:`w` so that we can
examine the pressure force and the membrane's response.  We must then transform
the formula (``Expression``) to a finite element function
(``Function``).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from :math:`p`. That is, we interpolate :math:`p`:

.. code-block:: python

        p = interpolate(p, V)

Calling ``plot(p)`` will produce a plot of :math:`p`. Note that the assignment
to ``p`` destroys the previous ``Expression`` object ``p``, so if
it is of interest to still have access to this object, another name must be used
for the ``Function`` object returned by ``interpolate``.

We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case :math:`\beta =0`.

The final program is found in the file ``membrane.py``, located
in the ``poisson`` directory. The key function to simulate
membrane deflection is named ``application``.

.. code-block:: python

        from dolfin import *
        from mshr import *
        import numpy as np
        
        def solver(
            f, u0, mesh, degree=1,
            linear_solver='Krylov', # Alt: 'direct'
            abs_tol=1E-5,           # Absolute tolerance in Krylov solver
            rel_tol=1E-3,           # Relative tolerance in Krylov solver
            max_iter=1000,          # Max no of iterations in Krylov solver
            log_level=PROGRESS,     # Amount of solver output
            dump_parameters=False,  # Write out parameter database?
            ):
            """
            Solve -Laplace(u)=f on given mesh with Lagrange elements
            of specified degree and u=u0 (Expresssion) on the boundary.
            """
            V = FunctionSpace(mesh, 'Lagrange', degree)
        
            def u0_boundary(x, on_boundary):
                return on_boundary
        
            bc = DirichletBC(V, u0, u0_boundary)
        
            # Define variational problem
            u = TrialFunction(V)
            v = TestFunction(V)
            a = inner(nabla_grad(u), nabla_grad(v))*dx
            L = f*v*dx
        
            # Compute solution
            u = Function(V)
        
            if linear_solver == 'Krylov':
                prm = parameters['krylov_solver'] # short form
                prm['absolute_tolerance'] = abs_tol
                prm['relative_tolerance'] = rel_tol
                prm['maximum_iterations'] = max_iter
                print(parameters['linear_algebra_backend'])
                set_log_level(log_level)
                if dump_parameters:
                    info(parameters, True)
                solver_parameters = {'linear_solver': 'gmres',
                                     'preconditioner': 'ilu'}
            else:
                solver_parameters = {'linear_solver': 'lu'}
        
            solve(a == L, u, bc, solver_parameters=solver_parameters)
            return u
        
        
        def application(beta, R0, num_elements_radial_dir):
            # Scaled pressure function
            p = Expression(
                '4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))',
                beta=beta, R0=R0)
        
            # Generate mesh over the unit circle
            domain = Circle(Point(0.0, 0.0), 1.0)
            mesh = generate_mesh(domain, num_elements_radial_dir)
        
            w = solver(p, Constant(0), mesh, degree=1,
                       linear_solver='direct')
            w.rename('w', 'deflection')  # set name and label (description)
        
            # Plot scaled solution, mesh and pressure
            plot(mesh, title='Mesh over scaled domain')
            plot(w, title='Scaled ' + w.label())
            V = w.function_space()
            p = interpolate(p, V)
            p.rename('p', 'pressure')
            plot(p, title='Scaled ' + p.label())

Choosing a very peak-formed pressure with large :math:`\beta` (e.g., :math:`\beta
\geq 20`) and a location :math:`R_0` toward the circular boundary (e.g.,
:math:`R_0=0.5`), may produce an exciting visual demonstrations of the very
smoothed elastic response to a peak force (or mathematically, the
smoothing properties of the inverse of the Laplace operator).  One
needs to experiment with the mesh resolution to get a smooth visual
representation of :math:`p`.  You are strongly encouraged to play around
with the plots and different mesh resolutions:

.. code-block:: text

        Terminal> python -c 'import membrane as m; m.application()' \ 
                  membrane.py

.. _tut:quickviz:

Quick visualization with VTK
----------------------------

.. index:: visualization

.. index:: plotting

.. index:: VTK

As we go along with examples it is fun to play around with
``plot`` commands and visualize what is computed. This section explains
some useful visualization features.

The ``plot`` command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.

.. index:: membranev.p

We have made a program ``membrane.py`` for the membrane deflection
problem in the section :ref:`tut:poisson:membrane` and added various
demonstrations of plotting capabilities. You are encouraged to play around with
``membrane.py`` and modify the code as you read about various features.

.. index:: plot

The ``plot`` function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:

.. code-block:: python

        plot(mesh, title='Finite element mesh')
        plot(w, wireframe=True, title='Solution')

Axes can be turned on by the ``axes=True`` argument, while
``interactive=True`` makes the program hang at the plot command - you have
to type ``q`` in the plot window to terminate the plot and continue execution.

The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the ``Help`` text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,

 * pressing ``m`` turns visualization of the mesh on and off,

 * pressing ``b`` turns on and off a bounding box,

 * pressing ``p`` dumps the plot to a PNG file,

 * pressing ``P`` dumps the plot to a PDF file,

 * pressing `Ctrl +' stretches the surface in the :math:`z` direction,

 * pressing `Ctrl -' shrinks++ the surface in the :math:`z` direction,

 * pressing `Ctrl w' closes the plot window,

 * pressing `Ctrl q' closes all plot windows.

The plots created by pressing ``p`` or ``P`` are stored in files with
names ``dolfin_plot_X.png`` or ``dolfin_plot_X.pdf``,
where ``X`` is an integer that is increase by one from the last plot
that was made. The file stem ``dolfin_plot_`` can be set to something
more suitable through the ``hardcopy_prefix`` keyword argument to the
``plot`` function,
for instance, ``plot(f, hardcopy_prefix='pressure')``.

.. index:: rotate PDF plots

.. index:: pdftk

Plots stored in PDF format need to be rotated 90 degrees before
inclusion in documents. This can be done by the ``convert -rotate 90``
command (from the ImageMagick utility), but the resulting file has
then no more high-resolution PDF vector graphics. A better solution
is therefore to use ``pdftk`` to preserve the vector graphics:

.. code-block:: text

        Terminal> pdftk dolfin_plot_1.pdf cat 1-endnorth output out.pdf

For making plots in batch, we can do the following:

.. code-block:: python

        viz_w = plot(w, interactive=False)
        viz_w.elevate(-10)  # adjust (lift) camera from the default view
        viz_w.plot(w)       # bring new settings into action
        viz_w.write_png('deflection')  # make deflection.png
        viz_w.write_pdf('deflection')  # make deflection.pdf
        # Rotate pdf file (right) from landscape to portrait
        import os
        os.system('pdftk deflection.pdf cat 1-endnorth output w.pdf')

The commands above appear in the ``application2``
function in the ``membrane.py`` file.

.. _tut:poisson:2D:fig1:

.. figure:: membrane_deflection.png
   :width: 480

   *Plot of the deflection of a membrane*

Paraview
--------

.. _tut:structviz:

Taking advantage of structured mesh data
----------------------------------------

.. index:: structured mesh

.. index::
   single: visualization, structured mesh

.. index:: scitools

When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for *structured data*.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.

.. index:: BoxField

A necessary first step is to transform our ``mesh`` object to an object
representing a rectangle with equally-shaped *rectangular* cells.
The second step is to
transform the one-dimensional array of nodal values to a
two-dimensional array holding the values at the corners of the cells
in the structured mesh. We want to access a value by
its :math:`i` and :math:`j` indices, :math:`i` counting cells in the :math:`x` direction, and
:math:`j` counting cells in the :math:`y` direction.  This transformation is in
principle straightforward, yet it frequently leads to obscure indexing
errors, so using software tools to ease the work is advantageous.

In the directory ``src/modules``, associated with this booklet,
we have included a Python module ``BoxField`` that can take a finite
element function ``u`` computed by a FEniCS software and represent
it on a structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: ``[i]`` in 1D, ``[i,j]`` in 2D, and
``[i,j,k]`` in 3D. Given a finite element function ``u``,
the following function returns a ``BoxField`` object that represents
``u`` on a structured mesh:

.. code-block:: python

        def structured_mesh(u, divisions):
            """Represent u on a structured mesh."""
            # u must have P1 elements, otherwise interpolate to P1 elements
            u2 = u if u.ufl_element().degree() == 1 else \ 
                 interpolate(u, FunctionSpace(mesh, 'Lagrange', 1))
            mesh = u.function_space().mesh()
            from BoxField import dolfin_function2BoxField
            u_box = dolfin_function2BoxField(
                u2, mesh, divisions, uniform_mesh=True)
            return u_box

Note that we can only turn functions on meshes with P1 elements into
``BoxField`` objects, so if ``u`` is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (``divisions``).

The ``u_box`` object contains several useful data structures:

 * ``u_box.grid``: object for the structured mesh

 * ``u_box.grid.coor[X]``: grid coordinates in ``X=0`` direction

 * ``u_box.grid.coor[Y]``: grid coordinates in ``Y=1`` direction

 * ``u_box.grid.coor[Z]``: grid coordinates in ``Z=2`` direction

 * ``u_box.grid.coorv[X]``: vectorized version of ``u_box.grid.coor[X]``
   (for vectorized computations or surface plotting)

 * ``u_box.grid.coorv[Y]``: vectorized version of ``u_box.grid.coor[Y]``

 * ``u_box.grid.coorv[Z]``: vectorized version of ``u_box.grid.coor[Z]``

 * ``u_box.values``: ``numpy`` array holding the ``u`` values;
   ``u_box.values[i,j]`` holds ``u`` at the mesh point with coordinates 

|    ``(u_box.grid.coor[X], u_box.grid.coor[Y])``

Iterating over points and values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let us go back to the ``solver`` function in the
``p2D_vc.py`` code from
the section :ref:`tut:possion:2D:varcoeff`, compute ``u``, map it onto a
``BoxField`` object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:

.. code-block:: python

        u = solver(p, f, u0, nx, ny, 1, linear_solver='direct')
        u_box = structured_mesh(u, (nx, ny))
        u_ = u_box.values       # numpy array
        X = 0;  Y = 1           # for indexing in x and y direction
        
        # Iterate over 2D mesh points (i,j)
        print('u_ is defined on a structured mesh with %s points' %
              str(u_.shape))
        for j in range(u_.shape[1]):
            for i in range(u_.shape[0]):
                print('u[%d,%d]=u(%g,%g)=%g' %
                      (i, j,
                       u_box.grid.coor[X][i], u_box.grid.coor[X][j],
                       u_[i,j]))

Finite difference approximations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that with ``u_``, we can easily express finite difference approximation
of derivatives:

.. code-block:: python

        x = u_box.grid.coor[X]
        dx = x[1] - x[0]
        u_xx = (u_[i-1,j] - 2*u_[i,j] + u_[i+1,j])/dx**2

.. index:: surface plot (structured mesh)

Surface plot
~~~~~~~~~~~~

The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure :ref:`tut:structviz:fig1` (upper left):

.. code-block:: python

        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        from matplotlib import cm
        fig = plt.figure()
        ax = fig.gca(projection='3d')
        cv = u_box.grid.coorv  # vectorized mesh coordinates
        ax.plot_surface(cv[X], cv[Y], u_, cmap=cm.coolwarm,
                        rstride=1, cstride=1)
        plt.title('Surface plot of solution')

The key issue is to know that the coordinates needed for the surface
plot is in ``u_box.grid.coorv`` and that the values are in ``u_``.

.. _tut:structviz:fig1:

.. figure:: p2D_vc_structmesh2.png
   :width: 800

   *Various plots of the solution on a structured mesh*

.. index:: contour plot

Contour plot
~~~~~~~~~~~~

A contour plot can also be made by Matplotlib:

.. code-block:: python

        fig = plt.figure()
        ax = fig.gca()
        levels = [1.5, 2.0, 2.5, 3.5]
        cs = ax.contour(cv[X], cv[Y], u_, levels=levels)
        plt.clabel(cs)  # add labels to contour lines
        plt.axis('equal')
        plt.title('Contour plot of solution')

The result appears in Figure :ref:`tut:structviz:fig1` (upper right).

Curve plot through the mesh
~~~~~~~~~~~~~~~~~~~~~~~~~~~

A handy feature of ``BoxField`` objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot :math:`u` along
the line :math:`y=0.4`. The mesh points, ``x``, and the :math:`u` values
along this line, ``u_val``, are extracted by

.. code-block:: python

        start = (0, 0.4)
        X = 0
        x, u_val, y_fixed, snapped = u_box.gridline(start, direction=X)

The variable ``snapped`` is true if the line had to be snapped onto a
gridline and in that case ``y_fixed`` holds the snapped
(altered) :math:`y` value. To avoid interpolation in the structured mesh,
``snapped`` is in fact *always* true.

A comparison of the numerical and exact solution along the line
:math:`y=0.5` (snapped from :math:`y=0.4`) is made by the following code:

.. code-block:: python

        start = (0, 0.4)
        x, u_val, y_fixed, snapped = u_box.gridline(start, direction=X)
        u_e_val = [u0((x_, y_fixed)) for x_ in x]
        
        plt.figure()
        plt.plot(x, u_val, 'r-')
        plt.plot(x, u_e_val, 'bo')
        plt.legend(['P1 elements', 'exact'], loc='upper left')
        plt.title('Solution along line y=%g' % y_fixed)
        plt.xlabel('x');  plt.ylabel('u')

See Figure :ref:`tut:structviz:fig1` (lower left) for the resulting curve plot.

Curve plot of the flux
~~~~~~~~~~~~~~~~~~~~~~

Let us also compare the numerical and
exact flux :math:`-p\partial u/\partial x` along the same line as above:

.. code-block:: python

        flux_u = flux(u, p)
        flux_u_x, flux_u_y = flux_u.split(deepcopy=True)
        
        # Plot the numerical and exact flux along the same line
        flux2_x = flux_u_x if flux_u_x.ufl_element().degree() == 1 \ 
                  else interpolate(flux_x,
                       FunctionSpace(u.function_space().mesh(),
                                     'Lagrange', 1))
        flux_u_x_box = structured_mesh(flux_u_x, (nx,ny))
        x, flux_u_val, y_fixed, snapped = \ 
           flux_u_x_box.gridline(start, direction=X)
        y = y_fixed
        
        plt.figure()
        plt.plot(x, flux_u_val, 'r-')
        plt.plot(x, flux_u_x_exact(x, y_fixed), 'bo')
        plt.legend(['P1 elements', 'exact'], loc='upper right')
        plt.title('Flux along line y=%g' % y_fixed)
        plt.xlabel('x');  plt.ylabel('u')

The second ``plt.plot`` command
requires a Python function ``flux_u_x_exact(x,y)`` to be
available for the exact flux expression.

Note that Matplotlib is one choice of plotting package. With the unified
interface in the `SciTools package <https://github.com/hplgit/scitools>`__ one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.

.. index:: sympy

Test problem          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~

The graphics referred to in Figure :ref:`tut:structviz:fig1` correspond to
a test problem with prescribed solution :math:`{u_{\small\mbox{e}}} = H(x)H(y)`, where

.. math::
         H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x){\thinspace .}

We just fit a function :math:`f(x,y)` in the PDE (can choose :math:`p=1`),
and notice that :math:`u=0` along the
boundary of the unit square. Although it is easy to carry out the
differentiation of :math:`f` by hand and hardcode the resulting expressions
in an ``Expression`` object, a more reliable habit is to use Python's
symbolic computing engine, ``sympy``, to perform mathematics and
automatically turn formulas into C++ syntax for ``Expression`` objects.
The following text assumes some familiarity with ``sympy`` and illustrates
how FEniCS programmers may take advantage of symbolic computing.

We start out with defining the exact solution in ``sympy``:

.. code-block:: python

        from sympy import exp, sin, pi  # for use in math formulas
        import sympy as sym
        H = lambda x: exp(-16*(x-0.5)**2)*sin(3*pi*x)
        x, y = sym.symbols('x[0], x[1]')
        u = H(x)*H(y)


.. admonition:: Define symbolic coordinates as required in ``Expression`` objects

   Note that we would normally write ``x, y = sym.symbols('x y')``, but
   if we want the resulting expressions to be have valid syntax for
   ``Expression`` objects, and then :math:`x` reads ``x[0]`` and :math:`y` must be ``x[1]``.
   This is easily accomplished with ``sympy`` by defining the names of ``x`` and
   ``y`` as ``x[0]`` and ``x[1]``: ``x, y = sym.symbols('x[0] x[1]')``.




Turning the expression for ``u`` into C or C++ syntax for ``Expression`` objects
needs two steps. First we ask for the C code of the expression,

.. code-block:: python

        u_c = sym.printing.ccode(u)

Then we do some editing of ``u_c`` to match the required syntax of
``Expression`` objects. Printing ``u_c`` gives (here manually broken up as
two lines)

.. code-block:: text

        -exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
        sin(3*M_PI*x[0])*sin(3*M_PI*x[1])

The necessary syntax adjustment is replacing
the symbol ``M_PI`` for :math:`\pi` in C/C++ by ``DOLFIN_PI``:

.. code-block:: python

        u_c = u_c.replace('M_PI', 'DOLFIN_PI')
        u0 = Expression(u_c)

Thereafter, we can progress with the computation of :math:`f = -\nabla\cdot(p\nabla u)`:

.. code-block:: python

        p = 1
        f = sym.diff(-p*sym.diff(u, x), x) + sym.diff(-p*sym.diff(u, y), y)
        f = sym.simplify(f)
        f_c = sym.printing.ccode(f)
        f_c = f_c.replace('M_PI', 'DOLFIN_PI')
        f = Expression(f_c)

We also need a Python function for the exact flux :math:`-p\partial u/\partial x`:

.. code-block:: python

        flux_u_x_exact = sym.lambdify([x, y], -p*sym.diff(u, x),
                                      modules='numpy')

It remains to define ``p = Constant(1)`` and set ``nx`` and ``ny`` before calling
``solver`` to compute the finite element solution of this problem.

.. FIGURE: [fig/p2D_vc_structmesh, width=800 frac=1] Various plots of the solution on a structured mesh.

