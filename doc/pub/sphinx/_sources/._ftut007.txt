.. !split

Multiple domain and boundaries
==============================

.. _tut:poisson1:DN:

Combining Dirichlet and Neumann conditions
------------------------------------------

Let us make a slight extension of our two-dimensional Poisson problem
from the section :ref:`tut:poisson1:bvp` and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition :math:`u=u_0` at the left and right sides, :math:`x=0` and
:math:`x=1`, while the Neumann condition

.. math::
        
        -{\partial u\over\partial n}=g
        

is applied to the remaining
sides :math:`y=0` and :math:`y=1`.
The Neumann condition is also known as a *natural boundary condition*
(in contrast to an essential boundary condition).

.. index:: Neumann boundary conditions

PDE problem
~~~~~~~~~~~

Let :math:`\Gamma_D` and :math:`\Gamma_N` denote the parts of :math:`\partial\Omega`
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

.. _Eq:_auto15:

.. math::

    \tag{31}
    - \nabla^2 u = f \mbox{ in } \Omega,  
        
        

.. _Eq:_auto16:

.. math::

    \tag{32}
    u = u_0 \mbox{ on } \Gamma_D,       
        
        

.. _Eq:_auto17:

.. math::

    \tag{33}
    - {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}
        
        

Again we choose :math:`u=1+x^2 + 2y^2` as the exact solution and adjust :math:`f`, :math:`g`, and
:math:`u_0` accordingly:

.. math::
        
        f &= -6,\\ 
        g &= \left\lbrace\begin{array}{ll}
        -4, & y=1\\ 
        0,  & y=0
        \end{array}\right.\\ 
        u_0 &= 1 + x^2 + 2y^2{\thinspace .}
        

For ease of programming we may introduce a :math:`g` function defined over the whole
of :math:`\Omega` such that :math:`g` takes on the right values at :math:`y=0` and
:math:`y=1`. One possible extension is

.. math::
        
        g(x,y) = -4y{\thinspace .}
        

Variational formulation          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
:math:`v` is only zero on :math:`\Gamma_D`. We have

.. math::
        
         -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
        = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
        \partial n}v {\, \mathrm{d}s},
        

and since :math:`v=0` on :math:`\Gamma_D`,

.. math::
        
        - \int_{\partial\Omega}{\partial u\over
        \partial n}v {\, \mathrm{d}s}
        =
        - \int_{\Gamma_N}{\partial u\over
        \partial n}v {\, \mathrm{d}s}
        = \int_{\Gamma_N}gv {\, \mathrm{d}s},
        

by applying the boundary condition on :math:`\Gamma_N`.
The resulting weak form reads

.. _Eq:tut:poisson:2D:DN:weak:

.. math::

    \tag{34}
    \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
        \int_{\Gamma_N} gv {\, \mathrm{d}s}
        = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}
        
        

Expressing this equation
in the standard notation :math:`a(u,v)=L(v)` is straightforward with

.. _Eq:tut:poisson2:vard:a:

.. math::

    \tag{35}
    a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},
        
        

.. _Eq:tut:poisson2:vard:L:

.. math::

    \tag{36}
    L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
        \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}  
        

Implementation          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
``p2D_plain.py``, from
the section :ref:`tut:poisson1:impl:code`,
we realize that the statements remain almost the same.
Only two adjustments are necessary:

  * The function describing the boundary where Dirichlet conditions
    apply must be modified.

  * The new boundary term must be added to the expression in ``L``.

The first adjustment can be coded as

.. code-block:: python

        def Dirichlet_boundary(x, on_boundary):
            if on_boundary:
                if x[0] == 0 or x[0] == 1:
                    return True
                else:
                    return False
            else:
                return False

A more compact implementation reads

.. code-block:: python

        def Dirichlet_boundary(x, on_boundary):
            return on_boundary and (x[0] == 0 or x[0] == 1)


.. admonition:: Never use ``==`` for comparing real numbers

   A list like ``x[0] == 1`` should never be used if ``x[0]`` is a real number,
   because rounding errors in ``x[0]`` may make the test fail even when it is
   mathematically correct. Consider
   
   .. code-block:: python
   
           >>> 0.1 + 0.2 == 0.3
           False
           >>> 0.1 + 0.2
           0.30000000000000004
   
   Comparison of real numbers need to use tolerances! The values of the
   tolerances depend on the size of the numbers involved in arithmetic
   operations:
   
   .. code-block:: python
   
           >>> abs(0.1+0.2 - 0.3)
           5.551115123125783e-17
           >>> abs(1.1+1.2 - 2.3)
           0.0
           >>> abs(10.1+10.2 - 20.3)
           3.552713678800501e-15
           >>> abs(100.1+100.2 - 200.3)
           0.0
           >>> abs(1000.1+1000.2 - 2000.3)
           2.2737367544323206e-13
           >>> abs(10000.1+10000.2 - 20000.3)
           3.637978807091713e-12
   
   For numbers around unity, tolerances as low as :math:`3\cdot 10^{-16}` can be used
   (in fact, this tolerance is known as ``DOLFIN_EPS`` in the ``dolfin`` package),
   otherwise an appropriate tolerance must be found.
   
   Testing for ``x[0] == 1`` should therefore be implemented as
   
   .. code-block:: python
   
           tol = 1E-14
           if abs(x[0] - 1) < tol:
               ...




Here is a new boundary function using tolerances in the test:

.. code-block:: python

        def Dirichlet_boundary(x, on_boundary):
            tol = 1E-14   # tolerance for coordinate comparisons
            return on_boundary and \ 
                   (abs(x[0]) < tol or abs(x[0] - 1) < tol)

The second adjustment of our program concerns the definition of ``L``,
where we have to add a boundary integral and a definition of the :math:`g`
function to be integrated:

.. code-block:: python

        g = Expression('-4*x[1]')
        L = f*v*dx - g*v*ds

The ``ds`` variable implies a boundary integral, while ``dx``
implies an integral over the domain :math:`\Omega`.
No more modifications are necessary.

.. _tut:poisson:multiple:Dirichlet:

Multiple Dirichlet conditions
-----------------------------

The PDE problem from the previous section applies a function :math:`u_0(x,y)`
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have :math:`m` functions for
setting Dirichlet conditions on :math:`m` parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.

Let us return to the case from the section :ref:`tut:poisson1:DN` and define
two separate functions for the two Dirichlet conditions:

.. math::
        
            - \nabla^2 u &= -6 \mbox{ in } \Omega, \\ 
            u &= u_L \mbox{ on } \Gamma_0, \\ 
            u &= u_R \mbox{ on } \Gamma_1, \\ 
            - {\partial u\over\partial n} &= g \mbox{ on } \Gamma_N {\thinspace .}
        

Here, :math:`\Gamma_0` is the boundary :math:`x=0`, while :math:`\Gamma_1` corresponds
to the boundary :math:`x=1`.  We have that :math:`u_L = 1 + 2y^2`, :math:`u_R = 2 +
2y^2`, and :math:`g=-4y`.

Functions for marking Dirichlet boundaries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the left boundary :math:`\Gamma_0` we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a ``DirichletBC`` object:

.. code-block:: python

        u_L = Expression('1 + 2*x[1]*x[1]')
        
        def left_boundary(x, on_boundary):
            tol = 1E-14   # tolerance for coordinate comparisons
            return on_boundary and abs(x[0]) < tol
        
        Gamma_0 = DirichletBC(V, u_L, left_boundary)

For the boundary :math:`x=1` we write a similar code snippet:

.. code-block:: python

        u_R = Expression('2 + 2*x[1]*x[1]')
        
        def right_boundary(x, on_boundary):
            tol = 1E-14   # tolerance for coordinate comparisons
            return on_boundary and abs(x[0] - 1) < tol
        
        Gamma_1 = DirichletBC(V, u_R, right_boundary)

The various essential conditions are then collected in a list
and used in the solution process:

.. code-block:: python

        bcs = [Gamma_0, Gamma_1]
        ...
        solve(a == L, u, bcs)
        # or
        problem = LinearVariationalProblem(a, L, u, bcs)
        solver  = LinearVariationalSolver(problem)
        solver.solve()

In other problems, where the :math:`u` values are constant at a part of the
boundary, we may use a simple ``Constant`` object instead of an
``Expression`` object.

Classes for marking Dirichlet boundaries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of using a function like ``left_boundary(x, on_boundary)`` to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class ``SubDomain`` and has a method ``inside(self, x, on_boundary)`` for the code that returns whether the ``point`` is on the
boundary in question or not. Our previous ``left_boundary`` function
takes this form in its class version:

.. code-block:: python

        class LeftBoundary(SubDomain):
            def inside(self, x, on_boundary):
                tol = 1E-14   # tolerance for coordinate comparisons
                return on_boundary and abs(x[0]) < tol
        
        left_boundary = LeftBoundary()
        Gamma_0 = DirichletBC(V, u_L, left_boundary)

Debugging Dirichlet conditions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the ``get_boundary_values`` method in the ``DirichletBC`` objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding essential conditions as values. In the present problem
we can write

.. code-block:: python

        coor = mesh.coordinates()
        d2v = dof_to_vertex_map(V)
        for bc in bcs:
            bc_dict = bc.get_boundary_values()
            for dof in bc_dict:
                print('dof %2d: u=%g\t at point %s' %
                      (dof, bc_dict[dof],
        	      str(tuple(coor[d2v[dof]].tolist()))))

The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:

.. code-block:: python

        Lagrange_1st_order = V.ufl_element().degree() == 1
        if Lagrange_1st_order:
            coor = mesh.coordinates()
            d2v = dof_to_vertex_map(V)
            for bc in bcs:
                bc_dict = bc.get_boundary_values()
                for dof in bc_dict:
                    print('dof %2d: u=%g' % (dof, bc_dict[dof])),
                    print('\t at point %s' %
                          (str(tuple(coor[d2v[dof]].tolist()))))

The output for a mesh made by ``UnitSquareMesh(3, 2)`` becomes

.. code-block:: text

        dof  0: u=1 	 at point (0.0, 0.0)
        dof  8: u=3 	 at point (0.0, 1.0)
        dof  4: u=1.5 	 at point (0.0, 0.5)
        dof  3: u=2 	 at point (1.0, 0.0)
        dof 11: u=4 	 at point (1.0, 1.0)
        dof  7: u=2.5 	 at point (1.0, 0.5)

.. The file ``dn2_p2D.py`` contains a complete program which

.. demonstrates the constructions above.

An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the *mesh function* concept and is therefore
left to the section :ref:`tut:poisson:mat:neumann`.

Handy methods in key FEniCS objects
-----------------------------------

.. index:: pydoc

In general,
``pydoc dolfin.X`` shows the documentation of any DOLFIN name ``X``
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.

Mesh
~~~~

Let ``mesh`` be a ``Mesh`` object.

  * ``mesh.coordinates()`` returns an array of the coordinates of
     the vertices in the mesh.

  * ``mesh.num_cells()`` returns the number of cells (triangles)
    in the mesh,

  * ``mesh.num_vertices()`` returns the number of vertices in
    the mesh (with our choice of linear Lagrange elements this equals the
    number of nodes, ``len(u_array)``, or dimension of the space ``V.dim()``),

  * ``mesh.cells()`` returns the vertex numbers of the vertices in
    each cell as a ``numpy`` array with shape
    (*number of cells*, *number of vertices in a cell*),

  * ``mesh.hmin()`` returns the minimum cell diameter ("smallest cell"),

  * ``mesh.hmax()`` returns the maximum cell diameter ("largest cell").

Writing ``print(mesh)`` dumps a short, pretty-print description
of the mesh (``print(mesh)`` actually displays the result of ``str(mesh)``,
which defines the pretty print):

.. code-block:: text

        <Mesh of topological dimension 2 (triangles) with
        16 vertices and 18 cells, ordered>

Function space
~~~~~~~~~~~~~~

Let ``V`` be a ``FunctionSpace`` object.

 * ``V.mesh()`` returns the associated mesh.

 * ``V.dim()`` returns the dimension (number of degrees of freedom).

 * ``V.ufl_element()`` returns the associated finite element.

Function
~~~~~~~~

Let ``u`` be a ``Function`` object.

 * ``u.function_space()`` returns the associated function space.

 * ``u.vector()`` returns the DOLFIN vector of degrees of freedom.

 * ``u.vector().array()`` returns a copy of the degrees of freedom
   in a ``numpy`` array.

