.. !split

.. _ch:fundamentals:

Fundamentals
%%%%%%%%%%%%


..

    The goal of this chapter is to show how a range of important PDEs
    from science and engineering can be quickly solved with a few lines
    of FEniCS code. We introduce the most
    fundamental FEniCS objects such as ``Mesh``, ``Function``,
    ``FunctionSpace``, ``TrialFunction``,
    and ``TestFunction``, and learn how to set up the variational formulation
    of the PDE problem in a way that closely resembles the mathematics.
    
    The code is made as simple as possible, we solve all linear systems
    by (sparse) Gaussian elimination, we don't use any problem-dependent
    optimizations of algorithms and code, and we only treat examples taking
    place in homogeneous media. Subsequent chapters will extend the
    examples here with more general, efficient, and sophisticated
    implementations.



The Poisson equation
====================

.. _tut:poisson1:bvp:

Mathematical problem formulation
--------------------------------

.. index:: Poisson's equation

Let us start by writing a "Hello, World!" program. In the world of
PDEs, this must be a program that solves the Poisson equation:

.. _Eq:tut:poisson1:

.. math::

    \tag{1}
    - \nabla^2 u(\boldsymbol{x}) = f(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ in } \Omega,
        
        

.. _Eq:tut:poisson1:bc:

.. math::

    \tag{2}
    u(\boldsymbol{x}) = u_0(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ on } \partial \Omega{\thinspace .} 
        

Here, :math:`u = u(\boldsymbol{x})` is the unknown function, :math:`f = f(\boldsymbol{x})` is a
prescribed function, :math:`\nabla^2` is the Laplace operator (also
often written as :math:`\Delta`), :math:`\Omega` is the spatial domain, and
:math:`\partial\Omega` is the boundary of :math:`\Omega`. A stationary PDE like
this, together with a complete set of boundary conditions, constitute
a *boundary-value problem*, which must be precisely stated before
it makes sense to start solving it with FEniCS.

In two space dimensions with coordinates :math:`x` and :math:`y`, we can write out
the Poisson equation as

.. _Eq:_auto1:

.. math::

    \tag{3}
    - {\partial^2 u\over\partial x^2} -
        {\partial^2 u\over\partial y^2} = f(x,y){\thinspace .}
        
        

The unknown :math:`u` is now a function of two variables, :math:`u = u(x,y)`, defined
over a two-dimensional domain :math:`\Omega`.

The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier - Stokes equations.

Solving a PDE such as the Poisson equation in FEniCS consists of the
following steps:

 1. Identify the computational domain (:math:`\Omega`), the PDE, its
    boundary conditions, and source terms (:math:`f`).

 2. Reformulate the PDE as a finite element variational problem.

 3. Write a Python program which defines the computational domain,
    the variational problem, the boundary conditions, and source
    terms, using the corresponding FEniCS abstractions.

 4. Call FEniCS to solve the PDE and, optionally, extend the program
    to compute derived quantities such as fluxes and averages, and
    visualize the results.

We shall now go through steps 2 - 4 in detail. The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.

.. _tut:poisson1:varform:

Finite element variational formulation
--------------------------------------

.. index:: variational formulation

FEniCS is based on the finite element method, which is a general and
efficient mathematical machinery for numerical solution of PDEs. The
starting point for the finite element methods is a PDE expressed in
*variational form*. Readers who are not familiar with variational
problems will get a brief introduction to the topic in this tutorial,
but getting and reading a proper book on the finite element method in
addition is encouraged. The section :ref:`tut:fembooks` contains a list of
some suitable books.

.. index:: test function

.. index:: trial function

The basic recipe for turning a PDE into a variational problem is to
multiply the PDE by a function :math:`v`, integrate the resulting equation
over the domain :math:`\Omega`, and perform integration by parts of terms
with second-order derivatives. The function :math:`v` which multiplies the
PDE is called a *test function*. The unknown function :math:`u` to be
approximated is referred to as a *trial function*. The terms test and
trial function are used in FEniCS programs too. Suitable function
spaces must be specified for the test and trial functions. For
standard PDEs arising in physics and mechanics such spaces are well
known.

In the present case, we first multiply the Poisson equation
by the test function :math:`v` and integrate over :math:`\Omega`:

.. _Eq:tut:poisson1:multbyv:

.. math::

    \tag{4}
    -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .} 

We then apply integration by parts to the integrand with
second-order derivatives. We find that

.. _Eq:tut:poisson1:eqbyparts:

.. math::

    \tag{5}
    -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
        = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
        \partial n}v {\, \mathrm{d}s} ,
        

where :math:`\frac{\partial u}{\partial n} = \nabla u \cdot n` is the
derivative of :math:`u` in the outward normal direction :math:`n` on the
boundary. The test function :math:`v` is required to vanish on the parts of
the boundary where the solution :math:`u` is known, which in the present
problem implies that :math:`v=0` on the whole boundary :math:`\partial\Omega`.
The second term on the right-hand side of
:ref:`(5) <Eq:tut:poisson1:eqbyparts>` therefore vanishes. From
:ref:`(4) <Eq:tut:poisson1:multbyv>` and :ref:`(5) <Eq:tut:poisson1:eqbyparts>` it
follows that

.. _Eq:tut:poisson1:weak1:

.. math::

    \tag{6}
    \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}
        
        

If we require that this equation holds for all test functions :math:`v` in
some suitable space :math:`\hat V`, the so-called *test space*, we obtain a
well-defined mathematical problem that uniquely determines the
solution :math:`u` which lies in some (possibly different) function space
:math:`V`, the so-called *trial space*.  We refer to
:ref:`(6) <Eq:tut:poisson1:weak1>` as the *weak form* or *variational form* of
the original boundary-value problem
:ref:`(1) <Eq:tut:poisson1>`--:ref:`(2) <Eq:tut:poisson1:bc>`.

The proper statement of
our variational problem now goes as follows:
Find :math:`u \in V` such that

.. _Eq:tut:poisson1:var:

.. math::

    \tag{7}
    \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} =
          \int_{\Omega} fv {\, \mathrm{d}x}
          \quad \forall v \in \hat{V}{\thinspace .}
        

The trial and test spaces :math:`V` and :math:`\hat V` are in the present
problem defined as

.. math::
        
             V      &= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}, \\ 
            \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}{\thinspace .}
        

In short, :math:`H^1(\Omega)` is the mathematically well-known Sobolev space
containing functions :math:`v` such that :math:`v^2` and :math:`|\nabla v|^2` have
finite integrals over :math:`\Omega` (essentially meaning that the functions
are continuous). The solution of the underlying PDE must lie in a
function space where also the derivatives are continuous, but the
Sobolev space :math:`H^1(\Omega)` allows functions with discontinuous
derivatives. This weaker continuity requirement of :math:`u` in the
variational statement :ref:`(7) <Eq:tut:poisson1:var>`, as a result of the
integration by parts, has great practical consequences when it comes
to constructing finite element function spaces. In particular, it
allows the use of piecewise polynomial function spaces; i.e., function
spaces constructed by stitching together polynomial functions on simple
domains such as intervals, triangles, or tetrahedrons.

The variational problem :ref:`(7) <Eq:tut:poisson1:var>` is a *continuous
problem*: it defines the solution :math:`u` in the infinite-dimensional
function space :math:`V`. The finite element method for the Poisson equation
finds an approximate solution of the variational problem
:ref:`(7) <Eq:tut:poisson1:var>` by replacing the infinite-dimensional function
spaces :math:`V` and :math:`\hat{V}` by *discrete* (finite-dimensional) trial and
test spaces :math:`V_h\subset{V}` and :math:`\hat{V}_h\subset\hat{V}`. The discrete variational problem reads: Find :math:`u_h \in
V_h \subset V` such that

.. _Eq:tut:poisson1:vard:

.. math::

    \tag{8}
    \int_{\Omega} \nabla u_h \cdot \nabla v {\, \mathrm{d}x} =
          \int_{\Omega} fv {\, \mathrm{d}x}
          \quad \forall v \in \hat{V}_h \subset \hat{V}{\thinspace .}
        

This variational problem, together with a suitable definition of the
function spaces :math:`V_h` and :math:`\hat{V}_h`, uniquely defines our approximate
numerical solution of Poisson's equation :ref:`(1) <Eq:tut:poisson1>`. The
mathematical framework may seem complicated at first glance, but the
good news is the finite element variational problem
:ref:`(8) <Eq:tut:poisson1:vard>` looks the same as the continuous variational
problem :ref:`(7) <Eq:tut:poisson1:var>`, and FEniCS can automatically solve
variational problems like :ref:`(8) <Eq:tut:poisson1:vard>`!

.. The choice of :math:`\hat{V}_h` and :math:`V_h` follows directly from the kind of

.. finite elements we want to apply in our problem. For example, choosing

.. the well-known linear triangular element with three nodes implies that

.. :math:`\hat V_h` and :math:`V_h` are the spaces of all piecewise linear functions

.. over a mesh of triangles, where the functions in :math:`\hat V_h` are zero

.. on the boundary and those in :math:`V_h` equal :math:`u_0` on the boundary.


.. admonition:: What we mean by the notation :math:`u` and :math:`V`

   The mathematics literature on variational problems writes :math:`u_h` for
   the solution of the discrete problem and :math:`u` for the solution of the
   continuous problem. To obtain (almost) a one-to-one relationship
   between the mathematical formulation of a problem and the
   corresponding FEniCS program, we shall drop the subscript :math:`_h` and use
   :math:`u` for the solution of the discrete problem and :math:`{u_{\small\mbox{e}}}` for the exact
   solution of the continuous problem, *if* we need to explicitly distinguish
   between the two. Similarly, we will let :math:`V` denote the discrete finite
   element function space in which we seek our solution.




.. _tut:poisson1:abstrat:

Abstract finite element variational formulation
-----------------------------------------------

.. index:: abstract variational formulation

It turns out to be convenient to introduce the following canonical
notation for variational problems:

.. _Eq:_auto2:

.. math::

    \tag{9}
    a(u, v) = L(v){\thinspace .}
        
        

For the Poisson equation, we have:

.. _Eq:tut:poisson1:vard:a:

.. math::

    \tag{10}
    a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},
        
        

.. _Eq:tut:poisson1:vard:L:

.. math::

    \tag{11}
    L(v) = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}  
        

From the mathematics literature, :math:`a(u,v)` is known as a *bilinear
form* and :math:`L(v)` as a *linear form*.  We shall in every linear problem
we solve identify the terms with the unknown :math:`u` and collect them in
:math:`a(u,v)`, and similarly collect all terms with only known functions in
:math:`L(v)`. The formulas for :math:`a` and :math:`L` are then coded directly in the
program.

FEniCS provides all the necessary mathematical notation needed to
express the variational problem :math:`a(u, v) = L(v)`. To solve a linear
PDE in FEniCS, such as the Poisson equation, a user thus needs to
perform only two steps:

  * Express the PDE as a (discrete) variational problem: find :math:`u\in V`
    such that :math:`a(u,v) = L(v)` for all :math:`v\in \hat{V}`.

  * Choose the finite element spaces :math:`V` and :math:`\hat V` by specifying
    the domain (the mesh) and the type of function space (polynomial
    degree and type).

.. Suggested: var coeff as early as possible!

.. A basic Poisson solver

.. Useful extensions/Useful stuff/: var coeff here

.. Visualization: membrane, vtk, paraview, structured mesh

.. Postprocessing computations: var coeff, functionals, conv rates

.. Multiple domains and boundaries

.. Stand-alone notebook?

.. (Need preprocess #if tests here since they are to be executed

.. when preprocess is run to get the right #include statements.

.. Thereafter, mako is executed and we can also have %if syntax.)

.. _tut:poisson1:testproblem:

Choosing a test problem
-----------------------

The Poisson equation :ref:`(1) <Eq:tut:poisson1>` has so far featured a general
domain :math:`\Omega` and general functions :math:`u_0` and :math:`f`. For our first
implementation, we must decide on specific choices of :math:`\Omega`, :math:`u_0`,
and :math:`f`.  It will be wise to construct a specific problem where we can
easily check that the computed solution is correct. Solutions that are
lower-order polynomials are primary candidates. Standard finite
element function spaces of degree :math:`r` will exactly reproduce
polynomials of degree :math:`r`. And piecewise linear elements (:math:`r=1`) are
able to exactly reproduce a quadratic polynomial on a uniformly
partitioned mesh. This important result can be used to verify our
implementation. We just manufacture some quadratic function in 2D as
the exact solution, say

.. _Eq:tut:poisson1:impl:uex:

.. math::

    \tag{12}
    \
        {u_{\small\mbox{e}}}(x,y) = 1 +x^2 + 2y^2{\thinspace .}
        

By inserting :ref:`(12) <Eq:tut:poisson1:impl:uex>` into the Poisson equation
:ref:`(1) <Eq:tut:poisson1>`, we find that :math:`{u_{\small\mbox{e}}}(x,y)` is a solution if

.. math::
         f(x,y) = -6,\quad u_0(x,y)={u_{\small\mbox{e}}}(x,y)=1 + x^2 + 2y^2,

regardless of the shape of the domain as long as :math:`{u_{\small\mbox{e}}}` is prescribed along
the boundary. We choose here, for simplicity,
the domain to be the unit square,

.. math::
         \Omega = [0,1]\times [0,1] {\thinspace .}

This simple but very powerful method for constructing test problems
is called the *method of manufactured solutions*: pick a simple
expression for the exact solution, plug it into the equation to obtain
the right-hand side (source term :math:`f`), then solve the equation with
this right-hand side and try to reproduce the exact solution.


.. admonition:: Tip: Try to verify your code with exact numerical solutions

   A common approach to testing the implementation of a numerical method
   is to compare the numerical
   solution with an exact analytical solution of the test problem and
   conclude that the program works if the error is "small enough".
   Unfortunately, it is impossible to tell if an error of size :math:`10^{-5}` on a
   :math:`20\times 20` mesh of linear elements is the expected (in)accuracy of the
   numerical approximation or if the error also contains the effect of a
   bug in the code. All we usually know about the numerical error is its
   *asymptotic properties*, for instance that it is proportional to :math:`h^2`
   if :math:`h` is the size of a cell in the mesh. Then we can compare the
   error on meshes with different :math:`h` values to see if the asymptotic
   behavior is correct. This is a very powerful verification
   technique and is explained in detail in the section :ref:`tut:poisson1:convrates`.
   However, if we have a test problem for which
   we know that there should be no approximation errors, we know that
   the analytical solution of the PDE problem should be reproduced to
   machine precision by the program. That is why we emphasize this kind
   of test problems throughout this tutorial. Typically, elements of
   degree :math:`r` can reproduce polynomials of degree :math:`r` exactly, so this
   is the starting point for constructing a solution without numerical
   approximation errors.




.. _tut:poisson1:impl:

FEniCS implementation
---------------------

A FEniCS program for solving our test problem for the Poisson equation
in 2D with the given choices of :math:`u_0`, :math:`f`, and :math:`\Omega` may look as
follows:

.. code-block:: python

        from fenics import *
        
        # Create mesh and define function space
        mesh = UnitSquareMesh(8, 8)
        V = FunctionSpace(mesh, 'P', 1)
        
        # Define boundary conditions
        u0 = Expression('1 + x[0]*x[0] + 2*x[1]*x[1]', degree=1)
        
        def u0_boundary(x, on_boundary):
            return on_boundary
        
        bc = DirichletBC(V, u0, u0_boundary)
        
        # Define variational problem
        u = TrialFunction(V)
        v = TestFunction(V)
        f = Constant(-6.0)
        a = dot(grad(u), grad(v))*dx
        L = f*v*dx
        
        # Compute solution
        u = Function(V)
        solve(a == L, u, bc)
        
        # Plot solution on the screen
        u.rename('u', 'solution')
        plot(u)
        plot(mesh)
        
        # Dump solution to file in VTK format
        vtkfile = File('poisson.pvd')
        vtkfile << u
        
        # Compute and print error
        u_e = interpolate(u0, V)
        error = max(abs(u_e.vector().array() - u.vector().array()))
        import numpy as np
        error = np.abs(u_e.vector().array() - u.vector().array()).max()
        print('error =', error)
        
        # Hold plot
        interactive()

The complete code can be found in the file `ft01_poisson_flat.py <https://github.com/hplgit/fenics-tutorial/blob/master/src/ft01_poisson_flat.py>`__.

.. _tut:poisson1:impl:run:

Running the program
-------------------

The FEniCS program must be available in a plain text file, written with a
text editor such as Atom, Sublime Text, Emacs, Vim, or similar.

To run the program ``ft01_poisson_flat.py``, open a terminal
window, move to the directory containing the program and type the
following command:

.. code-block:: text

        Terminal> python ft01_poisson_flat.py

Note that this command must be run in a FEniCS-enabled terminal. For
users of the FEniCS Docker containers, this means that you must type
this command after you have started a FEniCS session using
``fenicsproject run``.

When running the above command, FEniCS will run the program to compute
the approximate solution :math:`u`. The approximate solution :math:`u` will be
compared to the exact solution :math:`{u_{\small\mbox{e}}}` and the error in the maximum
norm will be printed. Since we know that our approximate solution
should reproduced the exact solution to within machine precision, this
error should be small, something on the order of :math:`10^{-15}`.

[**AL 3**: Add text here discussing what to expect in terms of plotting.  Perhaps we have seamless notebook plotting working soon...]

.. A plot window pops up showing how the solution :math:`u` looks like as a

.. surface.  With the left mouse button you can tilt the figure. Click

.. ``m`` to bring up the underlying mesh. Click ``p`` to save to a PNG file

.. ``dolfin_plot_0.png`` and ``P`` to save to a PDF file

.. ``dolfin_plot_1.pdf``. To kill the plot window and terminate the

.. application, click ``Ctrl+q`` (hold down the ``Ctrl`` key and press ``q``).

.. Figure :ref:`tut:poisson:2D:fig:ex1:u` displays the surface and the mesh

.. below.  Since :math:`u` is a simple quadratic function, constructed for

.. testing our solver, the surface looks quite boring.

.. _tut:poisson:2D:fig:ex1:u:

.. figure:: ex1_u.png
   :width: 600

   *Plot of the solution in the first FEniCS example*

.. _tut:poisson1:impl:dissect:

Dissection of the program
-------------------------

We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language. You may either take a
quick look at the `official Python tutorial <http://docs.python.org/tutorial/>`__ to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. This is
because both the amount of abstract mathematical formalism and the
amount of Python expertise that is actually needed to be productive
with FEniCS is quite limited. And Python is an easy-to-learn language
that you will certainly come to love and use far beyond FEniCS
programming. The section :ref:`tut:pybooks` lists some relevant Python
books.

The listed FEniCS program defines a finite element mesh, a finite
element function space :math:`V` on this mesh, boundary conditions for :math:`u`
(the function :math:`u_0`), and the bilinear and linear forms :math:`a(u,v)` and
:math:`L(v)`.  Thereafter, the unknown trial function :math:`u` is computed. Then
we can compare the numerical and exact solution as well as visualize
the computed solution :math:`u`.

The important first line
~~~~~~~~~~~~~~~~~~~~~~~~

The first line in the program,

.. code-block:: python

        from fenics import *

imports the key classes ``UnitSquareMesh``, ``FunctionSpace``, ``Function``,
and so forth, from the FEniCS library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line.

.. index:: Mesh

Generating simple meshes
~~~~~~~~~~~~~~~~~~~~~~~~

The statement

.. code-block:: python

        mesh = UnitSquareMesh(8, 8)

defines a uniform finite element mesh over the unit square
:math:`[0,1]\times [0,1]`. The mesh consists of *cells*, which in 2D are triangles
with straight sides. The parameters 8 and 8 specify that the square
should be divided into :math:`8\times 8` rectangles, each divided into a pair of
triangles. The total number of triangles (cells) thus becomes
128. The total number of vertices in the mesh is :math:`9\cdot 9=81`.
In later chapters, you will learn how to generate more complex meshes.

[**hpl 4**: Note that plot was made by the old partitioning :math:`6\times 4`. Probably no issue.]

.. index:: FunctionSpace

.. index:: finite element specifications

.. index:: CG finite element family

.. index:: Lagrange finite element family

.. index:: P1 element

Defining the finite element function space
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Having a mesh, we can define a finite element function space ``V`` over
this mesh:

.. code-block:: python

        V = FunctionSpace(mesh, 'P', 1)

The second argument ``'P``' specifies the type of element, while the third
argument is the degree of the basis functions of the element. The type
of element is here "P", implying the standard Lagrange family of
elements. You may also use ``'Lagrange'`` to specify this type of
element. FEniCS supports all simplex element families and the notation
defined in the `Periodic Table of the Finite Elements <http://femtable.org>`__ [Ref20]_.

.. index:: Periodic Table of the Finite Elements

The third argument ``1`` specifies the degree of the finite element.  In
this case, the standard :math:`\mathsf{P}_1` linear Lagrange element, which
is a triangle with nodes at the three vertices. Some finite element
practitioners refer to this element as the "linear triangle". The
computed solution :math:`u` will be continuous and linearly varying in :math:`x`
and :math:`y` over each cell in the mesh. Higher-degree polynomial
approximations over each cell are trivially obtained by increasing the
third parameter to ``FunctionSpace``, which will then generate function
spaces of type :math:`\mathsf{P}_2`, :math:`\mathsf{P}_3`, and so forth.
Changing the second parameter to ``'DP'`` creates a function
space for discontinuous Galerkin methods.

.. index:: TestFunction

.. index:: TrialFunction

.. index:: DirichletBC

.. index:: Dirichlet boundary conditions

Defining the trial and test functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In mathematics, we distinguish between the trial and test spaces :math:`V`
and :math:`\hat{V}`. The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space ``V`` for the and trial and test functions in the
program:

.. code-block:: python

        u = TrialFunction(V)
        v = TestFunction(V)

.. index:: boundary specification (function)

Defining the boundary and the boundary conditions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The next step is to specify the boundary condition: :math:`u=u_0` on
:math:`\partial\Omega`. This is done by

.. code-block:: python

        bc = DirichletBC(V, u0, u0_boundary)

where ``u0`` is an expression defining the solution values on the
boundary, and ``u0_boundary`` is a function (or object) defining
which points belong to the boundary.

Boundary conditions of the type :math:`u=u_0` are known as *Dirichlet
conditions*. For the present finite element method for the Poisson
problem, they are also called *essential boundary conditions*, as they
need to be imposed explicitly as part of the trial space (in contrast
to being defined implicitly as part of the variational formulation).
Naturally, the FEniCS class used to define Dirichlet boundary
conditions is named ``DirichletBC``.

.. index:: Expression

The variable ``u0`` refers to an ``Expression`` object, which is used to
represent a mathematical function. The typical construction is

.. code-block:: python

        u0 = Expression(formula)

where ``formula`` is a string containing the mathematical expression.
This formula is written with C++ syntax. The expression is
automatically turned into an efficient, compiled C++ function.
The expression may depend on the variables ``x[0]`` and ``x[1]``
corresponding to the :math:`x` and :math:`y` coordinates. In 3D, the expression
may also depend on the variable ``x[2]`` corresponding to the :math:`z`
coordinate. With our choice of :math:`u_0(x,y)=1 + x^2 + 2y^2`, the formula
string can be written as ``1 + x[0]*x[0] + 2*x[1]*x[1]``:

.. code-block:: python

        u0 = Expression('1 + x[0]*x[0] + 2*x[1]*x[1]')

[**hpl 5**: In the code there is a degree parameter that is not included above. Why?]

.. index:: C++ expression syntax

.. index:: expression syntax (C++)


.. admonition:: String expressions must have valid C++ syntax

   The string argument to an ``Expression`` object must obey C++ syntax.
   Most Python syntax for mathematical expressions are also valid C++ syntax,
   but power expressions make an exception: ``p**a`` must be written as
   ``pow(p,a)`` in C++ (this is also an alternative Python syntax).
   The following mathematical functions can be used directly
   in C++
   expressions when defining ``Expression`` objects:
   ``cos``, ``sin``, ``tan``, ``acos``, ``asin``,
   ``atan``, ``atan2``, ``cosh``, ``sinh``, ``tanh``, ``exp``,
   ``frexp``, ``ldexp``, ``log``, ``log10``, ``modf``,
   ``pow``, ``sqrt``, ``ceil``, ``fabs``, ``floor``, and ``fmod``.
   Moreover, the number :math:`\pi` is available as the symbol ``pi``.
   All the listed functions are taken from the ``cmath`` C++ header file, and
   one may hence
   consult the documentation of ``cmath`` for more information on the
   various functions.
   
   If/else tests are possible using the C syntax for inline branching. The
   function
   
   .. math::
            f(x,y) = \left\lbrace\begin{array}{ll} x^2, & x, y\geq 0\\ 
           2, & \hbox{otherwise}\end{array}\right.
   
   is implemented as
   
   .. code-block:: python
   
           f = Expression('x[0] >= 0 && x[1] >= 0? pow(x[0], 2) : 2')
   
   Parameters in expression strings are allowed, but
   must be initialized via keyword
   arguments when creating the ``Expression`` object. For example, the
   function :math:`f(x)=e^{-\kappa\pi^2t}\sin(\pi k x)` can be coded as
   
   .. code-block:: python
   
           f = Expression('exp(-kappa*pow(pi,2)*t)*sin(pi*k*x[0])',
                          kappa=1.0, t=0, k=4)
   
   At any time, parameters can be updated:
   
   .. code-block:: python
   
           f.t += dt
           f.k = 10




.. index:: boundary specification (function)

The function ``u0_boundary`` specifies which points that belong to the
part of the boundary where the boundary condition should be applied:

.. code-block:: python

        def u0_boundary(x, on_boundary):
            return on_boundary

A function like ``u0_boundary`` for marking the boundary must return a
boolean value: ``True`` if the given point ``x`` lies on the Dirichlet
boundary and ``False`` otherwise.  The argument ``on_boundary`` is ``True``
if ``x`` is on the physical boundary of the mesh, so in the present
case, where we are supposed to return ``True`` for all points on the
boundary, we can just return the supplied value of ``on_boundary``. The
``u0_boundary`` function will be called for every discrete point in the
mesh, which allows us to have boundaries where :math:`u` are known also
inside the domain, if desired.

One way to think about the specification of boundaries in FEniCS is
that FEniCS will ask you (or rather the function ``u0_boundary`` which
you have implemented) whether or not a specific point ``x`` is part of
the boundary. FEniCS already knows whether the point belongs to the
*actual* boundary (the mathematical boundary of the domain) and kindly
shares this information with you in the variable ``on_boundary``. You
may choose to use this information (as we do here), or ignore it
completely.

The argument ``on_boundary`` may also be omitted, but in that case we need
to test on the value of the coordinates in ``x``:

.. code-block:: python

        def u0_boundary(x):
            return x[0] == 0 or x[1] == 0 or x[0] == 1 or x[1] == 1

Comparing floating-point values using an exact match test with
``==`` is not good programming practice, because small round-off errors
in the computations of the ``x`` values could make a test ``x[0] == 1``
become false even though ``x`` lies on the boundary.  A better test is
to check for equality with a tolerance, either explicitly

.. code-block:: python

        def u0_boundary(x):
            return abs(x[0]) < tol or abs(x[1]) < tol \ 
                or abs((x[0] - 1) < tol or abs(x[1] - 1) < tol

or with the ``near`` command in FEniCS:

.. code-block:: python

        def u0_boundary(x):
            return near(x[0], 0, tol) or near(x[1], 0, tol) \ 
                or near(x[0], 1, tol) or near(x[1], 1, tol)

.. index:: UFL

Defining the source term
~~~~~~~~~~~~~~~~~~~~~~~~

Before defining the bilinear and linear forms :math:`a(u,v)` and :math:`L(v)` we
have to specify the source term :math:`f`:

.. code-block:: python

        f = Expression('-6')

When :math:`f` is constant over the domain, ``f`` can be
more efficiently represented as a ``Constant``:

.. code-block:: python

        f = Constant(-6)

Defining the variational problem
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We now have all the ingredients we need to define the
variational problem:

.. code-block:: python

        a = dot(grad(u), grad(v))*dx
        L = f*v*dx

In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas :math:`\nabla u\cdot\nabla v {\, \mathrm{d}x}` and :math:`fv {\, \mathrm{d}x}`.  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify and solve complicated PDE problems.  The
language used to express weak forms is called UFL (Unified Form
Language) [Ref21]_ [Ref01]_ and is an integral part of FEniCS.

.. Instead of ``grad`` we could also just have written ``grad`` in the

.. examples in this tutorial. However, when taking gradients of vector

.. fields, ``grad`` and ``grad`` differ. The latter is consistent with

.. the tensor algebra commonly used to derive vector and tensor PDEs,

.. where :math:`\nabla` ("nabla") acts as a vector operator, and therefore

.. this author prefers to always use ``grad``.

Forming and solving the linear system
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Having defined the finite element variational problem and boundary
condition, we can now ask FEniCS to compute the solution:

.. code-block:: python

        u = Function(V)
        solve(a == L, u, bc)

.. Some prefer to replace ``a`` and ``L`` by an ``equation``

.. variable, which is accomplished by this equivalent code:

.. !bc pycod

.. equation = dot(grad(u), grad(v))*dx == f*v*dx

.. u = Function(V)

.. solve(equation, u, bc)

.. !ec

Note that we first defined the variable ``u`` as a ``TrialFunction`` and
used it to represent the unknown in the form ``a``. Thereafter, we
redefined ``u`` to be a ``Function`` object representing the solution;
i.e., the computed finite element function :math:`u`. This redefinition of
the variable ``u`` is possible in Python and often done in FEniCS
applications for linear problems. The two types of objects that ``u``
refers to are equal from a mathematical point of view, and hence it is
natural to use the same variable name for both objects.

.. index:: degrees of freedom

[**AL 6**: I AM HERE]

Examining the values of the solution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to "prove" that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed ``u`` function to ``u0``.

A finite element function like :math:`u` is expressed as a linear combination
of basis functions :math:`\phi_j`, spanning the space :math:`V`:

.. _Eq:tut:poisson1:ufem:

.. math::

    \tag{13}
    u = \sum_{j=1}^N U_j \phi_j {\thinspace .}
        

By writing ``solve(a == L, u, bc)`` in the program, a linear system
will be formed from :math:`a` and :math:`L`, and this system is solved for the
:math:`U_1,\ldots,U_N` values. The :math:`U_1,\ldots,U_N` values are known
as *degrees of freedom* of :math:`u`. For Lagrange elements (and many other
element types) :math:`U_k` is simply the value of :math:`u` at the node
with global number :math:`k`.
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.

Having ``u`` represented as a ``Function`` object, we can either evaluate
``u(x)`` at any point ``x`` in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values :math:`U_j` directly by

.. code-block:: python

        u_nodal_values = u.vector()

The result is a ``Vector`` object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
``Vector`` object to a standard ``numpy`` array for further
processing:

.. index:: degrees of freedom array

.. index:: nodal values array

.. index::
   single: numbering; degrees of freedom

.. index::
   single: numbering; cell vertices

.. code-block:: python

        u_array = u_nodal_values.array()

With ``numpy`` arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: ``u_array[i]``,
where the index ``i`` always starts at ``0``. However, ``i`` corresponds
to :math:`u` at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the
mesh, see the section :ref:`tut:poisson1:verify1` for details.

.. index:: interpolate

For now, we want to check that the values in ``u_array`` are correct:
they should equal our ``u0`` function. The most natural approach is
to interpolate our ``u0`` expression onto our space
(i.e., the finite element mesh),

.. code-block:: python

        u0_Function = interpolate(u0, V)

The ``interpolate`` function returns a ``Function`` object, whose degrees
of freedom values can be obtained by ``.vector().array()``.  Our goal is
to show that the degrees of freedom arrays of ``u`` and ``u0_Function``
are equal. One safe of doing this is to compute the maximum error,

.. code-block:: python

        u0_array = u0_Function.vector().array()  # dof values
        max_error = (u0_array - u.vector().array()).max()
        print('max error:', max_error)


.. admonition:: How to check that the error vanishes

   With inexact arithmetics, as we always have on a computer,
   this maximum error is not zero, but should be a small number.
   The machine precision is about :math:`10^{-16}`, but in finite element
   calculations, rounding errors of this size may accumulate, so
   the expected accuracy of ``max_error`` smaller. Experiments show
   that increasing the number of elements and increasing the degree
   of the finite element polynomials increase ``max_error``.
   For a mesh with :math:`2(20\times 20)` cubic Lagrange elements (degree 3)
   ``max_error`` is about :math:`2\cdot 10^{-12}`, while for 18 linear elements
   the maximum error is about :math:`2\cdot 10^{-15}`.




Plotting the solution
~~~~~~~~~~~~~~~~~~~~~

The simplest way of quickly looking at ``u`` is to say

.. code-block:: python

        plot(u, interactive=True)
        # or
        plot(u)
        interactive()

Clicking on ``Help`` in the plot windows brings up a list of commands.
For example, typing ``m`` brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click ``Ctrl+q`` to kill the plot window and
continue execution beyond the ``plot(u, interactive=True)`` command or
``interactive()``.
Figure :ref:`tut:poisson:2D:fig:ex1:u` displays the resulting :math:`u` function.

Plotting both the solution and the mesh is accomplished by

.. code-block:: python

        plot(u)
        plot(mesh)
        # Hold plot
        interactive()

Type ``Ctrl+w`` to kill all plot windows and continue execution.

It is also possible to dump the computed solution to file, e.g., in the
VTK format:

.. code-block:: python

        vtkfile = File('poisson.pvd')
        vtkfile << u

The ``poisson.pvd`` file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The ``plot`` function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.

.. index:: rename

Prior to plotting and storing solutions to file it is wise to
give ``u`` a proper name by ``u.rename('u', 'solution')``. Then
``u`` will be used as name in plots (rather than the more cryptic
default names like ``f_7``).

Plotting in ParaView
--------------------

Just to get you quickly started with ParaView, launch the application,
choose **File - Open**, find the file ``poisson.pvd``, and click the green **Apply**
button to the left in the GUI. A 2D color plot of :math:`u(x,y)` is then shown.
You can save the figure to file by **File - Export Scene...** and choosing
a suitable filename.

.. figure:: poisson0_paraview.png
   :weight: 800

   Visualization of test problem in ParaView, with contour lines added in the right plot

.. _ftut:poisson:membrane:

Deflection of a membrane
------------------------

The previous problem and code targeted a simple test problem where we
can easily verify the implementation. Now we turn the attention to
a more physically relevant problem, in a non-trivial geometry, and
that results in solutions of somewhat more exciting shape.

We want to compute the deflection :math:`w` of a two-dimensional, circular membrane,
subject to a load :math:`p` over the membrane.
A scaled form of this problem
(see the section :ref:`tut:poisson:membrane` for mathematical details) has
the governing equation
:math:`-\nabla^2 w = p` over the unit circle, with :math:`w=0` on the boundary, and
the load given as

.. math::
         p = - 4\exp{\left(-\beta^2(x^2 + (y-R_0)^2)\right)},

where :math:`\beta` and :math:`R_0` are dimensionless numbers reflecting the
extent of the load and its location, respectively. Let us work with
a quite peak-shaped load, for which :math:`\beta=8` and :math:`R_0=0.6` are
relevant parameters.

Just a few modifications are necessary in our previous program to solve
this new problem.

Generating the mesh
~~~~~~~~~~~~~~~~~~~

A mesh over the unit circle can be created by the ``mshr`` tool in
FEniCS:

.. code-block:: python

        from mshr import *
        domain = Circle(Point(0.0, 0.0), 1.0)
        mesh = generate_mesh(domain, n)

The ``Circle`` shape from ``mshr`` takes the center and radius of the circle
as the two first arguments, while ``n`` is the resolution, here the
suggested number of cells per radius.

The expression for the load
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. index:: Expresion

.. index:: Expression with parameters

The right-hand side pressure function
is represented by an ``Expression`` object. There
are two physical parameters in the formula for :math:`f` that enter the
expression string and these parameters must have their values set
by keyword arguments:

.. code-block:: python

        p = Expression(
            '4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))',
            beta=beta, R0=R0)

The coordinates in ``Expression`` objects *must* be a vector
with indices 0, 1, and 2, and with the name ``x``. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set

.. code-block:: python

        f.beta = 12
        f.R0 = 0.3

.. index:: interpolation

Variational form
~~~~~~~~~~~~~~~~

We may introduce ``w`` instead of ``u`` as primary unknown and ``p`` instead
of ``f`` as right-hand side function:

.. code-block:: python

        w = TrialFunction(V)
        v = TestFunction(V)
        a = dot(grad(w), grad(v))*dx
        L = p*v*dx
        
        w = Function(V)
        solve(a == L, w, bc)

Visualization          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~

It would be of interest to visualize :math:`p` along with :math:`w` so that we can
examine the pressure force and the membrane's response.  We must then transform
the formula (``Expression``) to a finite element function
(``Function``).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from :math:`p`. That is, we interpolate :math:`p`:

.. code-block:: python

        p = interpolate(p, V)

Calling ``plot(p)`` will produce a plot of :math:`p`. Note that the assignment
to ``p`` destroys the previous ``Expression`` object ``p``, so if
it is of interest to still have access to this object, another name must be used
for the ``Function`` object returned by ``interpolate``.

We can now plot ``w`` and ``p`` as well as dump the fields to file in VTK format:

.. code-block:: python

        plot(w, title='Deflection')
        plot(p, title='Load')
        
        vtkfile = File('membrane.pvd')
        vtkfile << w
        vtkfile << p

Figure :ref:`ftut:poisson:membrane:fig` shows the result of the ``plot``
commands.

.. _ftut:poisson:membrane:fig:

.. figure:: membrane_fenics_viz.png
   :width: 800

   *Load (left) and resulting deflection (right) of a circular membrane*

.. Stand-alone notebook?

.. _tut:timedep:

The time-dependent diffusion equation
=====================================

The examples in the section :ref:`tut:poisson1:impl`
illustrate that solving linear, stationary PDE problems with the aid
of FEniCS is easy and requires little programming.  FEniCS clearly
automates the spatial discretization by the finite element method. One
can use a separate, one-dimensional finite element method in the
domain as well, but very often, it is easier to just use a finite
difference method, or to formulate the problem as an ODE system and
leave the time-stepping to an ODE solver.

.. The solution of

.. nonlinear problems, as we showed in Section

.. :ref:`tut:poisson:nonlinear`, can also be automated (cf. Section

.. :ref:`tut:nonlinear:Newton:auto`), but many scientists will prefer to

.. code the solution strategy of the nonlinear problem themselves and

.. experiment with various combinations of strategies in difficult

.. problems. Time-dependent problems are somewhat similar in this

.. respect: we have to add a time discretization scheme, which is often

.. quite simple, making it natural to explicitly code the details of the

.. scheme so that the programmer has full control.

.. We shall explain how

.. easily this is accomplished through examples.

[**hpl 7**: Should exemplify all three approaches? With emphasis on simple finite differences?]

.. _tut:timedep:diffusion1:

Variational formulation          (1)
------------------------------------

.. index:: time-dependent PDEs

Our model problem for time-dependent PDEs reads

.. _Eq:tut:diffusion:pde1:

.. math::

    \tag{14}
    {\partial u\over\partial t} = \nabla^2 u + f\hbox{ in }\Omega,
        
        

.. _Eq:tut:diffusion:pde1:bc:

.. math::

    \tag{15}
    u = u_0\hbox{ on } \partial \Omega,
        
        

.. _Eq:tut:diffusion:pde1:ic:

.. math::

    \tag{16}
    u = I \mbox{ at } t=0{\thinspace .}
        
        

Here, :math:`u` varies with space and time, e.g., :math:`u=u(x,y,t)` if the spatial
domain :math:`\Omega` is two-dimensional. The source function :math:`f` and the
boundary values :math:`u_0` may also vary with space and time.
The initial condition :math:`I` is a function of space only.

A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a recursive set of
stationary problems, and then turn each stationary problem into a
variational formulation.

Let superscript :math:`k` denote a quantity at time :math:`t_k`, where :math:`k` is an
integer counting time levels. For example, :math:`u^k` means :math:`u` at time
level :math:`k`.  A finite difference discretization in time first consists
in sampling the PDE at some time level, say :math:`k`:

.. _Eq:tut:diffusion:pde1:tk:

.. math::

    \tag{17}
    {\partial \over\partial t}u^k = \nabla^2 u^k + f^k{\thinspace .}
        
        

The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:

.. _Eq:tut:diffusion:BE:

.. math::

    \tag{18}
    {\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{{\Delta t}}},
        
        

where :math:`{\Delta t}` is the time discretization parameter.
Inserting :ref:`(18) <Eq:tut:diffusion:BE>` in :ref:`(17) <Eq:tut:diffusion:pde1:tk>` yields

.. _Eq:tut:diffusion:pde1:BE:

.. math::

    \tag{19}
    {u^k - u^{k-1}\over{{\Delta t}}} = \nabla^2 u^k + f^k{\thinspace .}
        
        

This is our time-discrete version of the diffusion PDE
:ref:`(14) <Eq:tut:diffusion:pde1>`.

We may reorder :ref:`(19) <Eq:tut:diffusion:pde1:BE>` so
that the left-hand side contains the terms with the unknown :math:`u^k` and
the right-hand side contains computed terms only. The result
is a recursive set of spatial
(stationary) problems for :math:`u^k` (assuming :math:`u^{k-1}` is known from
computations at the previous time level):

.. _Eq:tut:diffusion:pde1:u0:

.. math::

    \tag{20}
    u^0 = I, 
        

.. _Eq:tut:diffusion:pde1:uk:

.. math::

    \tag{21}
    u^k - {{\Delta t}}\nabla^2 u^k =  u^{k-1} + {{\Delta t}} f^k,\quad k=1,2,\ldots
        
        

Given :math:`I`, we can solve for :math:`u^0`, :math:`u^1`, :math:`u^2`, and so on.

As an alternative to :ref:`(21) <Eq:tut:diffusion:pde1:uk>`, which can be
convenient in implementations, we may collect
all terms on one side of the equality sign:

.. _Eq:tut:diffusion:pde1:uk2:

.. math::

    \tag{22}
    u^k - {{\Delta t}}\nabla^2 u^k -  u^{k-1} - {{\Delta t}} f^k = ,\quad k=1,2,\ldots
        
        

We use a finite element method to solve
:ref:`(20) <Eq:tut:diffusion:pde1:u0>` and either of the equations
:ref:`(21) <Eq:tut:diffusion:pde1:uk>` or :ref:`(22) <Eq:tut:diffusion:pde1:uk2>`.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function :math:`v\in \hat V` and integrate second-derivatives by
parts. Introducing the symbol :math:`u` for :math:`u^k` (which is natural in the
program), the resulting weak form can be conveniently written in
the standard notation:

.. math::
         a_0(u,v)=L_0(v),

for
:ref:`(20) <Eq:tut:diffusion:pde1:u0>`. The formulation :ref:`(21) <Eq:tut:diffusion:pde1:uk>`
gives rise to

.. math::
         a(u,v)=L(v),

where

.. _Eq:tut:diffusion:pde1:a0:

.. math::

    \tag{23}
    a_0(u,v) = \int_\Omega uv {\, \mathrm{d}x}, 
        

.. _Eq:tut:diffusion:pde1:L0:

.. math::

    \tag{24}
    L_0(v) = \int_\Omega Iv {\, \mathrm{d}x}, 
        

.. _Eq:tut:diffusion:pde1:a:

.. math::

    \tag{25}
    a(u,v) = \int_\Omega\left( uv + {{\Delta t}}
        \nabla u\cdot \nabla v\right) {\, \mathrm{d}x}, 
        

.. _Eq:tut:diffusion:pde1:L:

.. math::

    \tag{26}
    L(v) = \int_\Omega \left(u^{k-1} + {{\Delta t}}  f^k\right)v {\, \mathrm{d}x}{\thinspace .}
        
        

The alternative form :ref:`(22) <Eq:tut:diffusion:pde1:uk2>` has a formulation

.. math::
         F(u,v) = 0,

where

.. _Eq:tut:diffusion:pde1:F:

.. math::

    \tag{27}
    F = \int_\Omega\left( uv + {{\Delta t}}
        \nabla u\cdot \nabla v -
        \left(u^{k-1} - {{\Delta t}}  f^k\right)v\right) {\, \mathrm{d}x}{\thinspace .}
        
        

The continuous variational problem is to find
:math:`u^0\in V` such that :math:`a_0(u^0,v)=L_0(v)` holds for all :math:`v\in\hat V`,
and then find :math:`u^k\in V`
such that :math:`a(u^k,v)=L(v)` for all :math:`v\in\hat V`,
or alternatively, :math:`F(u^k,v)=0` for all :math:`v\in\hat V`,
:math:`k=1,2,\ldots`.

Approximate solutions in space are found by restricting the functional
spaces :math:`V` and :math:`\hat V` to finite-dimensional spaces, exactly as we
have done in the Poisson problems.  We shall use the symbol :math:`u` for
the finite element approximation at time :math:`t_k`. In case we need to
distinguish this space-time discrete approximation from the exact
solution of the continuous diffusion problem, we use :math:`{u_{\small\mbox{e}}}` for the
latter.  By :math:`u^{k-1}` we mean the finite element approximation of the
solution at time :math:`t_{k-1}`.

Instead of solving :ref:`(20) <Eq:tut:diffusion:pde1:u0>` by a finite element
method, i.e., projecting :math:`I` onto :math:`V` via the problem
:math:`a_0(u,v)=L_0(v)`, we could simply interpolate :math:`u^0` from :math:`I`. That
is, if :math:`u^0=\sum_{j=1}^N U^0_j\phi_j`, we simply set :math:`U_j=I(x_j,y_j)`,
where :math:`(x_j,y_j)` are the coordinates of node number :math:`j`. We refer to
these two strategies as computing the initial condition by either
projecting :math:`I` or interpolating :math:`I`.  Both operations are easy to
compute through one statement, using either the ``project`` or
``interpolate`` function.

.. _tut:timedep:diffusion1:impl:

A simple implementation          (1)
------------------------------------

Our program needs to implement the time stepping explicitly, but can
rely on FEniCS to easily compute :math:`a_0`, :math:`L_0`, :math:`F`, :math:`a`, and :math:`L`, and solve
the linear systems for the unknowns.

Test problem          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~

Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,

.. _Eq:tut:diffusion:pde1:u0test:

.. math::

    \tag{28}
    u = 1 + x^2 + \alpha y^2 + \beta t,
        
        

yields a function whose computed values at the nodes will be exact,
regardless of the size of the elements and :math:`{\Delta t}`, as long as the mesh
is uniformly partitioned.  By inserting
:ref:`(28) <Eq:tut:diffusion:pde1:u0test>` in the PDE problem
:ref:`(14) <Eq:tut:diffusion:pde1>`, it follows that :math:`u_0` must be given as
:ref:`(28) <Eq:tut:diffusion:pde1:u0test>` and that :math:`f(x,y,t)=\beta - 2 -
2\alpha` and :math:`I(x,y)=1+x^2+\alpha y^2`.

.. index:: ft02_diffusion_flat1.py

The code
~~~~~~~~

A new programming issue is how to deal with functions that vary in
space *and time*, such as the boundary condition :math:`u_0` given by
:ref:`(28) <Eq:tut:diffusion:pde1:u0test>`.  A natural solution is to apply an
``Expression`` object with time :math:`t` as a parameter, in addition to the
parameters :math:`\alpha` and :math:`\beta`
for ``Expression`` objects with parameters:

.. code-block:: python

        alpha = 3; beta = 1.2
        u0 = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                        alpha=alpha, beta=beta, t=0)

This function expression has the components of ``x`` as independent
variables, while ``alpha``, ``beta``, and ``t`` are parameters.  The
parameters can later be updated as in

.. code-block:: python

        u0.t = t

The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,

.. code-block:: python

        def boundary(x, on_boundary):  # define the Dirichlet boundary
            return on_boundary
        
        bc = DirichletBC(V, u0, boundary)

We shall use ``u`` for the unknown :math:`u` at the new time level and ``u_1``
for :math:`u` at the previous time level.  The initial value of ``u_1``,
implied by the initial condition on :math:`u`, can be computed by either
projecting or interpolating :math:`I`.  The :math:`I(x,y)` function is available
in the program through ``u0``, as long as ``u0.t`` is zero.  We can then
do

.. code-block:: python

        u_1 = interpolate(u0, V)
        # or
        u_1 = project(u0, V)


.. admonition:: Projecting versus interpolating the initial condition

   To actually recover the
   exact solution :ref:`(28) <Eq:tut:diffusion:pde1:u0test>` to machine precision,
   it is important not to compute the discrete initial condition by
   projecting :math:`I`, but by interpolating :math:`I` so that the nodal values are
   exact at :math:`t=0` (projection results in approximative values at the
   nodes).




We may either define :math:`a` or :math:`L` according to the formulas above, or
we may just define :math:`F` and ask FEniCS to figure out which terms that
go into the bilinear form :math:`a` and which that go into the linear form
:math:`L`. The latter is convenient, especially in more complicated problems,
so we illustrate that construction:

.. code-block:: python

        dt = 0.3      # time step
        
        u = TrialFunction(V)
        v = TestFunction(V)
        f = Constant(beta - 2 - 2*alpha)
        
        F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_1 + dt*f)*v*dx
        a, L = lhs(F), rhs(F)

Finally, we perform the time stepping in a loop:

.. code-block:: python

        u = Function(V)   # the unknown at a new time level
        T = 2             # total simulation time
        t = dt
        
        while t <= T:
            u0.t = t
            solve(a == L, u, bc)
        
            t += dt
            u_1.assign(u)


.. admonition:: Remember to update expression objects with the current time

   Inside the time loop,
   observe that ``u0.t`` must be updated before the ``solve`` statement
   to enforce computation of Dirichlet conditions at the
   current time level. (The Dirichlet conditions look up the ``u0`` object
   for values.)




The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of ``u`` and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after ``u`` is found:

.. code-block:: python

        u_e = interpolate(u0, V)
        error = np.abs(u_e.vector().array() -
                       u.vector().array()).max()
        print('error, t=%.2f: %-10.3g' % (t, max_error))

The complete program code for this time-dependent case goes as follows:

.. code-block:: python

        from fenics import *
        import numpy as np
        
        # Create mesh and define function space
        nx = ny = 4
        mesh = UnitSquareMesh(nx, ny)
        V = FunctionSpace(mesh, 'P', 1)
        
        # Define boundary conditions
        alpha = 3; beta = 1.2
        u0 = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                        alpha=alpha, beta=beta, t=0)
        
        def boundary(x, on_boundary):
            return on_boundary
        
        bc = DirichletBC(V, u0, boundary)
        
        # Initial condition
        u_1 = interpolate(u0, V)
        #project(u0, V) will not result in exact solution at the nodes!
        
        dt = 0.3      # time step
        
        # Define variational problem
        u = TrialFunction(V)
        v = TestFunction(V)
        f = Constant(beta - 2 - 2*alpha)
        
        F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_1 + dt*f)*v*dx
        a, L = lhs(F), rhs(F)
        
        # Compute solution
        u = Function(V)   # the unknown at a new time level
        T = 1.9           # total simulation time
        t = dt
        while t <= T:
            print('time =', t)
            u0.t = t
            solve(a == L, u, bc)
        
            # Verify
            u_e = interpolate(u0, V)
            error = np.abs(u_e.vector().array() -
                           u.vector().array()).max()
            print('error, t=%.2f: %-10.3g' % (t, max_error))
        
            t += dt
            u_1.assign(u)

The code is available in the
file `ft02_diffusion_flat1.py <https://github.com/hplgit/fenics-tutorial/blob/master/src/diffusion_flat1.py>`__.

Diffusion of a Gaussian function
--------------------------------

The mathematical problem
~~~~~~~~~~~~~~~~~~~~~~~~

Now we want to solve a more physical problem, namely the diffusion of
a Gaussian hill. It means that the initial condition is given by

.. math::
         I(x,y)= e^{-ax^2 - ay^2}

on a domain :math:`[-2,2]\times [2,2]`. A possible value of :math:`a` is 5.

Implementation          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

What are the necessary changes to the previous program?

1. The domain is not the unit square and it needs much higher resolution: ``mesh = RectangleMesh(Point(-2,-2), Point(2,2), 30, 30)``.

2. The boundary condition is zero everywhere: ``DirichletBC(V, Constant(0), boundary)``.

3. The initial condition is different: ``I = Expression('exp(...)')``.

4. The time step should be sufficiently small: ``dt = 0.01`` or ``dt = 0.05``.

5. The right-hand side function ``f`` is zero: ``f = Constant(0)`` (just ``0``
   will given an error as functions in FEniCS must be ``Expression``, ``Function``
   (over a mesh) or ``Constant``).

6. The end time for the simulation must be longer: ``T = 0.8``.

7. The initial condition and the solution inside the time loop should be
   stored to file in VTK format for visualization: ``vtkfile << (u, t)``.

8. We can add a ``plot(u)`` command inside the time loop as well.

The complete program appears below.

.. code-block:: python

        from fenics import *
        import time
        
        # Create mesh and define function space
        nx = ny = 30
        mesh = RectangleMesh(Point(-2,-2), Point(2,2), nx, ny)
        V = FunctionSpace(mesh, 'P', 1)
        
        # Define boundary conditions
        def boundary(x, on_boundary):
            return on_boundary
        
        bc = DirichletBC(V, Constant(0), boundary)
        
        # Initial condition
        I = Expression('exp(-a*pow(x[0],2)-a*pow(x[1],2))', a=5)
        u_1 = interpolate(I, V)
        u_1.rename('u', 'initial condition')
        vtkfile = File('diffusion.pvd')
        vtkfile << (u_1, 0.0)
        #project(u0, V) will not result in exact solution at the nodes!
        
        dt = 0.01    # time step
        
        # Define variational problem
        u = TrialFunction(V)
        v = TestFunction(V)
        f = Constant(0)
        
        F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_1 + dt*f)*v*dx
        a, L = lhs(F), rhs(F)
        
        # Compute solution
        u = Function(V)             # the unknown at a new time level
        u.rename('u', 'solution')   # name and label for u
        T = 0.5                     # total simulation time
        t = dt
        while t <= T:
            print('time =', t)
            solve(a == L, u, bc)
            vtkfile << (u, float(t))
            plot(u)
            time.sleep(0.3)
        
            t += dt
            u_1.assign(u)

Visualization in ParaView          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Start ParaView, choose **File - Open**, open the file ``diffusion.pvd``,
click the green **Apply** button on the left to see the initial condition
being plotting. Choose **View - Animation View**. Click on the play button
or (better) the next frame button in the row of buttons at the top of the GUI
to see the evolution of the scalar field you just have computed:

| 
| 

.. figure:: paraview_animation_buttons.png
   :width: 500

| 
| 

The cross in the middle of the plot can be turned off by the **Show Center**
button:

| 
| 

Choose **File - Save Animation...** to save the animation to the OGG video format.

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
            <source src='mov/diffusion0.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em></em></p>
        
        <!-- Issue warning if in a Safari browser -->
        <script language="javascript">
        if (!!(window.safari)) {
          document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
        </script>
        

.. figure:: paraview_show_center_button.png
   :width: 150

| 
| 

.. figure:: diffusion0_paraview_animation.png
   :width: 600

.. figure:: diffusion0_3snapshots.png
   :width: 800

.. Stand-alone notebook?

A nonlinear Poisson equation
============================

Variational formulation          (2)
------------------------------------

Now we shall address how to solve nonlinear PDEs in FEniCS. Our
sample PDE for implementation is taken as a nonlinear Poisson equation:

.. _Eq:_auto3:

.. math::

    \tag{29}
    -\nabla\cdot\left( q(u)\nabla u\right) = f,
        
        

in :math:`\Omega`, with :math:`u=u_0` on the boundary :math:`\partial\Omega`.
The coefficient :math:`q(u)` makes the equation nonlinear (unless :math:`q(u)`
is constant in :math:`u`).

The variational formulation of our model problem reads:
Find :math:`u \in V` such that

.. _Eq:tut:poisson:nonlinear1:

.. math::

    \tag{30}
    F(u; v) = 0 \quad \forall v \in \hat{V},
        

where

.. _Eq:tut:poisson:nonlinear2:

.. math::

    \tag{31}
    F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v {\, \mathrm{d}x},
        

and

.. math::
        
            \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and }x_0=1\}, \\ 
             V      &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and } v = 1\mbox{ on }x_0=1\}{\thinspace .}
        

The discrete problem arises as usual by restricting :math:`V` and :math:`\hat V` to a
pair of discrete spaces. As usual, we omit any subscript on discrete
spaces and simply say :math:`V` and :math:`\hat V` are chosen finite dimensional
according to some mesh with some element type.
Similarly, we let :math:`u` be the discrete solution and use :math:`{u_{\small\mbox{e}}}` for
the exact solution if it becomes necessary to distinguish between the two.

The discrete nonlinear problem is then written as: find :math:`u\in V` such that

.. _Eq:tut:poisson:nonlinear:d:

.. math::

    \tag{32}
    F(u; v) = 0 \quad \forall v \in \hat{V},
        
        

with :math:`u = \sum_{j=1}^N U_j \phi_j`. Since :math:`F` is a nonlinear function
of :math:`u`, the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns :math:`U_1,\ldots,U_N`.

.. _tut:nonlinear:Newton:auto:

A simple implementation          (2)
------------------------------------

Overview
~~~~~~~~

A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is the state the formula for :math:`F` and call
``solve(F == 0, u, bc)`` instead of ``solve(a == L, u, bc)`` as we did
in the linear case. Here is a minimalistic code:

.. code-block:: python

        from fenics import *
        
        def q(u):
            """Nonlinear coefficient in the PDE."""
            return 1 + u**2
        
        mesh = UnitSquareMesh(60, 40)
        V = FunctionSpace(mesh, 'P', 1)
        u0 = Expression(...)
        
        def u0_boundary(x, on_boundary):
            return on_boundary
        
        bc = DirichletBC(V, u0, u0_boundary)
        
        # Define variational problem
        u = Function(V)
        v = TestFunction(V)
        f = Expression(...)
        F = dot(q(u)*grad(u), grad(v))*dx - f*v*dx
        
        # Compute solution
        solve(F == 0, u, bc)

The major difference from a linear problem is that the unknown function
``u`` in the variational form is in the nonlinear case
a ``Function``, not a ``TrialFunction``.

The ``solve`` function takes the nonlinear equations and derives symbolically
the Jacobian matrix and runs a Newton method.

Constructing a test problem with SymPy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let us do a specific computation. We then need choices for :math:`f` and :math:`u_0`.
Previously, we have worked with manufactured solutions that can be
reproduced without approximation errors. This is more difficult in
nonlinear problems, and the algebra is more tedious. However, we may
utilize SymPy for symbolic computing and integrate such computations in the
FEniCS solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package (here, defining symbols, ``diff`` for
differentiation, ``ccode`` for C/C++ code generation).

We try out a two-dimensional solution that is linear in the unknowns:

.. code-block:: python

        # Warning: from fenics import * imports f, q, and sym
        # (which overwrites the f and q (function) objects
        # and also sym if we do import sympy as sym).
        # Therefore, do fenics import first and then overwrite
        from fenics import *
        
        def q(u):
            """Nonlinear coefficient in the PDE."""
            return 1 + u**2
        
        # Use sympy to compute f given manufactured solution u
        import sympy as sym
        x, y = sym.symbols('x[0] x[1]')
        u = 1 + x + 2*y
        f = - sym.diff(q(u)*sym.diff(u, x), x) - \ 
              sym.diff(q(u)*sym.diff(u, y), y)
        f = sym.simplify(f)


.. admonition:: Define symbolic coordinates as required in ``Expression`` objects

   Note that we would normally write ``x, y = sym.symbols('x y')``, but
   if we want the resulting expressions to be have valid syntax for
   ``Expression`` objects, and then :math:`x` reads ``x[0]`` and :math:`y` must be ``x[1]``.
   This is easily accomplished with ``sympy`` by defining the names of ``x`` and
   ``y`` as ``x[0]`` and ``x[1]``: ``x, y = sym.symbols('x[0] x[1]')``.




Turning the expressions for ``u`` and ``f`` into C or C++ syntax for
``Expression`` objects needs two steps. First we ask for the C code of
the expressions,

.. code-block:: python

        u_code = sym.printing.ccode(u)
        f_code = sym.printing.ccode(f)

Sometimes we need some editing of the result to match the required syntax of
``Expression`` objects, but not in this case. (The primary example is
that ``M_PI`` for :math:`\pi` in C/C++ must be replaced by ``pi`` for ``Expression``
objects.) In our case here,
the output of ``c_code`` and ``f_code`` is

.. code-block:: c

        x[0] + 2*x[1] + 1
        -10*x[0] - 20*x[1] - 10

After having defined the mesh, the function space, and the boundary,
we define the boundary values, ``u0``, as

.. code-block:: python

        u0 = Expression(u_code)

Similarly, we define the right-hand side function as

.. code-block:: python

        f = Expression(f_code)

The complete code is found in the file
`ft03_poisson_flat_nonlinear.py <https://github.com/hplgit/fenics-tutorial/blob/master/src/ft03_poisson_flat_nonlinear.py>`__.


.. admonition:: Name clash between ``fenics`` and program variables

   In a program like the one above, strange errors may occur due to
   name clashes. If you define ``sym``, ``q``, and ``f`` prior to doing
   ``from fenics import *``, the latter statement will also import
   variables with the names ``sym``, ``q``, and ``f`` and overwrite
   the objects you had! This may lead to strange errors. The best
   solution is to do ``import fenics as fe`` and prefix all FEniCS
   object names by ``fe``. The next best solution is to do the
   ``from fenics import *`` first and then define our own variables
   that overwrite those imported from ``fenics``. This is acceptable
   if we do not need ``f``, ``q``, and ``sym`` from ``fenics``.




Running the code gives output that tells how the Newton iteration
progresses. With :math:`2(6\times 4)` cells we get convergence in 7
iterations with a tolerance of :math:`10^{-9}`, and the error in the
numerical solution is about :math:`10^{-11}`. Using more elements, e.g.,
:math:`2(16\times 14)`, brings the error down to about :math:`10^{-15}`,
which provides evidence for a correct implementation.

The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much more manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter :ref:`tut:nonlinear` and show how we can implement our own solution
algorithms for nonlinear equations and also how we can steer the
parameters in the automated Newton method used above. You will then
realize how easy it is to implement tailored solution strategies for
nonlinear problems in FEniCS.

.. Stand-alone notebook?

.. _tut:elast:

The equations of linear elasticity
==================================

[**hpl 8**: This is *very* preliminary text! Anders, don't do much before I have taken a round and removed this comment. Ideas are of course welcome!]

.. _tut:elast:varform:

Variational formulation          (3)
------------------------------------

The equations governing small elastic deformations of a body :math:`\Omega`
are

.. _Eq:tut:elast:varform:equilibrium:

.. math::

    \tag{33}
    \nabla\cdot\sigma = \varrho f\hbox{ in }\Omega,
        
        

.. _Eq:tut:elast:varform:stresstrain:

.. math::

    \tag{34}
    \sigma = \lambda\,\hbox{tr}\,\varepsilon I + 2\mu\varepsilon,
        
        

.. _Eq:tut:elast:varform:strainu:

.. math::

    \tag{35}
    \varepsilon = \frac{1}{2}\left(\nabla u + (\nabla u)^T\right),
        
        

where :math:`\sigma` is the stress tensor, :math:`\varrho` is the density of the
material, :math:`f` is the body force, :math:`\lambda` and :math:`\mu` are Lame's
elasticity coefficients for the material in :math:`\Omega` $I$ is the
identity tensor, tr is the trace operator on a tensor, :math:`\varepsilon`
is the strain tensor, and :math:`u` is the displacement vector field.

We shall combine :ref:`(34) <Eq:tut:elast:varform:stresstrain>` and
:ref:`(35) <Eq:tut:elast:varform:strainu>` to

.. _Eq:tut:elast:varform:stressu:

.. math::

    \tag{36}
    \sigma = \lambda\nabla\cdot u I + \mu(\nabla u + (\nabla u)^T){\thinspace .}
        
        

Note that :ref:`(33) <Eq:tut:elast:varform:equilibrium>`-:ref:`(35) <Eq:tut:elast:varform:strainu>`
can easily be transformed to a vector PDE for :math:`u`, which is the governing
PDE for the unknown :math:`u`. In the derivation of the variational formulation,
however, the splitting of the equations as done above is convenient.

The variational formulation of
:ref:`(33) <Eq:tut:elast:varform:equilibrium>`-:ref:`(35) <Eq:tut:elast:varform:strainu>`
consists of forming the inner product of
:ref:`(33) <Eq:tut:elast:varform:equilibrium>` and a *vector* test function
:math:`v\in \hat{V}`, where :math:`\hat{V}` is a test vector function space, and
integrating over the domain :math:`\Omega`:

.. math::
         \int_\Omega (\nabla\cdot\sigma) \cdot v {\, \mathrm{d}x} =
        \int_\Omega \varrho f\cdot v{\, \mathrm{d}x}{\thinspace .}

Since :math:`\nabla\cdot\sigma` contains second-order derivatives of the primary
unknown :math:`u`, we integrate this term by parts:

.. math::
         \int_\Omega (\nabla\cdot\sigma) \cdot \nabla v {\, \mathrm{d}x}
        -\int_\Omega \sigma : \nabla v{\, \mathrm{d}x} + \int_{\partial\Omega}
        (\sigma\cdot n)\cdot v {\, \mathrm{d}s},

where the colon operator is the inner product between tensors, and :math:`n`
is the outward unit normal at the boundary. The quantity :math:`\sigma\cdot n`
is known as the *traction* or stress vector at the boundary, and is often
prescribed as a boundary condition. We assume that it is prescribed
at a part :math:`\partial\Omega_T` of the boundary and set :math:`T = \sigma\cdot n`.
We then have

.. math::
        
        \int_\Omega (\sigma : \nabla v + \varrho f\cdot v) = \int_{\partial\Omega_T}
        T\cdot v{\, \mathrm{d}s}{\thinspace .}

Inserting :ref:`(36) <Eq:tut:elast:varform:stressu>` for :math:`\sigma` gives the
variational form with :math:`u` as unknown.

We can now summarize the variational formulation as find :math:`u\in V` such that

.. _Eq:_auto4:

.. math::

    \tag{37}
    a(u,v) = L(v)\quad\forall v\in\hat{V},
        
        

where

.. _Eq:_auto5:

.. math::

    \tag{38}
    a(u,v) = \int_\Omega\sigma(u) :\nabla v {\, \mathrm{d}x},
        
        

.. _Eq:_auto6:

.. math::

    \tag{39}
    \sigma(u) = \lambda\nabla\cdot u I + \mu(\nabla u + (\nabla u)^T),
        
        

.. _Eq:_auto7:

.. math::

    \tag{40}
    L(v) = -\int_\Omega \varrho f\cdot v{\, \mathrm{d}x} + \int_{\partial\Omega_T}
        T\cdot v{\, \mathrm{d}s}{\thinspace .}
        
        

One can show that the inner product of a symmetric tensor :math:`A` and a
non-symmetric tensor :math:`B` vanishes. If we express :math:`\nabla v` as a sum
of its symmetric and non-symmetric parts, only the symmetric part will
survive in the product :math:`\sigma :\nabla v` since :math:`\sigma` is a
symmetric tensor. This gives rise to the slightly different
variational form

.. _Eq:_auto8:

.. math::

    \tag{41}
    a(u,v) = \int_\Omega\sigma(u) :\varepsilon(v) {\, \mathrm{d}x},
        
        

where :math:`\varepsilon(v)` is the symmetric part of :math:`v`:

.. math::
         \varepsilon(v) = \frac{1}{2}(\nabla v + (\nabla v)^T){\thinspace .}

A simple implementation          (3)
------------------------------------

Test problem          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~

As test example, we may look at a clamped beam deformed under its
own weight.  Then :math:`f=(0,0,-g)` is the body force with :math:`g` as the
acceleration of gravity. The beam is box-shaped with length :math:`L` and
square cross section of width :math:`W`. We set :math:`u=(0,0,0)` at the clamped
end, :math:`x=0`. The rest of the boundaries is traction free.

Let us scale the problem. [**hpl 9**: This was meant to simplify the problem so we don't need values for :math:`\lambda`, :math:`\mu`, :math:`\varrho`, etc for a specific material, but the scaling requires some care.]
In the equation for :math:`u`, arising from inserting
:ref:`(34) <Eq:tut:elast:varform:stresstrain>` and
:ref:`(35) <Eq:tut:elast:varform:strainu>` in
:ref:`(33) <Eq:tut:elast:varform:equilibrium>`,

.. math::
         \nabla\cdot(\lambda\nabla\cdot u) + \mu\nabla^2 u = \varrho f,

we insert coordinates made dimensionless by :math:`L`, and :math:`\bar u=u/u_c`,
which results in the dimensionless governing equation

.. math::
        
        \bar\nabla\cdot(\bar\nabla\cdot \bar u) + \beta\bar\nabla^2 \bar u =
        \bar f,\quad \bar f = (0,0,\gamma),

where :math:`\beta = \mu/\lambda` is a dimensionless elasticity parameter and

.. math::
         \gamma = \frac{\varrho gL^2}{u_c\lambda}{\thinspace .}

Sometimes, one will argue to chose :math:`u_c` to make :math:`\gamma` unity (:math:`u_c
= \varrho gL^2/\lambda`).  This is often the reasoning for getting a
:math:`\bar u` that is of order unity. However, in elasticity, this leads us
to displacements of the size of the geometry, which looks very strange
in plots.  We therefore want the characteristic displacement to be a
small fraction of the characteristic length of the geometry.
Actually, for a clamped beam, one has a deflection formula which gives
:math:`u_c = \frac{3}{2}\varrho gL^2\delta^2/E`, where :math:`\delta = L/W`.
Thus, the dimensionless parameter :math:`\delta` is very important in the
problem (as expected: :math:`\delta\gg 1` is what gives beam theory).
Taking :math:`E` to be of the same order of :math:`\lambda`, we realize that
:math:`\gamma \sim \delta^{-2}`.  Experiments with the code point to :math:`\gamma
= 0.25\delta^{-2}` as an appropriate choice.  We implement the code
with physical parameters, :math:`\lambda`, :math:`\mu`, :math:`\varrho`, :math:`g`, :math:`L`, and
:math:`W`, but set these to achieve the solution of the scaled problem:
:math:`\lambda = \varrho = L = 1`, :math:`W` as :math:`W/L`, :math:`g=\gamma`, and
:math:`\mu=\beta`.

Code
~~~~

[**hpl 10**: Must explain the code. New concepts here, though not many.]

.. code-block:: python

        from fenics import *
        
        # Scaled variables
        L = 1; W = 0.2
        lambda_ = 1
        rho = 1
        delta = W/L
        gamma = 0.25*delta**2
        beta = 0.8
        mu = beta
        g = gamma
        
        # Create mesh and define function space
        mesh = BoxMesh(Point(0,0,0), Point(L,W,W), 10, 3, 3)
        V = VectorFunctionSpace(mesh, 'P', 1)
        
        # Define boundary conditions
        tol = 1E-14
        
        def clamped_boundary(x, on_boundary):
            return on_boundary and (x[0] < tol)
        
        bc = DirichletBC(V, Constant((0,0,0)), clamped_boundary)
        
        def epsilon(u):
            return 0.5*(nabla_grad(u) + nabla_grad(u).T)
            #return sym(nabla_grad(u))
        
        def sigma(u):
            return lambda_*nabla_div(u)*Identity(d) + 2*mu*epsilon(u)
        
        # Define variational problem
        u = TrialFunction(V)
        d = u.geometric_dimension()  # no of space dim
        v = TestFunction(V)
        f = rho*Constant((0,0,g))
        T = Constant((0,0,0))
        a = inner(sigma(u), epsilon(v))*dx
        L = -dot(f, v)*dx + dot(T, v)*ds
        
        # Compute solution
        u = Function(V)
        solve(a == L, u, bc)
        
        # Plot solution and mesh
        plot(u, title='Displacement', mode='displacement')
        
        von_Mises = inner(sigma(u), sigma(u)) - div(u)
        V = FunctionSpace(mesh, 'P', 1)
        von_Mises = project(von_Mises, V)
        plot(von_Mises, title='Stress intensity', mode='displacement')
        u_magnitude = sqrt(dot(u,u))
        u_magnitude = project(u_magnitude, V)
        plot(u_magnitude, 'Displacement magnitude', mode='displacement')
        print('min/max u:', u_magnitude.vector().array().min(),
              u_magnitude.vector().array().max())

.. figure:: beam1.png
   :width: 800

   Gravity-induced deformation of a clamped beam: deflection (left) and stress intensity (right)

.. Stand-alone notebook?

The Navier - Stokes equations
=============================

Should we here also include coupling to a transport equation? It shows
multi-physics capabilities.

Variational formulation          (4)
------------------------------------

A simple implementation          (4)
------------------------------------

