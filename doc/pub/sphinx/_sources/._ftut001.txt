.. !split

Preface
%%%%%%%

FEniCS is a user-friendly tool for solving partial differential
equations (PDEs). The goal of this tutorial is to get you started with
FEniCS through a series of simple examples that demonstrate

  * how to define the PDE problem in terms of a variational problem,

  * how to define simple domains,

  * how to deal with Dirichlet, Neumann, and Robin conditions,

  * how to deal with variable coefficients,

  * how to deal with domains built of several materials (subdomains),

  * how to compute derived quantities like the flux vector field or
    a functional of the solution,

  * how to quickly visualize the mesh, the solution, the flux, etc.,

  * how to solve nonlinear PDEs in various ways,

  * how to deal with time-dependent PDEs,

  * how to set parameters governing solution methods for linear systems,

  * how to create domains of more complex shape.

The mathematics of the illustrations is kept simple to better focus
on FEniCS functionality and syntax. This means that we mostly use
the Poisson equation and the time-dependent diffusion equation
as model problems, often with input data adjusted such that we get
a very simple solution that can be exactly reproduced by any standard
finite element method over a uniform, structured mesh. This
latter property greatly simplifies the verification of the implementations.
Occasionally we insert a physically more relevant example
to remind the reader that changing the PDE and boundary
conditions to something more real might often be a trivial task.

.. With the fundamentals explained, we move on to physically more

.. complicated problems, including systems of PDEs, and show how to build

.. more complete simulation codes.

FEniCS may seem to require a thorough understanding of the abstract
mathematical version of the finite element method as well as
familiarity with the Python programming language.  Nevertheless, it
turns out that many are able to pick up the fundamentals of finite
elements *and* Python programming as they go along with this
tutorial. Simply keep on reading and try out the examples. You will be
amazed of how easy it is to solve PDEs with FEniCS!

Reading this tutorial obviously requires access to a machine where the
FEniCS software is installed. The section :ref:`tut:app:install` explains
briefly how to install the necessary tools.

[**hpl 1**: Rethink how to organize program examples!]
[**hpl 2**: Drop transient and stationary.]

All the examples discussed in the following are available as
executable Python source code files in a `directory tree <https://github.com/hplgit/fenics-tutorial/blob/master/src>`__.
File paths reflect the nature of the PDE problem being solved. For
example, ``poisson/p2D_iter.py`` has a descriptive directory
path and a very brief Unix-style filename (here ``p2D`` for Poisson 2D
problem, and ``_iter`` for a version with iterative linear solvers).

**The FEniCS version.**
This document is up-to-date with FEniCS version 1.6. To see which version
you have, run the following command in a Unix/Linux terminal window if
you run Python version 2.7:

.. code-block:: text

        Terminal> python -c 'import fenics; print fenics.__version__'
        1.6.0

In Python version 3.x you must write

.. code-block:: text

        Terminal> python -c 'import fenics; print(fenics.__version__)'
        1.6.0

**The Python version.**
Python comes in two versions, 2 and 3, and these are not compatible.
FEniCS has a code base that runs under both versions.
All the programs in this tutorial are also developed such that they
can be run under both Python 2 and 3. Programs that need to print must
then start with

.. code-block:: python

        from __future__ import print_function

to  enable the ``print`` function from Python 3 in Python 2. All
use of ``print`` in the programs consists of function calls, like
``print('a:', a)``. Almost all other constructions are of a form that looks the
same in Python 2 and 3.

Acknowledgments
~~~~~~~~~~~~~~~

We thank Johan Hake, Kent-Andre Mardal, and Kristian Valen-Sendstad
for promptly answering all questions about FEniCS functionality and
for implementing all requests when preparing the first version of this
tutorial for the FEniCS book [Ref01]_.  We are particularly thankful to
Professor Douglas Arnold for very valuable feedback on early
versions of the text.  Øystein Sørensen pointed out a lot of typos and
contributed with many helpful comments.  Many errors and typos were
also reported by Mauricio Angeles, Ida Drøsdal, Miroslav Kuchta, Hans
Ekkehard Plesser, Marie Rognes, and Hans Joachim (Achim) Scroll.
Ekkehard Ellmann as well as two anonymous reviewers provided a series
of suggestions and improvements.

To-do list
==========

Remember: cannot exceed 150 pages (as reported at the end of ``ftut.log``).
Solutions to exercises will not appear in the printed book. If we run
out of pages, we can also remove the exercises by putting if-else
constructs around them. There will be one short printed tutorial and
then extended e-versions with exercises (and optionally solution) on our
github web site.

Regarding layout, we must use ``svmono.cls`` for the printed book, but
are allowed to use gray background in code boxes and lmodern instead
of Courier for monospace font. Springer's official ebook has exactly
the same layout. For all other versions on our github
web site, we can choose whatever layout we want.

 * Reorganize sections into chapters. (HPL)

 * Rethink how to organize example programs in directories.
   Find a naming convention. (AL)
   HPL suggestion: Drop the ``stationary`` and ``transient`` directories,
   have at most separate directories for each PDE.

 * Programs are now flat demos. Educate the reader with
   better software engineering habits: functions, classes, unit tests.
   Avoid copy-and-edit flat programs implied by today's collection. (HPL)

 * Compute maximum error already in the first example so we can create
   a unit test as early as possible. (Done, HPL)

 * Find successful exercises from various tutorials (AL) and add as
   exercises in the book (HPL/AL). Exercises are key for learning
   software so having them (in an extended version?) sends an important
   signal about their relevance.

 * Write about installation in a way that does not get outdated.
   More as a guide to a newcomer: What to choose? (AL)

 * Multi-boundary examples do not work with FEniCS 1.6: ``dnr*.py``. (AL)

 * ``membrane2.py`` referred to, but it is still in sandbox. (HPL)

 * Meshr domains. Set up some common continuum mechanics examples first. (HPL/AL)

 * Decide on an elasticity problem.

 * Simple Navier-Stokes solver. Do backward facing step and flow around a
   cylinder.

 * According to the ``plot`` doc string, it should be easy to
   plot the element a la ``plot(u.function_space().ufl_element())`` but I
   did not get this to work. Not crucial, but plotting the element is a
   nice feature :-)

 * Show how the definition of boundaries can be done via strings
   compiled to C++ (as soon as we have an example with non-trivial
   boundary segments), cf. Navier-Stokes FEniCS demo.

 * Can we change the value of ``DOLFIN_EPS``? ``imort fenics; fenics.DOLFIN_EPS=...`` will work, but then all modules in the simulator must do ``import fenics``. Note that its value is very strict, e.g., ``10.1+10.2`` has rounding :math:`3.5 10^{-15}`, so ``DOLFIN_EPS`` is strictly for scaled problems only, where all variables are in :math:`[0,1]`.

 * Comment regarding FEniCS demos: The documented demos mention a lot
   of packages: DOLFIN, FFC, Fiat, ... Make sure the reader of the tutorial
   does not get lost in the jungle of packages and make sure the names are
   explained somewhere in the text
   such that the tutorial is a good background for
   understanding every demo in every detail.

 * Specifications of boundaries (``SubDomain``) can be done by a C++
   string as in ``DirichletBC(V, (0,0), 'on_boundary && x[0] < DOLFIN_EPS')``.
   This is an important performance enhancement for large meshes in time
   dependent problems so it should be documented.

HPL questions
-------------

Iterative linear solvers info
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can get this printed out on the screen, but is there any method to
extract this text inside the program, such that we can see how many
Krylov iterations we do etc.? Any way for Python to capture the standard
output stream in C++?

Easy to write a script that post-processes
the output, but we have to wait until the simulator has terminated, or
we can pipe to a script ``process.py`` that treats the output in some
desired way (could append some into to a file and that is reopened
by the simulator):

.. code-block:: text

        Terminal> python mysolver.py | process.py

where the simplest ``process.py`` is

.. code-block:: python

        import sys, time
        t0 = time.clock()
        while True:
            line = sys.stdin.readline()
            if not line:
                break
            t1 = time.clock()
            print 'after %g seconds: %s' % (t1-t0, line.rstrip())
        print 'END'

