<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>More old stuff</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Troubleshooting" href="._ftut008.html" />
    <link rel="prev" title="The nonlinear Poisson solver revisited" href="._ftut006.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut006.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut008.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="more-old-stuff">
<h1>More old stuff<a class="headerlink" href="#more-old-stuff" title="Permalink to this headline">¶</a></h1>
<div class="section" id="creating-more-complex-domains">
<span id="ftut-prepro"></span><h2>Creating more complex domains<a class="headerlink" href="#creating-more-complex-domains" title="Permalink to this headline">¶</a></h2>
<p>Up to now we have been very fond of the unit square as domain,
which is an appropriate choice for initial versions of a
PDE solver. The strength of the finite element method, however, is its
ease of handling domains with complex shapes. This section
shows some methods that can be used to create different types of
domains and meshes.</p>
<p>Domains of complex shape must normally be constructed in separate
preprocessor programs. Two relevant preprocessors are Triangle for
2D domains and NETGEN for 3D domains.</p>
<div class="section" id="built-in-mesh-generation-tools">
<span id="ftut-prepro-builtin"></span><h3>Built-in mesh generation tools<a class="headerlink" href="#built-in-mesh-generation-tools" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">DOLFIN has a few tools for creating various types of meshes over
domains with simple
shape:
<code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>,
<code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>,
<code class="docutils literal"><span class="pre">UnitCubeMesh</span></code>,
<code class="docutils literal"><span class="pre">IntervalMesh</span></code>,
<code class="docutils literal"><span class="pre">RectangleMesh</span></code>, and
<code class="docutils literal"><span class="pre">BoxMesh</span></code>.
Some of these names have been briefly met in previous sections.
The hopefully self-explanatory code snippet below summarizes
typical constructions of meshes with the aid of these tools:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1D domains</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>     <span class="c"># 20 cells, 21 vertices</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># domain [-1,1]</span>

<span class="c"># 2D domains (6x10 divisions, 120 cells, 77 vertices)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># &#39;right&#39; diagonal is default</span>
<span class="c"># The diagonals can be right, left or crossed</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># Domain [0,3]x[0,2] with 6x10 divisions and left diagonals</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>

<span class="c"># 6x10x5 boxes in the unit cube, each box gets 6 tetrahedra:</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c"># Domain [-1,1]x[-1,0]x[-1,2] with 6x10x5 divisions</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transforming-mesh-coordinates">
<span id="ftut-mesh-transform-cyl"></span><h3>Transforming mesh coordinates<a class="headerlink" href="#transforming-mesh-coordinates" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-6"></span><span class="target" id="index-7"></span><div class="section" id="coordinate-stretching">
<span id="index-8"></span><h4>Coordinate stretching<a class="headerlink" href="#coordinate-stretching" title="Permalink to this headline">¶</a></h4>
<p>A mesh that is denser toward a boundary is often desired to increase
accuracy in that region. Given a mesh with uniformly spaced
coordinates <span class="math">\(x_0,\ldots,x_{M-1}\)</span> in <span class="math">\([a,b]\)</span>, the coordinate transformation
<span class="math">\(\xi = (x-a)/(b-a)\)</span> maps <span class="math">\(x\)</span> onto <span class="math">\(\xi\in [0,1]\)</span>. A new mapping
<span class="math">\(\eta = \xi^s\)</span>, for some <span class="math">\(s&gt;1\)</span>, stretches the mesh toward <span class="math">\(\xi=0\)</span> (<span class="math">\(x=a\)</span>),
while <span class="math">\(\eta = \xi^{1/s}\)</span> makes a stretching toward <span class="math">\(\xi=1\)</span> (<span class="math">\(x=b\)</span>).
Mapping the <span class="math">\(\eta\in[0,1]\)</span> coordinates back to <span class="math">\([a,b]\)</span> gives new,
stretched <span class="math">\(x\)</span> coordinates,</p>
<div class="math" id="eq-auto45">
\[\tag{106}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^s\]</div>
<p>toward <span class="math">\(x=a\)</span>, or</p>
<div class="math" id="eq-auto46">
\[\tag{107}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^{1/s}\]</div>
<p>toward <span class="math">\(x=b\)</span>. Figure <a class="reference internal" href="#ftut-mesh-transform-cyl-fig1"><span class="std std-ref">Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</span></a> shows the
effect of making a rectangular mesh denser toward <span class="math">\(x=0\)</span> (prior to
the coordinate transformation below).</p>
</div>
<div class="section" id="rectangle-to-hollow-circle-mapping">
<h4>Rectangle to hollow circle mapping<a class="headerlink" href="#rectangle-to-hollow-circle-mapping" title="Permalink to this headline">¶</a></h4>
<p>One way of creating more complex geometries is to transform the
vertex coordinates in a rectangular mesh according to some formula.
Say we want to create a part of a hollow cylinder of <span class="math">\(\Theta\)</span> degrees,
with inner radius <span class="math">\(a\)</span> and outer radius <span class="math">\(b\)</span>. A standard mapping from polar
coordinates to Cartesian coordinates can be used to generate the
hollow cylinder. Given a rectangle in <span class="math">\((\bar x, \bar y)\)</span> space such that
<span class="math">\(a\leq \bar x\leq b\)</span> and <span class="math">\(0\leq \bar y\leq 1\)</span>, the mapping</p>
<div class="math">
\[\hat x = \bar x\cos (\Theta \bar y),\quad \hat y = \bar x\sin (\Theta \bar y),\]</div>
<p>takes a point in the rectangular <span class="math">\((\bar x,\bar y)\)</span>
geometry and maps it to a point
<span class="math">\((\hat x, \hat y)\)</span> in a hollow cylinder.</p>
<p>The corresponding Python code for first stretching the mesh and
then mapping it onto a hollow cylinder looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Theta</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">5.0</span>
<span class="n">nr</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c"># divisions in r direction</span>
<span class="n">nt</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c"># divisions in theta direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># First make a denser mesh towards r=a</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">1.3</span>

<span class="k">def</span> <span class="nf">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">))</span><span class="o">**</span><span class="n">s</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span> <span class="o">=</span> <span class="n">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">xy_bar_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_bar_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;stretched mesh&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">)]</span>

<span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span> <span class="o">=</span> <span class="n">cylinder</span><span class="p">(</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">)</span>
<span class="n">xy_hat_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_hat_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;hollow cylinder&#39;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The result of calling <code class="docutils literal"><span class="pre">denser</span></code> and <code class="docutils literal"><span class="pre">cylinder</span></code> above is a list of two
vectors, with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates, respectively.
Turning this list into a <code class="docutils literal"><span class="pre">numpy</span></code> array object results in a <span class="math">\(2\times M\)</span>
array, <span class="math">\(M\)</span> being the number of vertices in the mesh. However,
<code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> is by a convention an <span class="math">\(M\times 2\)</span> array so we
need to take the transpose. The resulting mesh is displayed
in Figure <a class="reference internal" href="#ftut-mesh-transform-cyl-fig1"><span class="std std-ref">Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</span></a>.</p>
<div class="figure" id="id4">
<span id="ftut-mesh-transform-cyl-fig1"></span><a class="reference internal image-reference" href="_images/hollow_cylinder.png"><img alt="_images/hollow_cylinder.png" src="_images/hollow_cylinder.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</em></span></p>
</div>
<p>Setting boundary conditions in meshes created from mappings like the one
illustrated above is most conveniently done by using a mesh function
to mark parts of the boundary. The marking is easiest to perform
before the mesh is mapped since one can then conceptually work with
the sides in a pure rectangle.</p>
</div>
</div>
</div>
<div class="section" id="a-general-dimensional-multi-material-test-problem">
<span id="ftut-possion-nd-nmat"></span><h2>A General <span class="math">\(d\)</span>-Dimensional multi-material test problem<a class="headerlink" href="#a-general-dimensional-multi-material-test-problem" title="Permalink to this headline">¶</a></h2>
<p><strong>This section is in a preliminary state!</strong></p>
<p>The purpose of the present section is to generalize the basic
ideas from the previous section to a problem involving
an arbitrary number of materials in 1D, 2D, or 3D domains.
The example also highlights how to build more general and flexible
FEniCS applications.</p>
<p>More to be done:</p>
<blockquote>
<div><ul class="simple">
<li>Batch compilation of subdomains, see mailinglist.txt, lots of
useful stuff in Hake&#8217;s example with &#8220;pointwise&#8221;, see what the
bcs are etc.</li>
<li>Use of <code class="docutils literal"><span class="pre">near</span></code> or similar function (better: user-adjusted tolerance)</li>
</ul>
</div></blockquote>
<div class="section" id="the-pde-problem">
<span id="ftut-possion-nd-nmat-pde"></span><h3>The PDE problem<a class="headerlink" href="#the-pde-problem" title="Permalink to this headline">¶</a></h3>
<p>We generalize the problem in the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>
to the case where there are <span class="math">\(s\)</span> materials <span class="math">\(\Omega_0,\ldots,\Omega_{s-1}\)</span>,
with associated constant <span class="math">\(k\)</span> values <span class="math">\(k_0,k_1,\ldots,k_{s-1}\)</span>,
as illustrated in Figure <a class="reference internal" href="#ftut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a>.</p>
<div class="figure" id="id5">
<span id="ftut-possion-nd-nmat-fig1"></span><a class="reference internal image-reference" href="_images/layers.sh"><img alt="_images/layers.sh" src="_images/layers.sh" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a multi-material problem</em></span></p>
</div>
<p>Although the sketch of the domain is in two dimensions, we can easily
define this problem in any number of dimensions, using
the ideas of the section <a class="reference internal" href="._ftut004.html#ftut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>, but the layer
boundaries are planes <span class="math">\(x_0=\hbox{const}\)</span> and <span class="math">\(u\)</span> varies with
<span class="math">\(x_0\)</span> only.</p>
<p>The PDE reads</p>
<div class="math" id="eq-ftut-poisson-2d-varcoeff2">
\[\tag{108}
\nabla\cdot (k\nabla u) =0 {\thinspace .}\]</div>
<p>To construct a problem where we can find an analytical solution that can
be computed to machine precision regardless of the element size,
we choose <span class="math">\(\Omega\)</span> as a hypercube <span class="math">\([0,1]^d\)</span>, and the materials as
layers in the <span class="math">\(x_0\)</span> direction, as depicted in
Figure <a class="reference internal" href="#ftut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a> for a 2D case with four materials.
The boundaries <span class="math">\(x_0=0\)</span> and <span class="math">\(x_0=1\)</span> have Dirichlet conditions
<span class="math">\(u=0\)</span> and <span class="math">\(u=1\)</span>, respectively, while Neumann conditions
<span class="math">\(\partial u/\partial n=0\)</span> are set on the remaining boundaries.
The complete boundary-value problem is then</p>
<div class="math" id="eq-ftut-poisson-2d-varcoeff3">
\[\begin{split}\tag{109}
\begin{array}{rcll}
        \nabla\cdot \left(k(x_0)\nabla u(x_0,\ldots,x_{d-1})\right)
          &amp;= 0 &amp;\mbox{in } \Omega, \\
        u &amp;= 0 &amp;\mbox{on } \Gamma_0,\\
        u &amp;= 1 &amp;\mbox{on } \Gamma_1,\\
        {\partial u\over\partial n} &amp;= 0 &amp;\mbox{on } \Gamma_N{\thinspace .}
      \end{array}\end{split}\]</div>
<p>The domain <span class="math">\(\Omega\)</span> is divided into <span class="math">\(s\)</span> materials <span class="math">\(\Omega_i\)</span>, <span class="math">\(i=0,\ldots,s-1\)</span>,
where</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i \leq x_0 &lt; L_{i+1}\}\end{split}\]</div>
<p>for given <span class="math">\(x_0\)</span> values <span class="math">\(0=L_0 &lt; L_1 &lt; \cdots &lt; L_s=1\)</span>
of the material (subdomain) boundaries.
The <span class="math">\(k(x_0)\)</span> function takes on the value <span class="math">\(k_i\)</span> in <span class="math">\(\Omega_i\)</span>.</p>
<p>The exact solution of the basic PDE
in <a class="reference internal" href="#eq-ftut-poisson-2d-varcoeff3"><span class="std std-ref">(109)</span></a></p>
<div class="math">
\[u(x_0,\ldots,x_{d-1}) =
{\int_0^{x_0} (k(\tau ))^{-1}d\tau\over
\int_0^1 (k(\tau ))^{-1}d\tau}{\thinspace .}\]</div>
<p>For a piecewise constant <span class="math">\(k(x_0)\)</span> as explained, we get</p>
<div class="math" id="eq-ftut-poisson-2d-varcoeff2-exact">
\[\tag{110}
u(x_0,\ldots,x_{d-1}) =
    {(x_0-L_i)k_i^{-1} + \sum_{j=0}^{i-1} (L_{j+1}-L_j)k_j^{-1}\over
    \sum_{j=0}^{s-1} (L_{j+1}-L_j)k_j^{-1}},\quad L_i\leq x_0 \leq L_{i+1}{\thinspace .}\]</div>
<p>That is, <span class="math">\(u(x_0,\ldots,x_{d-1})\)</span> is piecewise linear in <span class="math">\(x_0\)</span> and
constant in all other directions.
If <span class="math">\(L_i\)</span>
coincides with the element boundaries, Lagrange elements will
reproduce this exact solution to machine precision, which is ideal
for a test case.</p>
</div>
<div class="section" id="preparing-a-mesh-with-subdomains">
<span id="ftut-possion-nd-nmat-prepro"></span><h3>Preparing a mesh with subdomains<a class="headerlink" href="#preparing-a-mesh-with-subdomains" title="Permalink to this headline">¶</a></h3>
<p>Our first task is to generate a mesh for <span class="math">\(\Omega = [0,1]^d\)</span> and divide
it into subdomains</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i &lt; x_0 &lt; L_{i+1}\}\end{split}\]</div>
<p>for given subdomain boundaries <span class="math">\(x_0=L_i\)</span>, <span class="math">\(i=0,\ldots,s\)</span>, <span class="math">\(L_0=0\)</span>, <span class="math">\(L_s=1\)</span>.
Note that the boundaries <span class="math">\(x_0=L_i\)</span> are points in 1D, lines in 2D, and
planes in 3D.</p>
<p>Let us, on the command line, specify the polynomial degree of Lagrange
elements and the number of element divisions in the various space
directions, as explained in detail in
the section <a class="reference internal" href="._ftut004.html#ftut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>. This results in an object <code class="docutils literal"><span class="pre">mesh</span></code>
representing the interval <span class="math">\([0,1]\)</span> in 1D, the unit square in 2D, or the
unit cube in 3D.</p>
<p>Specification of subdomains (and boundary parts, if desired) is
done using a user-defined subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code>, as
explained in the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>.
We could, in principle,
introduce one subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code> for each subdomain, and
this would be feasible if one has a small and fixed number of
subdomains as in the example in the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a> with
two subdomains. Our present case is more general as we
have <span class="math">\(s\)</span> subdomains. It then makes sense to create one
subclass <code class="docutils literal"><span class="pre">Material</span></code> of <code class="docutils literal"><span class="pre">SubDomain</span></code> and have an attribute
to reflect the subdomain (material) number. We use this number
in the test whether a spatial point <code class="docutils literal"><span class="pre">x</span></code> is inside a subdomain or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Material</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define material (subdomain) no. i.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomain_number</span><span class="p">,</span> <span class="n">subdomain_boundaries</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">subdomain_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">subdomain_boundaries</span>
        <span class="n">SubDomain</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span>         <span class="c"># short form (cf. the math)</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&lt;=</span></code> in the test if a point is inside a subdomain is important as
<code class="docutils literal"><span class="pre">x</span></code> will equal vertex coordinates in the cells, and all vertices
of a cell must lead to a <code class="docutils literal"><span class="pre">True</span></code> return value from the <code class="docutils literal"><span class="pre">inside</span></code>
method
for the cell to be a part of the actual subdomain. That is, the
more mathematically natural test <code class="docutils literal"><span class="pre">L[i]</span> <span class="pre">&lt;=</span> <span class="pre">x[0]</span> <span class="pre">&lt;</span> <span class="pre">L[i+1]</span></code> fails to
include elements with <span class="math">\(x=L_{i+1}\)</span> as boundary in subdomain <span class="math">\(\Omega_i\)</span>.</p>
<p>The marking and numbering of all subdomains
goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cell_entity_dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c"># = d</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">cell_entity_dim</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers i=0,1,\ldots,s (=len(L)-1)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">material_i</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">material_i</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>We have now all the geometric information about subdomains in
a <code class="docutils literal"><span class="pre">MeshFunction</span></code> object <code class="docutils literal"><span class="pre">subdomains</span></code>. The subdomain number
of mesh entity number <code class="docutils literal"><span class="pre">e</span></code>, here cell <code class="docutils literal"><span class="pre">e</span></code>, is given
by <code class="docutils literal"><span class="pre">subdomains.array()[e]</span></code>.</p>
<p id="index-9">The code presented so far had the purpose of preparing a mesh and
a mesh function defining the subdomain. It is smart to put this code
in a separate file, say <code class="docutils literal"><span class="pre">ft16_define_layers.py</span></code>,
and view the code as a preprocessing step.
We must then store the computed mesh and mesh function in files.
Another program may load the files and perform the actually
solve the boundary-value problem.</p>
<p>Storing the mesh itself and the mesh function in XML format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">subdomains</span>
</pre></div>
</div>
<p>This preprocessing code knows about the layer geometries and
the corresponding <span class="math">\(k\)</span>, which
must be propagated to the solver code. One idea is to let the
preprocessing code write a Python module containing
the <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">k</span></code> lists as well as an implementation of a
function that evaluates the exact solution.
The solver code can import this module to get access to <code class="docutils literal"><span class="pre">L</span></code>,
<code class="docutils literal"><span class="pre">k</span></code>, and the exact solution (for comparison).
The relevant Python code for generating a Python module may take
the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;u_layered.py&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">import numpy</span>
<span class="s">L = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">k = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">s = len(L)-1</span>

<span class="s">def u_e(x):</span>
<span class="s">    # First find which subdomain x0 is located in</span>
<span class="s">    for i in range(len(L)-1):</span>
<span class="s">        if L[i] &lt;= x &lt;= L[i+1]:</span>
<span class="s">            break</span>

<span class="s">    # Vectorized implementation of summation:</span>
<span class="s">    s2 = sum((L[1:s+1] - L[0:s])*(1.0/k[:]))</span>
<span class="s">    if i == 0:</span>
<span class="s">        u = (x - L[i])*(1.0/k[0])/s2</span>
<span class="s">    else:</span>
<span class="s">        s1 = sum((L[1:i+1] - L[0:i])*(1.0/k[0:i]))</span>
<span class="s">        u = ((x - L[i])*(1.0/k[i]) + s1)/s2</span>
<span class="s">    return u</span>

<span class="s">if __name__ == &#39;__main__&#39;:</span>
<span class="s">    # Plot the exact solution</span>
<span class="s">    from scitools.std import linspace, plot, array</span>
<span class="s">    x = linspace(0, 1, 101)</span>
<span class="s">    u = array([u_e(xi) for xi in x])</span>
<span class="s">    print(u)</span>
<span class="s">    plot(x, u)</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># (L, k))</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-the-pde-problem">
<span id="ftut-possion-nd-nmat-solve"></span><h3>Solving the PDE problem<a class="headerlink" href="#solving-the-pde-problem" title="Permalink to this headline">¶</a></h3>
<p>The solver program starts with loading a prepared mesh with a mesh
function representing the subdomains:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the <span class="math">\(k\)</span> function as a finite element function.
As we recall from the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>, a <span class="math">\(k\)</span> that
is constant in each element is suitable.
We then follow the recipe from the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>
to compute <span class="math">\(k\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>

<span class="c"># Vectorized calculation</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The essential boundary conditions are defined in the same way is
in <code class="docutils literal"><span class="pre">dn2_p2D.py</span></code> from the section <a class="reference internal" href="._ftut004.html#ftut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>
and therefore not repeated here.
The variational problem is defined and solved in a standard manner,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">VariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Plotting the discontinuous <code class="docutils literal"><span class="pre">k</span></code> is often desired. Just a <code class="docutils literal"><span class="pre">plot(k)</span></code>
makes a continuous function out of <code class="docutils literal"><span class="pre">k</span></code>, which is not what we want.
Making a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells and filling in the right <span class="math">\(k\)</span>
values results in an object that can be displayed as a discontinuous field.
A relevant code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_meshfunc</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;double&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>

<span class="c"># Scalar version</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]]</span>

<span class="c"># Vectorized version</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">k_meshfunc</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;k as mesh function&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <code class="docutils literal"><span class="pre">ft17_Poisson_layers.py</span></code> contains the complete code.</p>
</div>
</div>
<div class="section" id="more-examples">
<h2>More Examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h2>
<p>Many more topics could be treated in a FEniCS tutorial, e.g., how
to solve systems of PDEs, how to work with mixed finite element
methods, how to create more complicated meshes and mark boundaries,
and how to create more advanced visualizations.  However, to limit the
size of this tutorial, the examples end here.
There are, fortunately, a rich set of FEniCS demos.
The FEniCS documentation explains a collection of PDE solvers in detail:
the Poisson equation, the mixed formulation for the Poission equation,
the Biharmonic equation, the equations of hyperelasticity, the
Cahn-Hilliard equation, and the incompressible Navier-Stokes equations.
Both Python and C++ versions of these solvers are explained.
An eigenvalue solver is also documented.
In the <code class="docutils literal"><span class="pre">fenics/demo</span></code> directory of the DOLFIN source code tree you can
find programs for these and many other examples, including
the advection-diffusion equation,
the equations of elastodynamics,
a reaction-diffusion equation,
various finite element methods for the Stokes problem,
discontinuous Galerkin methods for
the Poisson and advection-diffusion equations,
and an eigenvalue problem arising from electromagnetic waveguide
problem with Nedelec elements.
There are also numerous demos on how to apply various functionality in
FEniCS, e.g., mesh refinement and error control,
moving meshes (for ALE methods),
computing functionals over subsets of the mesh (such as
lift and drag on bodies in flow), and
creating separate subdomain meshes from a parent mesh.</p>
<p>The project cbc.solve (<a class="reference external" href="https://launchpad.net/cbc.solve">https://launchpad.net/cbc.solve</a>) offers
more complete PDE solvers for the Navier-Stokes equations, the
equations of hyperelasticity, fluid-structure interaction, viscous
mantle flow, and the bidomain model of electrophysiology.  Most of
these solvers are described in the &#8220;FEniCS book&#8221; <a class="reference internal" href="._ftut008.html#ref01" id="id1">[Ref01]</a>
(<a class="reference external" href="https://launchpad.net/fenics-book">https://launchpad.net/fenics-book</a>).  Another project, cbc.rans
(<a class="reference external" href="https://launchpad.net/cbc.rans">https://launchpad.net/cbc.rans</a>), offers an environment for very
flexible and easy implementation of Navier-Stokes solvers and
turbulence <a class="reference internal" href="._ftut008.html#ref23" id="id2">[Ref23]</a> <a class="reference internal" href="._ftut008.html#ref24" id="id3">[Ref24]</a>. For example, cbc.rans
contains an elliptic relaxation model for turbulent flow involving 18
nonlinear PDEs.  FEniCS proved to be an ideal environment for
implementing such complicated PDE models.  The easy construction of
systems of nonlinear PDEs in cbc.rans has been further generalized to
simplify the implementation of large systems of nonlinear PDEs in
general.  The functionality is found in the cbc.pdesys package
(<a class="reference external" href="https://launchpad.net/cbcpdesys">https://launchpad.net/cbcpdesys</a>).</p>
</div>
<div class="section" id="miscellaneous-topics">
<h2>Miscellaneous topics<a class="headerlink" href="#miscellaneous-topics" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 22</strong>: Needs to be cleaned up.]</p>
<div class="section" id="glossary">
<h3>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><p id="index-18">Below we explain some key terms used in this tutorial.</p>
<blockquote>
<div><dl class="docutils">
<dt>FEniCS: name of a software suite composed of many individual software</dt>
<dd>components (see <code class="docutils literal"><span class="pre">fenicsproject.org</span></code>). Some components are DOLFIN and
Viper, explicitly referred to in this tutorial. Others are
FFC and FIAT, heavily used by the programs appearing in this tutorial,
but never explicitly used from the programs.</dd>
<dt>DOLFIN: a FEniCS component, more precisely a C++ library, with</dt>
<dd>a Python interface, for performing important actions in finite element
programs. DOLFIN makes use of many other FEniCS components and
many external software packages.</dd>
<dt>Viper:  a FEniCS component for quick visualization of finite element</dt>
<dd>meshes and solutions.</dd>
<dt>UFL:    a FEniCS component implementing the <em>unified form language</em></dt>
<dd>for specifying finite element forms in FEniCS programs.
The definition of the forms, typically called <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> in
this tutorial, must have legal UFL syntax. The same applies to
the definition of functionals (see the section <a class="reference internal" href="._ftut004.html#ftut-poisson1-functionals"><span class="std std-ref">Computing functionals</span></a>).</dd>
<dt>Class (Python): a programming construction for creating objects</dt>
<dd>containing a set of variables and functions. Most
types of FEniCS objects are defined through the class concept.</dd>
<dt>Instance (Python): an object of a particular type, where the type is</dt>
<dd>implemented as a class. For instance,
<code class="docutils literal"><span class="pre">mesh</span> <span class="pre">=</span> <span class="pre">UnitIntervalMesh(10)</span></code> creates
an instance of class <code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>, which is reached by the
name <code class="docutils literal"><span class="pre">mesh</span></code>. (Class <code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code> is actually just
an interface to a corresponding C++ class in the DOLFIN C++ library.)</dd>
<dt>Class method (Python): a function in a class, reached by dot</dt>
<dd>notation: <code class="docutils literal"><span class="pre">instance_name.method_name</span></code></dd>
<dt>argument <code class="docutils literal"><span class="pre">self</span></code> (Python): required first parameter in class methods,</dt>
<dd>representing a particular object of the class.
Used in method definitions, but never in calls to a method.
For example, if <code class="docutils literal"><span class="pre">method(self,</span> <span class="pre">x)</span></code> is the definition of
<code class="docutils literal"><span class="pre">method</span></code> in a class <code class="docutils literal"><span class="pre">Y</span></code>, <code class="docutils literal"><span class="pre">method</span></code> is called as
<code class="docutils literal"><span class="pre">y.method(x)</span></code>, where <code class="docutils literal"><span class="pre">y</span></code> is an instance of class <code class="docutils literal"><span class="pre">Y</span></code>.
In a call like <code class="docutils literal"><span class="pre">y.method(x)</span></code>, <code class="docutils literal"><span class="pre">method</span></code> is invoked with
<code class="docutils literal"><span class="pre">self=y</span></code>.</dd>
<dt>Class attribute (Python): a variable in a class, reached by</dt>
<dd>dot notation: <code class="docutils literal"><span class="pre">instance_name.attribute_name</span></code></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="handy-methods-in-key-fenics-objects">
<h3>Handy methods in key FEniCS objects<a class="headerlink" href="#handy-methods-in-key-fenics-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-19">In general,
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">fenics.X</span></code> shows the documentation of any name <code class="docutils literal"><span class="pre">X</span></code>
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.</p>
<div class="section" id="mesh">
<h4>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h4>
<p>Let <code class="docutils literal"><span class="pre">mesh</span></code> be a <code class="docutils literal"><span class="pre">Mesh</span></code> object.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns an array of the coordinates of</dt>
<dd><p class="first last">the vertices in the mesh.</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_cells()</span></code> returns the number of cells (triangles)
in the mesh,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_vertices()</span></code> returns the number of vertices in
the mesh (with our choice of linear Lagrange elements this equals the
number of nodes, <code class="docutils literal"><span class="pre">len(u_array)</span></code>, or dimension of the space <code class="docutils literal"><span class="pre">V.dim()</span></code>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.cells()</span></code> returns the vertex numbers of the vertices in
each cell as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape
(<em>number of cells</em>, <em>number of vertices in a cell</em>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmin()</span></code> returns the minimum cell diameter (&#8220;smallest cell&#8221;),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmax()</span></code> returns the maximum cell diameter (&#8220;largest cell&#8221;).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.topology().dim()</span></code> returns the number of physical dimensions of
the mesh.</p>
</li>
</ul>
</div></blockquote>
<p>Writing <code class="docutils literal"><span class="pre">print(mesh)</span></code> dumps a short, pretty-print description
of the mesh (<code class="docutils literal"><span class="pre">print(mesh)</span></code> actually displays the result of <code class="docutils literal"><span class="pre">str(mesh)</span></code>,
which defines the pretty print):</p>
<div class="highlight-text"><div class="highlight"><pre>&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>
</div>
</div>
<div class="section" id="function-space">
<h4>Function space<a class="headerlink" href="#function-space" title="Permalink to this headline">¶</a></h4>
<p>Let <code class="docutils literal"><span class="pre">V</span></code> be a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">V.mesh()</span></code> returns the associated mesh.</li>
<li><code class="docutils literal"><span class="pre">V.dim()</span></code> returns the dimension (number of degrees of freedom).</li>
<li><code class="docutils literal"><span class="pre">V.ufl_element()</span></code> returns the associated finite element.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="function">
<h4>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h4>
<p>Let <code class="docutils literal"><span class="pre">u</span></code> be a <code class="docutils literal"><span class="pre">Function</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u.function_space()</span></code> returns the associated function space.</li>
<li><code class="docutils literal"><span class="pre">u.vector()</span></code> returns the vector object of degrees of freedom.</li>
<li><code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a copy of the degrees of freedom
in a <code class="docutils literal"><span class="pre">numpy</span></code> array.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="overview-of-objects-and-functions">
<h3>Overview of objects and functions<a class="headerlink" href="#overview-of-objects-and-functions" title="Permalink to this headline">¶</a></h3>
<p>Most classes in FEniCS have an explanation of the purpose and usage
that can be seen by using the general documentation command
<code class="docutils literal"><span class="pre">pydoc</span></code> for Python objects. You can type</p>
<div class="highlight-text" id="index-20"><div class="highlight"><pre>pydoc fenics.X
</pre></div>
</div>
<p>to look up documentation of a Python class <code class="docutils literal"><span class="pre">X</span></code> from the DOLFIN
library (<code class="docutils literal"><span class="pre">X</span></code> can be <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>,
<code class="docutils literal"><span class="pre">Viper</span></code>, etc.). Below is an overview of the most important classes
and functions
in FEniCS programs, in the order they typically appear within programs.</p>
<p><code class="docutils literal"><span class="pre">UnitSquareMesh(nx,</span> <span class="pre">ny)</span></code>: generate mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span> using <code class="docutils literal"><span class="pre">nx</span></code> divisions in <span class="math">\(x\)</span> direction and
<code class="docutils literal"><span class="pre">ny</span></code> divisions in <span class="math">\(y\)</span> direction. Each of the <code class="docutils literal"><span class="pre">nx*ny</span></code> squares
are divided into two cells of triangular shape.</p>
<p><code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>, <code class="docutils literal"><span class="pre">UnitCubeMesh</span></code>, <code class="docutils literal"><span class="pre">UnitCircleMesh</span></code>, <code class="docutils literal"><span class="pre">UnitSphere</span></code>,
<code class="docutils literal"><span class="pre">IntervalMesh</span></code>, <code class="docutils literal"><span class="pre">RectangleMesh</span></code>, and <code class="docutils literal"><span class="pre">BoxMesh</span></code>: generate mesh over
domains of simple geometric shape, see the section <a class="reference internal" href="#ftut-prepro"><span class="std std-ref">Creating more complex domains</span></a>.</p>
<p><code class="docutils literal"><span class="pre">FunctionSpace(mesh,</span> <span class="pre">element_type,</span> <span class="pre">degree)</span></code>:
a function space defined over a mesh, with a given element type
(e.g., <code class="docutils literal"><span class="pre">'Lagrange'</span></code> or <code class="docutils literal"><span class="pre">'DG'</span></code>), with basis functions as polynomials of
a specified degree.</p>
<p><code class="docutils literal"><span class="pre">Expression(formula,</span> <span class="pre">p1=v1,</span> <span class="pre">p2=v2,</span> <span class="pre">...)</span></code>:
a scalar- or vector-valued function, given as a
mathematical expression <code class="docutils literal"><span class="pre">formula</span></code> (string) written in C++ syntax.
The spatial coordinates in the expression are named
<code class="docutils literal"><span class="pre">x[0]</span></code>, <code class="docutils literal"><span class="pre">x[1]</span></code>, and <code class="docutils literal"><span class="pre">x[2]</span></code>, while time and other
physical parameters can be represented as symbols <code class="docutils literal"><span class="pre">p1</span></code>, <code class="docutils literal"><span class="pre">p2</span></code>,
etc., with corresponding values <code class="docutils literal"><span class="pre">v1</span></code>, <code class="docutils literal"><span class="pre">v2</span></code>, etc., initialized
through keyword arguments. These parameters become attributes,
whose values can be modified when desired.</p>
<p><code class="docutils literal"><span class="pre">Function(V)</span></code>: a scalar- or vector-valued finite element field in
the function space <code class="docutils literal"><span class="pre">V</span></code>. If <code class="docutils literal"><span class="pre">V</span></code> is a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> object,
<code class="docutils literal"><span class="pre">Function(V)</span></code> becomes a scalar field, and with <code class="docutils literal"><span class="pre">V</span></code> as a
<code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> object, <code class="docutils literal"><span class="pre">Function(V)</span></code> becomes a
vector field.</p>
<p><code class="docutils literal"><span class="pre">SubDomain</span></code>: class for defining a subdomain, either a part of the
boundary, an internal boundary, or a part of the domain.
The programmer must subclass <code class="docutils literal"><span class="pre">SubDomain</span></code> and implement the
<code class="docutils literal"><span class="pre">inside(self,</span> <span class="pre">x,</span> <span class="pre">on_boundary)</span></code> function
(see the section <a class="reference internal" href="._ftut003.html#ftut-poisson1-impl"><span class="std std-ref">FEniCS implementation</span></a>) for telling whether a
point <code class="docutils literal"><span class="pre">x</span></code> is inside the subdomain or not.</p>
<p><code class="docutils literal"><span class="pre">Mesh</span></code>: class for representing a finite element mesh, consisting of
cells, vertices, and optionally faces, edges, and facets.</p>
<p><code class="docutils literal"><span class="pre">MeshFunction</span></code>: tool for marking parts of the domain or the boundary.
Used for variable coefficients (&#8220;material properties&#8221;, see
the section <a class="reference internal" href="._ftut004.html#ftut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>) or for
boundary conditions (see the section <a class="reference internal" href="._ftut004.html#ftut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>).</p>
<p><code class="docutils literal"><span class="pre">DirichletBC(V,</span> <span class="pre">value,</span> <span class="pre">where)</span></code>: specification of Dirichlet (essential)
boundary conditions via a function space <code class="docutils literal"><span class="pre">V</span></code>, a function
<code class="docutils literal"><span class="pre">value(x)</span></code> for computing the value of the condition at a point <code class="docutils literal"><span class="pre">x</span></code>,
and a specification <code class="docutils literal"><span class="pre">where</span></code> of the boundary, either as a
<code class="docutils literal"><span class="pre">SubDomain</span></code> subclass instance, a plain function, or as a
<code class="docutils literal"><span class="pre">MeshFunction</span></code> instance.
In the latter case, a 4th argument is provided to describe which subdomain
number that describes the relevant boundary.</p>
<p><code class="docutils literal"><span class="pre">TestFunction(V)</span></code>: define a test function on a space <code class="docutils literal"><span class="pre">V</span></code> to be used
in a variational form.</p>
<p><code class="docutils literal"><span class="pre">TrialFunction(V)</span></code>: define a trial function on a space <code class="docutils literal"><span class="pre">V</span></code> to be used
in a variational form to represent the unknown in a finite element problem.</p>
<p><code class="docutils literal"><span class="pre">assemble(X)</span></code>: assemble a matrix, a right-hand side, or a functional,
given a from <code class="docutils literal"><span class="pre">X</span></code> written with UFL syntax.</p>
<p><code class="docutils literal"><span class="pre">assemble_system(a,</span> <span class="pre">L,</span> <span class="pre">bcs)</span></code>: assemble the matrix and the right-hand
side from a bilinear (<code class="docutils literal"><span class="pre">a</span></code>) and linear (<code class="docutils literal"><span class="pre">L</span></code>) form written with UFL
syntax. The <code class="docutils literal"><span class="pre">bcs</span></code> parameter holds one or more <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects.</p>
<p><code class="docutils literal"><span class="pre">LinearVariationalProblem(a,</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bcs)</span></code>: define a variational problem,
given a bilinear (<code class="docutils literal"><span class="pre">a</span></code>) and linear (<code class="docutils literal"><span class="pre">L</span></code>) form, written with UFL
syntax, and one or more <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects stored in <code class="docutils literal"><span class="pre">bcs</span></code>.</p>
<p><code class="docutils literal"><span class="pre">LinearVariationalSolver(problem)</span></code>: create solver object for a linear
variational problem object (<code class="docutils literal"><span class="pre">problem</span></code>).</p>
<p><code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code>: solve a linear system with <code class="docutils literal"><span class="pre">A</span></code> as coefficient
matrix (<code class="docutils literal"><span class="pre">Matrix</span></code> object), <code class="docutils literal"><span class="pre">U</span></code> as unknown (<code class="docutils literal"><span class="pre">Vector</span></code> object),
and <code class="docutils literal"><span class="pre">b</span></code> as right-hand side (<code class="docutils literal"><span class="pre">Vector</span></code> object).
Usually, <code class="docutils literal"><span class="pre">U</span> <span class="pre">=</span> <span class="pre">u.vector()</span></code>, where
<code class="docutils literal"><span class="pre">u</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code> object representing the unknown finite
element function of the problem, while
<code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are computed by calls to <code class="docutils literal"><span class="pre">assemble</span></code>
or <code class="docutils literal"><span class="pre">assemble_system</span></code>.</p>
<p><code class="docutils literal"><span class="pre">plot(q)</span></code>: quick visualization of a mesh, function, or mesh function
<code class="docutils literal"><span class="pre">q</span></code>, using a built-in, VTK-based component in FEniCS.</p>
<p><code class="docutils literal"><span class="pre">interpolate(func,</span> <span class="pre">V)</span></code>: interpolate a formula or finite
element function <code class="docutils literal"><span class="pre">func</span></code> onto the function space <code class="docutils literal"><span class="pre">V</span></code>.</p>
<p><code class="docutils literal"><span class="pre">project(func,</span> <span class="pre">V)</span></code>: project a formula or finite element function <code class="docutils literal"><span class="pre">func</span></code>
onto the function space <code class="docutils literal"><span class="pre">V</span></code>.</p>
</div>
<div class="section" id="linear-solvers-and-preconditioners">
<span id="ftut-app-solver-prec"></span><h3>Linear solvers and preconditioners<a class="headerlink" href="#linear-solvers-and-preconditioners" title="Permalink to this headline">¶</a></h3>
<p>The following solution methods for linear
systems can be accessed in FEniCS programs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'lu'</span></code></td>
<td>sparse LU factorization (Gaussian elim.)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'cholesky'</span></code></td>
<td>sparse Cholesky factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'cg'</span></code></td>
<td>Conjugate gradient method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'gmres'</span></code></td>
<td>Generalized minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'bicgstab'</span></code></td>
<td>Biconjugate gradient stabilized method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'minres'</span></code></td>
<td>Minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'tfqmr'</span></code></td>
<td>Transpose-free quasi-minimal residual method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'richardson'</span></code></td>
<td>Richardson method</td>
</tr>
</tbody>
</table>
<p>Possible choices of preconditioners include</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'none'</span></code></td>
<td>No preconditioner</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ilu'</span></code></td>
<td>Incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'icc'</span></code></td>
<td>Incomplete Cholesky factorization</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'jacobi'</span></code></td>
<td>Jacobi iteration</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'bjacobi'</span></code></td>
<td>Block Jacobi iteration</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'sor'</span></code></td>
<td>Successive over-relaxation</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'amg'</span></code></td>
<td>Algebraic multigrid (BoomerAMG or ML)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'additive_schwarz'</span></code></td>
<td>Additive Schwarz</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'hypre_amg'</span></code></td>
<td>Hypre algebraic multigrid (BoomerAMG)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'hypre_euclid'</span></code></td>
<td>Hypre parallel incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'hypre_parasails'</span></code></td>
<td>Hypre parallel sparse approximate inverse</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ml_amg'</span></code></td>
<td>ML algebraic multigrid</td>
</tr>
</tbody>
</table>
<p>Many of the choices listed above
are only offered by a specific backend, so setting the backend
appropriately is necessary for being able to choose a desired
linear solver or preconditioner. You can also use constructions like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prec</span> <span class="o">=</span> <span class="s">&#39;amg&#39;</span> <span class="k">if</span> <span class="n">has_krylov_solver_preconditioner</span><span class="p">(</span><span class="s">&#39;amg&#39;</span><span class="p">)</span> \
       <span class="k">else</span> <span class="s">&#39;default&#39;</span>
</pre></div>
</div>
<p>An up-to-date list of the available solvers and preconditioners
in FEniCS can be produced by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_solver_methods</span><span class="p">()</span>
<span class="n">list_krylov_solver_preconditioners</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-backend-specific-solver">
<span id="ftut-epetra"></span><h3>Using a backend-specific solver<a class="headerlink" href="#using-a-backend-specific-solver" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The linear algebra backends in FEniCS have recently changed. This
section is not yet up-to-date.</p>
</div>
<span class="target" id="index-21"></span><p id="index-22">The linear algebra backend determines the specific data structures
that are used in the <code class="docutils literal"><span class="pre">Matrix</span></code> and <code class="docutils literal"><span class="pre">Vector</span></code> classes. For example, with
the PETSc backend, <code class="docutils literal"><span class="pre">Matrix</span></code> encapsulates a PETSc matrix storage
structure, and <code class="docutils literal"><span class="pre">Vector</span></code> encapsulates a PETSc vector storage structure.
Sometimes one wants to perform operations directly on (say) the
underlying PETSc objects. These can be fetched by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span> <span class="n">b_PETSc</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span> <span class="n">U_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">u</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is a
<code class="docutils literal"><span class="pre">Matrix</span></code>, and <code class="docutils literal"><span class="pre">b</span></code> is a <code class="docutils literal"><span class="pre">Vector</span></code>.  The same syntax applies if we want
to fetch the underlying Epetra, uBLAS, or MTL4 matrices and vectors.</p>
<span class="target" id="index-23"></span><p id="index-24">Sometimes one wants to implement tailored solution algorithms, using
special features of the underlying numerical packages.  Here is an
example where we create an ML preconditioned Conjugate Gradient solver
by programming with Trilinos-specific objects directly.  Given a
linear system <span class="math">\(AU=b\)</span>, represented by a <code class="docutils literal"><span class="pre">Matrix</span></code> object <code class="docutils literal"><span class="pre">A</span></code>, and two
<code class="docutils literal"><span class="pre">Vector</span></code> objects <code class="docutils literal"><span class="pre">U</span></code> and <code class="docutils literal"><span class="pre">b</span></code> in a Python program, the purpose is to
set up a solver using the Aztec Conjugate Gradient method from
Trilinos&#8217; Aztec library and combine that solver with the algebraic
multigrid preconditioner ML from the ML library in Trilinos. Since the
various parts of Trilinos are mirrored in Python through the
PyTrilinos package, we can operate directly on Trilinos-specific
objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">PyTrilinos</span> <span class="kn">import</span> <span class="n">Epetra</span><span class="p">,</span> <span class="n">AztecOO</span><span class="p">,</span> <span class="n">TriUtils</span><span class="p">,</span> <span class="n">ML</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;&#39;&#39;You Need to have PyTrilinos with</span>
<span class="s">Epetra, AztecOO, TriUtils and ML installed</span>
<span class="s">for this demo to run&#39;&#39;&#39;</span><span class="p">)</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">has_la_backend</span><span class="p">(</span><span class="s">&#39;Epetra&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Warning: Dolfin is not compiled with Trilinos&#39;</span><span class="p">)</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Epetra&#39;</span>

<span class="c"># create matrix A and vector b in the usual way</span>
<span class="c"># u is a Function</span>

<span class="c"># Fetch underlying Epetra objects</span>
<span class="n">A_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
<span class="n">b_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
<span class="n">U_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>

<span class="c"># Sets up the parameters for ML using a python dictionary</span>
<span class="n">ML_param</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;max levels&quot;</span>        <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s">&quot;output&quot;</span>            <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s">&quot;smoother: type&quot;</span>    <span class="p">:</span> <span class="s">&quot;ML symmetric Gauss-Seidel&quot;</span><span class="p">,</span>
            <span class="s">&quot;aggregation: type&quot;</span> <span class="p">:</span> <span class="s">&quot;Uncoupled&quot;</span><span class="p">,</span>
            <span class="s">&quot;ML validate parameter list&quot;</span> <span class="p">:</span> <span class="bp">False</span>
<span class="p">}</span>

<span class="c"># Create the preconditioner</span>
<span class="n">prec</span> <span class="o">=</span> <span class="n">ML</span><span class="o">.</span><span class="n">MultiLevelPreconditioner</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">SetParameterList</span><span class="p">(</span><span class="n">ML_param</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">ComputePreconditioner</span><span class="p">()</span>

<span class="c"># Create solver and solve system</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AztecOO</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="n">U_epetra</span><span class="p">,</span> <span class="n">b_epetra</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetPrecOperator</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_solver</span><span class="p">,</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_cg</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_output</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">Iterate</span><span class="p">(</span><span class="n">MaxIters</span><span class="o">=</span><span class="mi">1550</span><span class="p">,</span> <span class="n">Tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>