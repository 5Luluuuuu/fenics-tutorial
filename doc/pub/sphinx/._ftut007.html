<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Multiple domain and boundaries</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Time-dependent problems" href="._ftut008.html" />
    <link rel="prev" title="Postprocessing computations" href="._ftut006.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut006.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut008.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="multiple-domain-and-boundaries">
<h1>Multiple domain and boundaries<a class="headerlink" href="#multiple-domain-and-boundaries" title="Permalink to this headline">¶</a></h1>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h2>Combining Dirichlet and Neumann conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="._ftut002.html#tut-poisson1-bvp"><span class="std std-ref">The Poisson equation</span></a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition <span class="math">\(u=u_0\)</span> at the left and right sides, <span class="math">\(x=0\)</span> and
<span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).</p>
<div class="section" id="pde-problem">
<span id="index-0"></span><h3>PDE problem<a class="headerlink" href="#pde-problem" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span> denote the parts of <span class="math">\(\partial\Omega\)</span>
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as</p>
<div class="math" id="eq-auto15">
\[\tag{31}
- \nabla^2 u = f \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-auto16">
\[\tag{32}
u = u_0 \mbox{ on } \Gamma_D,\]</div>
<div class="math" id="eq-auto17">
\[\tag{33}
- {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2{\thinspace .}\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y{\thinspace .}\]</div>
</div>
<div class="section" id="variational-formulation-2">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-2" title="Permalink to this headline">¶</a></h3>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_N}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.
The resulting weak form reads</p>
<div class="math" id="eq-tut-poisson-2d-dn-weak">
\[\tag{34}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
    \int_{\Gamma_N} gv {\, \mathrm{d}s}
    = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="eq-tut-poisson2-vard-a">
\[\tag{35}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-poisson2-vard-l">
\[\tag{36}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-2">
<h3>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code class="docutils literal"><span class="pre">p2D_plain.py</span></code>, from
the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl-code"><span class="std std-ref">A simple code</span></a>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <code class="docutils literal"><span class="pre">L</span></code>.</li>
</ul>
</div></blockquote>
<p>The first adjustment can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-never-use-for-comparing-real-numbers admonition">
<p class="first admonition-title">Never use <code class="docutils literal"><span class="pre">==</span></code> for comparing real numbers</p>
<p>A list like <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should never be used if <code class="docutils literal"><span class="pre">x[0]</span></code> is a real number,
because rounding errors in <code class="docutils literal"><span class="pre">x[0]</span></code> may make the test fail even when it is
mathematically correct. Consider</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span>
<span class="go">0.30000000000000004</span>
</pre></div>
</div>
<p>Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="go">5.551115123125783e-17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1.1</span><span class="o">+</span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">2.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10.1</span><span class="o">+</span><span class="mf">10.2</span> <span class="o">-</span> <span class="mf">20.3</span><span class="p">)</span>
<span class="go">3.552713678800501e-15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">100.1</span><span class="o">+</span><span class="mf">100.2</span> <span class="o">-</span> <span class="mf">200.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1000.1</span><span class="o">+</span><span class="mf">1000.2</span> <span class="o">-</span> <span class="mf">2000.3</span><span class="p">)</span>
<span class="go">2.2737367544323206e-13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10000.1</span><span class="o">+</span><span class="mf">10000.2</span> <span class="o">-</span> <span class="mf">20000.3</span><span class="p">)</span>
<span class="go">3.637978807091713e-12</span>
</pre></div>
</div>
<p>For numbers around unity, tolerances as low as <span class="math">\(3\cdot 10^{-16}\)</span> can be used
(in fact, this tolerance is known as <code class="docutils literal"><span class="pre">DOLFIN_EPS</span></code> in the <code class="docutils literal"><span class="pre">dolfin</span></code> package),
otherwise an appropriate tolerance must be found.</p>
<p>Testing for <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should therefore be implemented as</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<p>Here is a new boundary function using tolerances in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <code class="docutils literal"><span class="pre">L</span></code>,
where we have to add a boundary integral and a definition of the <span class="math">\(g\)</span>
function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ds</span></code> variable implies a boundary integral, while <code class="docutils literal"><span class="pre">dx</span></code>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No more modifications are necessary.</p>
</div>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h2>Multiple Dirichlet conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>The PDE problem from the previous section applies a function <span class="math">\(u_0(x,y)\)</span>
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have <span class="math">\(m\)</span> functions for
setting Dirichlet conditions on <span class="math">\(m\)</span> parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.</p>
<p>Let us return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a> and define
two separate functions for the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N {\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while <span class="math">\(\Gamma_1\)</span> corresponds
to the boundary <span class="math">\(x=1\)</span>.  We have that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 +
2y^2\)</span>, and <span class="math">\(g=-4y\)</span>.</p>
<div class="section" id="functions-for-marking-dirichlet-boundaries">
<h3>Functions for marking Dirichlet boundaries<a class="headerlink" href="#functions-for-marking-dirichlet-boundaries" title="Permalink to this headline">¶</a></h3>
<p>For the left boundary <span class="math">\(\Gamma_0\)</span> we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code class="docutils literal"><span class="pre">DirichletBC</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list
and used in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part of the
boundary, we may use a simple <code class="docutils literal"><span class="pre">Constant</span></code> object instead of an
<code class="docutils literal"><span class="pre">Expression</span></code> object.</p>
</div>
<div class="section" id="classes-for-marking-dirichlet-boundaries">
<h3>Classes for marking Dirichlet boundaries<a class="headerlink" href="#classes-for-marking-dirichlet-boundaries" title="Permalink to this headline">¶</a></h3>
<p>Instead of using a function like <code class="docutils literal"><span class="pre">left_boundary(x,</span> <span class="pre">on_boundary)</span></code> to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class <code class="docutils literal"><span class="pre">SubDomain</span></code> and has a method <code class="docutils literal"><span class="pre">inside(self,</span> <span class="pre">x,</span> <span class="pre">on_boundary)</span></code> for the code that returns whether the <code class="docutils literal"><span class="pre">point</span></code> is on the
boundary in question or not. Our previous <code class="docutils literal"><span class="pre">left_boundary</span></code> function
takes this form in its class version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LeftBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">left_boundary</span> <span class="o">=</span> <span class="n">LeftBoundary</span><span class="p">()</span>
<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="debugging-dirichlet-conditions">
<h3>Debugging Dirichlet conditions<a class="headerlink" href="#debugging-dirichlet-conditions" title="Permalink to this headline">¶</a></h3>
<p>Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <code class="docutils literal"><span class="pre">get_boundary_values</span></code> method in the <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding essential conditions as values. In the present problem
we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">],</span>
              <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Lagrange_1st_order</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">Lagrange_1st_order</span><span class="p">:</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
        <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">])),</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The output for a mesh made by <code class="docutils literal"><span class="pre">UnitSquareMesh(3,</span> <span class="pre">2)</span></code> becomes</p>
<div class="highlight-text"><div class="highlight"><pre>dof  0: u=1      at point (0.0, 0.0)
dof  8: u=3      at point (0.0, 1.0)
dof  4: u=1.5    at point (0.0, 0.5)
dof  3: u=2      at point (1.0, 0.0)
dof 11: u=4      at point (1.0, 1.0)
dof  7: u=2.5    at point (1.0, 0.5)
</pre></div>
</div>
<p>An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the <em>mesh function</em> concept and is therefore
left to the section <a class="reference internal" href="._ftut011.html#tut-poisson-mat-neumann"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.</p>
</div>
</div>
<div class="section" id="handy-methods-in-key-fenics-objects">
<h2>Handy methods in key FEniCS objects<a class="headerlink" href="#handy-methods-in-key-fenics-objects" title="Permalink to this headline">¶</a></h2>
<p id="index-1">In general,
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.X</span></code> shows the documentation of any DOLFIN name <code class="docutils literal"><span class="pre">X</span></code>
and lists all the methods (i.e.g, functions in the class) that
can be called. Below, we list just a few, but very useful, methods
in the most central FEniCS classes.</p>
<div class="section" id="mesh">
<h3>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">mesh</span></code> be a <code class="docutils literal"><span class="pre">Mesh</span></code> object.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns an array of the coordinates of</dt>
<dd><p class="first last">the vertices in the mesh.</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_cells()</span></code> returns the number of cells (triangles)
in the mesh,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.num_vertices()</span></code> returns the number of vertices in
the mesh (with our choice of linear Lagrange elements this equals the
number of nodes, <code class="docutils literal"><span class="pre">len(u_array)</span></code>, or dimension of the space <code class="docutils literal"><span class="pre">V.dim()</span></code>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.cells()</span></code> returns the vertex numbers of the vertices in
each cell as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape
(<em>number of cells</em>, <em>number of vertices in a cell</em>),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmin()</span></code> returns the minimum cell diameter (&#8220;smallest cell&#8221;),</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">mesh.hmax()</span></code> returns the maximum cell diameter (&#8220;largest cell&#8221;).</p>
</li>
</ul>
</div></blockquote>
<p>Writing <code class="docutils literal"><span class="pre">print(mesh)</span></code> dumps a short, pretty-print description
of the mesh (<code class="docutils literal"><span class="pre">print(mesh)</span></code> actually displays the result of <code class="docutils literal"><span class="pre">str(mesh)</span></code>,
which defines the pretty print):</p>
<div class="highlight-text"><div class="highlight"><pre>&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>
</div>
</div>
<div class="section" id="function-space">
<h3>Function space<a class="headerlink" href="#function-space" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">V</span></code> be a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">V.mesh()</span></code> returns the associated mesh.</li>
<li><code class="docutils literal"><span class="pre">V.dim()</span></code> returns the dimension (number of degrees of freedom).</li>
<li><code class="docutils literal"><span class="pre">V.ufl_element()</span></code> returns the associated finite element.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="function">
<h3>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal"><span class="pre">u</span></code> be a <code class="docutils literal"><span class="pre">Function</span></code> object.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u.function_space()</span></code> returns the associated function space.</li>
<li><code class="docutils literal"><span class="pre">u.vector()</span></code> returns the DOLFIN vector of degrees of freedom.</li>
<li><code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a copy of the degrees of freedom
in a <code class="docutils literal"><span class="pre">numpy</span></code> array.</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>