<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Postprocessing computations</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Multiple domain and boundaries" href="._ftut008.html" />
    <link rel="prev" title="Visualization" href="._ftut006.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut006.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut008.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="postprocessing-computations">
<h1>Postprocessing computations<a class="headerlink" href="#postprocessing-computations" title="Permalink to this headline">¶</a></h1>
<p>[<strong>hpl 3</strong>: Need a little intro.]</p>
<div class="section" id="computing-functionals">
<span id="tut-poisson1-functionals"></span><h2>Computing functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h2>
<p id="index-0">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally want to compute
functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="eq-tut-poisson1-functionals-energy">
\[\tag{28}
{1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},\]</div>
<p>which often reflects some energy quantity.
Another frequently occurring functional is the error</p>
<div class="math" id="eq-tut-poisson1-functionals-error">
\[\tag{29}
||{u_{\small\mbox{e}}}-u|| = \left(\int_\Omega ({u_{\small\mbox{e}}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>where <span class="math">\({u_{\small\mbox{e}}}\)</span> is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part <span class="math">\(\Gamma\)</span> of
the boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="eq-tut-poisson1-functionals-flux">
\[\tag{30}
F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},\]</div>
<p>where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and <span class="math">\(p\)</span> is a
coefficient (see the problem in the section <a class="reference internal" href="._ftut005.html#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient Poisson problem</span></a>
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.</p>
<div class="section" id="energy-functional">
<span id="index-1"></span><h3>Energy functional<a class="headerlink" href="#energy-functional" title="Permalink to this headline">¶</a></h3>
<p>The integrand of the
energy functional
<a class="reference internal" href="#eq-tut-poisson1-functionals-energy"><span class="std std-ref">(28)</span></a>
is described in the UFL language in the same manner as we describe
weak forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble</span></code> call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section <a class="reference internal" href="._ftut008.html#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.</p>
</div>
<div class="section" id="error-functional">
<span id="index-2"></span><h3>Error functional<a class="headerlink" href="#error-functional" title="Permalink to this headline">¶</a></h3>
<p>Computation of <a class="reference internal" href="#eq-tut-poisson1-functionals-error"><span class="std std-ref">(29)</span></a> is typically done
by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> is here in a <code class="docutils literal"><span class="pre">Function</span></code> or
<code class="docutils literal"><span class="pre">Expression</span></code> object <code class="docutils literal"><span class="pre">u_exact</span></code>, while <code class="docutils literal"><span class="pre">u</span></code> is the
finite element approximation.
(Sometimes, for very small error values, the result of
<code class="docutils literal"><span class="pre">assemble(error)</span></code> can be a (very small) negative number, so we have
used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive value
for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.)</p>
<p>As will be explained and demonstrate in the section <a class="reference internal" href="#tut-poisson1-convrates"><span class="std std-ref">Computing convergence rates</span></a>, the integration of <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_exact)**2*dx</span></code>
can result in too optimistic convergence rates unless one is careful
how <code class="docutils literal"><span class="pre">u_exact</span></code> is transferred onto a mesh. The general recommendation
for reliable error computation is to use the <code class="docutils literal"><span class="pre">errornorm</span></code> function
(see <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.errornorm</span></code> and the section <a class="reference internal" href="#tut-poisson1-convrates"><span class="std std-ref">Computing convergence rates</span></a>
for more information):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="flux-functionals">
<span id="index-3"></span><h3>Flux Functionals<a class="headerlink" href="#flux-functionals" title="Permalink to this headline">¶</a></h3>
<p>To compute flux integrals like <span class="math">\(F = -\int_\Gamma p\nabla
u\cdot\boldsymbol{n} {\, \mathrm{d}s}\)</span> we need to define the <span class="math">\(\boldsymbol{n}\)</span> vector,
referred to as <em>facet normal</em> in FEniCS. If the surface domain
<span class="math">\(\Gamma\)</span> in the flux integral is the complete
boundary we can perform the flux computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code> and <code class="docutils literal"><span class="pre">grad(u)</span></code> are interchangeable
in the above expression when <code class="docutils literal"><span class="pre">u</span></code> is a scalar function, we have
chosen to write <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code> because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With <code class="docutils literal"><span class="pre">grad(u)</span></code> we must in that
case write <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></code>.</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section <a class="reference internal" href="._ftut008.html#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>. Assuming that the
part corresponds to subdomain number <code class="docutils literal"><span class="pre">i</span></code>, the relevant syntax for
the variational formulation of the
flux is <code class="docutils literal"><span class="pre">-p*inner(grad(u),</span> <span class="pre">n)*ds(i)</span></code>.</p>
</div>
</div>
<div class="section" id="computing-convergence-rates">
<span id="tut-poisson1-convrates"></span><h2>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p>To illustrate error computations and convergence of finite element
solutions, we have included a function <code class="docutils literal"><span class="pre">convergence_rate</span></code> in
the <code class="docutils literal"><span class="pre">p2D_vc.py</span></code> program. This is a tool that is very
handy when verifying finite element codes and will therefore be explained in
detail here.</p>
<p>The <span class="math">\(L^2\)</span> norm of the error in a finite element approximation <span class="math">\(u\)</span>,
<span class="math">\({u_{\small\mbox{e}}}\)</span> being the exact solution, is given by</p>
<div class="section" id="various-ways-of-computing-the-error">
<h3>Various ways of computing the error<a class="headerlink" href="#various-ways-of-computing-the-error" title="Permalink to this headline">¶</a></h3>
<div class="math">
\[E = \left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>and implemented in FEniCS by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>Sometimes, for very small error values, the result of
<code class="docutils literal"><span class="pre">assemble(error)</span></code> can be a (very small) negative number, so we have
used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive value
for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.</p>
<p>We remark that <code class="docutils literal"><span class="pre">u_e</span></code> will, in the expression
above, be interpolated onto the function space <code class="docutils literal"><span class="pre">V</span></code> before <code class="docutils literal"><span class="pre">assemble</span></code>
can perform the integration over the domain. This implies that the
exact solution used in the integral will vary linearly over the cells,
and not as a sine function, if <code class="docutils literal"><span class="pre">V</span></code> corresponds to linear Lagrange
elements.  This situation may yield a smaller error <code class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_e</span></code> than
what is actually true.  More accurate representation of the exact
solution is easily achieved by interpolating the formula onto a space
defined by higher-order elements, say of third degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>To achieve complete mathematical control of which function space the
computations are carried out in, we can explicitly interpolate <code class="docutils literal"><span class="pre">u</span></code> to
the same space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Ve</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The square in the expression for <code class="docutils literal"><span class="pre">error</span></code> will be expanded and lead to
a lot of terms that almost cancel when the error is small, with the
potential of introducing significant rounding errors.  The function
<code class="docutils literal"><span class="pre">errornorm</span></code> is available for avoiding this effect by first
interpolating <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u_exact</span></code> to a space with higher-order elements,
then subtracting the degrees of freedom, and then performing the
integration of the error field. The usage is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s">&#39;L2&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at the short implementation of <code class="docutils literal"><span class="pre">errornorm</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
    <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="c"># Subtract degrees of freedom for the error field</span>
    <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                       <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">errornorm</span></code> procedure turns out to be identical to computing
the expression <code class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2*dx</span></code> directly in
the present test case.</p>
<p>Sometimes it is of interest to compute the error of the
gradient field: <span class="math">\(||\nabla (u-{u_{\small\mbox{e}}})||\)</span>
(often referred to as the <span class="math">\(H^1\)</span> seminorm of the error).
Given the error field <code class="docutils literal"><span class="pre">e_Ve</span></code> above, we simply write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H1seminorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
</pre></div>
</div>
<p>All the various types of error computations here are placed in a
function <code class="docutils literal"><span class="pre">compute_errors</span></code> in <code class="docutils literal"><span class="pre">p2D_vc.py</span></code>:
[<strong>hpl 10</strong>: Necessary to repeat code? New info is essentiall the return dict.]
[<strong>hpl 11</strong>: Anders, I (in 2010...) ran into problems with <code class="docutils literal"><span class="pre">dolfin.errornorm</span></code>, see comments in the code below, and made the version below. We should check out these problems again and adjust <code class="docutils literal"><span class="pre">dolfin.errornorm</span></code> if necessary.]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span class="sd">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span class="c"># Compute error norm (for very small errors, the value can be</span>
    <span class="c"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="c"># Function - Expression</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_e onto the same space as u:</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span class="c"># u will also be interpolated to the space Ve before integration</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c"># mesh here: BUG, module mesh in dolfin...make warning box</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># dolfin.errornorm interpolates u and u_e to a space with</span>
    <span class="c"># given degree, and creates the error field by subtracting</span>
    <span class="c"># the degrees of freedom, then the error field is integrated</span>
    <span class="c"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span class="c">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span class="c"># Manual implementation errornorm to get around the bug:</span>
    <span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
        <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
        <span class="c"># Subtract degrees of freedom for the error field</span>
        <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="c"># More efficient computation (avoids the rhs array result above)</span>
        <span class="c">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span class="c">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">Ve</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))),</span> <span class="n">e_Ve</span>
    <span class="n">E4</span><span class="p">,</span> <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>

    <span class="c"># Infinity norm based on nodal values</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">E5</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c"># H1 seminorm</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E6</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Collect error measures in a dictionary with self-explanatory keys</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">:</span> <span class="n">E1</span><span class="p">,</span>
              <span class="s">&#39;u - interpolate(u_exact,V)&#39;</span><span class="p">:</span> <span class="n">E2</span><span class="p">,</span>
              <span class="s">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span><span class="p">:</span> <span class="n">E3</span><span class="p">,</span>
              <span class="s">&#39;errornorm&#39;</span><span class="p">:</span> <span class="n">E4</span><span class="p">,</span>
              <span class="s">&#39;infinity norm (of dofs)&#39;</span><span class="p">:</span> <span class="n">E5</span><span class="p">,</span>
              <span class="s">&#39;grad(error) H1 seminorm&#39;</span><span class="p">:</span> <span class="n">E6</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">errors</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-convergence-rates-empirically">
<h3>Computing convergence rates empirically<a class="headerlink" href="#computing-convergence-rates-empirically" title="Permalink to this headline">¶</a></h3>
<p>Calling the <code class="docutils literal"><span class="pre">solver</span></code> function for finer and finer meshes enables us to
study the convergence rate. Define the element size <span class="math">\(h=1/n\)</span>, where <span class="math">\(n\)</span>
is the number of cell divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction (<code class="docutils literal"><span class="pre">n=Nx=Ny</span></code> in
the code). We perform experiments with <span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span> and compute
the corresponding errors <span class="math">\(E_0, E_1, E_3\)</span> and so forth.  Assuming
<span class="math">\(E_i=Ch_i^r\)</span> for unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare two
consecutive experiments, <span class="math">\(E_i=Ch_i^r\)</span> and <span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span>, and
solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace .}\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence
rate <code class="docutils literal"><span class="pre">degree+1</span></code> as <span class="math">\(i\)</span> increases.</p>
<p>The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by <code class="docutils literal"><span class="pre">compute_errors</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute convergence rates for various error norms for a</span>
<span class="sd">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span class="sd">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span class="sd">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Discretization parameter, h[degree][experiment]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Error measure(s), E[degree][experiment][error_type]</span>
    <span class="n">P_degrees</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">num_meshes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c"># Perform experiments with meshes and element types</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c"># Coarsest mesh division</span>
        <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                       <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;2*(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) P</span><span class="si">%d</span><span class="s"> mesh, </span><span class="si">%d</span><span class="s"> unknowns, E1=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
                   <span class="n">errors</span><span class="p">[</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">]))</span>
    <span class="c"># Convergence rates</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># log is a dolfin name too</span>
    <span class="n">error_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">error_types</span><span class="p">):</span>
            <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
                <span class="n">Ei</span>   <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">Eim1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">Ei</span><span class="o">/</span><span class="n">Eim1</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rates</span>

<span class="k">def</span> <span class="nf">convergence_rate_sin</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute convergence rates for u=sin(x)*sin(y) solution.&quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                         <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_exact</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Note: P4 for n&gt;=128 seems to break down</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                              <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
    <span class="c"># Print rates</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="n">error_types</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error_type</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;P</span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Note how we make a complete general function <code class="docutils literal"><span class="pre">convergence_rate</span></code>, aimed at
any 2D Poisson problem in the class we now can solve, and then call
this general function in <code class="docutils literal"><span class="pre">convergence_rate_sin</span></code> for a special test
case.</p>
</div>
<div class="section" id="test-problem-3">
<h3>Test problem<a class="headerlink" href="#test-problem-3" title="Permalink to this headline">¶</a></h3>
<p>The section <a class="reference internal" href="._ftut005.html#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a> specifies a more complicated solution,</p>
<div class="math">
\[u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square.
This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2 u(x,y)\)</span>.
With <span class="math">\(\omega\)</span> restricted to an integer
it follows that <span class="math">\(u_0=0\)</span>.</p>
<p>We need to define the
appropriate boundary conditions, the exact solution, and the <span class="math">\(f\)</span> function
in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
</div>
<div class="section" id="experiments">
<h3>Experiments<a class="headerlink" href="#experiments" title="Permalink to this headline">¶</a></h3>
<p>Calling <code class="docutils literal"><span class="pre">convergence_rate_sin()</span></code> gives some interesting results.
Using the error measure <code class="docutils literal"><span class="pre">E5</span></code> based on the infinity norm of the
difference of the degrees of freedom, we have</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.99</td>
<td>1.97</td>
<td>1.99</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.99</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.96</td>
<td>3.89</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
</tr>
<tr class="row-odd"><td>P4</td>
<td>3.75</td>
<td>4.99</td>
<td>5.0</td>
<td>5.0</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>The computations with P4 elements on a <span class="math">\(128\times 128\)</span> with a
direct solver (UMFPACK) on a small laptop broke down.
Otherwise we achieve expected results: the error goes like
<span class="math">\(h^{d+1}\)</span> for elements of degree <span class="math">\(d\)</span>. Also <span class="math">\(L^2\)</span> norms based
on the <code class="docutils literal"><span class="pre">errornorm</span></code> gives the expected <span class="math">\(h^{d+1}\)</span> rate for
<span class="math">\(u\)</span> and <span class="math">\(h^d\)</span> for <span class="math">\(\nabla u\)</span>.</p>
<p>However, using <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_exact)**2</span></code> for the error computation, which implies
interpolating <code class="docutils literal"><span class="pre">u_exact</span></code> onto the same space as <code class="docutils literal"><span class="pre">u</span></code>, results in <span class="math">\(h^4\)</span>
convergence for P2 elements.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.98</td>
<td>1.94</td>
<td>1.98</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.98</td>
<td>3.95</td>
<td>3.99</td>
<td>3.99</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.69</td>
<td>4.03</td>
<td>4.01</td>
<td>3.95</td>
<td>2.77</td>
</tr>
</tbody>
</table>
<p>This is an example where it is important to interpolate <code class="docutils literal"><span class="pre">u_exact</span></code> to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.</p>
<p>Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section <a class="reference internal" href="._ftut005.html#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a> and many other places in this tutorial).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>