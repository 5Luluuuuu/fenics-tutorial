<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Poisson solver revisited</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Useful extensions" href="._ftut005.html" />
    <link rel="prev" title="A simple implementation" href="._ftut003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-poisson-solver-revisited">
<span id="ch-poisson"></span><h1>The Poisson solver revisited<a class="headerlink" href="#the-poisson-solver-revisited" title="Permalink to this headline">¶</a></h1>
<p>[<strong>hpl 6</strong>: I don&#8217;t like this title, but have no other good alternaive...]</p>
<div class="section" id="refactored-implementation-1">
<span id="tut-poisson1-impl2"></span><h2>Refactored implementation<a class="headerlink" href="#refactored-implementation-1" title="Permalink to this headline">¶</a></h2>
<p>Our first programs in this book are all &#8220;flat&#8221;. That is,
they are not organized
into logical, reusable units in terms of Python functions. Such flat
programs are popular for quickly testing out some software, but not
well suited for serious problem solving. We shall therefore at once
<em>refactor</em> the program, meaning that we divide it into functions, but
this is just a reordering of the existing statements. During
refactoring, we try make functions as reusable as possible in other
contexts, but statements specific to a certain problem or task are
also encapsulated in (non-reusable) functions.  Being able to
distinguish reusable code from specialized code is a key issue when
refactoring code, and this ability depends on a good mathematical
understanding of the problem at hand (&#8220;what is general, what is
special?&#8221;).  In a flat program, general and specialized code (and
mathematics) is often mixed together.</p>
<div class="section" id="a-general-solver-function">
<h3>A general solver function<a class="headerlink" href="#a-general-solver-function" title="Permalink to this headline">¶</a></h3>
<p>We consider the flat program developed in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl"><span class="std std-ref">A simple implementation</span></a>.
Some of the code in this program is needed to solve any
Poisson problem <span class="math">\(-\nabla^2 u=f\)</span> on <span class="math">\([0,1]\times [0,1]\)</span> with <span class="math">\(u=u_0\)</span> on
the boundary, while other statements arise from our simple test
problem. Let us collect the general, reusable code in a function
<code class="docutils literal"><span class="pre">solver</span></code>.  Our special test problem will then just be an application
of <code class="docutils literal"><span class="pre">solver</span></code> with some additional statements.  We limit the <code class="docutils literal"><span class="pre">solver</span></code>
function to just <em>compute the numerical solution</em>. Plotting and
comparing the solution with the exact solution are considered to be
problem-specific activities to be performed elsewhere.</p>
<p>We parameterize <code class="docutils literal"><span class="pre">solver</span></code> by <span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and the resolution of the
mesh. Since it is so trivial to use higher-order finite element
functions by changing the third argument to <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, we let
also the degree of the polynomials in the finite element basis
functions be an argument to <code class="docutils literal"><span class="pre">solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u0 (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<div class="section" id="plotting-for-the-test-problem">
<h4>Plotting for the test problem<a class="headerlink" href="#plotting-for-the-test-problem" title="Permalink to this headline">¶</a></h4>
<p>The additional tasks we did in our initial program can be placed in
other functions. For example, plotting the solution in our particular
test problem is placed in an
<code class="docutils literal"><span class="pre">application_test</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution in the test problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="make-a-module">
<h4>Make a module!<a class="headerlink" href="#make-a-module" title="Permalink to this headline">¶</a></h4>
<p>The refactored code is put in a file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/ft04_p2D_func.py">ft04_p2D_func.py</a>. We should make
sure that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program should appear with a test
<code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code>. This test is true if the file is executed
as a program, but false if the file is imported.
If we want to run this file in the same way as we can
run <code class="docutils literal"><span class="pre">ft04_p2D_func.py</span></code>, the main program is simply a call to
<code class="docutils literal"><span class="pre">application_test()</span></code> followed by a call <code class="docutils literal"><span class="pre">interactive()</span></code> to hold the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application_test</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-and-unit-tests">
<span id="index-0"></span><h3>Verification and unit tests<a class="headerlink" href="#verification-and-unit-tests" title="Permalink to this headline">¶</a></h3>
<p>The remaining part of our first program is to compare the numerical and
the exact solution. Every time we edit the code we must rerun the test
and examine that <code class="docutils literal"><span class="pre">max_error</span></code> is sufficiently small so we know that the
code still works. To this end, we shall adopt <em>unit testing</em>, meaning
that we create a mathematical test and corresponding software that
can run all our tests automatically and check that all tests pass.
Python has several tools for unit testing. Two very popular ones are
pytest and nose. These are almost identical and very easy to use.
More classical unit testing with test classes is offered by the built-in
tool <code class="docutils literal"><span class="pre">unittest</span></code>, but here we are going to use pytest (or nose) since it demands
shorter and clearer code.</p>
<p>Mathematically, our unit test is that the finite element solution of
our problem when <span class="math">\(f=-6\)</span> equals the exact solution <span class="math">\(u=u_0=1+x^2+2y^2\)</span>.
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which depends
to the number of elements and the degrees of the polynomials in the finite
element basis functions. In the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl-dissect"><span class="std std-ref">Dissection of the program</span></a> we
reported some experiments with the size of the maximum error. If we want
to test that <code class="docutils literal"><span class="pre">solver</span></code> works for meshes up to <span class="math">\(2(20\times 20)\)</span> elements
and cubic Lagrange elements, <span class="math">\(10^{-11}\)</span> is
an appropriate tolerance for testing that the maximum error vanishes.</p>
<p>Only three statements are necessary to carry out the unit test. However,
we shall embed these statements in software that the testing frameworks
pytest and nose can recognize. This means that each unit test
must be placed in a function that</p>
<blockquote>
<div><ul class="simple">
<li>has a name starting with <code class="docutils literal"><span class="pre">test_</span></code></li>
<li>has no arguments</li>
<li>implements the test as <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success,</span> <span class="pre">msg</span></code></li>
</ul>
</div></blockquote>
<p>Regarding the last point, <code class="docutils literal"><span class="pre">success</span></code> is a boolean expression that is <code class="docutils literal"><span class="pre">False</span></code>
if the test fails, and in that case the string <code class="docutils literal"><span class="pre">msg</span></code> is written to the
screen. When the test fails, <code class="docutils literal"><span class="pre">assert</span></code> raises an <code class="docutils literal"><span class="pre">AssertionError</span></code> exception
in Python, otherwise the statement runs silently. The <code class="docutils literal"><span class="pre">msg</span></code> string is
optional, so <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success</span></code> is the minimal test. In our case, we
will do <code class="docutils literal"><span class="pre">assert</span> <span class="pre">max_error</span> <span class="pre">&lt;</span> <span class="pre">tol</span></code>, where <code class="docutils literal"><span class="pre">tol</span></code> is the tolerance (<span class="math">\(10^{-11}\)</span>)
mentioned above.</p>
<p>A proper <em>test function</em> for implementing this unit test in the pytest
or nose testing frameworks has the following form. Note that we perform
the test for different mesh resolutions and degrees of finite elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-11</span>  <span class="c"># This problem&#39;s precision</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh with P</span><span class="si">%d</span><span class="s"> elements&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="c"># Make a finite element function of the exact u0</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># exact solution</span>
            <span class="c"># Check that dof arrays are equal</span>
            <span class="n">u0_array</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s"> for 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh and degree=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>\
                  <span class="p">(</span><span class="n">max_error</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>We can at any time run</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; py.test -s -v ft04_p2D_func.py
</pre></div>
</div>
<p>and the pytest tool will run all functions <code class="docutils literal"><span class="pre">test_*()</span></code> in the file and report
how the tests go.</p>
<p>We shall make it a habit in this book to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented. We dare to assert that this is the only serious way
do reliable computational science with FEniCS.</p>
<div class="admonition-tip-print-messages-in-test-functions admonition">
<p class="first admonition-title">Tip: Print messages in test functions</p>
<p class="last">The <code class="docutils literal"><span class="pre">assert</span></code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code class="docutils literal"><span class="pre">assert</span></code>
(as we do in the example above) such that it is clear that the
test really takes place.
(Note that <code class="docutils literal"><span class="pre">py.test</span></code> needs the <code class="docutils literal"><span class="pre">-s</span></code> option to show printout
from the test functions.)</p>
</div>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section <a class="reference internal" href="._ftut006.html#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a>.  Information in the intermediate sections
can be studied on demand.</p>
</div>
<div class="section" id="exercise-1-solve-a-poisson-problem">
<h3>Exercise 1: Solve a Poisson problem<a class="headerlink" href="#exercise-1-solve-a-poisson-problem" title="Permalink to this headline">¶</a></h3>
<p>Solve the following problem</p>
<div class="math" id="eq-auto4">
\[\tag{33}
\nabla^2 u = 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x))
    \hbox{ in }\Omega = [0,1]\times [0,1]\]</div>
<div class="math" id="eq-auto5">
\[\tag{34}
u = 0\quad\hbox{ on }\partial\Omega\]</div>
<p>The exact solution is given by</p>
<div class="math">
\[u(x,y) = 2e^{-2x}\sin(\pi x)\sin(\pi y){\thinspace .}\]</div>
<p>Compute the maximum numerical approximation error in a mesh with
<span class="math">\(2(N_x\times N_y)\)</span> elements and in a mesh with double resolution:
<span class="math">\(4(N_x\times N_y)\)</span> elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
Make an illustrative plot of the solution too.</p>
<p><strong>a)</strong>
Base your implementation on editing the program
<code class="docutils literal"><span class="pre">ft01_p2D_flat.py</span></code>.</p>
<p><strong>Hint 1.</strong>
In the string for an <code class="docutils literal"><span class="pre">Expression</span></code> object, <code class="docutils literal"><span class="pre">pi</span></code> is the value of
<span class="math">\(\pi\)</span>. Also note that <span class="math">\(\pi^2\)</span> must be expressed with syntax
<code class="docutils literal"><span class="pre">pow(pi,2)</span></code> and not (the common Python syntax) <code class="docutils literal"><span class="pre">pi**2</span></code>.</p>
<p>FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code class="docutils literal"><span class="pre">/very/long/path/compile.log</span></code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.</p>
<p><strong>Hint 2.</strong>
The result that with P1 elements, doubling the resolution reduces the error
with a factor of four, is an
asymptotic result so it requires a sufficiently fine mesh. Here
one may start with <span class="math">\(N_x=N_y=20\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">p2D_fsin_flat</span></code>.</p>
<p><strong>Solution.</strong>
Looking at the <code class="docutils literal"><span class="pre">ft01_p2D_flat.py</span></code> code, we realize that
the following edits are required:</p>
<blockquote>
<div><ul class="simple">
<li>Modify the <code class="docutils literal"><span class="pre">mesh</span></code> computation.</li>
<li>Modify <code class="docutils literal"><span class="pre">u0</span></code> and <code class="docutils literal"><span class="pre">f</span></code>.</li>
<li>Add expression for the exact solution.</li>
<li>Modify the computation of the numerical error.</li>
<li>Insert a loop to enable solving the problem twice.</li>
<li>Put the error reduction computation and the plot statements after the loop.</li>
</ul>
</div></blockquote>
<p>Here is the modified code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">Nx</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Ny</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Define boundary conditions</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="c"># Note: no need for pi=DOLFIN_PI in f, pi is valid variable</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>

    <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>         <span class="c"># exact solution</span>
    <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
    <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error reduction:&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The number <span class="math">\(\pi\)</span> has the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> in C and C++, but in C++
strings in <code class="docutils literal"><span class="pre">Expression</span></code> objects, the symbol <code class="docutils literal"><span class="pre">pi</span></code> can be used directly
(or one can use the less readable <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/p2D_fsin.png"><img alt="_images/p2D_fsin.png" src="_images/p2D_fsin.png" style="width: 500px;" /></a>
</div>
<p><strong>b)</strong>
Base your implementation on a new file that imports functionality
from the module <code class="docutils literal"><span class="pre">ft04_p2D_func.py</span></code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code class="docutils literal"><span class="pre">p2D_fsin_func</span></code>.</p>
<p><strong>Solution.</strong>
Solving the two problems is a matter of calling <code class="docutils literal"><span class="pre">solver</span></code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code class="docutils literal"><span class="pre">test_solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">p2D_func</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span>
    <span class="n">interactive</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span>

<span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Loop over refined meshes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Nx</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">Ny</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Make a finite element function of the exact u_e</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># Linf norm</span>
        <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">error</span><span class="p">)):</span>
        <span class="n">error_reduction</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;error reduction:&#39;</span><span class="p">,</span> <span class="n">error_reduction</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error_reduction</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_solver</span><span class="p">()</span>
    <span class="n">application</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The unit test is embedded in a proper test function <code class="docutils literal"><span class="pre">test_solver</span></code>
for the pytest or
nose testing frameworks. Visualization of the solution is encapsulated
in the <code class="docutils literal"><span class="pre">application</span></code> function. Since we need <code class="docutils literal"><span class="pre">u_e</span></code>, <code class="docutils literal"><span class="pre">u0</span></code>, and <code class="docutils literal"><span class="pre">f</span></code>
in two functions, we place the definitions in a function <code class="docutils literal"><span class="pre">data</span></code> to
avoid copies of these expressions.</p>
<div class="section" id="remarks">
<h4>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h4>
<p>This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code class="docutils literal"><span class="pre">solver</span></code> function, requires <em>no modifications</em>
of the <code class="docutils literal"><span class="pre">ft04_p2D_func.py</span></code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code class="docutils literal"><span class="pre">ft04_p2D_func.py</span></code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension. Hopefully, with this exercise
you realize that embedding
PDE solvers in functions (or classes) makes more reusable software than
flat programs.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>