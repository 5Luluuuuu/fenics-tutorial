<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A basic Poisson solver</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Useful extensions" href="._ftut005.html" />
    <link rel="prev" title="Mathematical problem formulation" href="._ftut003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-basic-poisson-solver">
<span id="tut-poisson1-impl"></span><h1>A basic Poisson solver<a class="headerlink" href="#a-basic-poisson-solver" title="Permalink to this headline">¶</a></h1>
<p>The test problem so far has a general domain <span class="math">\(\Omega\)</span> and general functions
<span class="math">\(u_0\)</span> and <span class="math">\(f\)</span>. For our first implementation we must decide on specific
choices of <span class="math">\(\Omega\)</span>, <span class="math">\(u_0\)</span>, and <span class="math">\(f\)</span>.
It will be wise to construct a specific problem where we can easily
check that the computed solution is correct. Let us start with
specifying an exact solution <span class="math">\({u_{\small\mbox{e}}}(x,y)\)</span>:</p>
<div class="math" id="eq-tut-poisson1-impl-uex">
\[\tag{12}
\
    {u_{\small\mbox{e}}}(x,y) = 1 +x^2 + 2y^2\]</div>
<p>on some 2D domain.  By inserting <a class="reference internal" href="#eq-tut-poisson1-impl-uex"><span class="std std-ref">(12)</span></a> in
our Poisson problem, we find that <span class="math">\({u_{\small\mbox{e}}}(x,y)\)</span> is a solution if</p>
<div class="math">
\[f(x,y) = -6,\quad u_0(x,y)={u_{\small\mbox{e}}}(x,y)=1 + x^2 + 2y^2,\]</div>
<p>regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,</p>
<div class="math">
\[\Omega = [0,1]\times [0,1] .\]</div>
<p>The reason for specifying the solution <a class="reference internal" href="#eq-tut-poisson1-impl-uex"><span class="std std-ref">(12)</span></a>
is that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution (<span class="math">\(u\)</span>) with the exact
solution (<span class="math">\({u_{\small\mbox{e}}}\)</span>). These quantities should be equal
to machine precision <em>at the nodes</em>.
Test problems with this property will be frequently constructed
throughout this tutorial.</p>
<div class="section" id="a-simple-code">
<span id="tut-poisson1-impl-code"></span><h2>A simple code<a class="headerlink" href="#a-simple-code" title="Permalink to this headline">¶</a></h2>
<p>A FEniCS program for solving the Poisson equation in 2D with the given
choices of <span class="math">\(u_0\)</span>, <span class="math">\(f\)</span>, and <span class="math">\(\Omega\)</span> may look as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Find max error</span>
<span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>         <span class="c"># exact solution</span>
<span class="n">u0_array</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
<span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code can be found in the file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_plain.py">p2D_plain.py</a> in the
directory <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson">src/poisson</a>.</p>
</div>
<div class="section" id="running-the-program">
<span id="tut-poisson1-impl-run"></span><h2>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h2>
<p>To run the program <code class="docutils literal"><span class="pre">p2D_plain.py</span></code>, open a terminal window, move to
the directory containing the program and write</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python p2D_plain.py
</pre></div>
</div>
<p>A plot window pops up showing how the solution <span class="math">\(u\)</span> looks like as a surface.
With the left mouse button you can tilt the figure. Click <code class="docutils literal"><span class="pre">m</span></code> to bring
up the underlying mesh. Click <code class="docutils literal"><span class="pre">p</span></code> to save to a PNG file <code class="docutils literal"><span class="pre">dolfin_plot_0.png</span></code>
and <code class="docutils literal"><span class="pre">P</span></code> to save to a PDF file <code class="docutils literal"><span class="pre">dolfin_plot_1.pdf</span></code>. To kill the
plot window and terminate the application, click <code class="docutils literal"><span class="pre">Ctrl+q</span></code> (hold down
the <code class="docutils literal"><span class="pre">Ctrl</span></code> key and press <code class="docutils literal"><span class="pre">q</span></code>).
Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><span class="std std-ref">Plot of the solution in the first FEniCS example</span></a> displays the surface and the mesh below.
Since <span class="math">\(u\)</span> is a simple quadratic function,
constructed for testing our solver, the
surface looks quite boring.</p>
<div class="figure" id="id1">
<span id="tut-poisson-2d-fig-ex1-u"></span><a class="reference internal image-reference" href="_images/ex1_u.png"><img alt="_images/ex1_u.png" src="_images/ex1_u.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the solution in the first FEniCS example</em></span></p>
</div>
</div>
<div class="section" id="dissection-of-the-program">
<span id="tut-poisson1-impl-dissect"></span><h2>Dissection of the program<a class="headerlink" href="#dissection-of-the-program" title="Permalink to this headline">¶</a></h2>
<p>We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the <a class="reference external" href="http://docs.python.org/tutorial/">official Python tutorial</a> to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  the section <a class="reference internal" href="._ftut014.html#tut-appendix-pybooks"><span class="std std-ref">Books on Python</span></a> lists some relevant Python books.</p>
<p>The listed FEniCS program defines a finite element mesh, the discrete
function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span> corresponding to this mesh and the
element type, boundary conditions for <span class="math">\(u\)</span> (the function <span class="math">\(u_0\)</span>),
<span class="math">\(a(u,v)\)</span>, and <span class="math">\(L(v)\)</span>.  Thereafter, the unknown trial function <span class="math">\(u\)</span> is
computed. Then we can compare the numerical and exact solution
as well as investigate <span class="math">\(u\)</span> visually.</p>
<div class="section" id="the-key-import-line">
<h3>The key import line<a class="headerlink" href="#the-key-import-line" title="Permalink to this headline">¶</a></h3>
<p>The first line in the program,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>imports the key classes <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>, <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>,
and so forth, from the DOLFIN library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line. DOLFIN is a software library with efficient and convenient C++
classes for finite element computing, and <code class="docutils literal"><span class="pre">dolfin</span></code> is a Python package
providing access to this C++ library from Python programs.  You can
think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <code class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span> <span class="pre">import</span> <span class="pre">*</span></code> statement
imports other components too, but newcomers to FEniCS programming do
not need to care about this.</p>
<span class="target" id="index-0"></span></div>
<div class="section" id="generating-simple-meshes">
<span id="index-1"></span><h3>Generating simple meshes<a class="headerlink" href="#generating-simple-meshes" title="Permalink to this headline">¶</a></h3>
<p>The statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a uniform finite element mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span>. The mesh consists of <em>cells</em>, which are triangles
with straight sides. The parameters 6 and 4 tell that the square is
first divided into <span class="math">\(6\times 4\)</span> rectangles, and then each rectangle is
divided into two triangles. The total number of triangles then becomes
48. The total number of vertices in this mesh is <span class="math">\(7\cdot 5=35\)</span>.
DOLFIN offers some classes for creating meshes over very simple
geometries. For domains of more complicated shape one needs to use a
separate <em>preprocessor</em> program to create the mesh.  The FEniCS
program will then read the mesh from file.</p>
<span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span></div>
<div class="section" id="defining-a-function-space-corresponding-to-a-mesh">
<span id="index-6"></span><h3>Defining a function space corresponding to a mesh<a class="headerlink" href="#defining-a-function-space-corresponding-to-a-mesh" title="Permalink to this headline">¶</a></h3>
<p>Having a mesh, we can define a discrete function space <code class="docutils literal"><span class="pre">V</span></code> over this mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.  The
type of element is here &#8220;Lagrange&#8221;, implying the standard Lagrange
family of elements.  (Some FEniCS programs use <code class="docutils literal"><span class="pre">'CG'</span></code>, for Continuous
Galerkin, as a synonym for <code class="docutils literal"><span class="pre">'Lagrange'</span></code>.)  With degree 1, we simply
get the standard linear Lagrange element, which is a triangle with
nodes at the three vertices.  Some finite element practitioners refer
to this element as the &#8220;linear triangle&#8221; or the P1 element.  The
computed <span class="math">\(u\)</span> will be continuous and linearly varying in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
over each cell in the mesh.  Higher-degree polynomial approximations
over each cell are trivially obtained by increasing the third
parameter in <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, which will then generate P2, P3, and so
forth, type of elements. Changing the second parameter to <code class="docutils literal"><span class="pre">'DG'</span></code>
creates a function space for discontinuous Galerkin methods.</p>
<span class="target" id="index-7"></span><span class="target" id="index-8"></span><span class="target" id="index-9"></span></div>
<div class="section" id="defining-test-and-trial-functions">
<span id="index-10"></span><h3>Defining test and trial functions<a class="headerlink" href="#defining-test-and-trial-functions" title="Permalink to this headline">¶</a></h3>
<p>In mathematics, we distinguish between the trial and test spaces <span class="math">\(V\)</span>
and <span class="math">\(\hat{V}\)</span>. The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <code class="docutils literal"><span class="pre">V</span></code> for the and trial and test functions in the
program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-boundary-and-boundary-conditions">
<span id="index-11"></span><h3>Specifying the boundary and boundary conditions<a class="headerlink" href="#specifying-the-boundary-and-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>The next step is to specify the boundary condition: <span class="math">\(u=u_0\)</span> on
<span class="math">\(\partial\Omega\)</span>. This is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u0</span></code> is an instance holding the <span class="math">\(u_0\)</span> values, and <code class="docutils literal"><span class="pre">u0_boundary</span></code>
is a function (or object) describing whether a point lies on the
boundary where <span class="math">\(u\)</span> is specified.</p>
<p>Boundary conditions of the type <span class="math">\(u=u_0\)</span> are known as <em>Dirichlet
conditions</em>, and also as <em>essential boundary conditions</em> in a finite
element context.  Naturally, the name of the DOLFIN class holding the
information about Dirichlet boundary conditions is <code class="docutils literal"><span class="pre">DirichletBC</span></code>.</p>
<p id="index-12">The <code class="docutils literal"><span class="pre">u0</span></code> variable refers to an <code class="docutils literal"><span class="pre">Expression</span></code> object, which is used to
represent a mathematical function. The typical construction is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">formula</span></code> is a string containing the mathematical expression.
This formula is written with C++ syntax (the expression is
automatically turned into an efficient, compiled C++ function, see
the section <a class="reference internal" href="._ftut014.html#tut-app-cpp-functions"><span class="std std-ref">User-defined functions</span></a> for details on the syntax). The
independent variables in the function expression are supposed to be
available as a point vector <code class="docutils literal"><span class="pre">x</span></code>, where the first element <code class="docutils literal"><span class="pre">x[0]</span></code>
corresponds to the <span class="math">\(x\)</span> coordinate, the second element <code class="docutils literal"><span class="pre">x[1]</span></code> to the
<span class="math">\(y\)</span> coordinate, and (in a three-dimensional problem) <code class="docutils literal"><span class="pre">x[2]</span></code> to the <span class="math">\(z\)</span>
coordinate. With our choice of <span class="math">\(u_0(x,y)=1 + x^2 + 2y^2\)</span>, the formula
string must be written as <code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">x[0]*x[0]</span> <span class="pre">+</span> <span class="pre">2*x[1]*x[1]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-13">The information about where to apply the <code class="docutils literal"><span class="pre">u0</span></code> function as boundary
condition is coded in a function <code class="docutils literal"><span class="pre">u0_boundary</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>A function like <code class="docutils literal"><span class="pre">u0_boundary</span></code> for marking the boundary must return a
boolean value: <code class="docutils literal"><span class="pre">True</span></code> if the given point <code class="docutils literal"><span class="pre">x</span></code> lies on the Dirichlet
boundary and <code class="docutils literal"><span class="pre">False</span></code> otherwise.  The argument <code class="docutils literal"><span class="pre">on_boundary</span></code> is <code class="docutils literal"><span class="pre">True</span></code>
if <code class="docutils literal"><span class="pre">x</span></code> is on the physical boundary of the mesh, so in the present
case, where we are supposed to return <code class="docutils literal"><span class="pre">True</span></code> for all points on the
boundary, we can just return the supplied value of <code class="docutils literal"><span class="pre">on_boundary</span></code>.  The
<code class="docutils literal"><span class="pre">u0_boundary</span></code> function will be called for every discrete point in the
mesh, which allows us to have boundaries where <span class="math">\(u\)</span> are known also
inside the domain, if desired.</p>
<p>One can also omit the <code class="docutils literal"><span class="pre">on_boundary</span></code> argument, but in that case we need
to test on the value of the coordinates in <code class="docutils literal"><span class="pre">x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>As for the formula in <code class="docutils literal"><span class="pre">Expression</span></code> objects, <code class="docutils literal"><span class="pre">x</span></code> in the <code class="docutils literal"><span class="pre">u0_boundary</span></code>
function represents a point in space with coordinates <code class="docutils literal"><span class="pre">x[0]</span></code>, <code class="docutils literal"><span class="pre">x[1]</span></code>,
etc. Comparing floating-point values using an exact match test with
<code class="docutils literal"><span class="pre">==</span></code> is not good programming practice, because small round-off errors
in the computations of the <code class="docutils literal"><span class="pre">x</span></code> values could make a test <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code>
become false even though <code class="docutils literal"><span class="pre">x</span></code> lies on the boundary.  A better test is
to check for equality with a tolerance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-right-hand-side-function">
<span id="index-14"></span><h3>Specifying the right-hand side function<a class="headerlink" href="#specifying-the-right-hand-side-function" title="Permalink to this headline">¶</a></h3>
<p>Before defining <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> we have to specify the <span class="math">\(f\)</span> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-6&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When <span class="math">\(f\)</span> is constant over the domain, <code class="docutils literal"><span class="pre">f</span></code> can be
more efficiently represented as a <code class="docutils literal"><span class="pre">Constant</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-variational-formulation">
<h3>Specifying the variational formulation<a class="headerlink" href="#specifying-the-variational-formulation" title="Permalink to this headline">¶</a></h3>
<p>Now we have all the objects we need in order to specify this problem&#8217;s
<span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas <span class="math">\(\nabla u\cdot\nabla v {\, \mathrm{d}x}\)</span> and <span class="math">\(fv {\, \mathrm{d}x}\)</span>.  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.  The language used to express weak
forms is called UFL (Unified Form Language) and is an integral part of
FEniCS.</p>
<p>Instead of <code class="docutils literal"><span class="pre">nabla_grad</span></code> we could also just have written <code class="docutils literal"><span class="pre">grad</span></code> in the
examples in this tutorial. However, when taking gradients of vector
fields, <code class="docutils literal"><span class="pre">grad</span></code> and <code class="docutils literal"><span class="pre">nabla_grad</span></code> differ. The latter is consistent with
the tensor algebra commonly used to derive vector and tensor PDEs,
where <span class="math">\(\nabla\)</span> (&#8220;nabla&#8221;) acts as a vector operator, and therefore
this author prefers to always use <code class="docutils literal"><span class="pre">nabla_grad</span></code>.</p>
</div>
<div class="section" id="forming-and-solving-the-linear-system">
<h3>Forming and solving the linear system<a class="headerlink" href="#forming-and-solving-the-linear-system" title="Permalink to this headline">¶</a></h3>
<p>Having <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> defined, and information about essential
(Dirichlet) boundary conditions in <code class="docutils literal"><span class="pre">bc</span></code>, we can compute the solution,
a finite element function <code class="docutils literal"><span class="pre">u</span></code>, by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Some prefer to replace <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> by an <code class="docutils literal"><span class="pre">equation</span></code>
variable, which is accomplished by this equivalent code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">equation</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we first defined the variable <code class="docutils literal"><span class="pre">u</span></code> as a <code class="docutils literal"><span class="pre">TrialFunction</span></code> and
used it to represent the unknown in the form <code class="docutils literal"><span class="pre">a</span></code>.  Thereafter, we
redefined <code class="docutils literal"><span class="pre">u</span></code> to be a <code class="docutils literal"><span class="pre">Function</span></code> object representing the solution,
i.e., the computed finite element function <span class="math">\(u\)</span>.  This redefinition of
the variable <code class="docutils literal"><span class="pre">u</span></code> is possible in Python and often done in FEniCS
applications. The two types of objects that <code class="docutils literal"><span class="pre">u</span></code> refers to are equal
from a mathematical point of view, and hence it is natural to use the
same variable name for both objects. In a program, however,
<code class="docutils literal"><span class="pre">TrialFunction</span></code> objects must always be used for the unknowns in the
problem specification (the form <code class="docutils literal"><span class="pre">a</span></code>), while <code class="docutils literal"><span class="pre">Function</span></code> objects must be
used for quantities that are computed (known).</p>
</div>
<div class="section" id="examining-the-values-of-the-solution">
<span id="index-15"></span><h3>Examining the values of the solution<a class="headerlink" href="#examining-the-values-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to &#8220;prove&#8221; that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed <code class="docutils literal"><span class="pre">u</span></code> function to <code class="docutils literal"><span class="pre">u0</span></code>.</p>
<p>A finite element function like <span class="math">\(u\)</span> is expressed as a linear combination
of basis functions <span class="math">\(\phi_j\)</span>, spanning the space <span class="math">\(V\)</span>:</p>
<div class="math" id="eq-tut-poisson1-ufem">
\[\tag{13}
u = \sum_{j=1}^N U_j \phi_j {\thinspace .}\]</div>
<p>By writing <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> in the program, a linear system
will be formed from <span class="math">\(a\)</span> and <span class="math">\(L\)</span>, and this system is solved for the
<span class="math">\(U_1,\ldots,U_N\)</span> values. The <span class="math">\(U_1,\ldots,U_N\)</span> values are known
as <em>degrees of freedom</em> of <span class="math">\(u\)</span>. For Lagrange elements (and many other
element types) <span class="math">\(U_k\)</span> is simply the value of <span class="math">\(u\)</span> at the node
with global number <span class="math">\(k\)</span>.
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.</p>
<p>Having <code class="docutils literal"><span class="pre">u</span></code> represented as a <code class="docutils literal"><span class="pre">Function</span></code> object, we can either evaluate
<code class="docutils literal"><span class="pre">u(x)</span></code> at any point <code class="docutils literal"><span class="pre">x</span></code> in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values <span class="math">\(U_j\)</span> directly by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_nodal_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is a DOLFIN <code class="docutils literal"><span class="pre">Vector</span></code> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<code class="docutils literal"><span class="pre">Vector</span></code> object to a standard <code class="docutils literal"><span class="pre">numpy</span></code> array for further
processing:</p>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><div class="highlight-python" id="index-19"><div class="highlight"><pre><span class="n">u_array</span> <span class="o">=</span> <span class="n">u_nodal_values</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With <code class="docutils literal"><span class="pre">numpy</span></code> arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: <code class="docutils literal"><span class="pre">u_array[i]</span></code>,
where the index <code class="docutils literal"><span class="pre">i</span></code> always starts at <code class="docutils literal"><span class="pre">0</span></code>. However, <code class="docutils literal"><span class="pre">i</span></code> corresponds
to <span class="math">\(u\)</span> at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the mesh, see the section <a class="reference internal" href="._ftut005.html#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a>
for details.</p>
<p id="index-20">For now, we want to check that the values in <code class="docutils literal"><span class="pre">u_array</span></code> are correct:
they should equal our <code class="docutils literal"><span class="pre">u0</span></code> function. The most natural approach is
to interpolate our <code class="docutils literal"><span class="pre">u0</span></code> expression onto our space
(i.e., the finite element mesh),</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">interpolate</span></code> function returns a <code class="docutils literal"><span class="pre">Function</span></code> object, whose degrees
of freedom values can be obtained by <code class="docutils literal"><span class="pre">.vector().array()</span></code>.  Our goal is
to show that the degrees of freedom arrays of <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u0_Function</span></code>
are equal. One safe of doing this is to compute the maximum error,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0_array</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
<span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-how-to-check-that-the-error-vanishes admonition">
<p class="first admonition-title">How to check that the error vanishes</p>
<p class="last">With inexact arithmetics, as we always have on a computer,
this maximum error is not zero, but should be a small number.
The machine precision is about <span class="math">\(10^{-16}\)</span>, but in finite element
calculations, rounding errors of this size may accumulate, so
the expected accuracy of <code class="docutils literal"><span class="pre">max_error</span></code> smaller. Experiments show
that increasing the number of elements and increasing the degree
of the finite element polynomials increase <code class="docutils literal"><span class="pre">max_error</span></code>.
For a mesh with <span class="math">\(2(20\times 20)\)</span> cubic Lagrange elements (degree 3)
<code class="docutils literal"><span class="pre">max_error</span></code> is about <span class="math">\(2\cdot 10^{-12}\)</span>, while for 18 linear elements
the maximum error is about <span class="math">\(2\cdot 10^{-15}\)</span>.</p>
</div>
</div>
<div class="section" id="plotting-the-solution">
<h3>Plotting the solution<a class="headerlink" href="#plotting-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The simplest way of quickly looking at <code class="docutils literal"><span class="pre">u</span></code> is to say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Clicking on <code class="docutils literal"><span class="pre">Help</span></code> in the plot windows brings up a list of commands.
For example, typing <code class="docutils literal"><span class="pre">m</span></code> brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click <code class="docutils literal"><span class="pre">Ctrl+q</span></code> to kill the plot window and
continue execution beyond the <code class="docutils literal"><span class="pre">plot(u,</span> <span class="pre">interactive=True)</span></code> command or
<code class="docutils literal"><span class="pre">interactive()</span></code>.  Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><span class="std std-ref">Plot of the solution in the first FEniCS example</span></a> displays the
resulting <span class="math">\(u\)</span> function.</p>
<p>Plotting both the solution and the mesh is accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Type <code class="docutils literal"><span class="pre">Ctrl+w</span></code> to kill all plot windows and continue execution.</p>
<p>It is also possible to dump the computed solution to file, e.g., in the
VTK format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">poisson.pvd</span></code> file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The <code class="docutils literal"><span class="pre">plot</span></code> function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.</p>
</div>
</div>
<div class="section" id="refactored-implementation">
<span id="tut-poisson1-impl2"></span><h2>Refactored implementation<a class="headerlink" href="#refactored-implementation" title="Permalink to this headline">¶</a></h2>
<p>Our initial program above is &#8220;flat&#8221;. That is, it is not organized into
logical, reusable units in terms of Python functions. Such flat programs are
popular for quickly testing out some software, but not well suited for
serious problem solving. We shall therefore at once <em>refactor</em> the program,
meaning that we divide it into functions, but this is just a
reordering of the existing statements. During refactoring, we try
make functions as reusable as possible in other contexts, but
statements specific to a certain problem or task are also encapsulated
in (non-reusable) functions.
Being able to distinguish reusable code from specialized code is a key issue
when refactoring code, and this ability depends on a good mathematical
understanding of the problem at hand (&#8220;what is general, what is special?&#8221;).
In a flat program, general and specialized code (and mathematics)
is often mixed together.</p>
<div class="section" id="a-general-solver-function">
<h3>A general solver function<a class="headerlink" href="#a-general-solver-function" title="Permalink to this headline">¶</a></h3>
<p>Some of the code in the previous flat program are needed to solve any
Poisson problem <span class="math">\(-\nabla^2 u=f\)</span> on <span class="math">\([0,1]\times [0,1]\)</span> with <span class="math">\(u=u_0\)</span> on
the boundary. Let us collect this code in a reusable function
<code class="docutils literal"><span class="pre">solver</span></code>.  Our special test problem will then just be an application
of <code class="docutils literal"><span class="pre">solver</span></code> with some additional statements.
We limit the <code class="docutils literal"><span class="pre">solver</span></code> function to just <em>compute the numerical
solution</em>. Plotting and comparing the solution with the exact solution
are considered to be problem-specific activities to be performed elsewhere.</p>
<p>We parameterize <code class="docutils literal"><span class="pre">solver</span></code> by <span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and the
resolution of the mesh. Since it is so trivial to use higher-order
finite element functions by changing the third argument to
<code class="docutils literal"><span class="pre">FunctionSpace</span></code>, we let also the degree of the polynomials in the
finite element basis functions be an argument to <code class="docutils literal"><span class="pre">solver</span></code>.
[<strong>hpl 4</strong>: The refactoring extends functionality. Should we be strict and keep linear elements? The test is better when it tests the degree parameter as well...]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u0 (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
</div>
<div class="section" id="plotting-for-the-test-problem">
<h3>Plotting for the test problem<a class="headerlink" href="#plotting-for-the-test-problem" title="Permalink to this headline">¶</a></h3>
<p>The additional tasks we did in our initial program can be placed in
other functions. For example, plotting the solution in our particular
test problem is placed in an
<code class="docutils literal"><span class="pre">application_test</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution in the test problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="make-a-module">
<h3>Make a module!<a class="headerlink" href="#make-a-module" title="Permalink to this headline">¶</a></h3>
<p>The refactored code is put in a file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/p2D_func.py">p2D_func.py</a>. We should make
sure that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program should appear with a test
<code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code>. This test is true if the file is executed
as a program, but false if the file is imported.
If we want to run this file in the same way as we can
run <code class="docutils literal"><span class="pre">p2D_func.py</span></code>, the main program is simply a call to
<code class="docutils literal"><span class="pre">application_test()</span></code> followed by a call <code class="docutils literal"><span class="pre">interactive()</span></code> to hold the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application_test</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="verification">
<span id="index-21"></span><h3>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h3>
<p>The remaining part of our first program is to compare the numerical and
the exact solution. Every time we edit the code we must rerun the test
and examine that <code class="docutils literal"><span class="pre">max_error</span></code> is sufficiently small so we know that the
code still works. To this end, we shall adopt <em>unit testing</em>, meaning
that we create a mathematical test and corresponding software that
can run all our tests automatically and check that all tests pass.
Python has several tools for unit testing. Two very popular ones are
pytest and nose. These are almost identical and very easy to use.
More classical unit testing with test classes is offered by the built-in
tool <code class="docutils literal"><span class="pre">unittest</span></code>, but here we are going to use pytest (or nose) since it demands
shorter and clearer code.</p>
<p>Mathematically, our unit test is that the finite element solution of
our problem when <span class="math">\(f=-6\)</span> equals the exact solution <span class="math">\(u=u_0=1+x^2+2y^2\)</span>.
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which depends
to the number of elements and the degrees of the polynomials in the finite
element basis functions. In the section <a class="reference internal" href="#tut-poisson1-impl-dissect"><span class="std std-ref">Dissection of the program</span></a> we
reported some experiments with the size of the maximum error. If we want
to test that <code class="docutils literal"><span class="pre">solver</span></code> works for meshes up to <span class="math">\(2(20\times 20)\)</span> elements
and cubic Lagrange elements, <span class="math">\(10^{-11}\)</span> is
an appropriate tolerance for testing that the maximum error vanishes.</p>
<p>Only three statements are necessary to carry out the unit test. However,
we shall embed these statements in software that the testing frameworks
pytest and nose can recognize. This means that each unit test
must be placed in a function that</p>
<blockquote>
<div><ul class="simple">
<li>has a name starting with <code class="docutils literal"><span class="pre">test_</span></code></li>
<li>has no arguments</li>
<li>implements the test as <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success,</span> <span class="pre">msg</span></code></li>
</ul>
</div></blockquote>
<p>Regarding the last point, <code class="docutils literal"><span class="pre">success</span></code> is a boolean expression that is <code class="docutils literal"><span class="pre">False</span></code>
if the test fails, and in that case the string <code class="docutils literal"><span class="pre">msg</span></code> is written to the
screen. When the test fails, <code class="docutils literal"><span class="pre">assert</span></code> raises an <code class="docutils literal"><span class="pre">AssertionError</span></code> exception
in Python, otherwise the statement runs silently. The <code class="docutils literal"><span class="pre">msg</span></code> string is
optional, so <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success</span></code> is the minimal test. In our case, we
will do <code class="docutils literal"><span class="pre">assert</span> <span class="pre">max_error</span> <span class="pre">&lt;</span> <span class="pre">tol</span></code>, where <code class="docutils literal"><span class="pre">tol</span></code> is the tolerance (<span class="math">\(10^{-11}\)</span>)
mentioned above.</p>
<p>A proper <em>test function</em> for implementing this unit test in the pytest
or nose testing frameworks has the following form. Note that we perform
the test for different mesh resolutions and degrees of finite elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-11</span>  <span class="c"># This problem&#39;s precision</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">x) mesh with P</span><span class="si">%d</span><span class="s"> elements&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="c"># Make a finite element function of the exact u0</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># exact solution</span>
            <span class="c"># Check that dof arrays are equal</span>
            <span class="n">u0_array</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s"> for 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh and degree=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>\
                  <span class="p">(</span><span class="n">max_error</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>We can at any time run</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; py.test -s -v p2D_func.py
</pre></div>
</div>
<p>and the pytest tool will run all functions <code class="docutils literal"><span class="pre">test_*()</span></code> in the file and report
how the tests go.</p>
<p>We shall make it a habit in this book to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented. We dare to assert that this is the only serious way
do reliable computational science with FEniCS.</p>
<div class="admonition-tip-print-messages-in-test-functions admonition">
<p class="first admonition-title">Tip: Print messages in test functions</p>
<p class="last">The <code class="docutils literal"><span class="pre">assert</span></code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code class="docutils literal"><span class="pre">assert</span></code>
(as we do in the example above) such that it is clear that the
test really takes place.
(Note that <code class="docutils literal"><span class="pre">py.test</span></code> needs the <code class="docutils literal"><span class="pre">-s</span></code> option to show printout
from the test functions.)</p>
</div>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section <a class="reference internal" href="._ftut006.html#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a>.  Information in the intermediate sections
can be studied on demand.</p>
</div>
</div>
<div class="section" id="exercise-1-solve-a-poisson-problem">
<h2>Exercise 1: Solve a Poisson problem<a class="headerlink" href="#exercise-1-solve-a-poisson-problem" title="Permalink to this headline">¶</a></h2>
<p>Solve the following problem</p>
<div class="math" id="eq-auto3">
\[\tag{14}
\nabla^2 u = 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x)),
    \quad\hbox{ in }\Omega = [0,1]\times [0,1]\]</div>
<div class="math" id="eq-auto4">
\[\tag{15}
u = 0\quad\hbox{ on }\partial\Omega\]</div>
<p>The exact solution is given by</p>
<div class="math">
\[{u_{\small\mbox{e}}} = 2e^{-2x}\sin(\pi x)\sin(\pi y){\thinspace .}\]</div>
<p>Compute the maximum numerical approximation error in a mesh with
<span class="math">\(2(N_x\times N_y)\)</span> elements and in a mesh with double resolution:
<span class="math">\(4(N_x\times N_y)\)</span> elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
(This is a good verification that the implementation is correct, but
note that the result requires sufficiently fine mesh - here
one may start with <span class="math">\(N_x=N_y=20\)</span>.)
Make an illustrative plot of the solution too.</p>
<p><strong>a)</strong>
Base your implementation on editing the program
<code class="docutils literal"><span class="pre">p2D_plain.py</span></code>.</p>
<p><strong>Hint.</strong>
In the string for an <code class="docutils literal"><span class="pre">Expression</span></code> object, <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code> is the value of
<span class="math">\(\pi\)</span>. Also note that <span class="math">\(\pi^2\)</span> must be expressed with syntax
<code class="docutils literal"><span class="pre">pow(DOLFIN_PI,2)</span></code> and not (the common Python syntax) <code class="docutils literal"><span class="pre">DOLFIN_PI**2</span></code>.</p>
<p>FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code class="docutils literal"><span class="pre">/very/long/path/compile.log</span></code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.</p>
<p>Filename: <code class="docutils literal"><span class="pre">p2D_fsin_plain</span></code>.</p>
<p><strong>Solution.</strong>
Looking at the <code class="docutils literal"><span class="pre">p2D_plain.py</span></code> code, we realize that
the following edits are required:</p>
<blockquote>
<div><ul class="simple">
<li>Modify the <code class="docutils literal"><span class="pre">mesh</span></code> computation.</li>
<li>Modify <code class="docutils literal"><span class="pre">u0</span></code> and <code class="docutils literal"><span class="pre">f</span></code>.</li>
<li>Add expression for the exact solution.</li>
<li>Modify the computation of the numerical error.</li>
<li>Insert a loop to enable solving the problem twice.</li>
<li>Put the error reduction computation and the plot statements after the loop.</li>
</ul>
</div></blockquote>
<p>Here is the modified code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">Nx</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Ny</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Define boundary conditions</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">,</span> <span class="n">pi</span><span class="o">=</span><span class="n">DOLFIN_PI</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*DOLFIN_PI*x[0])*sin(DOLFIN_PI*x[1])&#39;</span><span class="p">)</span>

    <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>         <span class="c"># exact solution</span>
    <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
    <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error reduction:&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The number <span class="math">\(\pi\)</span> has the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> in C and C++, but in FEniCS C++
expressions the symbol <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code> must be used. Above, we introduce
the variable <code class="docutils literal"><span class="pre">pi</span></code> in the expression for <code class="docutils literal"><span class="pre">f</span></code>, since we find it more
readable, and then we define <code class="docutils literal"><span class="pre">pi</span></code> as <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code> as an extra parameter
to <code class="docutils literal"><span class="pre">Expression</span></code>. The alternative of using <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code> inside the
string <code class="docutils literal"><span class="pre">f</span></code> gives a more difficult-to-read expression.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/p2D_fsin.png"><img alt="_images/p2D_fsin.png" src="_images/p2D_fsin.png" style="width: 500px;" /></a>
</div>
<p><strong>b)</strong>
Base your implementation on a new file that imports functionality
from the module <code class="docutils literal"><span class="pre">p2D_func.py</span></code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code class="docutils literal"><span class="pre">p2D_fsin_func</span></code>.</p>
<p><strong>Solution.</strong>
Solving the two problems is a matter of calling <code class="docutils literal"><span class="pre">solver</span></code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code class="docutils literal"><span class="pre">test_solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">p2D_func</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span>
    <span class="n">interactive</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*DOLFIN_PI*x[0])*sin(DOLFIN_PI*x[1])&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">,</span> <span class="n">pi</span><span class="o">=</span><span class="n">DOLFIN_PI</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span>

<span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Loop over refined meshes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Nx</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">Ny</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Make a finite element function of the exact u_e</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># Linf norm</span>
        <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">error</span><span class="p">)):</span>
        <span class="n">error_reduction</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;error reduction:&#39;</span><span class="p">,</span> <span class="n">error_reduction</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error_reduction</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_solver</span><span class="p">()</span>
    <span class="n">application</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The unit test is embedded in a proper test function <code class="docutils literal"><span class="pre">test_solver</span></code>
for the pytest or
nose testing frameworks. Visualization of the solution is encapsulated
in the <code class="docutils literal"><span class="pre">application</span></code> function. Since we need <code class="docutils literal"><span class="pre">u_e</span></code>, <code class="docutils literal"><span class="pre">u0</span></code>, and <code class="docutils literal"><span class="pre">f</span></code>
in two functions, we place the definitions in a function <code class="docutils literal"><span class="pre">data</span></code> to
avoid copies of these expressions.</p>
<div class="section" id="remarks">
<h3>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h3>
<p>This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code class="docutils literal"><span class="pre">solver</span></code> function, requires <em>no modifications</em>
of the <code class="docutils literal"><span class="pre">p2D_func.py</span></code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code class="docutils literal"><span class="pre">p2D_func.py</span></code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>