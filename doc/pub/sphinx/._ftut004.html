<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Poisson solver revisited</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="The diffusion solver revisited" href="._ftut005.html" />
    <link rel="prev" title="Fundamentals" href="._ftut003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-poisson-solver-revisited">
<span id="ch-poisson"></span><h1>The Poisson solver revisited<a class="headerlink" href="#the-poisson-solver-revisited" title="Permalink to this headline">¶</a></h1>
<p>[<strong>hpl 9</strong>: I don&#8217;t like this title, but have no other good alternaive...]</p>
<div class="section" id="refactored-implementation-1">
<span id="tut-poisson1-impl2"></span><h2>Refactored implementation<a class="headerlink" href="#refactored-implementation-1" title="Permalink to this headline">¶</a></h2>
<p>Our first programs in this book are all &#8220;flat&#8221;. That is,
they are not organized
into logical, reusable units in terms of Python functions. Such flat
programs are popular for quickly testing out some software, but not
well suited for serious problem solving. We shall therefore at once
<em>refactor</em> the program, meaning that we divide it into functions, but
this is just a reordering of the existing statements. During
refactoring, we try make functions as reusable as possible in other
contexts, but statements specific to a certain problem or task are
also encapsulated in (non-reusable) functions.  Being able to
distinguish reusable code from specialized code is a key issue when
refactoring code, and this ability depends on a good mathematical
understanding of the problem at hand (&#8220;what is general, what is
special?&#8221;).  In a flat program, general and specialized code (and
mathematics) is often mixed together.</p>
<div class="section" id="a-general-solver-function">
<h3>A general solver function<a class="headerlink" href="#a-general-solver-function" title="Permalink to this headline">¶</a></h3>
<p>We consider the flat program developed in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl"><span class="std std-ref">FEniCS implementation</span></a>.
Some of the code in this program is needed to solve any
Poisson problem <span class="math">\(-\nabla^2 u=f\)</span> on <span class="math">\([0,1]\times [0,1]\)</span> with <span class="math">\(u=u_0\)</span> on
the boundary, while other statements arise from our simple test
problem. Let us collect the general, reusable code in a function
<code class="docutils literal"><span class="pre">solver</span></code>.  Our special test problem will then just be an application
of <code class="docutils literal"><span class="pre">solver</span></code> with some additional statements.  We limit the <code class="docutils literal"><span class="pre">solver</span></code>
function to just <em>compute the numerical solution</em>. Plotting and
comparing the solution with the exact solution are considered to be
problem-specific activities to be performed elsewhere.</p>
<p>We parameterize <code class="docutils literal"><span class="pre">solver</span></code> by <span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and the resolution of the
mesh. Since it is so trivial to use higher-order finite element
functions by changing the third argument to <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, we let
also the degree of the polynomials in the finite element basis
functions be an argument to <code class="docutils literal"><span class="pre">solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u0 (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<div class="section" id="plotting-for-the-test-problem">
<h4>Plotting for the test problem<a class="headerlink" href="#plotting-for-the-test-problem" title="Permalink to this headline">¶</a></h4>
<p>The additional tasks we did in our initial program can be placed in
other functions. For example, plotting the solution in our particular
test problem is placed in an
<code class="docutils literal"><span class="pre">application_test</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution in the test problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>  <span class="c"># name &#39;u&#39; is used in plot</span>
    <span class="n">vtkfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="make-a-module">
<h4>Make a module!<a class="headerlink" href="#make-a-module" title="Permalink to this headline">¶</a></h4>
<p>The refactored code is put in a file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/poisson/ft04_poisson_func.py">ft04_poisson_func.py</a>. We should make
sure that such a file can be imported (and hence reused) in other programs.
Then all statements in the main program should appear with a test
<code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code>. This test is true if the file is executed
as a program, but false if the file is imported.
If we want to run this file in the same way as we can
run <code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code>, the main program is simply a call to
<code class="docutils literal"><span class="pre">application_test()</span></code> followed by a call <code class="docutils literal"><span class="pre">interactive()</span></code> to hold the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application_test</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-and-unit-tests">
<span id="index-0"></span><h3>Verification and unit tests<a class="headerlink" href="#verification-and-unit-tests" title="Permalink to this headline">¶</a></h3>
<p>The remaining part of our first program is to compare the numerical and
the exact solution. Every time we edit the code we must rerun the test
and examine that <code class="docutils literal"><span class="pre">max_error</span></code> is sufficiently small so we know that the
code still works. To this end, we shall adopt <em>unit testing</em>, meaning
that we create a mathematical test and corresponding software that
can run all our tests automatically and check that all tests pass.
Python has several tools for unit testing. Two very popular ones are
pytest and nose. These are almost identical and very easy to use.
More classical unit testing with test classes is offered by the built-in
tool <code class="docutils literal"><span class="pre">unittest</span></code>, but here we are going to use pytest (or nose) since it demands
shorter and clearer code.</p>
<p>Mathematically, our unit test is that the finite element solution of
our problem when <span class="math">\(f=-6\)</span> equals the exact solution <span class="math">\(u=u_0=1+x^2+2y^2\)</span>.
We have already created code that finds the maximum error in the
numerical solution. Because of rounding errors, we cannot demand this
maximum error to be zero, but we have to use a tolerance, which depends
to the number of elements and the degrees of the polynomials in the finite
element basis functions. In the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl-dissect"><span class="std std-ref">Dissection of the program</span></a> we
reported some experiments with the size of the maximum error. If we want
to test that <code class="docutils literal"><span class="pre">solver</span></code> works for meshes up to <span class="math">\(2(20\times 20)\)</span> elements
and cubic Lagrange elements, <span class="math">\(10^{-11}\)</span> is
an appropriate tolerance for testing that the maximum error vanishes.</p>
<p>Only three statements are necessary to carry out the unit test. However,
we shall embed these statements in software that the testing frameworks
pytest and nose can recognize. This means that each unit test
must be placed in a function that</p>
<blockquote>
<div><ul class="simple">
<li>has a name starting with <code class="docutils literal"><span class="pre">test_</span></code></li>
<li>has no arguments</li>
<li>implements the test as <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success,</span> <span class="pre">msg</span></code></li>
</ul>
</div></blockquote>
<p>Regarding the last point, <code class="docutils literal"><span class="pre">success</span></code> is a boolean expression that is <code class="docutils literal"><span class="pre">False</span></code>
if the test fails, and in that case the string <code class="docutils literal"><span class="pre">msg</span></code> is written to the
screen. When the test fails, <code class="docutils literal"><span class="pre">assert</span></code> raises an <code class="docutils literal"><span class="pre">AssertionError</span></code> exception
in Python, otherwise the statement runs silently. The <code class="docutils literal"><span class="pre">msg</span></code> string is
optional, so <code class="docutils literal"><span class="pre">assert</span> <span class="pre">success</span></code> is the minimal test. In our case, we
will do <code class="docutils literal"><span class="pre">assert</span> <span class="pre">max_error</span> <span class="pre">&lt;</span> <span class="pre">tol</span></code>, where <code class="docutils literal"><span class="pre">tol</span></code> is the tolerance (<span class="math">\(10^{-11}\)</span>)
mentioned above.</p>
<p>A proper <em>test function</em> for implementing this unit test in the pytest
or nose testing frameworks has the following form. Note that we perform
the test for different mesh resolutions and degrees of finite elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to &quot;machine precision&quot;.&quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-11</span>  <span class="c"># This problem&#39;s precision</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh with P</span><span class="si">%d</span><span class="s"> elements&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="c"># Make a finite element function of the exact u0</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># exact solution</span>
            <span class="c"># Check that dof arrays are equal</span>
            <span class="n">u0_array</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s"> for 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh and degree=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>\
                  <span class="p">(</span><span class="n">max_error</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>We can at any time run</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; py.test -s -v ft04_poisson_func.py
</pre></div>
</div>
<p>and the pytest tool will run all functions <code class="docutils literal"><span class="pre">test_*()</span></code> in the file and report
how the tests go.</p>
<p>We shall make it a habit in this book to encapsulate numerical test
problems in unit tests as done above, and we strongly encourage the
reader to create similar unit tests whenever a FEniCS solver is
implemented. We dare to assert that this is the only serious way
do reliable computational science with FEniCS.</p>
<div class="admonition-tip-print-messages-in-test-functions admonition">
<p class="first admonition-title">Tip: Print messages in test functions</p>
<p class="last">The <code class="docutils literal"><span class="pre">assert</span></code> statement runs silently when the test passes so users may
become uncertain if all the statements in a test function are really
executed. A psychological help is to print out something before <code class="docutils literal"><span class="pre">assert</span></code>
(as we do in the example above) such that it is clear that the
test really takes place.
(Note that <code class="docutils literal"><span class="pre">py.test</span></code> needs the <code class="docutils literal"><span class="pre">-s</span></code> option to show printout
from the test functions.)</p>
</div>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient
reader who is more interested in seeing the previous program being
adapted to a real physical problem, and play around with some
interesting visualizations, can safely jump to the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a>.  Information in the intermediate sections
can be studied on demand.</p>
</div>
<div class="section" id="exercise-1-solve-a-poisson-problem">
<h3>Exercise 1: Solve a Poisson problem<a class="headerlink" href="#exercise-1-solve-a-poisson-problem" title="Permalink to this headline">¶</a></h3>
<p>Solve the following problem</p>
<div class="math" id="eq-auto9">
\[\tag{42}
\nabla^2 u = 2e^{-2x}\sin(\pi y)((4-5\pi^2)\sin(2\pi x) - 8\pi\cos(2\pi x))
    \hbox{ in }\Omega = [0,1]\times [0,1]\]</div>
<div class="math" id="eq-auto10">
\[\tag{43}
u = 0\quad\hbox{ on }\partial\Omega\]</div>
<p>The exact solution is given by</p>
<div class="math">
\[u(x,y) = 2e^{-2x}\sin(\pi x)\sin(\pi y){\thinspace .}\]</div>
<p>Compute the maximum numerical approximation error in a mesh with
<span class="math">\(2(N_x\times N_y)\)</span> elements and in a mesh with double resolution:
<span class="math">\(4(N_x\times N_y)\)</span> elements. Show that the doubling the resolution
reduces the error by a factor 4 when using Lagrange elements of degree one.
Make an illustrative plot of the solution too.</p>
<p><strong>a)</strong>
Base your implementation on editing the program
<code class="docutils literal"><span class="pre">ft01_poisson_flat.py</span></code>.</p>
<p><strong>Hint 1.</strong>
In the string for an <code class="docutils literal"><span class="pre">Expression</span></code> object, <code class="docutils literal"><span class="pre">pi</span></code> is the value of
<span class="math">\(\pi\)</span>. Also note that <span class="math">\(\pi^2\)</span> must be expressed with syntax
<code class="docutils literal"><span class="pre">pow(pi,2)</span></code> and not (the common Python syntax) <code class="docutils literal"><span class="pre">pi**2</span></code>.</p>
<p>FEniCS will abort with a compilation error if you type the expressions
in a wrong way syntax-wise.  Search for <em>error:</em> in the
<code class="docutils literal"><span class="pre">/very/long/path/compile.log</span></code> file mentioned in the error message to
see what the C++ compiler reported as error in the expressions.</p>
<p><strong>Hint 2.</strong>
The result that with P1 elements, doubling the resolution reduces the error
with a factor of four, is an
asymptotic result so it requires a sufficiently fine mesh. Here
one may start with <span class="math">\(N_x=N_y=20\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">poisson_fsin_flat</span></code>.</p>
<p><strong>Solution.</strong>
Looking at the <code class="docutils literal"><span class="pre">ft01_poisson_flat.py</span></code> code, we realize that
the following edits are required:</p>
<blockquote>
<div><ul class="simple">
<li>Modify the <code class="docutils literal"><span class="pre">mesh</span></code> computation.</li>
<li>Modify <code class="docutils literal"><span class="pre">u0</span></code> and <code class="docutils literal"><span class="pre">f</span></code>.</li>
<li>Add expression for the exact solution.</li>
<li>Modify the computation of the numerical error.</li>
<li>Insert a loop to enable solving the problem twice.</li>
<li>Put the error reduction computation and the plot statements after the loop.</li>
</ul>
</div></blockquote>
<p>Here is the modified code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">Nx</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Ny</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Define boundary conditions</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="c"># Note: no need for pi=DOLFIN_PI in f, pi is valid variable</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>

    <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>         <span class="c"># exact solution</span>
    <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
    <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Error reduction:&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The number <span class="math">\(\pi\)</span> has the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> in C and C++, but in C++
strings in <code class="docutils literal"><span class="pre">Expression</span></code> objects, the symbol <code class="docutils literal"><span class="pre">pi</span></code> can be used directly
(or one can use the less readable <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/poisson_fsin.png"><img alt="_images/poisson_fsin.png" src="_images/poisson_fsin.png" style="width: 500px;" /></a>
</div>
<p><strong>b)</strong>
Base your implementation on a new file that imports functionality
from the module <code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code>. Embed the check of the
reduction of the numerical approximation error in a unit test.
Filename: <code class="docutils literal"><span class="pre">poisson_fsin_func</span></code>.</p>
<p><strong>Solution.</strong>
Solving the two problems is a matter of calling <code class="docutils literal"><span class="pre">solver</span></code> with
different sets of arguments.
To compute the numerical error,
we need code that is close to what we have in <code class="docutils literal"><span class="pre">test_solver</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">poisson_func</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span>
    <span class="n">interactive</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return data for this Poisson problem.&quot;&quot;&quot;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;2*exp(-2*x[0])*sin(2*pi*x[0])*sin(pi*x[1])&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-2*exp(-2*x[0])*sin(pi*x[1])*(&#39;</span>
                   <span class="s">&#39;(4-5*pow(pi,2))*sin(2*pi*x[0]) &#39;</span>
                   <span class="s">&#39; - 8*pi*cos(2*pi*x[0]))&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span>

<span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check convergence rate of solver.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Loop over refined meshes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Nx</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">Ny</span> <span class="o">*=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Make a finite element function of the exact u_e</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># Linf norm</span>
        <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">error</span><span class="p">)):</span>
        <span class="n">error_reduction</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;error reduction:&#39;</span><span class="p">,</span> <span class="n">error_reduction</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error_reduction</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Plot the solution.&quot;&quot;&quot;</span>
    <span class="n">u0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Dump solution to file in VTK format</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="c"># Plot solution and mesh</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_solver</span><span class="p">()</span>
    <span class="n">application</span><span class="p">()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The unit test is embedded in a proper test function <code class="docutils literal"><span class="pre">test_solver</span></code>
for the pytest or
nose testing frameworks. Visualization of the solution is encapsulated
in the <code class="docutils literal"><span class="pre">application</span></code> function. Since we need <code class="docutils literal"><span class="pre">u_e</span></code>, <code class="docutils literal"><span class="pre">u0</span></code>, and <code class="docutils literal"><span class="pre">f</span></code>
in two functions, we place the definitions in a function <code class="docutils literal"><span class="pre">data</span></code> to
avoid copies of these expressions.</p>
<div class="section" id="remarks">
<h4>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h4>
<p>This exercise demonstrates that changing a flat program to solve a new
problem requires careful editing of statements scattered around in the
file, while
the solution in b), based on the <code class="docutils literal"><span class="pre">solver</span></code> function, requires <em>no modifications</em>
of the <code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code> file, just
<em>minimalistic additional new code</em> in a separate file. The Poisson solver
remains in one place (<code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code>) while in a) we got two
Poisson solvers. If you decide to switch to an iterative solution method
for linear systems, you can do so in one place in b), and all applications
can take advantage of the extension. Hopefully, with this exercise
you realize that embedding
PDE solvers in functions (or classes) makes more reusable software than
flat programs.</p>
</div>
</div>
</div>
<div class="section" id="useful-extensions">
<h2>Useful extensions<a class="headerlink" href="#useful-extensions" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 10</strong>: Need a little intro.]</p>
<div class="section" id="controlling-the-solution-process">
<span id="tut-poisson1-solve-prm"></span><h3>Controlling the solution process<a class="headerlink" href="#controlling-the-solution-process" title="Permalink to this headline">¶</a></h3>
<p>Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.
The forthcoming text tells you how to
advantage of state-of-the-art iterative solution methods in FEniCS.</p>
<div class="section" id="setting-linear-solver-parameters">
<h4>Setting linear solver parameters<a class="headerlink" href="#setting-linear-solver-parameters" title="Permalink to this headline">¶</a></h4>
<p>Preconditioned Krylov solvers is a type of popular iterative methods
that are easily accessible in FEniCS programs. The Poisson equation
results in a symmetric, positive definite coefficient matrix, for
which the optimal Krylov solver is the Conjugate Gradient (CG)
method. However, the CG method requires boundary conditions to be
implemented in a symmetric way. This is not the case by default, so
then a Krylov solver for non-symmetric system, such as GMRES, is a
better choice.  Incomplete LU factorization (ILU) is a popular and
robust all-round preconditioner, so let us try the GMRES-ILU pair:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
<span class="c"># Alternative syntax</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="n">preconditioner</span><span class="o">=</span><span class="s">&#39;ilu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>the section <a class="reference internal" href="._ftut007.html#tut-app-solver-prec"><span class="std std-ref">Linear solvers and preconditioners</span></a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.</p>
<span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span></div>
<div class="section" id="linear-algebra-backend">
<span id="index-5"></span><h4>Linear algebra backend<a class="headerlink" href="#linear-algebra-backend" title="Permalink to this headline">¶</a></h4>
<p>The actual GMRES and ILU implementations that are brought into action
depends on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology.  PETSc is the default choice if FEniCS is compiled
with PETSc, otherwise uBLAS.  Epetra (Trilinos), Eigen, MTL4 are other
supported backends. Which backend to apply can be controlled by
setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">backendname</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">backendname</span></code> is a string, either <code class="docutils literal"><span class="pre">'Eigen'</span></code>, <code class="docutils literal"><span class="pre">'PETSc'</span></code>, <code class="docutils literal"><span class="pre">'uBLAS'</span></code>,
<code class="docutils literal"><span class="pre">'Epetra'</span></code>, or <code class="docutils literal"><span class="pre">'MTL4'</span></code>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear systems
of equations.</p>
<p id="index-6">A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the
default linear algebra backend.  The default solver is sparse LU
decomposition (<code class="docutils literal"><span class="pre">'lu'</span></code>), and the actual software that is called is then
the sparse LU solver from UMFPACK (which PETSc has an interface
to). The available linear algebra backends in a FEniCS installation is
listed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_algebra_backends</span><span class="p">()</span>
</pre></div>
</div>
<span class="target" id="index-7"></span></div>
<div class="section" id="the-parameters-database">
<span id="index-8"></span><h4>The <code class="docutils literal"><span class="pre">parameters</span></code> database<a class="headerlink" href="#the-parameters-database" title="Permalink to this headline">¶</a></h4>
<p>We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method.  Such parameters can be set by accessing the <em>global
parameter database</em>, which is called <code class="docutils literal"><span class="pre">parameters</span></code> and which behaves as
a nested dictionary. Write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code class="docutils literal"><span class="pre">info</span></code>.
According to this output, the relevant parameter set is
named <code class="docutils literal"><span class="pre">'krylov_solver'</span></code>, and the parameters are set like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span>  <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.</p>
<p>To get a printout of the number of actual iterations to reach the
stopping criterion, we can insert</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>
</div>
<p>A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <code class="docutils literal"><span class="pre">PROGRESS</span></code>, while
<code class="docutils literal"><span class="pre">DEBUG</span></code> results in more information, including CPU time spent in
the various parts of the matrix assembly and solve process.</p>
<p>We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">File</span><span class="p">(</span><span class="s">&#39;fenics_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>If a <code class="docutils literal"><span class="pre">fenics_parameters.xml</span></code> file is found in the directory where a
FEniCS program is run, this file is read and used to initialize the
<code class="docutils literal"><span class="pre">parameters</span></code> object. Otherwise, the file
<code class="docutils literal"><span class="pre">.config/fenics/fenics_parameters.xml</span></code> in the user&#8217;s home directory is
read, if it exists.  Another alternative is to load the XML (with any
name) manually in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">File</span><span class="p">(</span><span class="s">&#39;fenics_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>The XML file can also be in gzip&#8217;ed form with the extension <code class="docutils literal"><span class="pre">.xml.gz</span></code>.</p>
</div>
<div class="section" id="an-extended-solver-function">
<span id="index-9"></span><h4>An extended solver function<a class="headerlink" href="#an-extended-solver-function" title="Permalink to this headline">¶</a></h4>
<p>Let us extend the previous solver function from
<code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code> such that it also offers the GMRES+ILU
preconditioned Krylov solver.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -Laplace(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u0 (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>

<span class="k">def</span> <span class="nf">solver_objects</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;As solver, but use objects for linear variational problem</span>
<span class="sd">    and solver.&quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
    <span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;gmres&#39;</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

    <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>This new <code class="docutils literal"><span class="pre">solver</span></code> function, found in the file
<code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code>, replaces the one in <code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code>:
it has all the functionality of the previous <code class="docutils literal"><span class="pre">solver</span></code> function,
but can also solve the linear system with
iterative methods and report the progress of such solvers.</p>
</div>
<div class="section" id="remark-regarding-unit-tests">
<h4>Remark regarding unit tests<a class="headerlink" href="#remark-regarding-unit-tests" title="Permalink to this headline">¶</a></h4>
<p>Regarding verification of the new <code class="docutils literal"><span class="pre">solver</span></code> function in terms of unit
tests, it turns out that unit testing in a problem where the
approximation error vanishes is gets more complicated when we use
iterative methods. The problem is to keep the error due to iterative
solution smaller than the tolerance used in the verification
tests. First of all this means that the tolerances used in the Krylov
solvers must be smaller than the tolerance used in the <code class="docutils literal"><span class="pre">assert</span></code> test,
but this is no guarantee to keep the linear solver error this small.
For linear elements and small meshes, a tolerance of <span class="math">\(10^{-11}\)</span> works
well in the case of Krylov solvers too (using a tolerance <span class="math">\(10^{-12}\)</span>
in those solvers. However, as soon as we switch to P2 elements, it is
hard to force the linear solver error below <span class="math">\(10^{-6}\)</span>. Consequently,
tolerances in tests depend on the numerical methods. The interested
reader is referred to the <code class="docutils literal"><span class="pre">test_solver</span></code> function in
<code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code> for details: this test function tests the
numerical solution for direct and iterative linear solvers, for
different meshes, and different degrees of the polynomials in the
finite element basis functions.</p>
</div>
</div>
<div class="section" id="linear-variational-problem-and-solver-objects">
<span id="tut-poisson1-solver-problem"></span><h3>Linear variational problem and solver objects<a class="headerlink" href="#linear-variational-problem-and-solver-objects" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">The <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> call is just a compact syntax alternative to a
slightly more comprehensive specification of the variational equation
and the solution of the associated linear system.  This alternative
syntax is used in a lot of FEniCS applications and will also be
used later in this tutorial, so we show it already now:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Many objects have an attribute <code class="docutils literal"><span class="pre">parameters</span></code> corresponding to
a parameter set in the global <code class="docutils literal"><span class="pre">parameters</span></code> database,
but local to the object. Here, <code class="docutils literal"><span class="pre">solver.parameters</span></code> play that
role. Setting the CG method with ILU preconditioning as solution
method and specifying solver-specific parameters can be done
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;gmres&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Settings in the global <code class="docutils literal"><span class="pre">parameters</span></code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as done above.</p>
<p>The linear variational problem and solver objects as outlined above
are incorporated in an alternative solver function, named
<code class="docutils literal"><span class="pre">solver_objects</span></code>, in
<code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code>. Otherwise, this function is parallel to the
previously shown <code class="docutils literal"><span class="pre">solver</span></code> function.</p>
</div>
<div class="section" id="writing-out-the-discrete-solution">
<span id="tut-poisson1-verify1"></span><h3>Writing out the discrete solution<a class="headerlink" href="#writing-out-the-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>We have seen how to grab the degrees of freedom array from a
finite element function <code class="docutils literal"><span class="pre">u</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_array</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The elements in <code class="docutils literal"><span class="pre">u_array</span></code> correspond to function values of <code class="docutils literal"><span class="pre">u</span></code> at nodes
in the mesh.  Now, a fundamental question is: What are the
coordinates of node <code class="docutils literal"><span class="pre">i</span></code> whose value is <code class="docutils literal"><span class="pre">u_array[i]</span></code>? To answer this
question, we need to understand how to get our hands on the
coordinates, and in particular, the numbering of degrees of freedom
and the numbering of vertices in the mesh. We start with P1 (1st order
Lagrange) elements where all the nodes are vertices in the mesh.</p>
<p>The function <code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns the coordinates of the
vertices as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape <span class="math">\((M,d\)</span>), <span class="math">\(M\)</span> being the number
of vertices in the mesh and <span class="math">\(d\)</span> being the number of space dimensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coor</span>
<span class="go">array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0. ],</span>
<span class="go">       [ 1. ,  0. ],</span>
<span class="go">       [ 0. ,  0.5],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  0.5],</span>
<span class="go">       [ 0. ,  1. ],</span>
<span class="go">       [ 0.5,  1. ],</span>
<span class="go">       [ 1. ,  1. ]])</span>
</pre></div>
</div>
<p>We see from this output that vertices are first numbered along <span class="math">\(y=0\)</span>
with increasing <span class="math">\(x\)</span> coordinate, then along <span class="math">\(y=0.5\)</span>, and so on.</p>
<p>Next we compute a function <code class="docutils literal"><span class="pre">u</span></code> on this mesh, e.g., the <span class="math">\(u=x+y\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0]+x[1]&#39;</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_array</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_array</span>
<span class="go">array([ 1. ,  0.5,  1.5,  0. ,  1. ,  2. ,  0.5,  1.5,  1. ])</span>
</pre></div>
</div>
<p>We observe that <code class="docutils literal"><span class="pre">u_array[0]</span></code> is <em>not</em> the value of <span class="math">\(x+y\)</span> at vertex number 0,
since this vertex has coordinates <span class="math">\(x=y=0\)</span>. The numbering of the
degrees of freedom <span class="math">\(U_1,\ldots,U_{N}\)</span> is obviously not the same as the
numbering of the vertices.</p>
<p>In the plot of <code class="docutils literal"><span class="pre">u</span></code>, type <code class="docutils literal"><span class="pre">w</span></code> to turn on wireframe instead of fully colored
surface, <code class="docutils literal"><span class="pre">m</span></code> to show the mesh, and then <code class="docutils literal"><span class="pre">v</span></code> to show the
numbering of the vertices.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/vertex_numbering.png"><img alt="_images/vertex_numbering.png" src="_images/vertex_numbering.png" style="width: 500px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<span class="target" id="index-13"></span><p id="index-14">The vertex values of a <code class="docutils literal"><span class="pre">Function</span></code> object can be extracted by
<code class="docutils literal"><span class="pre">u.compute_vertex_values()</span></code>, which returns an array where element <code class="docutils literal"><span class="pre">i</span></code>
is the value of <code class="docutils literal"><span class="pre">u</span></code> at vertex <code class="docutils literal"><span class="pre">i</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%d</span><span class="s">: u_at_vertices[</span><span class="si">%d</span><span class="s">]=</span><span class="si">%g</span><span class="se">\t</span><span class="s">u(</span><span class="si">%s</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
<span class="gp">... </span>          <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">vertex 0: u_at_vertices[0]=0    u([ 0.  0.])=8.46545e-16</span>
<span class="go">vertex 1: u_at_vertices[1]=0.5  u([ 0.5  0. ])=0.5</span>
<span class="go">vertex 2: u_at_vertices[2]=1    u([ 1.  0.])=1</span>
<span class="go">vertex 3: u_at_vertices[3]=0.5  u([ 0.   0.5])=0.5</span>
<span class="go">vertex 4: u_at_vertices[4]=1    u([ 0.5  0.5])=1</span>
<span class="go">vertex 5: u_at_vertices[5]=1.5  u([ 1.   0.5])=1.5</span>
<span class="go">vertex 6: u_at_vertices[6]=1    u([ 0.  1.])=1</span>
<span class="go">vertex 7: u_at_vertices[7]=1.5  u([ 0.5  1. ])=1.5</span>
<span class="go">vertex 8: u_at_vertices[8]=2    u([ 1.  1.])=2</span>
</pre></div>
</div>
<span class="target" id="index-15"></span><p id="index-16">Alternatively, we can ask for the mapping from vertex numbering to degrees
of freedom numbering in the space <span class="math">\(V\)</span>:</p>
<div class="highlight-text"><div class="highlight"><pre>v2d = vertex_to_dof_map(V)
</pre></div>
</div>
<p>Now, <code class="docutils literal"><span class="pre">u_array[v2d[i]]</span></code> will give us the value of the
degree of freedom in <code class="docutils literal"><span class="pre">u</span></code> corresponding
to vertex <code class="docutils literal"><span class="pre">i</span></code> (<code class="docutils literal"><span class="pre">v2d[i]</span></code>). In particular, <code class="docutils literal"><span class="pre">u_array[v2d]</span></code> is an array
with all the elements in the same (vertex numbered) order as <code class="docutils literal"><span class="pre">coor</span></code>.
The inverse map, from degrees of freedom
number to vertex number is given by <code class="docutils literal"><span class="pre">dof_to_vertex_map(V)</span></code>, so
<code class="docutils literal"><span class="pre">coor[dof_to_vertex_map(V)]</span></code> results in an array of all the
coordinates in the same order as the degrees of freedom.</p>
<p>For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices.
[<strong>hpl 11</strong>: Anders, is the following true?] There is no simple way of getting the
coordinates associated with the non-vertex degrees of freedom, so
if we want to write out the values of a finite element solution,
the following code snippet does the task at the vertices, and this
will work for all kinds of Lagrange elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compare_exact_and_numerical_solution</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="c"># Grab exact and numerical solution at the vertices and compare</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">u0_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">u0_at_vertices</span> <span class="o">=</span> <span class="n">u0_Function</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
    <span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%2d</span><span class="s"> (</span><span class="si">%9g</span><span class="s">,</span><span class="si">%9g</span><span class="s">): error=</span><span class="si">%g</span><span class="s">&#39;</span>
              <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                 <span class="n">u0_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c"># Could compute u0(x) - u_at_vertices[i] but this</span>
        <span class="c"># is much more expensive and gives more rounding errors</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">u0</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;numerical error at </span><span class="si">%s</span><span class="s">: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>As expected, the error is either identically zero or about <span class="math">\(10^{-15}\)</span> or
<span class="math">\(10^{-16}\)</span>.</p>
<div class="admonition-cheap-vs-expensive-function-evaluation admonition">
<p class="first admonition-title">Cheap vs expensive function evaluation</p>
<p>Given a <code class="docutils literal"><span class="pre">Function</span></code> object <code class="docutils literal"><span class="pre">u</span></code>, we can evaluate its values in various
ways:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">u(x)</span></code> for an arbitrary point <code class="docutils literal"><span class="pre">x</span></code></li>
<li><code class="docutils literal"><span class="pre">u.vector().array()[i]</span></code> for degree of freedom number <code class="docutils literal"><span class="pre">i</span></code></li>
<li><code class="docutils literal"><span class="pre">u.compute_vertex_values()[i]</span></code> at vertex number <code class="docutils literal"><span class="pre">i</span></code></li>
</ol>
<p class="last">The first method, though very flexible, is in general very expensive
while the other two are very efficient (but limited to certain points).</p>
</div>
<p>To demonstrate the use of point evaluations of <code class="docutils literal"><span class="pre">Function</span></code> objects,
we write out the computed <code class="docutils literal"><span class="pre">u</span></code> at the center point
of the domain and compare it with the exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">u0</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;numerical error at </span><span class="si">%s</span><span class="s">: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>Trying a <span class="math">\(2(3\times 3)\)</span> mesh, the output from the
previous snippet becomes</p>
<div class="highlight-text"><div class="highlight"><pre>numerical error at (0.5, 0.5): -0.0833333
</pre></div>
</div>
<p>The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell,
and <code class="docutils literal"><span class="pre">u</span></code> varies linearly over the cell while
<code class="docutils literal"><span class="pre">u0</span></code> is a quadratic function. When the center point is a node, as in
a <span class="math">\(2(t\times 2)\)</span> or <span class="math">\(2(4\times 4)\)</span> mesh, the error is of the order
<span class="math">\(10^{-15}\)</span>.</p>
<p>We have seen how to extract the nodal values in a <code class="docutils literal"><span class="pre">numpy</span></code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that <span class="math">\(\max_j U_j = 1\)</span>. Then we
must divide all <span class="math">\(U_j\)</span> values
by <span class="math">\(\max_j U_j\)</span>. The following function performs the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">normalize_solution</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize u: return u divided by max(u).&quot;&quot;&quot;</span>
    <span class="n">u_array</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">u_max</span> <span class="o">=</span> <span class="n">u_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">u_array</span> <span class="o">/=</span> <span class="n">u_max</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_array</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">u_array</span><span class="p">)</span>  <span class="c"># alternative</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>That is, we manipulate <code class="docutils literal"><span class="pre">u_array</span></code> as desired, and then we insert this
array into <code class="docutils literal"><span class="pre">u</span></code>&#8216;s <code class="docutils literal"><span class="pre">Vector</span></code> object.  The <code class="docutils literal"><span class="pre">/=</span></code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <code class="docutils literal"><span class="pre">u_array</span></code> are divided by the value <code class="docutils literal"><span class="pre">max_u</span></code>.
Alternatively, one could write <code class="docutils literal"><span class="pre">u_array</span> <span class="pre">=</span> <span class="pre">u_array/max_u</span></code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code class="docutils literal"><span class="pre">u_array</span></code>.</p>
<div class="admonition-be-careful-when-manipulating-degrees-of-freedom admonition">
<p class="first admonition-title">Be careful when manipulating degrees of freedom</p>
<p class="last">A call like <code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a <em>copy</em> of the data in
<code class="docutils literal"><span class="pre">u.vector()</span></code>. One must therefore never perform assignments like
<code class="docutils literal"><span class="pre">u.vector.array()[:]</span> <span class="pre">=</span> <span class="pre">...</span></code>, but instead extract the <code class="docutils literal"><span class="pre">numpy</span></code> array
(i.e., a copy), manipulate it, and insert it back with <code class="docutils literal"><span class="pre">u.vector()[:]</span>
<span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">``u.set_local(...)</span></code>.</p>
</div>
<p>All the code in this subsection can be found in the file <code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code>.</p>
</div>
<div class="section" id="parameterizing-the-number-of-space-dimensions">
<span id="tut-poisson-nd"></span><h3>Parameterizing the number of space dimensions<a class="headerlink" href="#parameterizing-the-number-of-space-dimensions" title="Permalink to this headline">¶</a></h3>
<p id="index-17">FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory programs <code class="docutils literal"><span class="pre">ft01_poisson_flat.py</span></code> or
<code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code> and change the
mesh construction from <code class="docutils literal"><span class="pre">UnitSquareMesh(6,</span> <span class="pre">4)</span></code> to <code class="docutils literal"><span class="pre">UnitCubeMesh(6,</span> <span class="pre">4,</span>
<span class="pre">5)</span></code>. Now the domain is the unit cube partitioned into <span class="math">\(6\times 4\times
5\)</span> boxes, and each box is divided into six tetrahedra-shaped
finite elements for computations.  Run the program and observe that we
can solve a 3D problem without any other modifications (!). The
visualization allows you to rotate the cube and observe the function
values as colors on the boundary.</p>
<div class="section" id="generating-a-hypercube">
<h4>Generating a hypercube<a class="headerlink" href="#generating-a-hypercube" title="Permalink to this headline">¶</a></h4>
<p>The syntax for generating a unit interval, square, or box is different,
so we need to encapsulate this part of the code. Given a list or
tuple with the divisions into cells in the various spatial direction,
the following function returns the mesh in a <span class="math">\(d\)</span>-dimensional problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">unit_hypercube</span><span class="p">(</span><span class="n">divisions</span><span class="p">,</span> <span class="n">degree</span><span class="p">):</span>
    <span class="n">mesh_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnitIntervalMesh</span><span class="p">,</span> <span class="n">UnitSquareMesh</span><span class="p">,</span> <span class="n">UnitCubeMesh</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_classes</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">V</span><span class="p">,</span> <span class="n">mesh</span>
</pre></div>
</div>
<p>The construction <code class="docutils literal"><span class="pre">mesh_class[d-1]</span></code> will pick the right name of the
object used to define the domain and generate the mesh.
Moreover, the argument <code class="docutils literal"><span class="pre">*divisions</span></code>
sends all the component of the list <code class="docutils literal"><span class="pre">divisions</span></code> as separate
arguments. For example, in a 2D problem where <code class="docutils literal"><span class="pre">divisions</span></code> has
two elements, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_classes</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Replacing the <code class="docutils literal"><span class="pre">Nx</span></code> and <code class="docutils literal"><span class="pre">Ny</span></code> parameters by <code class="docutils literal"><span class="pre">divisions</span></code> and calling
<code class="docutils literal"><span class="pre">unit_hypercube</span></code> to create the mesh are the two modifications that
we need in any of the previously shown <code class="docutils literal"><span class="pre">solver</span></code> functions to turn
them into solvers for <span class="math">\(d\)</span>-dimensional problems!</p>
</div>
</div>
<div class="section" id="computing-derivatives">
<span id="tut-poisson-gradu"></span><h3>Computing derivatives<a class="headerlink" href="#computing-derivatives" title="Permalink to this headline">¶</a></h3>
<p id="index-18">In Poisson and many other problems, the gradient of the solution is
of interest. The computation is in principle simple:
since
<span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>, we have that</p>
<div class="math">
\[\nabla u = \sum_{j=1}^N U_j \nabla \phi_j{\thinspace .}\]</div>
<p>Given the solution variable <code class="docutils literal"><span class="pre">u</span></code> in the program, its gradient is
obtained by <code class="docutils literal"><span class="pre">grad(u)</span></code> or <code class="docutils literal"><span class="pre">grad(u)</span></code>.  However, the gradient of a
piecewise continuous finite element scalar field is a discontinuous
vector field since the <span class="math">\(\phi_j\)</span> has discontinuous derivatives at the
boundaries of the cells. For example, using Lagrange elements of
degree 1, <span class="math">\(u\)</span> is linear over each cell, and the numerical <span class="math">\(\nabla u\)</span>
becomes a piecewise constant vector field. On the contrary, the exact
gradient is continuous.  For visualization and data analysis purposes
we often want the computed gradient to be a continuous vector
field. Typically, we want each component of <span class="math">\(\nabla u\)</span> to be
represented in the same way as <span class="math">\(u\)</span> itself. To this end, we can project
the components of <span class="math">\(\nabla u\)</span> onto the same function space as we used
for <span class="math">\(u\)</span>.  This means that we solve <span class="math">\(w = \nabla u\)</span> approximately by a
finite element method, using the same elements for the components of
<span class="math">\(w\)</span> as we used for <span class="math">\(u\)</span>. This process is known as <em>projection</em>.</p>
<span class="target" id="index-19"></span><p id="index-20">Not surprisingly, projection is a so common operation in finite
element programs that FEniCS has a function for doing the task:
<code class="docutils literal"><span class="pre">project(q,</span> <span class="pre">W)</span></code>, which returns the projection of some <code class="docutils literal"><span class="pre">Function</span></code> or
<code class="docutils literal"><span class="pre">Expression</span></code> object named <code class="docutils literal"><span class="pre">q</span></code> onto the <code class="docutils literal"><span class="pre">FunctionSpace</span></code> (if <code class="docutils literal"><span class="pre">q</span></code> is
scalar) or <code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> (if <code class="docutils literal"><span class="pre">q</span></code> is vector-valued) named <code class="docutils literal"><span class="pre">W</span></code>.
Specifically, in our case where <code class="docutils literal"><span class="pre">u</span></code> is computed and we want to project
the vector-valued <code class="docutils literal"><span class="pre">grad(u)</span></code> onto the <code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> where each
component has the same <code class="docutils literal"><span class="pre">Function</span></code> space as <code class="docutils literal"><span class="pre">u</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
<span class="n">degree</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

<span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-gradu"><span class="std std-ref">Example of visualizing the vector field  \( nabla u \)  by arrows at the nodes</span></a> shows
example of how such a smoothed <code class="docutils literal"><span class="pre">gradu(u)</span></code> vector field is visualized.</p>
<div class="figure" id="id6">
<span id="tut-poisson-2d-fig-ex1-gradu"></span><a class="reference internal image-reference" href="_images/ex1_gradu.png"><img alt="_images/ex1_gradu.png" src="_images/ex1_gradu.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Example of visualizing the vector field  \( nabla u \)  by arrows at the nodes</em></span></p>
</div>
<p>The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.</p>
<p>The scalar component fields of the gradient
can be extracted as separate fields and, e.g., visualized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">grad_u_y</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of grad(u)&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">deepcopy=True</span></code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code class="docutils literal"><span class="pre">deepcopy=False</span></code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)</p>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><p id="index-23">The <code class="docutils literal"><span class="pre">grad_u_x</span></code> and <code class="docutils literal"><span class="pre">grad_u_y</span></code> variables behave as
<code class="docutils literal"><span class="pre">Function</span></code> objects. In particular, we can extract the underlying
arrays of nodal values by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x_array</span> <span class="o">=</span> <span class="n">grad_u_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">grad_u_y_array</span> <span class="o">=</span> <span class="n">grad_u_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The degrees of freedom of the <code class="docutils literal"><span class="pre">grad_u</span></code> vector field can also be
reached by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_array</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>but this is a flat <code class="docutils literal"><span class="pre">numpy</span></code> array where the degrees of freedom for the
<span class="math">\(x\)</span> component of the gradient is stored in the first part, then the
degrees of freedom of the <span class="math">\(y\)</span> component, and so on. This is less convenient
to work with.</p>
<p id="index-24">The function <code class="docutils literal"><span class="pre">gradient(u)</span></code> in <code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code>
returns a projected (smoothed) <span class="math">\(\nabla u\)</span> vector field, given some
finite element function <code class="docutils literal"><span class="pre">u</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">V_g</span><span class="p">)</span>
    <span class="n">grad_u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;grad(u)&#39;</span><span class="p">,</span> <span class="s">&#39;continuous gradient field&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad_u</span>
</pre></div>
</div>
<p>Examining the arrays with vertex values of <code class="docutils literal"><span class="pre">grad_u_x</span></code> and <code class="docutils literal"><span class="pre">grad_u_y</span></code>
quickly reveals that the computed <code class="docutils literal"><span class="pre">grad_u</span></code> field does not equal the
exact gradient <span class="math">\((2x, 4y)\)</span> in this particular test problem where
<span class="math">\(u=1+x^2+2y^2\)</span>.  There are inaccuracies at the boundaries, arising
from the approximation problem for <span class="math">\(w\)</span>. Increasing the mesh resolution
shows, however, that the components of the gradient vary linearly as
<span class="math">\(2x\)</span> and <span class="math">\(4y\)</span> in the interior of the mesh (i.e., as soon as we are one
element away from the boundary).  The <code class="docutils literal"><span class="pre">application_test_gradient</span></code>
function in <code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code> performs some experiments.</p>
<div class="admonition-detour-manual-projection admonition">
<p class="first admonition-title">Detour: Manual projection</p>
<p>Although you will always use <code class="docutils literal"><span class="pre">project</span></code> to project a finite element
function, it can be constructive this point in the tutorial to formulate the
projection mathematically and implement its steps manually in FEniCS.</p>
<p>Looking at the component <span class="math">\(\partial u/\partial x\)</span> of the gradient, we
project the (discrete) derivative <span class="math">\(\sum_jU_j{\partial \phi_j/\partial
x}\)</span> onto a function space with basis <span class="math">\(\phi_1,\phi_2,\ldots\)</span> such that
the derivative in this space is expressed by the standard sum
<span class="math">\(\sum_j\bar U_j \phi_j\)</span>, for suitable (new) coefficients <span class="math">\(\bar U_j\)</span>.</p>
<p class="last">The variational problem for <span class="math">\(w\)</span> reads: find  <span class="math">\(w\in V^{(\mbox{g})}\)</span> such that</p>
</div>
<div class="math" id="eq-auto11">
\[ \tag{44}
 a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]\[where\]\[.. _Eq:_auto12:\]</div>
<div class="math">
\[ \tag{45}
 a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]\[.. _Eq:_auto13:\]</div>
<div class="math">
\[ \tag{46}
 L(v) = \int_\Omega \nabla u\cdot v {\, \mathrm{d}x}{\thinspace .}\]\[\begin{split}The function spaces  \( V^{(\mbox{g})} \)  and  \( \hat{V^{(\mbox{g})}} \)  (with the superscript g
denoting &quot;gradient&quot;) are vector versions of the function space for
 \( u \) , with boundary conditions removed (if  \( V \)  is the space we used for
 \( u \) , with no restrictions on boundary values, :math:`V^{(\mbox{g})} = \hat{V^{(\mbox{g})}} =
[V]^d`, where  \( d \)  is the number of space dimensions).  For example, if
we used piecewise linear functions on the mesh to approximate  \( u \) , the
variational problem for  \( w \)  corresponds to approximating each
component field of  \( w \)  by piecewise linear functions.\end{split}\]\[The variational problem for the vector field
 \( w \) , called ``grad_u`` in the code, is easy to solve in FEniCS:\]\[.. code-block:: python\]\[        V_g = VectorFunctionSpace(mesh, 'P', 1)
        w = TrialFunction(V_g)
        v = TestFunction(V_g)\]\[        a = dot(w, v)*dx
        L = dot(grad(u), v)*dx
        grad_u = Function(V_g)
        solve(a == L, grad_u)\]\[        plot(grad_u, title='grad(u)')\]\[The boundary condition argument to ``solve`` is dropped since there are
no essential boundary conditions in this problem.
The new thing is basically that we work with a ``VectorFunctionSpace``,
since the unknown is now a vector field, instead of the
``FunctionSpace`` object for scalar fields.\]</div>
</div>
<div class="section" id="a-variable-coefficient-poisson-problem">
<span id="tut-possion-2d-varcoeff"></span><h3>A variable-coefficient Poisson problem<a class="headerlink" href="#a-variable-coefficient-poisson-problem" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-25"></span><p id="index-26">Suppose we have a variable coefficient <span class="math">\(p(x,y)\)</span> in the Laplace operator,
as in the boundary-value problem</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff">
\[\begin{split}\tag{47}
- \nabla\cdot \left\lbrack
    p(x,y)\nabla u(x,y)\right\rbrack &amp;= f(x,y) \quad \mbox{in } \Omega,
        \\
        u(x,y) &amp;= u_0(x,y) \quad \mbox{on}\  \partial\Omega{\thinspace .}\end{split}\]</div>
<p>We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS program.</p>
<div class="section" id="test-problem-3">
<h4>Test problem<a class="headerlink" href="#test-problem-3" title="Permalink to this headline">¶</a></h4>
<p>Let us continue to use our favorite solution <span class="math">\(u(x,y)=1+x^2+2y^2\)</span> and
then prescribe <span class="math">\(p(x,y)=x+y\)</span>. It follows that
<span class="math">\(u_0(x,y) = 1 + x^2 + 2y^2\)</span> and <span class="math">\(f(x,y)=-8x-10y\)</span>.</p>
</div>
<div class="section" id="modifications-of-the-pde-solver">
<h4>Modifications of the PDE solver<a class="headerlink" href="#modifications-of-the-pde-solver" title="Permalink to this headline">¶</a></h4>
<p>What are the modifications we need to do in the previously shown codes
to incorporate the variable coefficient <span class="math">\(p\)</span>?
from the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a>?</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">solver</span></code> must take <code class="docutils literal"><span class="pre">p</span></code> as argument,</li>
<li><code class="docutils literal"><span class="pre">f</span></code> in our test problem
must be an <code class="docutils literal"><span class="pre">Expression</span></code> since it is no longer a constant,</li>
<li>a new <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">p</span></code> must be defined for the variable coefficient,</li>
<li>the formula for <span class="math">\(a(u,v)\)</span> in the variational problem is slightly changed.</li>
</ul>
</div></blockquote>
<p>First we address the modified variational problem. Multiplying
the PDE by a test function <span class="math">\(v\)</span> and
integrating by parts now results
in</p>
<div class="math">
\[\int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega} p{\partial u\over
\partial n}v {\, \mathrm{d}s} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The function spaces for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the same as in
the section <a class="reference internal" href="._ftut003.html#tut-poisson1-varform"><span class="std std-ref">Finite element variational formulation</span></a>, implying that the boundary integral
vanishes since <span class="math">\(v=0\)</span> on <span class="math">\(\partial\Omega\)</span> where we have Dirichlet conditions.
The weak form <span class="math">\(a(u,v)=L(v)\)</span> then has</p>
<div class="math" id="eq-auto14">
\[\tag{48}
a(u,v) = \int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto15">
\[\tag{49}
L(v) = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>In the code for solving <span class="math">\(-\nabla^2u=f\)</span> we must replace</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>to solve <span class="math">\(-\nabla\cdot(p\nabla u)=f\)</span>. Moreover,
the definitions of <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">f</span></code> in the test problem read</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No additional modifications are necessary. The file
<code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> (variable-coefficient Poisson problem in 2D)
is a copy of <code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code> with the mentioned changes
incorporated. Observe that <span class="math">\(p=1\)</span> recovers the original problem in
<code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code>.</p>
<p>You can run it and confirm
that it recovers the exact <span class="math">\(u\)</span> at the nodes.</p>
</div>
<div class="section" id="modifications-of-the-flux-computations">
<h4>Modifications of the flux computations<a class="headerlink" href="#modifications-of-the-flux-computations" title="Permalink to this headline">¶</a></h4>
<p>The flux <span class="math">\(-p\nabla u\)</span> may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>,
we normally want the piecewise discontinuous flux or gradient to be
approximated by a continuous vector field, using the same elements as
used for the numerical solution <span class="math">\(u\)</span>. The approximation now consists of
solving <span class="math">\(w = -p\nabla u\)</span> by a finite element method: find <span class="math">\(w\in V^{(\mbox{g})}\)</span>
such that</p>
<div class="math" id="eq-auto16">
\[\tag{50}
a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math" id="eq-auto17">
\[\tag{51}
a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto18">
\[\tag{52}
L(v) = \int_\Omega (-p \nabla u)\cdot v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>This problem is identical to the one in the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>,
except that <span class="math">\(p\)</span> enters the integral in <span class="math">\(L\)</span>.</p>
<p>The relevant Python statement for computing the flux field take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span>
               <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degreee</span><span class="p">))</span>
</pre></div>
</div>
<p>An appropriate function for computing the flux based on <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">p</span></code> is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return p*grad(u) projected onto same space as u.&quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="n">flux_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">V_g</span><span class="p">)</span>
    <span class="n">flux_u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;flux(u)&#39;</span><span class="p">,</span> <span class="s">&#39;continuous flux field&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flux_u</span>

<span class="k">def</span> <span class="nf">application_test_flux</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;solution&#39;</span><span class="p">)</span>
    <span class="n">flux_u</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="c"># Grab each component as a scalar field</span>
    <span class="n">flux_u_x</span><span class="p">,</span> <span class="n">flux_u_y</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">flux_u_x</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;flux(u)_x&#39;</span><span class="p">,</span> <span class="s">&#39;x-component of flux(u)&#39;</span><span class="p">)</span>
    <span class="n">flux_u_y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;flux(u)_y&#39;</span><span class="p">,</span> <span class="s">&#39;y-component of flux(u)&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">flux_u</span><span class="p">,</span>   <span class="n">title</span><span class="o">=</span><span class="n">flux_u</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">flux_u_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">flux_u_x</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">flux_u_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">flux_u_y</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>

    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">flux_x_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
    <span class="n">flux_y_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">y</span>

    <span class="n">coor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="c"># Quite large errors for coarse meshes, but the error</span>
        <span class="c"># decreases with increasing resolution</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flux_u_x</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%d</span><span class="s">, </span><span class="si">%s</span><span class="s">, -p*u_x=</span><span class="si">%g</span><span class="s">, error=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">value</span><span class="p">,</span>
                   <span class="n">flux_x_exact</span><span class="p">(</span><span class="o">*</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flux_u_y</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%d</span><span class="s">, </span><span class="si">%s</span><span class="s">, -p*u_y=</span><span class="si">%g</span><span class="s">, error=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">value</span><span class="p">,</span>
                   <span class="n">flux_y_exact</span><span class="p">(</span><span class="o">*</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Compute integrated L2 error of the flux components</span>
        <span class="c"># (Will this work for unstructured mesh? Need to think about that)</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yv</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span class="sd">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span class="c"># Compute error norm (for very small errors, the value can be</span>
    <span class="c"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="c"># Function - Expression</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_e onto the same space as u:</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span class="c"># u will also be interpolated to the space Ve before integration</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># fenics.errornorm interpolates u and u_e to a space with</span>
    <span class="c"># given degree, and creates the error field by subtracting</span>
    <span class="c"># the degrees of freedom, then the error field is integrated</span>
    <span class="c"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span class="c">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span class="c"># Manual implementation errornorm to get around the bug:</span>
    <span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
        <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
        <span class="c"># Subtract degrees of freedom for the error field</span>
        <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="c"># More efficient computation (avoids the rhs array result above)</span>
        <span class="c">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span class="c">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">Ve</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))),</span> <span class="n">e_Ve</span>
    <span class="n">E4</span><span class="p">,</span> <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>

    <span class="c"># Infinity norm based on nodal values</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">E5</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c"># H1 seminorm</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E6</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Collect error measures in a dictionary with self-explanatory keys</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">:</span> <span class="n">E1</span><span class="p">,</span>
              <span class="s">&#39;u - interpolate(u_exact,V)&#39;</span><span class="p">:</span> <span class="n">E2</span><span class="p">,</span>
              <span class="s">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span><span class="p">:</span> <span class="n">E3</span><span class="p">,</span>
              <span class="s">&#39;errornorm&#39;</span><span class="p">:</span> <span class="n">E4</span><span class="p">,</span>
              <span class="s">&#39;infinity norm (of dofs)&#39;</span><span class="p">:</span> <span class="n">E5</span><span class="p">,</span>
              <span class="s">&#39;grad(error) H1 seminorm&#39;</span><span class="p">:</span> <span class="n">E6</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">errors</span>

<span class="k">def</span> <span class="nf">convergence_rate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute convergence rates for various error norms for a</span>
<span class="sd">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span class="sd">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span class="sd">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Discretization parameter, h[degree][experiment]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Error measure(s), E[degree][experiment][error_type]</span>
    <span class="n">P_degrees</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">num_meshes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c"># Perform experiments with meshes and element types</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c"># Coarsest mesh division</span>
        <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                       <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;2*(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) P</span><span class="si">%d</span><span class="s"> mesh, </span><span class="si">%d</span><span class="s"> unknowns, E1=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
                   <span class="n">errors</span><span class="p">[</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">]))</span>
    <span class="c"># Convergence rates</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># log is a fenics name too</span>
    <span class="n">error_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">error_types</span><span class="p">):</span>
            <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
                <span class="n">Ei</span>   <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">Eim1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">Ei</span><span class="o">/</span><span class="n">Eim1</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rates</span>

<span class="k">def</span> <span class="nf">convergence_rate_sin</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute convergence rates for u=sin(x)*sin(y) solution.&quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                         <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_exact</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Note: P4 for n&gt;=128 seems to break down</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                              <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
    <span class="c"># Print rates</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="n">error_types</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error_type</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;P</span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">divisions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span class="c"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
         <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">BoxField</span> <span class="kn">import</span> <span class="n">fenics_function2BoxField</span>
    <span class="n">u_box</span> <span class="o">=</span> <span class="n">fenics_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">divisions</span><span class="p">,</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_box</span>

<span class="k">def</span> <span class="nf">application_structured_mesh</span><span class="p">(</span><span class="n">model_problem</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">model_problem</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># Numerical solution is exact</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
        <span class="n">flux_u_x_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>  <span class="n">ny</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">elif</span> <span class="n">model_problem</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c"># Mexican hat solution</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>  <span class="c"># for use in math formulas</span>
        <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
        <span class="n">H</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0], x[1]&#39;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">H</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">u_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="c"># &#39;-exp(-16*pow(x - 0.5, 2) - 16*pow(y - 0.5, 2))*&#39;</span>
        <span class="c"># &#39;sin(3*M_PI*x)*sin(3*M_PI*y)&#39;</span>
        <span class="n">u_c</span> <span class="o">=</span> <span class="n">u_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;DOLFIN_PI&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;u in C:&#39;</span><span class="p">,</span> <span class="n">u_c</span><span class="p">)</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_c</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Don&#39;t use Constant(1) here (!)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f_c</span> <span class="o">=</span> <span class="n">f_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;DOLFIN_PI&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_c</span><span class="p">)</span>
        <span class="n">flux_u_x_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                                      <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;f in C:&#39;</span><span class="p">,</span> <span class="n">f_c</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>  <span class="n">ny</span> <span class="o">=</span> <span class="mi">22</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">u_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
    <span class="n">u_</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span>  <span class="c"># numpy array</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>      <span class="c"># for indexing in x and y direction</span>

    <span class="c"># Iterate over 2D mesh points (i,j)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_ is defined on a structured mesh with </span><span class="si">%s</span><span class="s"> points&#39;</span>
          <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;u[</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">]=u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                       <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>

    <span class="c"># Make surface plot</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">cv</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span>  <span class="c"># vectorized mesh coordinates</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span>
                    <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Surface plot of solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp0.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp0.pdf&#39;</span><span class="p">)</span>

    <span class="c"># Make contour plot</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>  <span class="c"># 7 levels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>  <span class="c"># add labels to contour lines</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Contour plot of solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>

    <span class="c"># Plot u along a line y=const and compare with exact solution</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
    <span class="n">u_e_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">u0</span><span class="p">((</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">))</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e_val</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.pdf&#39;</span><span class="p">)</span>

    <span class="n">flux_u</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">flux_u_x</span><span class="p">,</span> <span class="n">flux_u_y</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># Plot the numerical and exact flux along the same line</span>
    <span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_u_x</span> <span class="k">if</span> <span class="n">flux_u_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> \
              <span class="k">else</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span>
                   <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span>
                                 <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">flux_u_x_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">flux_u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
       <span class="n">flux_u_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_x_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">),</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Flux along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp3.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp3.pdf&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solver_linalg</span><span class="p">(</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="n">assembly</span><span class="o">=</span><span class="s">&#39;variational&#39;</span><span class="p">,</span> <span class="c"># or &#39;matvec&#39; or &#39;system&#39;</span>
    <span class="n">start_vector</span><span class="o">=</span><span class="s">&#39;zero&#39;</span><span class="p">,</span>    <span class="c"># or &#39;random&#39;</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -div(p*grad(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and u=u0 (Expresssion) on</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">initial_guess</span> <span class="o">==</span> <span class="s">&#39;random&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># for testing</span>
        <span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">assembly</span> <span class="o">==</span> <span class="s">&#39;variational&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
            <span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
            <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
            <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
            <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
            <span class="n">prm</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
            <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                                 <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

        <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Cannot return cofficient matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">assembly</span> <span class="o">==</span> <span class="s">&#39;matvec&#39;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
            <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;direct&#39;</span><span class="p">:</span>
                <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;gmres&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
                <span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">assembly</span> <span class="o">==</span> <span class="s">&#39;system&#39;</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="p">[</span><span class="n">bc</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;direct&#39;</span><span class="p">:</span>
                <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
                <span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
                <span class="n">prm</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span>

<span class="k">def</span> <span class="nf">application_linalg</span><span class="p">():</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">assembly</span> <span class="ow">in</span> <span class="s">&#39;variational&#39;</span><span class="p">,</span> <span class="s">&#39;matvec&#39;</span><span class="p">,</span> <span class="s">&#39;system&#39;</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;--- </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh, </span><span class="si">%s</span><span class="s"> assembly ---&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">assembly</span><span class="p">))</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">solver_linalg</span><span class="p">(</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span>
                <span class="n">assembly</span><span class="o">=</span><span class="n">assembly</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;A: </span><span class="si">%s</span><span class="s"> assembly</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">assembly</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">solver_bc</span><span class="p">(</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>                   <span class="c"># Coefficients in the PDE</span>
    <span class="n">boundary_conditions</span><span class="p">,</span>    <span class="c"># Dict of boundary conditions</span>
    <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>                 <span class="c"># Cell division of the domain</span>
    <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c"># Polynomial degree</span>
    <span class="n">subdomains</span><span class="o">=</span><span class="p">[],</span>          <span class="c"># List of SubDomain objects in domain</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve -div(p*grad(u)=f on [0,1]x[0,1] with 2*Nx*Ny Lagrange</span>
<span class="sd">    elements of specified degree and Dirichlet, Neumann, or Robin</span>
<span class="sd">    conditions on the boundary. Piecewise constant p over subdomains</span>
<span class="sd">    are also allowed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

    <span class="c"># Subdomains in the domain?</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="k">if</span> <span class="n">subdomains</span><span class="p">:</span>
        <span class="c"># subdomains is list of SubDomain objects,</span>
        <span class="c"># p is array of corresponding constant values of p</span>
        <span class="c"># in each subdomain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&#39;p must be array if we have sudomains, not </span><span class="si">%s</span><span class="s">&#39;</span>
                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
        <span class="n">materials</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># &quot;the rest&quot;</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">subdomain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subdomains</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">subdomain</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="n">p_values</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
        <span class="n">help</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">p_values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&#39;p is type </span><span class="si">%s</span><span class="s">, must be Expression or Constant&#39;</span>
                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="c"># Boundary subdomains</span>
    <span class="k">class</span> <span class="nc">BoundaryX0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="k">class</span> <span class="nc">BoundaryX1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="k">class</span> <span class="nc">BoundaryY0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="k">class</span> <span class="nc">BoundaryY1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="c"># Mark boundaries</span>
    <span class="n">boundary_parts</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
    <span class="n">boundary_parts</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">9999</span><span class="p">)</span>
    <span class="n">bx0</span> <span class="o">=</span> <span class="n">BoundaryX0</span><span class="p">()</span>
    <span class="n">bx1</span> <span class="o">=</span> <span class="n">BoundaryX1</span><span class="p">()</span>
    <span class="n">by0</span> <span class="o">=</span> <span class="n">BoundaryY0</span><span class="p">()</span>
    <span class="n">by1</span> <span class="o">=</span> <span class="n">BoundaryY1</span><span class="p">()</span>
    <span class="n">bx0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bx1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">by0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">by1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="c"># boundary_parts.array() is a numpy array</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundary_parts</span><span class="p">)</span>

    <span class="c"># boundary_conditions is a dict of dicts:</span>
    <span class="c"># {0: {&#39;Dirichlet&#39;: u0},</span>
    <span class="c">#  1: {&#39;Robin&#39;: (r, s)},</span>
    <span class="c">#  2: {&#39;Neumann: g}},</span>
    <span class="c">#  3: {&#39;Neumann&#39;, 0}}</span>

    <span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># List of Dirichlet conditions</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;Dirichlet&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">],</span>
                            <span class="n">boundary_parts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c"># Print the vertices that are on the boundaries</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bx0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bx1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">by0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">by1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>


        <span class="c"># Print the Dirichlet conditions</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;No of Dirichlet conditions:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcs</span><span class="p">))</span>
        <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
            <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;   at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>

    <span class="c"># Collect Neumann integrals</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">Neumann_integrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;Neumann&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span>
                <span class="n">Neumann_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="c"># Collect Robin integrals</span>
    <span class="n">Robin_a_integrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Robin_L_integrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
            <span class="n">Robin_a_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="n">Robin_L_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="c"># Simpler Robin integrals</span>
    <span class="n">Robin_integrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
            <span class="n">Robin_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="c"># Define variational problem, solver_bc</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
        <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_a_integrals</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_L_integrals</span><span class="p">)</span>

    <span class="c"># Simpler variational formulation</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
        <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_integrals</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_tol</span>
        <span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="k">print</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">])</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump_parameters</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span>  <span class="c"># Note: p may be modified (Function on V0)</span>

<span class="k">def</span> <span class="nf">application_bc_test</span><span class="p">():</span>
    <span class="c"># Define manufactured solution in sympy and derive f, g, etc.</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>  <span class="c"># UFL needs x[0] for x etc.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># -Laplace(u)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># x=0 boundary</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary, du/dn=-du/dy</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c"># any function can go here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Turn to C/C++ code for UFL expressions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Test problem (C/C++):</span><span class="se">\n</span><span class="s">u = </span><span class="si">%s</span><span class="se">\n</span><span class="s">f = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_00: </span><span class="si">%s</span><span class="se">\n</span><span class="s">u_01: </span><span class="si">%s</span><span class="se">\n</span><span class="s">g = </span><span class="si">%s</span><span class="se">\n</span><span class="s">r = </span><span class="si">%s</span><span class="se">\n</span><span class="s">s = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

    <span class="c"># Turn into FEniCS objects</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>   <span class="c"># x=0</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>   <span class="c"># x=1</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Robin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span>     <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">}}</span>        <span class="c"># y=1</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="o">*</span><span class="n">Ny</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">,</span>  <span class="c"># for small problems only</span>
        <span class="p">)</span>

    <span class="c"># Compute max error in infinity norm</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                       <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>

    <span class="c"># Print numerical and exact solution at the vertices</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>  <span class="c"># (small problems only)</span>
        <span class="n">u_e_at_vertices</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%2d</span><span class="s"> (</span><span class="si">%9g</span><span class="s">,</span><span class="si">%9g</span><span class="s">): error=</span><span class="si">%g</span><span class="s"> </span><span class="si">%g</span><span class="s"> vs </span><span class="si">%g</span><span class="s">&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">test_solvers_bc</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Reproduce u=1+x^2+2y^2 to with different solvers.&quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">3E-12</span>  <span class="c"># Appropriate tolerance for these tests (P2, 20x20 mesh)</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># x=0 boundary</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c"># arbitrary function can go here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Turn to C/C++ code for UFL expressions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Test problem (C/C++):</span><span class="se">\n</span><span class="s">u = </span><span class="si">%s</span><span class="se">\n</span><span class="s">f = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_00: </span><span class="si">%s</span><span class="se">\n</span><span class="s">u_01: </span><span class="si">%s</span><span class="se">\n</span><span class="s">g = </span><span class="si">%s</span><span class="se">\n</span><span class="s">r = </span><span class="si">%s</span><span class="se">\n</span><span class="s">s = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

    <span class="c"># Turn into FEniCS objects</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Robin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">}}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">linear_solver</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;direct&#39;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;solving on 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">x) mesh with P</span><span class="si">%d</span><span class="s"> elements&#39;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">)),</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39; </span><span class="si">%s</span><span class="s"> solver, </span><span class="si">%s</span><span class="s"> function&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">linear_solver</span><span class="p">,</span> <span class="n">solver_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
                    <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                <span class="n">linear_solver</span><span class="o">=</span><span class="n">linear_solver</span><span class="p">,</span>
                    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
                    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>
                <span class="c"># Make a finite element function of the exact u0</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
                <span class="n">u_e_Function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># exact solution</span>
                <span class="c"># Check that dof arrays are equal</span>
                <span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e_Function</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>  <span class="c"># dof values</span>
                <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s"> for 2(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) mesh, degree=</span><span class="si">%d</span><span class="s">,&#39;</span>\
                      <span class="s">&#39; </span><span class="si">%s</span><span class="s"> solver, </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                      <span class="p">(</span><span class="n">max_error</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">linear_solver</span><span class="p">,</span>
                       <span class="n">solver_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>

<span class="k">def</span> <span class="nf">application_bc_test_2mat</span><span class="p">():</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>

    <span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span>

    <span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">-</span><span class="n">tol</span>

    <span class="n">subdomains</span> <span class="o">=</span> <span class="p">[</span><span class="n">Omega0</span><span class="p">(),</span> <span class="n">Omega1</span><span class="p">()]</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">]</span>

    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span class="s">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span><span class="p">,</span>
        <span class="n">p_0</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_1</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="c"># y=1</span>
        <span class="p">}</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
        <span class="n">p_values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="o">*</span><span class="n">Ny</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">,</span>  <span class="c"># for small problems only</span>
        <span class="p">)</span>

    <span class="c"># Compute max error in infinity norm</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                       <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>

    <span class="c"># Print numerical and exact solution at the vertices</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>  <span class="c"># (small problems only)</span>
        <span class="n">u_e_at_vertices</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%2d</span><span class="s"> (</span><span class="si">%9g</span><span class="s">,</span><span class="si">%9g</span><span class="s">): error=</span><span class="si">%g</span><span class="s"> </span><span class="si">%g</span><span class="s"> vs </span><span class="si">%g</span><span class="s">&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">test_solvers_bc_2mat</span><span class="p">():</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">2E-13</span>  <span class="c"># Tolerance for comparisons</span>

    <span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span>

    <span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">-</span><span class="n">tol</span>

    <span class="n">subdomains</span> <span class="o">=</span> <span class="p">[</span><span class="n">Omega0</span><span class="p">(),</span> <span class="n">Omega1</span><span class="p">()]</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">]</span>
    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="c"># y=1</span>
        <span class="p">}</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span class="s">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span><span class="p">,</span>
        <span class="n">p_0</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_1</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
                <span class="n">p_values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">,</span>
                <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="c"># Compute max error in infinity norm</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                           <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">max_error</span>

<span class="k">def</span> <span class="nf">application_flow_around_circle</span><span class="p">(</span><span class="n">obstacle</span><span class="o">=</span><span class="s">&#39;rectangle&#39;</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>

    <span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">class</span> <span class="nc">Rectangle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.3</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.7</span> <span class="ow">and</span> <span class="mf">0.3</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.7</span>

    <span class="n">obstacle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">()</span> <span class="k">if</span> <span class="n">obstacle</span> <span class="o">==</span> <span class="s">&#39;circle&#39;</span> <span class="k">else</span> <span class="n">Rectangle</span><span class="p">()</span>
    <span class="n">subdomains</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="n">obstacle</span><span class="p">]</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1E-4</span><span class="p">]</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="c"># y=1</span>
        <span class="p">}</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
        <span class="n">p_values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;porous_media_flow.pvd&#39;</span><span class="p">)</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">v</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c">#application_test()</span>
    <span class="c">#application_test_flux(Nx=20, Ny=20)</span>
    <span class="c">#convergence_rate()</span>
    <span class="c">#application_structured_mesh(2)</span>
    <span class="c">#application_linalg()</span>
    <span class="c">#application_bc_test_2mat()</span>
    <span class="n">application_flow_around_circle</span><span class="p">()</span>
    <span class="c">#test_solvers_bc()</span>
    <span class="c"># Hold plot</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Plotting the flux vector field is naturally as easy as plotting
the gradient (see the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;flux field&#39;</span><span class="p">)</span>

<span class="n">flux_x</span><span class="p">,</span> <span class="n">flux_y</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For data analysis of the nodal values of the flux field we can
grab the underlying <code class="docutils literal"><span class="pre">numpy</span></code> arrays (demands a <code class="docutils literal"><span class="pre">deepcopy=True</span></code>
in the split of <code class="docutils literal"><span class="pre">flux</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_x_array</span> <span class="o">=</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">flux_y_array</span> <span class="o">=</span> <span class="n">flux_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">application_test_flux</span></code> in the
program <code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> demonstrates the computations described
above.</p>
</div>
</div>
<div class="section" id="creating-the-linear-system-explicitly">
<span id="tut-poisson1-linalg"></span><h3>Creating the linear system explicitly<a class="headerlink" href="#creating-the-linear-system-explicitly" title="Permalink to this headline">¶</a></h3>
<p>Given <span class="math">\(a(u,v)=L(v)\)</span>, the discrete solution <span class="math">\(u\)</span> is computed by
inserting <span class="math">\(u=\sum_{j=1}^N U_j \phi_j\)</span> into <span class="math">\(a(u,v)\)</span> and demanding
<span class="math">\(a(u,v)=L(v)\)</span> to be fulfilled for <span class="math">\(N\)</span> test functions
<span class="math">\(\hat\phi_1,\ldots,\hat\phi_N\)</span>. This implies</p>
<div class="math">
\[\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,\]</div>
<p>which is nothing but a linear system,</p>
<div class="math">
\[AU = b,\]</div>
<p>where the entries in <span class="math">\(A\)</span> and <span class="math">\(b\)</span> are given by</p>
<div class="math">
\[\begin{split}A_{ij} &amp;= a(\phi_j, \hat{\phi}_i), \\
b_i &amp;= L(\hat\phi_i){\thinspace .}\end{split}\]</div>
<span class="target" id="index-27"></span><span class="target" id="index-28"></span><p id="index-29">The examples so far have specified the left- and right-hand side of
the variational formulation and then asked FEniCS to assemble the
linear system and solve it.  An alternative is to explicitly call
functions for assembling the coefficient matrix <span class="math">\(A\)</span> and the right-side
vector <span class="math">\(b\)</span>, and then solve the linear system <span class="math">\(AU=b\)</span> with respect to
the <span class="math">\(U\)</span> vector.  Instead of <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">b)</span></code> we now write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> are as before. That is, <code class="docutils literal"><span class="pre">a</span></code> refers to the
bilinear form involving a <code class="docutils literal"><span class="pre">TrialFunction</span></code> object (e.g., <code class="docutils literal"><span class="pre">u</span></code>)
and a <code class="docutils literal"><span class="pre">TestFunction</span></code> object (<code class="docutils literal"><span class="pre">v</span></code>), and <code class="docutils literal"><span class="pre">L</span></code> involves a
<code class="docutils literal"><span class="pre">TestFunction</span></code> object (<code class="docutils literal"><span class="pre">v</span></code>). From <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code>,
the <code class="docutils literal"><span class="pre">assemble</span></code> function can
compute <span class="math">\(A\)</span> and <span class="math">\(b\)</span>.</p>
<p>The matrix <span class="math">\(A\)</span> and vector <span class="math">\(b\)</span> are first assembled without incorporating
essential (Dirichlet) boundary conditions. Thereafter, the
call <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> performs the necessary modifications of
the linear system such that <code class="docutils literal"><span class="pre">u</span></code> is guaranteed to equal the prescribed
boundary values.
When we have multiple Dirichlet conditions stored in a list <code class="docutils literal"><span class="pre">bcs</span></code>,
as explained in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>, we must apply
each condition in <code class="docutils literal"><span class="pre">bcs</span></code> to the system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># bcs is a list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-30">There is an alternative function <code class="docutils literal"><span class="pre">assemble_system</span></code>, which can
assemble the system and take boundary conditions into account in one call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble_system</span></code> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.
The conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.</p>
<p>With <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> the
matrix <code class="docutils literal"><span class="pre">A</span></code> is modified in an nonsymmetric way.</p>
<p>Note that the solution <code class="docutils literal"><span class="pre">u</span></code> is, as before, a <code class="docutils literal"><span class="pre">Function</span></code> object.
The degrees of freedom, <span class="math">\(U=A^{-1}b\)</span>, are filled
into <code class="docutils literal"><span class="pre">u</span></code>&#8216;s <code class="docutils literal"><span class="pre">Vector</span></code> object (<code class="docutils literal"><span class="pre">u.vector()</span></code>)
by the <code class="docutils literal"><span class="pre">solve</span></code> function.</p>
<p>The object <code class="docutils literal"><span class="pre">A</span></code> is of type <code class="docutils literal"><span class="pre">Matrix</span></code>, while <code class="docutils literal"><span class="pre">b</span></code> and
<code class="docutils literal"><span class="pre">u.vector()</span></code> are of type <code class="docutils literal"><span class="pre">Vector</span></code>. We may convert the
matrix and vector data to <code class="docutils literal"><span class="pre">numpy</span></code> arrays by calling the
<code class="docutils literal"><span class="pre">array()</span></code> method as shown before. If you wonder how essential
boundary conditions are incorporated in the linear system, you can
print out <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> before and after the
<code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>  <span class="c"># print for small meshes only</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
</pre></div>
</div>
<p>With access to the elements in <code class="docutils literal"><span class="pre">A</span></code> through a <code class="docutils literal"><span class="pre">numpy</span></code> array we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code class="docutils literal"><span class="pre">eig</span></code> function in <code class="docutils literal"><span class="pre">numpy.linalg</span></code>). We can alternatively dump
<code class="docutils literal"><span class="pre">A.array()</span></code> and <code class="docutils literal"><span class="pre">b.array()</span></code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s">&#39;Ab.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()})</span>
</pre></div>
</div>
<p>Writing <code class="docutils literal"><span class="pre">load</span> <span class="pre">Ab.mat</span></code> in MATLAB or Octave will then make
the array variables <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> available for computations.</p>
<p id="index-31">Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code class="docutils literal"><span class="pre">numpy</span></code> arrays or matrices in MATLAB
file format are dense matrices. FEniCS also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <code class="docutils literal"><span class="pre">demo/la/eigenvalue</span></code> in the FEniCS source code tree
for a demo).</p>
<p>By default, <code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> applies sparse LU decomposition
as solver. Specification of an iterative solver and preconditioner
is done through two optional arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Appropriate names of solvers and preconditioners are found in
the section <a class="reference internal" href="._ftut007.html#tut-app-solver-prec"><span class="std std-ref">Linear solvers and preconditioners</span></a>.</p>
<p id="index-32">To control tolerances in the stopping criterion and the maximum
number of iterations, one can explicitly form a <code class="docutils literal"><span class="pre">KrylovSolver</span></code> object
and set items in its <code class="docutils literal"><span class="pre">parameters</span></code> attribute
(see also the section <a class="reference internal" href="#tut-poisson1-solver-problem"><span class="std std-ref">Linear variational problem and solver objects</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">solver_linalg</span></code> in the
program file <code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> implements a solver function where
the user can choose between different types of assembly: the variational
(<code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code>), assembling the matrix and right-hand side separately, and assembling the system such that the coefficient matrix preserves
symmetry.
The function <code class="docutils literal"><span class="pre">application_linalg</span></code> runs a test problem on sequence of
meshes and solves the problem with symmetric and non-symmetric modification
of the coefficient matrix. One can monitor the number of Krylov
method iteration and realize that with a symmetric coefficient matrix,
the Conjugate Gradient method requires slightly fewer iterations than
GMRES in the non-symmetric case. Taking into account that the Conjugate
Gradient method has less work per iteration, there is some efficiency to
be gained by using <code class="docutils literal"><span class="pre">assemble_system</span></code>.</p>
<p>[<strong>hpl 12</strong>: Running <code class="docutils literal"><span class="pre">application_linalg</span></code>, the results are strange: Why does the <code class="docutils literal"><span class="pre">solve(a==L,...)</span></code> method need many more iterations than <code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b,</span> <span class="pre">...)</span></code> when we use the same Krylov parameter settings? Something wrong with the settings?]</p>
<p id="index-33">The choice of start vector for the iterations in a linear solver is often
important. With the <code class="docutils literal"><span class="pre">solver.solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> call the default start vector
is the zero vector. A start vector
with random numbers in the interval <span class="math">\([-100,100]\)</span> can be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we must turn off the default behavior of setting the start
vector (&#8220;initial guess&#8221;) to zero, and then the provided value of <code class="docutils literal"><span class="pre">U</span></code>
is used as start vector.</p>
<p>Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, <span class="math">\(A\)</span> may
be constant throughout a time-dependent simulation, so we can avoid
recalculating <span class="math">\(A\)</span> at every time level and save a significant amount
of simulation time.  The sections <a class="reference internal" href="._ftut003.html#tut-timedep-diffusion1-impl"><span class="std std-ref">A simple implementation</span></a>
and <a class="reference internal" href="._ftut005.html#tut-timedep-diffusion1-noassemble"><span class="std std-ref">Avoiding all assembly</span></a> deal with this topic
in detail.</p>
</div>
</div>
<div class="section" id="visualization-2">
<h2>Visualization<a class="headerlink" href="#visualization-2" title="Permalink to this headline">¶</a></h2>
<p>Perhaps you are not particularly amazed by viewing the simple surface
of <span class="math">\(u\)</span> in the test problem used in the previous sections.  However,
solving a real physical problem with a more interesting and amazing
solution on the screen is only a matter of specifying a more exciting
domain, boundary condition, and/or right-hand side <span class="math">\(f\)</span>.  The present
chapter starts with the solver for a membrane deflection, where the
geometry is a circle instead of the unit square, and where the
involved functions have more exciting shapes. We then go on with
explaining how the membrane deflection and the pressure load can be
visualized, using both the built-in FEniCS visualization tool and the
powerful application ParaView. Finally, we return to box-shaped
domains with uniform partition and show how the unstructured data in
FEniCS finite element solvers can be transformed to structured mesh
representations like those commonly used for finite difference
methods. The structured mesh representation, whenever possible,
gives greater flexibility
with respect to visualization and data analysis.</p>
<div class="section" id="deflection-of-a-circular-membrane">
<span id="tut-poisson-membrane"></span><h3>Deflection of a circular membrane<a class="headerlink" href="#deflection-of-a-circular-membrane" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-problem">
<h4>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h4>
<p>One possible physical problem regards the deflection <span class="math">\(D(x,y)\)</span> of an
elastic circular membrane with radius <span class="math">\(R\)</span>, subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is</p>
<div class="math" id="eq-auto19">
\[\tag{53}
-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},\]</div>
<p>with</p>
<div class="math" id="eq-auto20">
\[\tag{54}
p(x,y) = {A\over 2\pi\sigma}\exp{\left(
    - {1\over2}\left( {x-x_0\over\sigma}\right)^2
    - {1\over2}\left( {y-y_0\over\sigma}\right)^2
    \right)}\, .\]</div>
<p>Here, <span class="math">\(T\)</span> is the tension in the membrane (constant), <span class="math">\(p\)</span> is the external
pressure load,
<span class="math">\(A\)</span> the amplitude of the pressure, <span class="math">\((x_0,y_0)\)</span> the localization of
the Gaussian pressure function, and <span class="math">\(\sigma\)</span> the &#8220;width&#8221; of this
function. The boundary of the membrane has no
deflection, implying <span class="math">\(D=0\)</span> as boundary condition.</p>
</div>
<div class="section" id="scaling">
<h4>Scaling<a class="headerlink" href="#scaling" title="Permalink to this headline">¶</a></h4>
<p>The localization of the pressure, <span class="math">\((x_0,y_0)\)</span>, is for simplicity
set to <span class="math">\((0, R_0)\)</span>.
There are many physical parameters in this problem, and we can benefit
from grouping them by means of scaling. Let us introduce dimensionless
coordinates <span class="math">\(\bar x = x/R\)</span>, <span class="math">\(\bar y = y/R\)</span>, and a dimensionless
deflection <span class="math">\(w=D/D_c\)</span>, where <span class="math">\(D_c\)</span> is a characteristic size of the
deflection. Introducing <span class="math">\(\bar R_0=R_0/R\)</span>, we get</p>
<div class="math">
\[\begin{split}\frac{\partial^2 w}{\partial\bar x^2} +
\frac{\partial^2 w}{\partial\bar y^2}= \alpha
\exp{\left(
- \beta^2(\bar x^2
+ (\bar y-\bar R_0)^2)\right)}\hbox{ for } \bar x^2 + \bar y^2 &lt; 1,\end{split}\]</div>
<p>where</p>
<div class="math">
\[\alpha = \frac{R^2A}{2\pi T D_c\sigma},\quad\beta = \frac{R}{\sqrt{2}\sigma}{\thinspace .}\]</div>
<p>With an appropriate scaling, <span class="math">\(\bar w\)</span> and its derivatives are of size
unity, so the left-hand side of the scaled PDE is about unity in size,
while the right-hand side has <span class="math">\(\alpha\)</span> as its characteristic size.
This suggest choosing <span class="math">\(\alpha\)</span> to be unity, or around unit.  We shall
in particular choose <span class="math">\(\alpha=4\)</span>. With this value, the solution is
<span class="math">\(w(\bar x,\bar y) = 1-\bar x^2 - \bar y^2\)</span>.  (One can also find the
analytical solution in scaled coordinates and show that the maximum
deflection <span class="math">\(D(0,0)\)</span> is <span class="math">\(D_c\)</span> if we choose <span class="math">\(\alpha=4\)</span> to determine
<span class="math">\(D_c\)</span>.)  With <span class="math">\(D_c=AR^2/(8\pi\sigma T)\)</span> and dropping the bars we get
the scaled problem</p>
<div class="math" id="eq-tut-poisson1-membrane-scaled-eq">
\[\tag{55}
\nabla^2w = 4\exp{\left(
    - \beta^2(x^2
    + (y-R_0)^2)\right)},\]</div>
<p>to be solved over the unit circle with <span class="math">\(w=0\)</span> on the boundary.  Now
there are only two parameters to vary: the dimensionless extent of the
pressure, <span class="math">\(\beta\)</span>, and the localization of the pressure peak, <span class="math">\(R_0\in
[0,1]\)</span>.  As <span class="math">\(\beta\rightarrow 0\)</span>, we have a special case with solution
<span class="math">\(w=1-x^2-y^2\)</span>.</p>
<p>Given a computed <span class="math">\(w\)</span>, the physical deflection is given by</p>
<div class="math">
\[D = \frac{AR^2}{8\pi\sigma T}w{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-1">
<h4>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h4>
<p>Very few modifications of the software in <code class="docutils literal"><span class="pre">ft05_poisson_iter.py</span></code> are
required. Actually, the <code class="docutils literal"><span class="pre">solver</span></code> function can be reused, except that
the domain is now a circle and not a square. We change the <code class="docutils literal"><span class="pre">solver</span></code>
function by letting the mesh be an argument <code class="docutils literal"><span class="pre">mesh</span></code> (instead of <code class="docutils literal"><span class="pre">Nx</span></code>
and <code class="docutils literal"><span class="pre">Ny</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="o">...</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The final program is found in the file <code class="docutils literal"><span class="pre">ft07_poisson_membrane.py</span></code>.  The
key function to simulate membrane deflection is named <code class="docutils literal"><span class="pre">application</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">):</span>
    <span class="c"># Scaled pressure function</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))&#39;</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="n">R0</span><span class="p">)</span>

    <span class="c"># Generate mesh over the unit circle</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">num_elements_radial_dir</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># set name and label (description)</span>

    <span class="c"># Plot scaled solution, mesh and pressure</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled &#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>

    <span class="c"># Dump p and w to file in VTK format</span>
    <span class="n">vtkfile1</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;membrane_displacement.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile1</span> <span class="o">&lt;&lt;</span> <span class="n">w</span>
    <span class="n">vtkfile2</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;membrane_load.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile2</span> <span class="o">&lt;&lt;</span> <span class="n">p</span>
</pre></div>
</div>
<div class="admonition-tip-clean-up-compilation-files admonition">
<p class="first admonition-title">Tip: Clean up compilation files</p>
<p>Running FEniCS programs usually implies compilation of some generated
C++ code. If you run into compilation errors, the first action to perform
is to clean up compilation files by the command</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; instant-clean
</pre></div>
</div>
<p class="last">Then recompile, and if the error persist, open the <code class="docutils literal"><span class="pre">.log</span></code> file referred
to in the error message, search for the word <em>error</em>, and see
if the error message from the C++ compiler makes sense. As a user,
your compilation errors will in most cases arise from wrong (C++) syntax
in <code class="docutils literal"><span class="pre">Expression</span></code> objects.</p>
</div>
<p>Choosing a very peak-formed pressure with large <span class="math">\(\beta\)</span> (e.g., <span class="math">\(\beta
\geq 20\)</span>) and a location <span class="math">\(R_0\)</span> toward the circular boundary (e.g.,
<span class="math">\(R_0=0.5\)</span>), may produce an exciting visual demonstrations of the very
smoothed elastic response to a peak force (or mathematically, the
smoothing properties of the inverse of the Laplace operator).  One
needs to experiment with the mesh resolution to get a smooth visual
representation of <span class="math">\(p\)</span>.  You are strongly encouraged to play around
with the plots and different mesh resolutions:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import membrane as m; m.application()&#39; \
          membrane.py
</pre></div>
</div>
</div>
<div class="section" id="test-problem-4">
<h4>Test problem<a class="headerlink" href="#test-problem-4" title="Permalink to this headline">¶</a></h4>
<p>We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case <span class="math">\(\beta =0\)</span>.
A unit test, implemented for the pytest or nose frameworks, appears in
the function <code class="docutils literal"><span class="pre">test_membrane</span></code>.</p>
</div>
</div>
<div class="section" id="visualization-in-fenics">
<span id="tut-quickviz"></span><h3>Visualization in FEniCS<a class="headerlink" href="#visualization-in-fenics" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-34"></span><span class="target" id="index-35"></span><p id="index-36">As we go along with examples it is fun to play around with
<code class="docutils literal"><span class="pre">plot</span></code> commands and visualize what is computed. This section explains
some useful visualization features.</p>
<p>The <code class="docutils literal"><span class="pre">plot</span></code> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.</p>
<p id="index-37">We have made a program <code class="docutils literal"><span class="pre">ft07_poisson_membrane.py</span></code> for the membrane
deflection problem in the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a> and added
various demonstrations of plotting capabilities. You are encouraged to
play around with <code class="docutils literal"><span class="pre">ft07_poisson_membrane.py</span></code> and modify the code as
you read about various features.</p>
<p id="index-38">The <code class="docutils literal"><span class="pre">plot</span></code> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Finite element mesh&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">wireframe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Axes can be turned on by the <code class="docutils literal"><span class="pre">axes=True</span></code> argument, while
<code class="docutils literal"><span class="pre">interactive=True</span></code> makes the program hang at the plot command - you have
to type <code class="docutils literal"><span class="pre">q</span></code> in the plot window to terminate the plot and continue execution.</p>
<p>The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <code class="docutils literal"><span class="pre">Help</span></code> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,</p>
<blockquote>
<div><ul class="simple">
<li>pressing <code class="docutils literal"><span class="pre">m</span></code> turns visualization of the mesh on and off,</li>
<li>pressing <code class="docutils literal"><span class="pre">b</span></code> turns on and off a bounding box,</li>
<li>pressing <code class="docutils literal"><span class="pre">p</span></code> dumps the plot to a PNG file,</li>
<li>pressing <code class="docutils literal"><span class="pre">P</span></code> dumps the plot to a PDF file,</li>
<li>pressing <cite>Ctrl +&#8217; stretches the surface in the :math:`z</cite> direction,</li>
<li>pressing <cite>Ctrl -&#8216; shrinks++ the surface in the :math:`z</cite> direction,</li>
<li>pressing <a href="#id1"><span class="problematic" id="id2">`</span></a>Ctrl w&#8217; closes the plot window,</li>
<li>pressing <a href="#id3"><span class="problematic" id="id4">`</span></a>Ctrl q&#8217; closes all plot windows.</li>
</ul>
</div></blockquote>
<p>The plots created by pressing <code class="docutils literal"><span class="pre">p</span></code> or <code class="docutils literal"><span class="pre">P</span></code> are stored in files with
names <code class="docutils literal"><span class="pre">dolfin_plot_X.png</span></code> or <code class="docutils literal"><span class="pre">dolfin_plot_X.pdf</span></code>,
where <code class="docutils literal"><span class="pre">X</span></code> is an integer that is increased by one from the last plot
that was made. The file stem <code class="docutils literal"><span class="pre">dolfin_plot_</span></code> can be set to something
more suitable through the <code class="docutils literal"><span class="pre">hardcopy_prefix</span></code> keyword argument to the
<code class="docutils literal"><span class="pre">plot</span></code> function,
for instance, <code class="docutils literal"><span class="pre">plot(f,</span> <span class="pre">hardcopy_prefix='pressure')</span></code>.</p>
<span class="target" id="index-39"></span><p id="index-40">Plots stored in PDF format need to be rotated 90 degrees before
inclusion in documents. This can be done by the <code class="docutils literal"><span class="pre">convert</span> <span class="pre">-rotate</span> <span class="pre">90</span></code>
command (from the ImageMagick utility), but the resulting file has
then no more high-resolution PDF vector graphics. A better solution
is therefore to use <code class="docutils literal"><span class="pre">pdftk</span></code> to preserve the vector graphics:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; pdftk dolfin_plot_1.pdf cat 1-endnorth output out.pdf
</pre></div>
</div>
<p>For making plots in batch, we can do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># adjust (lift) camera from the default view</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>       <span class="c"># bring new settings into action</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># make deflection.png</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s">&#39;deflection&#39;</span><span class="p">)</span>  <span class="c"># make deflection.pdf</span>
<span class="c"># Rotate pdf file (right) from landscape to portrait</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;pdftk deflection.pdf cat 1-endnorth output w.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The commands above appear in the <code class="docutils literal"><span class="pre">application2</span></code>
function in the <code class="docutils literal"><span class="pre">ft07_poisson_membrane.py</span></code> file.</p>
<div class="figure" id="id7">
<span id="tut-poisson-2d-fig1"></span><a class="reference internal image-reference" href="_images/membrane_deflection.png"><img alt="_images/membrane_deflection.png" src="_images/membrane_deflection.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the deflection of a membrane</em></span></p>
</div>
</div>
<div class="section" id="visualization-in-paraview">
<span id="tut-paraview"></span><h3>Visualization in ParaView<a class="headerlink" href="#visualization-in-paraview" title="Permalink to this headline">¶</a></h3>
<p>We strongly recommend FEniCS users to visualize
multi-dimensional  scalar and vector fields with
<a class="reference external" href="http://www.paraview.org">ParaView</a>.</p>
<p>The <code class="docutils literal"><span class="pre">application</span></code> function in the <code class="docutils literal"><span class="pre">ft07_poisson_membrane.py</span></code> file
writes <span class="math">\(w\)</span> and <span class="math">\(p\)</span>, to as finite element functions, to file.
The default filenames are <code class="docutils literal"><span class="pre">membrane000000.vtu</span></code> for the first field, <span class="math">\(w\)</span>, and
<code class="docutils literal"><span class="pre">membrane000001.vtu</span></code> for the second field, <span class="math">\(p\)</span>. These files are in VTK
format and their data can be visualized in ParaView.</p>
<ol class="arabic simple">
<li>Start the ParaView application.</li>
<li>Open a file with <strong>File - Open...</strong>. You will see a list of <code class="docutils literal"><span class="pre">.vtu</span></code> files,
more specifically you see <code class="docutils literal"><span class="pre">mambrane..vtu</span></code>. Click to the left of that
name to expand the collection of <code class="docutils literal"><span class="pre">membrane*.vtu</span></code> files. Choose the
first one, <code class="docutils literal"><span class="pre">membrane000000.vtu</span></code></li>
<li>Click on <strong>Apply</strong> to the left (<em>Properties</em> pane) in the GUI, and
ParaView will visualize the contents of the file, here as a color image.</li>
<li>To get rid of the axis in the lower left corner of the plot area
and axis cross in the middle of the circle, find the <em>Show Orientation Axis</em> and <em>Show Center</em> buttons to the right in the second row of buttons at the top of the GUI. Click on these buttons to toggle axis information on/off.</li>
<li>If you want a color bar to explain the mapping between <span class="math">\(w\)</span> values and colors,
go to the <em>Color Map Editor</em> in the right of the GUI and use the
<em>Show/hide color legend</em> button. Alternatively, find <em>Coloring</em> in the
lower left part of the GUI, and toggle the <em>Show</em> button.</li>
<li>The color map, by default going from blue (low values) to red (high values),
can easily be changed. Find the <em>Coloring</em> menu in the left part of the
GUI, click <em>Edit</em>, then in the <em>Color Map Editor</em> double click at the
left end of the color spectrum and choose another color, say yellow, then
double click at the right and of the spectrum and choose pink, scroll
down to the bottom of the dialog and click <em>Update</em>. The color map now
goes from yellow to pink.</li>
<li>To save the plot to file, click on <strong>File - Export Scene...</strong>,
choose a file type, fill in a filename, and save.
See Figure <a class="reference internal" href="#tut-paraview-figwp"><span class="std std-ref">Default visualizations in ParaView: deflection (left, middle) and pressure load (right)</span></a> (middle).</li>
<li>To change the background color of plots, choose
<strong>Edit - Settings...</strong>, <strong>Color</strong> tab, click on <strong>Background Color</strong>,
and choose it to be, e.g., white. Then choose <strong>Foreground Color</strong> to
be something different.</li>
<li>To plot the mesh with colors reflecting the size of <span class="math">\(w\)</span>, find the
<em>Representation</em> drop down menu in the left part of the GUI, and replace
<em>Surface</em> by <em>Wireframe</em>.</li>
<li>To overlay a surface plot with a wireframe plot, load <span class="math">\(w\)</span> and plot</li>
</ol>
<blockquote>
<div>as surface, then load <span class="math">\(w\)</span> again and plot as wireframe. Make sure
both icons in the <em>Pipeline Browser</em> in the left part of the GUI
are <em>on</em> for the two <code class="docutils literal"><span class="pre">membrane000000.vtu</span></code> files.
See Figure <a class="reference internal" href="#tut-paraview-figwp"><span class="std std-ref">Default visualizations in ParaView: deflection (left, middle) and pressure load (right)</span></a> (left).</div></blockquote>
<ol class="arabic simple" start="11">
<li>Redo the surface plot. Then we can add some contour lines.</li>
</ol>
<blockquote>
<div>Press the semi-sphere icon in the third row of buttons at the top of the
GUI (the so-called <em>filters</em>). A set of contour values can now be
specified at in a dialog box in the left part of the GUI. Remove
the default contour (0.578808) and add 0.01, 0.02, 0.03, 0.04, 0.05.
Click <em>Apply</em> and see an overlay of white contour lines.
In the <em>Pipeline Browser</em> you can click on the icons to turn
a filter on or off.</div></blockquote>
<div class="figure" id="id8">
<span id="tut-paraview-figwp"></span><a class="reference internal image-reference" href="_images/paraview_membrane3b.png"><img alt="_images/paraview_membrane3b.png" src="_images/paraview_membrane3b.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Default visualizations in ParaView: deflection (left, middle) and pressure load (right)</em></span></p>
</div>
<p>A particularly useful feature of ParaView is that you can record GUI clicks
(<strong>Tools - Start/Stop Trace</strong>) and
get them translated to Python code. This allows you automate the
visualization process. You can also make curve plots along lines through
the domain, etc.</p>
<p>For more information, we refer to The ParaView Guide <a class="reference internal" href="._ftut008.html#ref22" id="id5">[Ref22]</a>
(free PDF available) and to the <a class="reference external" href="http://www.paraview.org/Wiki/The_ParaView_Tutorial">ParaView tutorial</a>.</p>
</div>
<div class="section" id="exercise-2-visualize-a-solution-in-a-cube">
<h3>Exercise 2: Visualize a solution in a cube<a class="headerlink" href="#exercise-2-visualize-a-solution-in-a-cube" title="Permalink to this headline">¶</a></h3>
<p>Solve the problem <span class="math">\(-\nabla^2 u = f\)</span> on the unit cube <span class="math">\([0,1]\times[0,1]\times
[0,1]\)</span> with <span class="math">\(u_0 = 1 + x^2 + 2y^2 - 4z^2\)</span> on the boundary.
Visualize the solution. Explore both the built-in visualization tool and
ParaView.</p>
<p><strong>Solution.</strong>
As hinted by the filename in this exercise,
a good starting point is the <code class="docutils literal"><span class="pre">solver</span></code> function in
the program <code class="docutils literal"><span class="pre">ft04_poisson_func.py</span></code>, which solves the corresponding 2D
problem. Only one line in the body of <code class="docutils literal"><span class="pre">solver</span></code> needs to be changed (!):
<code class="docutils literal"><span class="pre">mesh</span> <span class="pre">=</span> <span class="pre">...</span></code>. Replace this line with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">)</span>
</pre></div>
</div>
<p>and add <code class="docutils literal"><span class="pre">Nz</span></code> as argument to <code class="docutils literal"><span class="pre">solver</span></code>. We implement the new <span class="math">\(u_0\)</span> function
in <code class="docutils literal"><span class="pre">application_test</span></code> and realize that the proper <span class="math">\(f(x,y,z)\)</span> function
in this new case is 2.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1] - 4*x[2]*x[2]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The numerical solution is without approximation errors so we can
reuse the unit test from 2D, but it needs an extra <code class="docutils literal"><span class="pre">Nz</span></code> parameter.</p>
<p>The variation in <span class="math">\(u\)</span> is only quadratic so a coarse mesh is okay for
visualization. Below is plot from the ParaView (left) and the built-in
visualization tool (right).  The usage is as in 2D, but now one can
use the mouse to rotate the 3D cube.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cube3D_quad_sol.png"><img alt="_images/cube3D_quad_sol.png" src="_images/cube3D_quad_sol.png" style="width: 800px;" /></a>
</div>
<p>We can in ParaView add a contour filter and define contour surfaces for
<span class="math">\(u=-2,1,0,1,2,3\)</span>, then add a slice filter to get a slice with colors:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cube3D_quad_sol_contours.png"><img alt="_images/cube3D_quad_sol_contours.png" src="_images/cube3D_quad_sol_contours.png" style="width: 500px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">p3D_func</span></code>.</p>
</div>
<div class="section" id="taking-advantage-of-structured-mesh-data">
<span id="tut-structviz"></span><h3>Taking advantage of structured mesh data<a class="headerlink" href="#taking-advantage-of-structured-mesh-data" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-41"></span><span class="target" id="index-42"></span><p id="index-43">When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.</p>
<p id="index-44">A necessary first step is to transform our <code class="docutils literal"><span class="pre">mesh</span></code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
second step is to transform the one-dimensional array of nodal values
to a two-dimensional array holding the values at the corners of the
cells in the structured mesh. We want to access a value by its <span class="math">\(i\)</span> and
<span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span> direction, and <span class="math">\(j\)</span> counting
cells in the <span class="math">\(y\)</span> direction.  This transformation is in principle
straightforward, yet it frequently leads to obscure indexing errors,
so using software tools to ease the work is advantageous.</p>
<p>In the directory <code class="docutils literal"><span class="pre">src/modules</span></code>, associated with this booklet, we have
included a Python module <code class="docutils literal"><span class="pre">BoxField</span></code> that can take a finite element
function <code class="docutils literal"><span class="pre">u</span></code> computed by a FEniCS software and represent it on a
structured box-shaped mesh and assign or extract values by
multi-dimensional indexing: <code class="docutils literal"><span class="pre">[i]</span></code> in 1D, <code class="docutils literal"><span class="pre">[i,j]</span></code> in 2D, and <code class="docutils literal"><span class="pre">[i,j,k]</span></code>
in 3D. Given a finite element function <code class="docutils literal"><span class="pre">u</span></code>, the following function
returns a <code class="docutils literal"><span class="pre">BoxField</span></code> object that represents <code class="docutils literal"><span class="pre">u</span></code> on a structured mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">divisions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent u on a structured mesh.&quot;&quot;&quot;</span>
    <span class="c"># u must have P1 elements, otherwise interpolate to P1 elements</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
         <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">BoxField</span> <span class="kn">import</span> <span class="n">fenics_function2BoxField</span>
    <span class="n">u_box</span> <span class="o">=</span> <span class="n">fenics_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">divisions</span><span class="p">,</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_box</span>
</pre></div>
</div>
<p>Note that we can only turn functions on meshes with P1 elements into
<code class="docutils literal"><span class="pre">BoxField</span></code> objects, so if <code class="docutils literal"><span class="pre">u</span></code> is based on another element type, we first
interpolate the scalar field onto a mesh with P1 elements. Also note
that to use the
function, we need to know the divisions into cells in the various
spatial directions (<code class="docutils literal"><span class="pre">divisions</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">u_box</span></code> object contains several useful data structures:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u_box.grid</span></code>: object for the structured mesh</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">X=0</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Y=1</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code>: grid coordinates in <code class="docutils literal"><span class="pre">Z=2</span></code> direction</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[X]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>
(for vectorized computations or surface plotting)</li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Y]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Y]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.grid.coorv[Z]</span></code>: vectorized version of <code class="docutils literal"><span class="pre">u_box.grid.coor[Z]</span></code></li>
<li><code class="docutils literal"><span class="pre">u_box.values</span></code>: <code class="docutils literal"><span class="pre">numpy</span></code> array holding the <code class="docutils literal"><span class="pre">u</span></code> values;
<code class="docutils literal"><span class="pre">u_box.values[i,j]</span></code> holds <code class="docutils literal"><span class="pre">u</span></code> at the mesh point with coordinates</li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">(u_box.grid.coor[X],</span> <span class="pre">u_box.grid.coor[Y])</span></code></div>
</div>
<div class="section" id="iterating-over-points-and-values">
<h4>Iterating over points and values<a class="headerlink" href="#iterating-over-points-and-values" title="Permalink to this headline">¶</a></h4>
<p>Let us go back to the <code class="docutils literal"><span class="pre">solver</span></code> function in the
<code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> code from
the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient Poisson problem</span></a>, compute <code class="docutils literal"><span class="pre">u</span></code>, map it onto a
<code class="docutils literal"><span class="pre">BoxField</span></code> object for a structured mesh representation, and
write out the coordinates and function values at all mesh points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span>       <span class="c"># numpy array</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c"># for indexing in x and y direction</span>

<span class="c"># Iterate over 2D mesh points (i,j)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;u_ is defined on a structured mesh with </span><span class="si">%s</span><span class="s"> points&#39;</span> <span class="o">%</span>
      <span class="nb">str</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;u[</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">]=u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
               <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
               <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="finite-difference-approximations">
<h4>Finite difference approximations<a class="headerlink" href="#finite-difference-approximations" title="Permalink to this headline">¶</a></h4>
<p>Note that with <code class="docutils literal"><span class="pre">u_</span></code>, we can easily express finite difference approximation
of derivatives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u_xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="surface-plot">
<span id="index-45"></span><h4>Surface plot<a class="headerlink" href="#surface-plot" title="Permalink to this headline">¶</a></h4>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
With Matplotlib we can create a surface plot, see
Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper left):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span>  <span class="c"># vectorized mesh coordinates</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span>
                <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Surface plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The key issue is to know that the coordinates needed for the surface
plot is in <code class="docutils literal"><span class="pre">u_box.grid.coorv</span></code> and that the values are in <code class="docutils literal"><span class="pre">u_</span></code>.</p>
<div class="figure" id="id9">
<span id="tut-structviz-fig1"></span><a class="reference internal image-reference" href="_images/poisson_vc_structmesh2.png"><img alt="_images/poisson_vc_structmesh2.png" src="_images/poisson_vc_structmesh2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Various plots of the solution on a structured mesh</em></span></p>
</div>
</div>
<div class="section" id="contour-plot">
<span id="index-46"></span><h4>Contour plot<a class="headerlink" href="#contour-plot" title="Permalink to this headline">¶</a></h4>
<p>A contour plot can also be made by Matplotlib:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>  <span class="c"># add labels to contour lines</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Contour plot of solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result appears in Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (upper right).</p>
</div>
<div class="section" id="curve-plot-through-the-mesh">
<h4>Curve plot through the mesh<a class="headerlink" href="#curve-plot-through-the-mesh" title="Permalink to this headline">¶</a></h4>
<p>A handy feature of <code class="docutils literal"><span class="pre">BoxField</span></code> objects is the ability to give a start
point in the grid and a direction, and then extract the field and
corresponding coordinates along the nearest line of mesh points. In 3D fields
one can also extract data in a plane.  Say we want to plot <span class="math">\(u\)</span> along
the line <span class="math">\(y=0.4\)</span>. The mesh points, <code class="docutils literal"><span class="pre">x</span></code>, and the <span class="math">\(u\)</span> values
along this line, <code class="docutils literal"><span class="pre">u_val</span></code>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal"><span class="pre">snapped</span></code> is true if the line had to be snapped onto a
gridline and in that case <code class="docutils literal"><span class="pre">y_fixed</span></code> holds the snapped
(altered) <span class="math">\(y\)</span> value. To avoid interpolation in the structured mesh,
<code class="docutils literal"><span class="pre">snapped</span></code> is in fact <em>always</em> true.</p>
<p>A comparison of the numerical and exact solution along the line
<span class="math">\(y=0.5\)</span> (snapped from <span class="math">\(y=0.4\)</span>) is made by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">u_e_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">u0</span><span class="p">((</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">))</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e_val</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> (lower left) for the resulting curve plot.</p>
</div>
<div class="section" id="curve-plot-of-the-flux">
<h4>Curve plot of the flux<a class="headerlink" href="#curve-plot-of-the-flux" title="Permalink to this headline">¶</a></h4>
<p>Let us also compare the numerical and
exact flux <span class="math">\(-p\partial u/\partial x\)</span> along the same line as above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_u</span> <span class="o">=</span> <span class="n">flux</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">flux_u_x</span><span class="p">,</span> <span class="n">flux_u_y</span> <span class="o">=</span> <span class="n">flux_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Plot the numerical and exact flux along the same line</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_u_x</span> <span class="k">if</span> <span class="n">flux_u_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> \
          <span class="k">else</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span>
               <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span>
                             <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_u_x_box</span> <span class="o">=</span> <span class="n">structured_mesh</span><span class="p">(</span><span class="n">flux_u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
<span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
   <span class="n">flux_u_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_val</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_u_x_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">),</span> <span class="s">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;P1 elements&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Flux along line y=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The second <code class="docutils literal"><span class="pre">plt.plot</span></code> command
requires a Python function <code class="docutils literal"><span class="pre">flux_u_x_exact(x,y)</span></code> to be
available for the exact flux expression.</p>
<p>Note that Matplotlib is one choice of plotting package. With the unified
interface in the <a class="reference external" href="https://github.com/hplgit/scitools">SciTools package</a> one
can access Matplotlib, Gnuplot, MATLAB, OpenDX, VisIt, and other plotting
engines through the same API.</p>
</div>
<div class="section" id="test-problem-5">
<span id="index-47"></span><h4>Test problem<a class="headerlink" href="#test-problem-5" title="Permalink to this headline">¶</a></h4>
<p>The graphics referred to in Figure <a class="reference internal" href="#tut-structviz-fig1"><span class="std std-ref">Various plots of the solution on a structured mesh</span></a> correspond to
a test problem with prescribed solution <span class="math">\({u_{\small\mbox{e}}} = H(x)H(y)\)</span>, where</p>
<div class="math">
\[H(x) = e^{-16(x-\frac{1}{2})^2}\sin(3\pi x){\thinspace .}\]</div>
<p>We just fit a function <span class="math">\(f(x,y)\)</span> in the PDE (can choose <span class="math">\(p=1\)</span>),
and notice that <span class="math">\(u=0\)</span> along the
boundary of the unit square. Although it is easy to carry out the
differentiation of <span class="math">\(f\)</span> by hand and hardcode the resulting expressions
in an <code class="docutils literal"><span class="pre">Expression</span></code> object, a more reliable habit is to use Python&#8217;s
symbolic computing engine, SymPy, to perform mathematics and
automatically turn formulas into C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects.
A short introduction was given in the section <a class="reference internal" href="._ftut003.html#tut-nonlinear-newton-auto"><span class="std std-ref">A simple implementation</span></a>.</p>
<p>We start out with defining the exact solution in <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>  <span class="c"># for use in math formulas</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">H</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0], x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">H</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-define-symbolic-coordinates-as-required-in-expression-objects admonition">
<p class="first admonition-title">Define symbolic coordinates as required in <code class="docutils literal"><span class="pre">Expression</span></code> objects</p>
<p class="last">Note that we would normally write <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x</span> <span class="pre">y')</span></code>, but
if we want the resulting expressions to be have valid syntax for
<code class="docutils literal"><span class="pre">Expression</span></code> objects, and then <span class="math">\(x\)</span> reads <code class="docutils literal"><span class="pre">x[0]</span></code> and <span class="math">\(y\)</span> must be <code class="docutils literal"><span class="pre">x[1]</span></code>.
This is easily accomplished with <code class="docutils literal"><span class="pre">sympy</span></code> by defining the names of <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">x[0]</span></code> and <code class="docutils literal"><span class="pre">x[1]</span></code>: <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x[0]</span> <span class="pre">x[1]')</span></code>.</p>
</div>
<p>Turning the expression for <code class="docutils literal"><span class="pre">u</span></code> into C or C++ syntax for <code class="docutils literal"><span class="pre">Expression</span></code> objects
needs two steps. First we ask for the C code of the expression,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Printing out <code class="docutils literal"><span class="pre">u_c</span></code> gives (the output is here manually broken into two
lines):</p>
<div class="highlight-text"><div class="highlight"><pre>-exp(-16*pow(x[0] - 0.5, 2) - 16*pow(x[1] - 0.5, 2))*
sin(3*M_PI*x[0])*sin(3*M_PI*x[1])
</pre></div>
</div>
<p>The necessary syntax adjustment is replacing
the symbol <code class="docutils literal"><span class="pre">M_PI</span></code> for <span class="math">\(\pi\)</span> in C/C++ by <code class="docutils literal"><span class="pre">pi</span></code> (or <code class="docutils literal"><span class="pre">DOLFIN_PI</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_c</span> <span class="o">=</span> <span class="n">u_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;pi&#39;</span><span class="p">)</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_c</span><span class="p">)</span>
</pre></div>
</div>
<p>Thereafter, we can progress with the computation of <span class="math">\(f = -\nabla\cdot(p\nabla u)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">f_c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;M_PI&#39;</span><span class="p">,</span> <span class="s">&#39;pi&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_c</span><span class="p">)</span>
</pre></div>
</div>
<p>We also need a Python function for the exact flux <span class="math">\(-p\partial u/\partial x\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_u_x_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                              <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It remains to define <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Constant(1)</span></code> and set <code class="docutils literal"><span class="pre">nx</span></code> and <code class="docutils literal"><span class="pre">ny</span></code> before calling
<code class="docutils literal"><span class="pre">solver</span></code> to compute the finite element solution of this problem.</p>
</div>
</div>
</div>
<div class="section" id="postprocessing-computations">
<h2>Postprocessing computations<a class="headerlink" href="#postprocessing-computations" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 10</strong>: Need a little intro.]</p>
<div class="section" id="computing-functionals">
<span id="tut-poisson1-functionals"></span><h3>Computing functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h3>
<p id="index-48">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally want to compute
functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="eq-tut-poisson1-functionals-energy">
\[\tag{56}
{1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},\]</div>
<p>which often reflects some energy quantity.
Another frequently occurring functional is the error</p>
<div class="math" id="eq-tut-poisson1-functionals-error">
\[\tag{57}
||{u_{\small\mbox{e}}}-u|| = \left(\int_\Omega ({u_{\small\mbox{e}}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>where <span class="math">\({u_{\small\mbox{e}}}\)</span> is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part <span class="math">\(\Gamma\)</span> of
the boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="eq-tut-poisson1-functionals-flux">
\[\tag{58}
F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},\]</div>
<p>where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and <span class="math">\(p\)</span> is a
coefficient (see the problem in the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient Poisson problem</span></a>
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.</p>
<div class="section" id="energy-functional">
<span id="index-49"></span><h4>Energy functional<a class="headerlink" href="#energy-functional" title="Permalink to this headline">¶</a></h4>
<p>The integrand of the
energy functional
<a class="reference internal" href="#eq-tut-poisson1-functionals-energy"><span class="std std-ref">(56)</span></a>
is described in the UFL language in the same manner as we describe
weak forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble</span></code> call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section <a class="reference internal" href="#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.</p>
</div>
<div class="section" id="error-functional">
<span id="index-50"></span><h4>Error functional<a class="headerlink" href="#error-functional" title="Permalink to this headline">¶</a></h4>
<p>Computation of <a class="reference internal" href="#eq-tut-poisson1-functionals-error"><span class="std std-ref">(57)</span></a> is typically done
by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> is here in a <code class="docutils literal"><span class="pre">Function</span></code> or
<code class="docutils literal"><span class="pre">Expression</span></code> object <code class="docutils literal"><span class="pre">u_exact</span></code>, while <code class="docutils literal"><span class="pre">u</span></code> is the
finite element approximation.
(Sometimes, for very small error values, the result of
<code class="docutils literal"><span class="pre">assemble(error)</span></code> can be a (very small) negative number, so we have
used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive value
for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.)</p>
<p>As will be explained and demonstrate in the section <a class="reference internal" href="#tut-poisson1-convrates"><span class="std std-ref">Computing convergence rates</span></a>, the integration of <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_exact)**2*dx</span></code>
can result in too optimistic convergence rates unless one is careful
how <code class="docutils literal"><span class="pre">u_exact</span></code> is transferred onto a mesh. The general recommendation
for reliable error computation is to use the <code class="docutils literal"><span class="pre">errornorm</span></code> function
(see <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">fenics.errornorm</span></code> and the section <a class="reference internal" href="#tut-poisson1-convrates"><span class="std std-ref">Computing convergence rates</span></a>
for more information):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="flux-functionals">
<span id="index-51"></span><h4>Flux Functionals<a class="headerlink" href="#flux-functionals" title="Permalink to this headline">¶</a></h4>
<p>To compute flux integrals like <span class="math">\(F = -\int_\Gamma p\nabla
u\cdot\boldsymbol{n} {\, \mathrm{d}s}\)</span> we need to define the <span class="math">\(\boldsymbol{n}\)</span> vector,
referred to as <em>facet normal</em> in FEniCS. If the surface domain
<span class="math">\(\Gamma\)</span> in the flux integral is the complete
boundary we can perform the flux computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <code class="docutils literal"><span class="pre">grad(u)</span></code> and <code class="docutils literal"><span class="pre">grad(u)</span></code> are interchangeable
in the above expression when <code class="docutils literal"><span class="pre">u</span></code> is a scalar function, we have
chosen to write <code class="docutils literal"><span class="pre">grad(u)</span></code> because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With <code class="docutils literal"><span class="pre">grad(u)</span></code> we must in that
case write <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></code>.</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section <a class="reference internal" href="#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>. Assuming that the
part corresponds to subdomain number <code class="docutils literal"><span class="pre">i</span></code>, the relevant syntax for
the variational formulation of the
flux is <code class="docutils literal"><span class="pre">-p*dot(grad(u),</span> <span class="pre">n)*ds(i)</span></code>.</p>
</div>
</div>
<div class="section" id="computing-convergence-rates">
<span id="tut-poisson1-convrates"></span><h3>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>To illustrate error computations and convergence of finite element
solutions, we have included a function <code class="docutils literal"><span class="pre">convergence_rate</span></code> in
the <code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> program. This is a tool that is very
handy when verifying finite element codes and will therefore be explained in
detail here.</p>
<p>The <span class="math">\(L^2\)</span> norm of the error in a finite element approximation <span class="math">\(u\)</span>,
<span class="math">\({u_{\small\mbox{e}}}\)</span> being the exact solution, is given by</p>
<div class="section" id="various-ways-of-computing-the-error">
<h4>Various ways of computing the error<a class="headerlink" href="#various-ways-of-computing-the-error" title="Permalink to this headline">¶</a></h4>
<div class="math">
\[E = \left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>and implemented in FEniCS by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>Sometimes, for very small error values, the result of
<code class="docutils literal"><span class="pre">assemble(error)</span></code> can be a (very small) negative number, so we have
used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive value
for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.</p>
<p>We remark that <code class="docutils literal"><span class="pre">u_e</span></code> will, in the expression
above, be interpolated onto the function space <code class="docutils literal"><span class="pre">V</span></code> before <code class="docutils literal"><span class="pre">assemble</span></code>
can perform the integration over the domain. This implies that the
exact solution used in the integral will vary linearly over the cells,
and not as a sine function, if <code class="docutils literal"><span class="pre">V</span></code> corresponds to linear Lagrange
elements.  This situation may yield a smaller error <code class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_e</span></code> than
what is actually true.  More accurate representation of the exact
solution is easily achieved by interpolating the formula onto a space
defined by higher-order elements, say of third degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>To achieve complete mathematical control of which function space the
computations are carried out in, we can explicitly interpolate <code class="docutils literal"><span class="pre">u</span></code> to
the same space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Ve</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The square in the expression for <code class="docutils literal"><span class="pre">error</span></code> will be expanded and lead to
a lot of terms that almost cancel when the error is small, with the
potential of introducing significant rounding errors.  The function
<code class="docutils literal"><span class="pre">errornorm</span></code> is available for avoiding this effect by first
interpolating <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u_exact</span></code> to a space with higher-order elements,
then subtracting the degrees of freedom, and then performing the
integration of the error field. The usage is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s">&#39;L2&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at the short implementation of <code class="docutils literal"><span class="pre">errornorm</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
    <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="c"># Subtract degrees of freedom for the error field</span>
    <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                       <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">errornorm</span></code> procedure turns out to be identical to computing
the expression <code class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2*dx</span></code> directly in
the present test case.</p>
<p>Sometimes it is of interest to compute the error of the
gradient field: <span class="math">\(||\nabla (u-{u_{\small\mbox{e}}})||\)</span>
(often referred to as the <span class="math">\(H^1\)</span> seminorm of the error).
Given the error field <code class="docutils literal"><span class="pre">e_Ve</span></code> above, we simply write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H1seminorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
</pre></div>
</div>
<p>All the various types of error computations here are placed in a
function <code class="docutils literal"><span class="pre">compute_errors</span></code> in <code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code>:
[<strong>hpl 14</strong>: Necessary to repeat code? New info is essentiall the return dict.]
[<strong>hpl 15</strong>: Anders, I (in 2010...) ran into problems with <code class="docutils literal"><span class="pre">fenics.errornorm</span></code>, see comments in the code below, and made the version below. We should check out these problems again and adjust <code class="docutils literal"><span class="pre">fenics.errornorm</span></code> if necessary.]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute various measures of the error u - u_exact, where</span>
<span class="sd">    u is a finite element Function and u_exact is an Expression.&quot;&quot;&quot;</span>

    <span class="c"># Compute error norm (for very small errors, the value can be</span>
    <span class="c"># negative so we run abs(assemble(error)) to avoid failure in sqrt</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="c"># Function - Expression</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_e onto the same space as u:</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Explicit interpolation of u_exact to higher-order elements,</span>
    <span class="c"># u will also be interpolated to the space Ve before integration</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="p">(),</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># fenics.errornorm interpolates u and u_e to a space with</span>
    <span class="c"># given degree, and creates the error field by subtracting</span>
    <span class="c"># the degrees of freedom, then the error field is integrated</span>
    <span class="c"># TEMPORARY BUG - doesn&#39;t accept Expression for u_e</span>
    <span class="c">#E4 = errornorm(u_e, u, normtype=&#39;l2&#39;, degree=3)</span>
    <span class="c"># Manual implementation errornorm to get around the bug:</span>
    <span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
        <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
        <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
        <span class="c"># Subtract degrees of freedom for the error field</span>
        <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
        <span class="c"># More efficient computation (avoids the rhs array result above)</span>
        <span class="c">#e_Ve.assign(u_e_Ve)                      # e_Ve = u_e_Ve</span>
        <span class="c">#e_Ve.vector().axpy(-1.0, u_Ve.vector())  # e_Ve += -1.0*u_Ve</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">Ve</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))),</span> <span class="n">e_Ve</span>
    <span class="n">E4</span><span class="p">,</span> <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>

    <span class="c"># Infinity norm based on nodal values</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">E5</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c"># H1 seminorm</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">E6</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>

    <span class="c"># Collect error measures in a dictionary with self-explanatory keys</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">:</span> <span class="n">E1</span><span class="p">,</span>
              <span class="s">&#39;u - interpolate(u_exact,V)&#39;</span><span class="p">:</span> <span class="n">E2</span><span class="p">,</span>
              <span class="s">&#39;interpolate(u,Ve) - interpolate(u_exact,Ve)&#39;</span><span class="p">:</span> <span class="n">E3</span><span class="p">,</span>
              <span class="s">&#39;errornorm&#39;</span><span class="p">:</span> <span class="n">E4</span><span class="p">,</span>
              <span class="s">&#39;infinity norm (of dofs)&#39;</span><span class="p">:</span> <span class="n">E5</span><span class="p">,</span>
              <span class="s">&#39;grad(error) H1 seminorm&#39;</span><span class="p">:</span> <span class="n">E6</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">errors</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-convergence-rates-empirically">
<h4>Computing convergence rates empirically<a class="headerlink" href="#computing-convergence-rates-empirically" title="Permalink to this headline">¶</a></h4>
<p>Calling the <code class="docutils literal"><span class="pre">solver</span></code> function for finer and finer meshes enables us to
study the convergence rate. Define the element size <span class="math">\(h=1/n\)</span>, where <span class="math">\(n\)</span>
is the number of cell divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction (<code class="docutils literal"><span class="pre">n=Nx=Ny</span></code> in
the code). We perform experiments with <span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span> and compute
the corresponding errors <span class="math">\(E_0, E_1, E_3\)</span> and so forth.  Assuming
<span class="math">\(E_i=Ch_i^r\)</span> for unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare two
consecutive experiments, <span class="math">\(E_i=Ch_i^r\)</span> and <span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span>, and
solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace .}\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence
rate <code class="docutils literal"><span class="pre">degree+1</span></code> as <span class="math">\(i\)</span> increases.</p>
<p>The procedure above can easily be turned into Python code. Here
we run through a different types of elements (P1, P2, P3, and P4),
perform experiments over a series of refined meshes, and for
each experiment report the six error types as returned by <code class="docutils literal"><span class="pre">compute_errors</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute convergence rates for various error norms for a</span>
<span class="sd">    sequence of meshes with Nx=Ny=b and P1, P2, ...,</span>
<span class="sd">    Pdegrees elements. Return rates for two consecutive meshes:</span>
<span class="sd">    rates[degree][error_type] = r0, r1, r2, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Discretization parameter, h[degree][experiment]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># Error measure(s), E[degree][experiment][error_type]</span>
    <span class="n">P_degrees</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">num_meshes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c"># Perform experiments with meshes and element types</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c"># Coarsest mesh division</span>
        <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                       <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">compute_errors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;2*(</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">) P</span><span class="si">%d</span><span class="s"> mesh, </span><span class="si">%d</span><span class="s"> unknowns, E1=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
                   <span class="n">errors</span><span class="p">[</span><span class="s">&#39;u - u_exact&#39;</span><span class="p">]))</span>
    <span class="c"># Convergence rates</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># log is a fenics name too</span>
    <span class="n">error_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
        <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">error_types</span><span class="p">):</span>
            <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
                <span class="n">Ei</span>   <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">Eim1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">Ei</span><span class="o">/</span><span class="n">Eim1</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rates</span>

<span class="k">def</span> <span class="nf">convergence_rate_sin</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute convergence rates for u=sin(x)*sin(y) solution.&quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                         <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_exact</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Note: P4 for n&gt;=128 seems to break down</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                              <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
    <span class="c"># Print rates</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">error_type</span> <span class="ow">in</span> <span class="n">error_types</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">error_type</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">P_degrees</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;P</span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="n">degree</span><span class="p">][</span><span class="n">error_type</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Note how we make a complete general function <code class="docutils literal"><span class="pre">convergence_rate</span></code>, aimed at
any 2D Poisson problem in the class we now can solve, and then call
this general function in <code class="docutils literal"><span class="pre">convergence_rate_sin</span></code> for a special test
case.</p>
</div>
<div class="section" id="test-problem-6">
<h4>Test problem<a class="headerlink" href="#test-problem-6" title="Permalink to this headline">¶</a></h4>
<p>The section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a> specifies a more complicated solution,</p>
<div class="math">
\[u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square.
This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2 u(x,y)\)</span>.
With <span class="math">\(\omega\)</span> restricted to an integer
it follows that <span class="math">\(u_0=0\)</span>.</p>
<p>We need to define the
appropriate boundary conditions, the exact solution, and the <span class="math">\(f\)</span> function
in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
</div>
<div class="section" id="experiments">
<h4>Experiments<a class="headerlink" href="#experiments" title="Permalink to this headline">¶</a></h4>
<p>Calling <code class="docutils literal"><span class="pre">convergence_rate_sin()</span></code> gives some interesting results.
Using the error measure <code class="docutils literal"><span class="pre">E5</span></code> based on the infinity norm of the
difference of the degrees of freedom, we have</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.99</td>
<td>1.97</td>
<td>1.99</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.99</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.96</td>
<td>3.89</td>
<td>3.96</td>
<td>3.99</td>
<td>4.0</td>
</tr>
<tr class="row-odd"><td>P4</td>
<td>3.75</td>
<td>4.99</td>
<td>5.0</td>
<td>5.0</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>The computations with P4 elements on a <span class="math">\(128\times 128\)</span> with a
direct solver (UMFPACK) on a small laptop broke down.
Otherwise we achieve expected results: the error goes like
<span class="math">\(h^{d+1}\)</span> for elements of degree <span class="math">\(d\)</span>. Also <span class="math">\(L^2\)</span> norms based
on the <code class="docutils literal"><span class="pre">errornorm</span></code> gives the expected <span class="math">\(h^{d+1}\)</span> rate for
<span class="math">\(u\)</span> and <span class="math">\(h^d\)</span> for <span class="math">\(\nabla u\)</span>.</p>
<p>However, using <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_exact)**2</span></code> for the error computation, which implies
interpolating <code class="docutils literal"><span class="pre">u_exact</span></code> onto the same space as <code class="docutils literal"><span class="pre">u</span></code>, results in <span class="math">\(h^4\)</span>
convergence for P2 elements.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">element</th>
<th class="head"><span class="math">\(n=8\)</span></th>
<th class="head"><span class="math">\(n=16\)</span></th>
<th class="head"><span class="math">\(n=32\)</span></th>
<th class="head"><span class="math">\(n=64\)</span></th>
<th class="head"><span class="math">\(n=128\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P1</td>
<td>1.98</td>
<td>1.94</td>
<td>1.98</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr class="row-odd"><td>P2</td>
<td>3.98</td>
<td>3.95</td>
<td>3.99</td>
<td>3.99</td>
<td>3.99</td>
</tr>
<tr class="row-even"><td>P3</td>
<td>3.69</td>
<td>4.03</td>
<td>4.01</td>
<td>3.95</td>
<td>2.77</td>
</tr>
</tbody>
</table>
<p>This is an example where it is important to interpolate <code class="docutils literal"><span class="pre">u_exact</span></code> to a
higher-order space (polynomials of degree 3 are sufficient here) to
avoid computing a too optimistic convergence rate.</p>
<p>Checking convergence rates is the next best method for verifying PDE codes
(the best being a numerical solution without approximation errors
as in the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a> and many other places in this tutorial).</p>
</div>
</div>
</div>
<div class="section" id="multiple-domains-and-boundaries">
<h2>Multiple domains and boundaries<a class="headerlink" href="#multiple-domains-and-boundaries" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 10</strong>: Need a little intro.]</p>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h3>Combining Dirichlet and Neumann conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h3>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="._ftut003.html#tut-poisson1-bvp"><span class="std std-ref">Mathematical problem formulation</span></a> and add a Neumann boundary
condition. The domain is still the unit square, but now we set the
Dirichlet condition <span class="math">\(u=u_0\)</span> at the left and right sides, <span class="math">\(x=0\)</span> and
<span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).</p>
<div class="section" id="pde-problem">
<span id="index-52"></span><h4>PDE problem<a class="headerlink" href="#pde-problem" title="Permalink to this headline">¶</a></h4>
<p>Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span> denote the parts of <span class="math">\(\partial\Omega\)</span>
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as</p>
<div class="math" id="eq-auto21">
\[\tag{59}
- \nabla^2 u = f \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-auto22">
\[\tag{60}
u = u_0 \mbox{ on } \Gamma_D,\]</div>
<div class="math" id="eq-auto23">
\[\tag{61}
- {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2{\thinspace .}\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y{\thinspace .}\]</div>
</div>
<div class="section" id="variational-formulation-5">
<h4>Variational formulation<a class="headerlink" href="#variational-formulation-5" title="Permalink to this headline">¶</a></h4>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_N}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.
The resulting weak form reads</p>
<div class="math" id="eq-tut-poisson-2d-dn-weak">
\[\tag{62}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
    \int_{\Gamma_N} gv {\, \mathrm{d}s}
    = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="eq-tut-poisson2-vard-a">
\[\tag{63}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-poisson2-vard-l">
\[\tag{64}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-2">
<h4>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h4>
<p>How does the Neumann condition impact the implementation?
Let us go back to the very simplest file,
<code class="docutils literal"><span class="pre">ft01_poisson_flat.py</span></code>, from
the section <span class="xref std std-ref">tut:poisson1:impl:code</span>,
we realize that the statements remain almost the same.
Only two adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <code class="docutils literal"><span class="pre">L</span></code>.</li>
</ul>
</div></blockquote>
<p>The first adjustment can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-never-use-for-comparing-real-numbers admonition">
<p class="first admonition-title">Never use <code class="docutils literal"><span class="pre">==</span></code> for comparing real numbers</p>
<p>A list like <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should never be used if <code class="docutils literal"><span class="pre">x[0]</span></code> is a real number,
because rounding errors in <code class="docutils literal"><span class="pre">x[0]</span></code> may make the test fail even when it is
mathematically correct. Consider</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span>
<span class="go">0.30000000000000004</span>
</pre></div>
</div>
<p>Comparison of real numbers need to use tolerances! The values of the
tolerances depend on the size of the numbers involved in arithmetic
operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="go">5.551115123125783e-17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1.1</span><span class="o">+</span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">2.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10.1</span><span class="o">+</span><span class="mf">10.2</span> <span class="o">-</span> <span class="mf">20.3</span><span class="p">)</span>
<span class="go">3.552713678800501e-15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">100.1</span><span class="o">+</span><span class="mf">100.2</span> <span class="o">-</span> <span class="mf">200.3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">1000.1</span><span class="o">+</span><span class="mf">1000.2</span> <span class="o">-</span> <span class="mf">2000.3</span><span class="p">)</span>
<span class="go">2.2737367544323206e-13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="mf">10000.1</span><span class="o">+</span><span class="mf">10000.2</span> <span class="o">-</span> <span class="mf">20000.3</span><span class="p">)</span>
<span class="go">3.637978807091713e-12</span>
</pre></div>
</div>
<p>For numbers around unity, tolerances as low as <span class="math">\(3\cdot 10^{-16}\)</span> can be used
(in fact, this tolerance is known as the constant <code class="docutils literal"><span class="pre">DOLFIN_EPS</span></code> in FEniCS),
otherwise an appropriate tolerance must be found.</p>
<p>Testing for <code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> should therefore be implemented as</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<p>Here is a new boundary function using tolerances in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <code class="docutils literal"><span class="pre">L</span></code>,
where we have to add a boundary integral and a definition of the <span class="math">\(g\)</span>
function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ds</span></code> variable implies a boundary integral, while <code class="docutils literal"><span class="pre">dx</span></code>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No more modifications are necessary.</p>
</div>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h3>Multiple Dirichlet conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h3>
<p>The PDE problem from the previous section applies a function <span class="math">\(u_0(x,y)\)</span>
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have <span class="math">\(m\)</span> functions for
setting Dirichlet conditions on <span class="math">\(m\)</span> parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.</p>
<p>Let us return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a> and define
two separate functions for the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N {\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while <span class="math">\(\Gamma_1\)</span> corresponds
to the boundary <span class="math">\(x=1\)</span>.  We have that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 +
2y^2\)</span>, and <span class="math">\(g=-4y\)</span>.</p>
<div class="section" id="functions-for-marking-dirichlet-boundaries">
<h4>Functions for marking Dirichlet boundaries<a class="headerlink" href="#functions-for-marking-dirichlet-boundaries" title="Permalink to this headline">¶</a></h4>
<p>For the left boundary <span class="math">\(\Gamma_0\)</span> we define the
usual triple of a function for the boundary value, a function for
defining the boundary of interest, and a <code class="docutils literal"><span class="pre">DirichletBC</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list
and used in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part of the
boundary, we may use a simple <code class="docutils literal"><span class="pre">Constant</span></code> object instead of an
<code class="docutils literal"><span class="pre">Expression</span></code> object.</p>
</div>
</div>
<div class="section" id="working-with-subdomains">
<span id="tut-possion-2d-2mat-impl"></span><h3>Working with subdomains<a class="headerlink" href="#working-with-subdomains" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-53"></span><p id="index-54">Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent
the various materials. We can thereafter define material properties
through functions, known in FEniCS as <em>mesh functions</em>, that are
piecewise constant in each subdomain.  A simple example with two
materials (subdomains) in 2D will demonstrate the basic steps in the
process.</p>
<div class="figure" id="id10">
<span id="tut-possion-2d-2mat-fig1"></span><a class="reference internal image-reference" href="_images/layered_medium_2.png"><img alt="_images/layered_medium_2.png" src="_images/layered_medium_2.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Medium with discontinuous material properties</em></span></p>
</div>
<p>Suppose we want to solve</p>
<div class="math" id="eq-tut-poisson-2d-2mat-varcoeff2">
\[\tag{65}
\nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,\]</div>
<p>in a domain <span class="math">\(\Omega\)</span> consisting of two subdomains where <span class="math">\(k\)</span> takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> and divide it into two equal
subdomains,
as depicted in Figure <a class="reference internal" href="#tut-possion-2d-2mat-fig1"><span class="std std-ref">Medium with discontinuous material properties</span></a>,</p>
<div class="math">
\[\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]{\thinspace .}\]</div>
<p>We define <span class="math">\(k(x,y)=k_0\)</span> in <span class="math">\(\Omega_0\)</span> and <span class="math">\(k(x,y)=k_1\)</span> in <span class="math">\(\Omega_1\)</span>,
where <span class="math">\(k_0&gt;0\)</span> and <span class="math">\(k_1&gt;0\)</span> are given constants.</p>
<p>Physically, the present problem may correspond to heat conduction, where
the heat conduction in <span class="math">\(\Omega_1\)</span> is more efficient than
in <span class="math">\(\Omega_0\)</span>. An alternative interpretation is flow in porous media
with two geological layers, where the layers&#8217; ability to transport
the fluid differ.</p>
<div class="section" id="expression-objects-with-if-test">
<h4>Expression objects with if test<a class="headerlink" href="#expression-objects-with-if-test" title="Permalink to this headline">¶</a></h4>
<p>The simplest way of implementing a variable <span class="math">\(k\)</span> is to define an
<code class="docutils literal"><span class="pre">Expression</span></code> object where we return the appropriate <span class="math">\(k\)</span> value
depending on the position in space.  Since we need some testing on the
coordinates, the most straightforward approach is to define a subclass
of <code class="docutils literal"><span class="pre">Expression</span></code>, where we can use a full Python method instead of just
a C++ string formula for specifying a function.  The method that
defines the function is called <code class="docutils literal"><span class="pre">eval</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">K</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_k_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">k1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="n">k0</span><span class="p">,</span> <span class="n">k1</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
        <span class="c"># Fill in-place value[0] for scalar function,</span>
        <span class="c"># value[:] for vector function (no return)</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span><span class="p">:</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span>

<span class="c"># Initialize</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">()</span>
<span class="n">k</span><span class="o">.</span><span class="n">set_k_values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">eval</span></code> method gives great flexibility in defining functions, but a
downside is that C++ calls up <code class="docutils literal"><span class="pre">eval</span></code> in Python for each point <code class="docutils literal"><span class="pre">x</span></code>,
which is a slow process, and the number of calls is proportional to
the number of numerical integration points in the mesh (about the
number of degrees of freedom).  Function expressions in terms of
strings are compiled to efficient C++ functions, being called from
C++, so we should try to express functions as string expressions if
possible. (The <code class="docutils literal"><span class="pre">eval</span></code> method can also be defined through C++ code, but
this is much more complicated and not covered here.)  The idea is to
use inline if tests in C++:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">k1</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[1] &lt;= 0.5+tol? k0 : k1&#39;</span><span class="p">,</span>
               <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="n">k1</span><span class="p">)</span>
</pre></div>
</div>
<p>The method with if tests on the location is feasible when the
subdomains have very simple shapes. A completely general method,
utilizing <em>mesh functions</em>, is described next.</p>
</div>
<div class="section" id="mesh-functions">
<span id="index-55"></span><h4>Mesh functions<a class="headerlink" href="#mesh-functions" title="Permalink to this headline">¶</a></h4>
<p>We now address how to specify the subdomains <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>
so that the method also works for subdomains of any shape. For this
purpose we need to use subclasses of class <code class="docutils literal"><span class="pre">SubDomain</span></code>, not only plain
functions as we have used so far for specifying boundaries. Consider
the boundary function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>for defining the boundary <span class="math">\(x=0\)</span>. Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code>,
which implements the <code class="docutils literal"><span class="pre">inside</span></code> method as an alternative to the
<code class="docutils literal"><span class="pre">boundary</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>A word about computer science terminology may be used here: The term
<em>instance</em> means a Python object of a particular type (such as
<code class="docutils literal"><span class="pre">SubDomain</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>, <code class="docutils literal"><span class="pre">FunctionSpace</span></code>, etc.).  Many use <em>instance</em>
and <em>object</em> as interchangeable terms. In other computer programming
languages one may also use the term <em>variable</em> for the same thing.  We
mostly use the well-known term <em>object</em> in this text.</p>
<p>A subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code> with an <code class="docutils literal"><span class="pre">inside</span></code> method offers functionality
for marking parts of the domain or the boundary. Now we need to define
one class for the subdomain <span class="math">\(\Omega_0\)</span> where <span class="math">\(y\leq 1/2\)</span> and another
for the subdomain <span class="math">\(\Omega_1\)</span> where <span class="math">\(y\geq 1/2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>

<span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span>

<span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">-</span><span class="n">tol</span>
</pre></div>
</div>
<p>Notice the use of <code class="docutils literal"><span class="pre">&lt;=</span></code> and <code class="docutils literal"><span class="pre">&gt;=</span></code> in both tests. For a cell to belong
to, e.g., <span class="math">\(\Omega_1\)</span>, the <code class="docutils literal"><span class="pre">inside</span></code> method must return <code class="docutils literal"><span class="pre">True</span></code> for all
the vertices <code class="docutils literal"><span class="pre">x</span></code> of the cell. So to make the cells at the internal
boundary <span class="math">\(y=1/2\)</span> belong to <span class="math">\(\Omega_1\)</span>, we need the test <code class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span>
<span class="pre">0.5</span></code>. However, because of potential rounding errors in the coordinates
<code class="docutils literal"><span class="pre">x[1]</span></code>, we use a tolerance in the comparisons: <code class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">0.5-tol</span></code>.</p>
<p>The next task is to use a <em>mesh function</em> to mark all cells in
<span class="math">\(\Omega_0\)</span> with the subdomain number 0 and all cells in <span class="math">\(\Omega_1\)</span>
with the subdomain number 1.  Our convention is to number subdomains
as <span class="math">\(0,1,2,\ldots\)</span>.</p>
<p>A <code class="docutils literal"><span class="pre">MeshFunction</span></code> object is a discrete function that can be evaluated
at a set of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells is suitable
to represent subdomains (materials), while a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous
fields.  The specialized classes <code class="docutils literal"><span class="pre">CellFunction</span></code> and <code class="docutils literal"><span class="pre">FacetFunction</span></code>
are used to construct mesh functions of cells and facets,
respectively.</p>
<p>Since we need to define subdomains of <span class="math">\(\Omega\)</span> in the present example,
we make use of a <code class="docutils literal"><span class="pre">CellFunction</span></code>. The constructor
is fed with two arguments: 1) the type of value: <code class="docutils literal"><span class="pre">'int'</span></code> for integers,
<code class="docutils literal"><span class="pre">'uint'</span></code> for positive (unsigned) integers, <code class="docutils literal"><span class="pre">'double'</span></code> for real
numbers, and <code class="docutils literal"><span class="pre">'bool'</span></code> for logical values; 2) a <code class="docutils literal"><span class="pre">Mesh</span></code> object.
Alternatively, the constructor can take just a filename and initialize
the <code class="docutils literal"><span class="pre">CellFunction</span></code> from data in a file.</p>
<p>We start with creating a <code class="docutils literal"><span class="pre">CellFunction</span></code> whose values are non-negative
integers (<code class="docutils literal"><span class="pre">'uint'</span></code>) for numbering the subdomains.
The appropriate code for two subdomains then reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers 0 and 1</span>
<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">Omega0</span><span class="p">()</span>
<span class="n">subdomain0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">Omega1</span><span class="p">()</span>
<span class="n">subdomain1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Alternative</span>
<span class="n">materials</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">subdomain1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">materials.array()</span></code> returns a <code class="docutils literal"><span class="pre">numpy</span></code> array of the
subdomain values. That is, <code class="docutils literal"><span class="pre">materials.array()[i]</span></code> is
the subdomain value of cell number <code class="docutils literal"><span class="pre">i</span></code>. This array is used to
look up the subdomain or material number of a specific element.</p>
<p>We need a function <code class="docutils literal"><span class="pre">k</span></code> that is constant in each subdomain <span class="math">\(\Omega_0\)</span>
and <span class="math">\(\Omega_1\)</span>. Since we want <code class="docutils literal"><span class="pre">k</span></code> to be a finite element function, it
is natural to choose a space of functions that is constant over each
element.  The family of discontinuous Galerkin methods, in FEniCS
denoted by <code class="docutils literal"><span class="pre">'DG'</span></code>, is suitable for this purpose. Since we want
functions that are piecewise constant, the value of the degree
parameter is zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
</pre></div>
</div>
<p>To fill <code class="docutils literal"><span class="pre">k</span></code> with the right values in each element, we loop over
all cells (i.e., indices in <code class="docutils literal"><span class="pre">materials.array()</span></code>),
extract the corresponding subdomain number of a cell,
and assign the corresponding <span class="math">\(k\)</span> value to the <code class="docutils literal"><span class="pre">k.vector()</span></code> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>  <span class="c"># values of k in the two subdomains</span>
<span class="k">for</span> <span class="n">cell_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">material_no</span> <span class="o">=</span> <span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span>
    <span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">material_no</span><span class="p">]</span>
</pre></div>
</div>
<p>Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <code class="docutils literal"><span class="pre">numpy</span></code> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<code class="docutils literal"><span class="pre">materials.array()</span></code>, but where the value <code class="docutils literal"><span class="pre">i</span></code> of an entry
in <code class="docutils literal"><span class="pre">materials.array()</span></code> is replaced by <code class="docutils literal"><span class="pre">k_values[i]</span></code>.
Such an operation is carried out by the <code class="docutils literal"><span class="pre">numpy</span></code> function <code class="docutils literal"><span class="pre">choose</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">help</span></code> array is required since <code class="docutils literal"><span class="pre">choose</span></code> cannot work with
<code class="docutils literal"><span class="pre">materials.array()</span></code> because this array has elements of
type <code class="docutils literal"><span class="pre">uint32</span></code>. We must therefore transform this array to an array
<code class="docutils literal"><span class="pre">help</span></code> with standard <code class="docutils literal"><span class="pre">int32</span></code> integers.</p>
<p>The next section exemplifies a complete solver with a piecewise
constant coefficient, like <span class="math">\(k\)</span>, defined through <code class="docutils literal"><span class="pre">SubDomain</span></code> objects,
combined with different types of boundary conditions.</p>
</div>
<div class="section" id="c-strings-for-subdomain-definitions">
<span id="index-56"></span><h4>C++ strings for subdomain definitions<a class="headerlink" href="#c-strings-for-subdomain-definitions" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">SubDomain</span></code> class in Python is convenient, but leads to lots of
function calls from C++ to Python, which are slow. In large problems,
the subdomains should be defined through C++ code. This is easy to achieve
using the <code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> object. Consider the definition of
classes <code class="docutils literal"><span class="pre">Omega0</span></code> and <code class="docutils literal"><span class="pre">Omega1</span></code> above in Python.
The key strings that define these subdomain can be expressed in
C++ syntax and fed to <code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># Tolerance for coordinate comparisons</span>

<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span>
                <span class="s">&#39;x[1] &lt;= boundary+tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span>
                <span class="s">&#39;x[1] &gt;= boundary-tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, <code class="docutils literal"><span class="pre">subdomain0</span></code> and <code class="docutils literal"><span class="pre">subdomain1</span></code>, can be used
as ordinary <code class="docutils literal"><span class="pre">SubDomain</span></code> objects.</p>
<p>Compiled subdomain strings can be applied for specifying boundaries as
well, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">y_R</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span><span class="s">&#39;on_boundary &amp;&amp; near(x[1], R, eps=tol)&#39;</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>   <span class="c"># y=2</span>
</pre></div>
</div>
<p>It is possible to feed the C++ string (without parameters) directly as
the third argument to <code class="docutils literal"><span class="pre">DirichletBC</span></code> without explicitly constructing a
<code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">&#39;on_boundary &amp;&amp; near(x[1], 2, 1E-14)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="index-57"></span></div>
</div>
<div class="section" id="exercise-3-efficiency-of-python-vs-c-expressions">
<span id="ftut-poisson-exer-eff-expression"></span><h3>Exercise 3: Efficiency of Python vs C++ expressions<a class="headerlink" href="#exercise-3-efficiency-of-python-vs-c-expressions" title="Permalink to this headline">¶</a></h3>
<p>Consider a cube mesh with <span class="math">\(N\)</span> cells in each spatial direction.
We want to define a <code class="docutils literal"><span class="pre">Function</span></code> on this mesh where the
values are given by the mathematical function <span class="math">\(f(x,y,z)=a\sin(bxyz)\)</span>,
where <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are two parameters. Write a <code class="docutils literal"><span class="pre">class</span> <span class="pre">SineXYZ</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SineXYZ</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Create an alternative <code class="docutils literal"><span class="pre">Expression</span></code> based on giving the formula for <span class="math">\(f(x,y,z)\)</span>
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using <code class="docutils literal"><span class="pre">time.clock()</span></code> to measure the CPU time).</p>
<p>The <code class="docutils literal"><span class="pre">sin</span></code> function used in class <code class="docutils literal"><span class="pre">SineXYZ.eval</span></code> can mean many things.
This is an advanced FEniCS function if imported from <code class="docutils literal"><span class="pre">fenics</span></code>.
Much more efficient versions for sin of numbers are found in <code class="docutils literal"><span class="pre">math.sin</span></code>
and <code class="docutils literal"><span class="pre">numpy.sin</span></code>. Compare the use <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">fenics</span></code>, <code class="docutils literal"><span class="pre">math</span></code>, <code class="docutils literal"><span class="pre">numpy</span></code>, and
<code class="docutils literal"><span class="pre">sympy</span></code> (note that <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">sympy</span></code> is very slow).</p>
<p><strong>Solution.</strong>
Here is an appropriate program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill a Function with sin(x*y*z) values.&quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;Python&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;fenics.sin&#39;</span><span class="p">):</span>
            <span class="c"># Need sin as local variable in this function</span>
            <span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;math.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;numpy.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;sympy.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;method=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;sin:&#39;</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">sin</span><span class="p">))</span>

        <span class="k">class</span> <span class="nc">SineXYZ</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

            <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">SineXYZ</span><span class="p">()</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;C++&#39;</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;a*sin(b*x[0]*x[1]*x[2])&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_fenics</span>  <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;Python-fenics.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_math</span>    <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;Python-math.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_numpy</span>   <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;Python-numpy.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_sympy</span>   <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;Python-sympy.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_cpp</span> <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;C++&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;&quot;&quot;DOFs: </span><span class="si">%d</span><span class="s"></span>
<span class="s">Python:</span>
<span class="s">fenics.sin: </span><span class="si">%.2f</span><span class="s"></span>
<span class="s">math.sin:   </span><span class="si">%.2f</span><span class="s"></span>
<span class="s">numpy.sin:  </span><span class="si">%.2f</span><span class="s"></span>
<span class="s">sympy.sin:  </span><span class="si">%.2f</span><span class="s"></span>
<span class="s">C++:        </span><span class="si">%.2f</span><span class="s"></span>
<span class="s">Speed-up:   math: </span><span class="si">%.2f</span><span class="s">  sympy: </span><span class="si">%.2f</span><span class="s">&quot;&quot;&quot;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
           <span class="n">cpu_py_fenics</span><span class="p">,</span> <span class="n">cpu_py_math</span><span class="p">,</span>
           <span class="n">cpu_py_numpy</span><span class="p">,</span> <span class="n">cpu_py_sympy</span><span class="p">,</span>
           <span class="n">cpu_cpp</span><span class="p">,</span>
           <span class="n">cpu_py_math</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">cpu_cpp</span><span class="p">),</span>
           <span class="n">cpu_py_sympy</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">cpu_cpp</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">profile</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">cProfile</span>
    <span class="n">prof</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
    <span class="n">prof</span><span class="o">.</span><span class="n">runcall</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">prof</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s">&quot;tmp.profile&quot;</span><span class="p">)</span>
    <span class="c"># http://docs.python.org/2/library/profile.html</span>

<span class="n">main</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="c">#profile()</span>
</pre></div>
</div>
<p>Running the program shows that <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">math</span></code> is the most efficient choice,
but a string C++ runs 40 times faster. Note that <code class="docutils literal"><span class="pre">fenics.sin</span></code>, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the <code class="docutils literal"><span class="pre">sin</span></code>
functions for numbers in <code class="docutils literal"><span class="pre">math</span></code> and <code class="docutils literal"><span class="pre">numpy</span></code>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Expression_efficiency</span></code>.</p>
</div>
<div class="section" id="multiple-neumann-robin-and-dirichlet-condition">
<span id="tut-poisson-multi-bc"></span><h3>Multiple Neumann, Robin, and Dirichlet condition<a class="headerlink" href="#multiple-neumann-robin-and-dirichlet-condition" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-58"></span><span class="target" id="index-59"></span><span class="target" id="index-60"></span><p id="index-61">Consider the model problem from the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a> where we had both Dirichlet and
Neumann conditions.  The term <code class="docutils literal"><span class="pre">v*g*ds</span></code> in the expression for <code class="docutils literal"><span class="pre">L</span></code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all exterior facets.  However, the
contributions from the parts of the boundary where we have Dirichlet
conditions are erased when the linear system is modified by the
Dirichlet conditions.  We would like, from an efficiency point of
view, to integrate <code class="docutils literal"><span class="pre">v*g*ds</span></code> only over the parts of the boundary where
we actually have Neumann conditions.  And more importantly, in other
problems one may have different Neumann conditions or other conditions
like the Robin type condition.  With the mesh function concept we can
mark different parts of the boundary and integrate over specific
parts.  The same concept can also be used to treat multiple Dirichlet
conditions.  The forthcoming text illustrates how this is done.</p>
<div class="section" id="three-types-of-boundary-conditions">
<h4>Three types of boundary conditions<a class="headerlink" href="#three-types-of-boundary-conditions" title="Permalink to this headline">¶</a></h4>
<p>We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin.  Dirichlet conditions apply to some
parts <span class="math">\(\Gamma_{D,0}\)</span>, <span class="math">\(\Gamma_{D,1}\)</span>, <span class="math">\(...\)</span>, of the boundary:</p>
<div class="math">
\[u_{0,0}\hbox{ on }\Gamma_{D,0},\quad
u_{0,1}\hbox{ on }\Gamma_{D,1}, \ldots\]</div>
<p>where <span class="math">\(u_{0,i}\)</span> are prescribed functions, <span class="math">\(i=0,1,\ldots\)</span>
On other parts, <span class="math">\(\Gamma_{N,0}\)</span>, <span class="math">\(\Gamma_{N,1}\)</span>, and so on, we have
Neumann conditions</p>
<div class="math">
\[-p{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{N,0},\quad
-p{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{N,1},\quad \ldots\]</div>
<p>Finally, we have <em>Robin conditions</em></p>
<div class="math" id="eq-tut-poisson-multi-bc-robin">
\[\tag{66}
-p{\partial u\over\partial n} = r(u-s),\]</div>
<p>where <span class="math">\(r\)</span> and <span class="math">\(s\)</span> are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton&#8217;s cooling law. In that case, <span class="math">\(r\)</span> is a heat
transfer coefficient, and <span class="math">\(s\)</span> is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts <span class="math">\(\Gamma_{R,0}\)</span>, <span class="math">\(\Gamma_{R,1}\)</span>, and so forth:</p>
<div class="math">
\[-p{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\Gamma_{R,0},\quad
-p{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\Gamma_{R,1},\quad \ldots\]</div>
</div>
<div class="section" id="a-general-model-problem">
<span id="index-62"></span><h4>A general model problem<a class="headerlink" href="#a-general-model-problem" title="Permalink to this headline">¶</a></h4>
<p>With the notation above,
the model problem to be solved with multiple Dirichlet, Neumann, and
Robin conditions can formally be defined as</p>
<div class="math" id="eq-tut-poisson-2d-dn3">
\[\tag{67}
-\nabla\cdot(p\nabla u) = -f, \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcd">
\[\tag{68}
u = u_{0,i} \mbox{ on } \Gamma_{D,i},\quad i=0,1,\ldots\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcn">
\[\tag{69}
-p{\partial u\over\partial n} = g_i \mbox{ on } \Gamma_{N,i},\quad
    i=0,1,\ldots\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-bcr">
\[\tag{70}
-p{\partial u\over\partial n} = r_i(u-s_i) \mbox{ on } \Gamma_{R,i},\quad
    i=0,1,\ldots\]</div>
</div>
<div class="section" id="variational-formulation-6">
<h4>Variational formulation<a class="headerlink" href="#variational-formulation-6" title="Permalink to this headline">¶</a></h4>
<p>Integration by parts of <span class="math">\(-\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}\)</span> becomes
as usual</p>
<div class="math">
\[ -\int_\Omega v\nabla\cdot(p\nabla u) {\, \mathrm{d}x}
= \int_\Omega p\nabla u\cdot \nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>The boundary integral does not apply to the parts of
the boundary where we have Dirichlet conditions (<span class="math">\(\Gamma_{D,i}\)</span>).
Moreover, on the remaining parts, we must split the boundary integral
into the parts where we have Neumann and Robin conditions such that we
insert the right conditions as integrands.
Specifically, we have</p>
<div class="math">
\[\begin{split}-\int_{\partial\Omega}p\frac{\partial u}{\partial n}v {\, \mathrm{d}s}
&amp;=
-\sum_i\int_{\Gamma_{N,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}
-\sum_i\int_{\Gamma_{R,i}}p\frac{\partial u}{\partial n} {\, \mathrm{d}s}\\
&amp;=
\sum_i\int_{\Gamma_{N,i}}g_i {\, \mathrm{d}s} +
\sum_i\int_{\Gamma_{R,i}}r_i(u-s_i) {\, \mathrm{d}s}{\thinspace .}\end{split}\]</div>
<p>The variational formulation then becomes</p>
<div class="math" id="eq-tut-poisson-multi-bc-varform">
\[\tag{71}
F = \int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x} +
    \sum_i\int_{\Gamma_{N,i}} g_iv {\, \mathrm{d}s} +
    \sum_i\int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
    - \int_{\Omega} fv {\, \mathrm{d}x} =0{\thinspace .}\]</div>
<p>We have been used to writing
this variational formulation in the standard notation
<span class="math">\(a(u,v)=L(v)\)</span>, which requires that we identify all integrals with
<em>both</em> <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, and collect these in <span class="math">\(a(u,v)\)</span>, while the remaining
integrals with <span class="math">\(v\)</span> and not <span class="math">\(u\)</span> go into <span class="math">\(L(v)\)</span>.  The integral from the
Robin condition must of this reason be split in two parts:</p>
<div class="math">
\[\int_{\Gamma_{R,i}}r_i(u-s_i)v {\, \mathrm{d}s}
= \int_{\Gamma_{R,i}} r_iuv {\, \mathrm{d}s} - \int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>We then have</p>
<div class="math" id="eq-tut-poisson-2d-dn3-var-a">
\[\tag{72}
a(u, v) = \int_{\Omega} p\nabla u\cdot \nabla v {\, \mathrm{d}x}
    + \sum_i\int_{\Gamma_{R,i}}r_iuv {\, \mathrm{d}s},\]</div>
<div class="math" id="eq-tut-poisson-2d-dn3-var-l">
\[\tag{73}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \sum_i\int_{\Gamma_{N,i}} g_i v {\, \mathrm{d}s} + \sum_i\int_{\Gamma_{R,i}}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-of-boundary-conditions">
<h4>Implementation of boundary conditions<a class="headerlink" href="#implementation-of-boundary-conditions" title="Permalink to this headline">¶</a></h4>
<p>Looking at our previous <code class="docutils literal"><span class="pre">solver</span></code> functions for solving the 2D Poisson equation,
the following new aspects must be taken care of:</p>
<blockquote>
<div><ol class="arabic simple">
<li>definition of a mesh function over the boundary,</li>
<li>marking each side as a subdomain, using the mesh function,</li>
<li>splitting a boundary integral into parts.</li>
</ol>
</div></blockquote>
<p>A general approach to the first task is to mark each of the desired
boundaries with markers 0, 1, 2, and so forth. Here we aim at
the four sides of the unit square, marked with
0 (<span class="math">\(x=0\)</span>), 1 (<span class="math">\(x=1\)</span>), 2 (<span class="math">\(y=0\)</span>), and 3 (<span class="math">\(y=1\)</span>).
The marking of boundaries makes use of a mesh function object, but contrary to
the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>, this is not a function over
cells, but a function over cell facets. We apply the <code class="docutils literal"><span class="pre">FacetFunction</span></code>
for this purpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">boundary_parts</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a> we use a subclass of
<code class="docutils literal"><span class="pre">SubDomain</span></code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the <span class="math">\(x=0\)</span> boundary can be marked by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BoundaryX0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">bx0</span> <span class="o">=</span> <span class="n">BoundaryX0</span><span class="p">()</span>
<span class="n">bx0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we make the classes <code class="docutils literal"><span class="pre">BoundaryX1</span></code> for the <span class="math">\(x=1\)</span> boundary,
<code class="docutils literal"><span class="pre">BoundaryY0</span></code> for the <span class="math">\(y=0\)</span> boundary, and <code class="docutils literal"><span class="pre">BoundaryY1</span></code> for the <span class="math">\(y=1\)</span>
boundary, and mark these as subdomains 1, 2, and 3, respectively.</p>
<p>For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,</p>
<div class="highlight-text"><div class="highlight"><pre>boundary_conditions = {
  0: {&#39;Dirichlet&#39;: u0},
  1: {&#39;Robin&#39;: (r, s)},
  2: {&#39;Neumann: g}},
  3: {&#39;Neumann&#39;, 0}}
</pre></div>
</div>
<p>specifies</p>
<blockquote>
<div><ul class="simple">
<li>a Dirichlet condition, with values implemented by an <code class="docutils literal"><span class="pre">Expression</span></code>
or <code class="docutils literal"><span class="pre">Constant</span></code> object
<code class="docutils literal"><span class="pre">u0</span></code>, on subdomain 0, i.e., the <span class="math">\(x=1\)</span> boundary;</li>
<li>a Robin condition <a class="reference internal" href="#eq-tut-poisson-multi-bc-robin"><span class="std std-ref">(66)</span></a>
on subdomain 1, <span class="math">\(x=1\)</span>, with <code class="docutils literal"><span class="pre">Expression</span></code> or <code class="docutils literal"><span class="pre">Constant</span></code> objects
<code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code> specifying <span class="math">\(r\)</span> and <span class="math">\(s\)</span>;</li>
<li>a Neumann condition <span class="math">\(\partial u/\partial n=g\)</span> on subdomain 2, <span class="math">\(y=0\)</span>,
where an <code class="docutils literal"><span class="pre">Expression</span></code> or <code class="docutils literal"><span class="pre">Constant</span></code> object <code class="docutils literal"><span class="pre">g</span></code> implements the value <span class="math">\(g\)</span>;</li>
<li>a homogeneous Neumann condition <span class="math">\(\partial u/\partial n=0\)</span> on
subdomain 3, <span class="math">\(y=1\)</span>.</li>
</ul>
</div></blockquote>
<p>As explained in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>,
multiple Dirichlet conditions must be collected in a list of
<code class="docutils literal"><span class="pre">DirichletBC</span></code> objects. Based on the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data
structure above, we can construct this list by the following snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># List of Dirichlet conditions</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Dirichlet&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">],</span>
                        <span class="n">boundary_parts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>The new aspect of the variational problem is the two distinct
boundary integrals over <span class="math">\(\Gamma_{N,i}\)</span> and <span class="math">\(\Gamma_{R,i}\)</span>.
Having a mesh function over exterior cell facets (our
<code class="docutils literal"><span class="pre">boundary_parts</span></code> object), where subdomains (boundary parts) are
numbered as <span class="math">\(0,1,2,\ldots\)</span>, the special symbol <code class="docutils literal"><span class="pre">ds(0)</span></code>
implies integration over subdomain (part) 0, <code class="docutils literal"><span class="pre">ds(1)</span></code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code class="docutils literal"><span class="pre">ds</span></code>-type objects generalizes to volume
integrals too: <code class="docutils literal"><span class="pre">dx(0)</span></code>, <code class="docutils literal"><span class="pre">dx(1)</span></code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside <span class="math">\(\Omega\)</span>.</p>
<p>Before we have <code class="docutils literal"><span class="pre">ds(n)</span></code> for integers <code class="docutils literal"><span class="pre">n</span></code> defined, we must do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries_parts</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, if we want integration of different parts of the domain,
we redefine <code class="docutils literal"><span class="pre">dx</span></code> as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">domains</span></code> is a <code class="docutils literal"><span class="pre">CellFunction</span></code> defining subdomains in <span class="math">\(\Omega\)</span>.</p>
<p>Suppose we have a Robin condition with values <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code> on subdomain
<code class="docutils literal"><span class="pre">R</span></code>, a Neumann condition with value <code class="docutils literal"><span class="pre">g</span></code> on subdomain <code class="docutils literal"><span class="pre">N</span></code>, the
variational form can be written</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>In our case things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data structure. We can collect
all Neumann conditions by the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">Neumann_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Neumann&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Neumann&#39;</span><span class="p">]</span>
            <span class="n">Neumann_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>Applying <code class="docutils literal"><span class="pre">sum(Nemann_integrals)</span></code> will apply the <code class="docutils literal"><span class="pre">+</span></code> operator to
the variational forms in the <code class="docutils literal"><span class="pre">Numeann_integrals</span></code> list and result
in the integrals we need for the right-hand side <code class="docutils literal"><span class="pre">L</span></code> of the
variational form.</p>
<p>The integrals in the Robin condition can similarly be collected
in lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Robin_a_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Robin_L_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">Robin_a_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">Robin_L_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>We are now in a position to define the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> expressions
in the variational formulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_a_integrals</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_L_integrals</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="simplified-handling-of-the-variational-formulation">
<h4>Simplified handling of the variational formulation<a class="headerlink" href="#simplified-handling-of-the-variational-formulation" title="Permalink to this headline">¶</a></h4>
<p>We carefully ordered the terms in the variational formulation above
into the <span class="math">\(a\)</span> and <span class="math">\(L\)</span> parts. This requires a splitting of the Robin
condition and makes the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> expressions less readable (still we
think understanding this splitting is key for any finite element programmer!).
Fortunately, UFL allow us to specify the complete variational form
<a class="reference internal" href="#eq-tut-poisson-multi-bc-varform"><span class="std std-ref">(71)</span></a> as <em>one expression</em> and offer tools to
extract what goes into the bilinear form <span class="math">\(a(u,v)\)</span> and the linear form
<span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">Robin_integrals</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Neumann_integrals</span><span class="p">)</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>This time we can more naturally define the integrals from the
Robin condition as <code class="docutils literal"><span class="pre">r*(u-s)*v*ds(n)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Robin_integrals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">Robin_integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete code is in the <code class="docutils literal"><span class="pre">solver_bc</span></code> function in the
<code class="docutils literal"><span class="pre">ft06_poisson_vc.py</span></code> file.</p>
</div>
<div class="section" id="test-problem-7">
<h4>Test problem<a class="headerlink" href="#test-problem-7" title="Permalink to this headline">¶</a></h4>
<p>Let us continue to use <span class="math">\({u_{\small\mbox{e}}}=1+x^2+2y^2\)</span> as the exact solution, and
set <span class="math">\(p=1\)</span> and <span class="math">\(f=-6\)</span> in the PDE.  Our domain is the unit square, and
we assign Dirichlet conditions at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, a Neumann condition
at <span class="math">\(y=1\)</span>, and a Robin condition at <span class="math">\(y=0\)</span>. With the given <span class="math">\({u_{\small\mbox{e}}}\)</span>, we
realize that the Neumann condition is <span class="math">\(-4y\)</span> (which means <span class="math">\(-4\)</span> at
<span class="math">\(y=1\)</span>), while the Robin
condition can be selected in many ways. Since <span class="math">\(\partial u/\partial
n=-\partial u/\partial y=0\)</span> at <span class="math">\(y=0\)</span>, we can select <span class="math">\(s=u\)</span> and have <span class="math">\(r\)</span>
arbitrary in the Robin condition.</p>
<p>The boundary parts are <span class="math">\(\Gamma_{D,0}\)</span>: <span class="math">\(x=0\)</span>, <span class="math">\(\Gamma_{D,1}\)</span>: <span class="math">\(x=1\)</span>,
<span class="math">\(\Gamma_{R,0}\)</span>: <span class="math">\(y=0\)</span>, and <span class="math">\(\Gamma_{N,0}\)</span>: <span class="math">\(y=1\)</span>.</p>
<p>When implementing this test problem (and especially other test problems
with more complicated expressions), it is advantageous to use
symbolic computing. Below we define <span class="math">\({u_{\small\mbox{e}}}\)</span> as a <code class="docutils literal"><span class="pre">sympy</span></code> expression
and derive other functions from their mathematical definitions.
Then we turn these expressions into C/C++ code, which can be
fed into <code class="docutils literal"><span class="pre">Expression</span></code> objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application_bc_test</span><span class="p">():</span>
    <span class="c"># Define manufactured solution in sympy and derive f, g, etc.</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>  <span class="c"># UFL needs x[0] for x etc.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># -Laplace(u)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># x=0 boundary</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary</span>
    <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># x=1 boundary, du/dn=-du/dy</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c"># any function can go here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Turn to C/C++ code for UFL expressions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Test problem (C/C++):</span><span class="se">\n</span><span class="s">u = </span><span class="si">%s</span><span class="se">\n</span><span class="s">f = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u_00: </span><span class="si">%s</span><span class="se">\n</span><span class="s">u_01: </span><span class="si">%s</span><span class="se">\n</span><span class="s">g = </span><span class="si">%s</span><span class="se">\n</span><span class="s">r = </span><span class="si">%s</span><span class="se">\n</span><span class="s">s = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

    <span class="c"># Turn into FEniCS objects</span>
    <span class="n">u_00</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_00</span><span class="p">)</span>
    <span class="n">u_01</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_01</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>   <span class="c"># x=0</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>   <span class="c"># x=1</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Robin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span>     <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">}}</span>        <span class="c"># y=1</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="o">*</span><span class="n">Ny</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">,</span>  <span class="c"># for small problems only</span>
        <span class="p">)</span>

    <span class="c"># Compute max error in infinity norm</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                       <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">max_error</span><span class="p">)</span>

    <span class="c"># Print numerical and exact solution at the vertices</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>  <span class="c"># (small problems only)</span>
        <span class="n">u_e_at_vertices</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%2d</span><span class="s"> (</span><span class="si">%9g</span><span class="s">,</span><span class="si">%9g</span><span class="s">): error=</span><span class="si">%g</span><span class="s"> </span><span class="si">%g</span><span class="s"> vs </span><span class="si">%g</span><span class="s">&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">u_e_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>
</div>
<p>This simple test problem is turned into a real unit test for different
function spaces in the function <code class="docutils literal"><span class="pre">test_solver_bc</span></code>.</p>
</div>
<div class="section" id="debugging-the-setting-of-boundary-conditions">
<h4>Debugging the setting of boundary conditions<a class="headerlink" href="#debugging-the-setting-of-boundary-conditions" title="Permalink to this headline">¶</a></h4>
<p>It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code class="docutils literal"><span class="pre">SubDomain.inside</span></code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the output.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="c"># Print the vertices that are on the boundaries</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bx0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bx1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on x=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on y=1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
    <span class="c"># Print the Dirichlet conditions</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;No of Dirichlet conditions:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcs</span><span class="p">))</span>
    <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
        <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;   at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>In addition, it is helpful to print the exact and the numerical solution
at all the vertices as shown in the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Writing out the discrete solution</span></a>.</p>
</div>
<div class="section" id="implementation-of-multiple-subdomains">
<h4>Implementation of multiple subdomains<a class="headerlink" href="#implementation-of-multiple-subdomains" title="Permalink to this headline">¶</a></h4>
<p>The section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a> explains how to deal with
multiple subdomains of <span class="math">\(\Omega\)</span> and a piecewise constant coefficient
function <span class="math">\(p\)</span> that takes on different constant values in the different
subdomains. We can easily add this type of <span class="math">\(p\)</span> coefficient to the
<code class="docutils literal"><span class="pre">solver_bc</span></code> function. The signature of the function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_bc</span><span class="p">(</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>                   <span class="c"># Coefficients in the PDE</span>
    <span class="n">boundary_conditions</span><span class="p">,</span>    <span class="c"># Dict of boundary conditions</span>
    <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>                 <span class="c"># Cell division of the domain</span>
    <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c"># Polynomial degree</span>
    <span class="n">subdomains</span><span class="o">=</span><span class="p">[],</span>          <span class="c"># List of SubDomain objects in domain</span>
    <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;Krylov&#39;</span><span class="p">,</span> <span class="c"># Alt: &#39;direct&#39;</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">,</span>           <span class="c"># Absolute tolerance in Krylov solver</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span>           <span class="c"># Relative tolerance in Krylov solver</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>          <span class="c"># Max no of iterations in Krylov solver</span>
    <span class="n">log_level</span><span class="o">=</span><span class="n">PROGRESS</span><span class="p">,</span>     <span class="c"># Amount of solver output</span>
    <span class="n">dump_parameters</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># Write out parameter database?</span>
    <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="o">...</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span>   <span class="c"># p may be modified</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">subdomain</span></code> is an empty list, we assume there are no subdomains, and
<span class="math">\(p\)</span> is an <code class="docutils literal"><span class="pre">Expression</span></code> or <code class="docutils literal"><span class="pre">Constant</span></code> object specifying a formula for
<span class="math">\(p\)</span>. If not, <code class="docutils literal"><span class="pre">subdomain</span></code> is a list of <code class="docutils literal"><span class="pre">SubDomain</span></code> objects, defining
different parts of the domain. The first element is a dummy object,
defining &#8220;the rest&#8221; of the domain. The next elements define specific
geometries in the <code class="docutils literal"><span class="pre">inside</span></code> methods. We start by marking all elements
with subdomain number 0, this will then be &#8220;the rest&#8221; after marking
subdomains 1, 2, and so on. The next step is to define <code class="docutils literal"><span class="pre">p</span></code> as a
piecewise constant function over cells and fill it with values.
We assume that the user-argument <code class="docutils literal"><span class="pre">p</span></code> is an array (or list) holding
the values of <span class="math">\(p\)</span> in the different parts corresponding to <code class="docutils literal"><span class="pre">subdomains</span></code>.
The returned <code class="docutils literal"><span class="pre">p</span></code> is needed for flux computations. If there are no
subdomains, the returned <code class="docutils literal"><span class="pre">p</span></code> is just the original <code class="docutils literal"><span class="pre">p</span></code> argument.</p>
<p>The appropriate code for computing <code class="docutils literal"><span class="pre">p</span></code> becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="k">if</span> <span class="n">subdomains</span><span class="p">:</span>
    <span class="c"># subdomains is list of SubDomain objects,</span>
    <span class="c"># p is array of corresponding constant values of p</span>
    <span class="c"># in each subdomain</span>
    <span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
    <span class="n">materials</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># &quot;the rest&quot;</span>
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">subdomain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subdomains</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">subdomain</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="n">p_values</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
    <span class="n">help</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">p_values</span><span class="p">)</span>
</pre></div>
</div>
<p>We define <span class="math">\(p(x,y)=p_0\)</span> in <span class="math">\(\Omega_0\)</span> and <span class="math">\(k(x,y)=p_1\)</span> in <span class="math">\(\Omega_1\)</span>,
where <span class="math">\(p_0&gt;0\)</span> and <span class="math">\(p_1&gt;0\)</span> are given constants.
As boundary conditions, we choose <span class="math">\(u=0\)</span> at <span class="math">\(y=0\)</span>, <span class="math">\(u=1\)</span> at <span class="math">\(y=1\)</span>,
and <span class="math">\(\partial u/\partial n=0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>.
One can show that the exact solution is now given by</p>
<div class="math" id="eq-auto24">
\[\begin{split}\tag{74}
u(x, y) = \left\lbrace\begin{array}{ll}
    {2yp_1\over p_0+p_1}, &amp; y \leq 1/2\\
    {(2y-1)p_0 + p_1\over p_0+p_1}, &amp; y \geq 1/2
    \end{array}\right.\end{split}\]</div>
<p>As long as the element boundaries coincide with the internal boundary
<span class="math">\(y=1/2\)</span>, this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We can use this property to verify
the implementation and make a unit test for a series of function
spaces:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solvers_bc_2mat</span><span class="p">():</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">2E-13</span>  <span class="c"># Tolerance for comparisons</span>

    <span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="o">+</span><span class="n">tol</span>

    <span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">-</span><span class="n">tol</span>

    <span class="n">subdomains</span> <span class="o">=</span> <span class="p">[</span><span class="n">Omega0</span><span class="p">(),</span> <span class="n">Omega1</span><span class="p">()]</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">]</span>
    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Neumann&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="c"># y=0</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="c"># y=1</span>
        <span class="p">}</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span>
        <span class="s">&#39;x[1] &lt;= 0.5? 2*x[1]*p_1/(p_0+p_1) : &#39;</span>
        <span class="s">&#39;((2*x[1]-1)*p_0 + p_1)/(p_0+p_1)&#39;</span><span class="p">,</span>
        <span class="n">p_0</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_1</span><span class="o">=</span><span class="n">p_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">)]:</span>
        <span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">solver_bc</span><span class="p">(</span>
                <span class="n">p_values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
                <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">,</span>
                <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="c"># Compute max error in infinity norm</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                           <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">max_error</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="refactoring-of-a-solver-function-into-solver-and-problem-classes">
<h3>Refactoring of a solver function into solver and problem classes<a class="headerlink" href="#refactoring-of-a-solver-function-into-solver-and-problem-classes" title="Permalink to this headline">¶</a></h3>
<p>A FEniCS solver for a PDE can be implemented in a general way, but
the problem-dependent data, like boundary conditions, must be specified
in each case by the user. The implementation in the previous section
required the user to supply a <code class="docutils literal"><span class="pre">boundary_conditions</span></code> dictionary with
specifications of the boundary condition on each of the four sides of
the unit square. If we, e.g., want two Dirichlet conditions at one
side, as our mathematical formulation of the problem in the previous
section in fact supports, this is not possible without extending
the <code class="docutils literal"><span class="pre">solver_bc</span></code> function.</p>
<p>A different software design is to introduce a problem class and
methods, supplied by the user from case to case, where boundary
conditions and other input data are defined. Such a design is used in
a lot of more advanced FEniCS application codes, and it is time to
exemplify it here.  As a counterpart to the solver function, we
introduce a solver class, but all the arguments for various input data
are instead method calls to an instance of a <em>problem class</em>. This
puts a somewhat greater burden on the programmer, but it allows for
more flexibility, and the code for, e.g., boundary conditions can be
more tailored to the problem at hand than the code we introduced in
the <code class="docutils literal"><span class="pre">solver_bc</span></code> function in the previous section.</p>
<p>The solver class will need problem information and for this purpose
call up the methods in a problem class. For example, the solver
gets the <span class="math">\(f\)</span> and <span class="math">\(p\)</span> functions in the PDE problem by calling
<code class="docutils literal"><span class="pre">problem.f_rhs()</span></code> and <code class="docutils literal"><span class="pre">problem.p_coeff()</span></code>. The mesh object and the
polynomial degree of the elements are supposed to be returned from
<code class="docutils literal"><span class="pre">problem.mesh_degree()</span></code>. Furthermore, the problem class defines the
boundary conditions in the problem as lists of minimal information
from which the solver can build proper data structures.</p>
<p>The solver class is a wrapping of the previous <code class="docutils literal"><span class="pre">solver_bc</span></code> and <code class="docutils literal"><span class="pre">flux</span></code>
functions as methods in a class, but some of the code for handling
boundary conditions in <code class="docutils literal"><span class="pre">solver_bc</span></code> is now delegated to the user in
the problem class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">mesh_degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">Dirichlet_cond</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">Dirichlet_conditions</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Dirichlet_cond</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">)):</span>
            <span class="c"># Just one Expression for Dirichlet conditions on</span>
            <span class="c"># the entire boundary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span>
                <span class="n">V</span><span class="p">,</span> <span class="n">Dirichlet_cond</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">:</span> <span class="n">on_boundary</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Boundary SubDomain markers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">index</span>
                <span class="ow">in</span> <span class="n">Dirichlet_cond</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="c"># Print the Dirichlet conditions</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;No of Dirichlet conditions:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">))</span>
            <span class="n">coor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
            <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">:</span>
                <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&#39;   at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                              <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">p_coeff</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>  <span class="c"># store for flux computations</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">f_rhs</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">F</span> <span class="o">-=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">F</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds_</span>
                  <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">ds_</span> <span class="ow">in</span> <span class="n">problem</span><span class="o">.</span><span class="n">Neumann_conditions</span><span class="p">()])</span>
        <span class="n">F</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">ds_</span>
                  <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ds_</span> <span class="ow">in</span> <span class="n">problem</span><span class="o">.</span><span class="n">Robin_conditions</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">V</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;A:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;b:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">):</span>
        <span class="c"># Compute solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">linear_solver</span> <span class="o">==</span> <span class="s">&#39;Krylov&#39;</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                                 <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;lu&#39;</span><span class="p">}</span>

        <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">,</span>
              <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>

    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute and return flux -p*grad(u).&quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">),</span> <span class="n">V_g</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;flux(u)&#39;</span><span class="p">,</span> <span class="s">&#39;continuous flux field&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_u</span>
</pre></div>
</div>
<p>Note that this is a general Poisson problem solver that works in any number
of space dimensions and with any mesh and composition of boundary conditions.</p>
<div class="admonition-tip-be-careful-with-the-mesh-variable admonition">
<p class="first admonition-title">Tip: Be careful with the <code class="docutils literal"><span class="pre">mesh</span></code> variable</p>
<p class="last">In classes, one often stores the mesh in <code class="docutils literal"><span class="pre">self.mesh</span></code>. When you need
the mesh, it is easy to write just <code class="docutils literal"><span class="pre">mesh</span></code>, but this gives rise to
peculiar error messages, since <code class="docutils literal"><span class="pre">mesh</span></code> is a Python module imported
by <code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code> and already available as a name in your file.
When encountering strange error messages in statements containing a
variable <code class="docutils literal"><span class="pre">mesh</span></code>, make sure you use <code class="docutils literal"><span class="pre">self.mesh</span></code>.</p>
</div>
<p>Below is the specific problem class for solving a scaled 2D Poisson
problem.  We have a two-material domain where a rectangle
<span class="math">\([0.3,0.7]\times [0.3,0.7]\)</span> is embedded in the unit square and where
<span class="math">\(p\)</span> has a constant value inside the rectangle and another value
outside. On <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span> we have homogeneous Neumann conditions,
and on <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span> we have the Dirichlet conditions <span class="math">\(u=1\)</span> and
<span class="math">\(u=0\)</span>, respectively.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Problem1</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    -div(p*grad(u)=f on the unit square.</span>
<span class="sd">    General Dirichlet, Neumann, or Robin condition along each</span>
<span class="sd">    side. Can have multiple subdomains with p constant in</span>
<span class="sd">    each subdomain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize mesh, boundary parts, and p.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

        <span class="k">class</span> <span class="nc">BoundaryX0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">class</span> <span class="nc">BoundaryX1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">class</span> <span class="nc">BoundaryY0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">class</span> <span class="nc">BoundaryY1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="c"># Mark boundaries</span>
        <span class="c">#self.boundary_parts = FacetFunction(&#39;size_t&#39;, mesh)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">9999</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bx0</span> <span class="o">=</span> <span class="n">BoundaryX0</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bx1</span> <span class="o">=</span> <span class="n">BoundaryX1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">by0</span> <span class="o">=</span> <span class="n">BoundaryY0</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">by1</span> <span class="o">=</span> <span class="n">BoundaryY1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bx0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bx1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">by0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">by1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span>  <span class="n">Measure</span><span class="p">(</span>
            <span class="s">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">subdomain_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">)</span>

        <span class="c"># The domain is the unit square with an embedded rectangle</span>
        <span class="k">class</span> <span class="nc">Rectangle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
                <span class="k">return</span> <span class="mf">0.3</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.7</span> <span class="ow">and</span> <span class="mf">0.3</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.7</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s">&#39;size_t&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># &quot;the rest&quot;</span>
        <span class="n">subdomain</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">()</span>
        <span class="n">subdomain</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V0</span><span class="p">)</span>
        <span class="n">help</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">p_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1E-3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">p_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mesh_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">p_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>

    <span class="k">def</span> <span class="nf">f_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Dirichlet_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of (value,boundary) pairs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">Neumann_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of g*ds(n) values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">))]</span>
</pre></div>
</div>
<p>A specific problem can be solved by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">Problem1</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solution</span><span class="p">()</span>
    <span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;potential&#39;</span><span class="p">)</span>  <span class="c"># name &#39;u&#39; is used in plot</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">flux_u</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">flux</span><span class="p">()</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">flux_u</span><span class="p">)</span>
    <span class="n">vtkfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
    <span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
    <span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code is found in the file <code class="docutils literal"><span class="pre">ft08_poisson_class.py</span></code>.</p>
<div class="admonition-pros-and-cons-of-solver-problem-classes-vs-solver-function admonition">
<p class="first admonition-title">Pros and cons of solver/problem classes vs solver function</p>
<p class="last">What are the advantages of class <code class="docutils literal"><span class="pre">Solver</span></code> and <code class="docutils literal"><span class="pre">Problem</span></code> over the
function implementation in the section <a class="reference internal" href="#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>?
The primary advantage is that
the class version works for any mesh and any composition of
boundary conditions, while the solver function is tied to a mesh
over the unit square, only one type of boundary condition on a
each side, and a piecewise constant <span class="math">\(p\)</span> function. The programmer has
to supply more code in the class version, but gets greater flexibility.
The disadvantage of the class version is that it applies the class
concept so one needs experience with Python class programming.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>