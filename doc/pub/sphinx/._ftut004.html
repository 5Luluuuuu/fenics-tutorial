<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A Gallery of finite element solvers</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="The Poisson solver revisited" href="._ftut005.html" />
    <link rel="prev" title="The Fundamentals: A Poisson equation solver" href="._ftut003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-gallery-of-finite-element-solvers">
<span id="ch-gallery"></span><h1>A Gallery of finite element solvers<a class="headerlink" href="#a-gallery-of-finite-element-solvers" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The goal of this chapter is to show how a range of important PDEs
from science and engineering can be quickly solved with a few lines
of FEniCS code. We start with the time-dependent diffusion equation
and continue with a nonlinear Poisson equation, the vector PDE for
linear elasticity, and the Navier-Stokes equations.</p>
<p>We derive the variational formulation and put
together basic objects such as <code class="docutils literal"><span class="pre">Mesh</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>,
<code class="docutils literal"><span class="pre">FunctionSpace</span></code>, <code class="docutils literal"><span class="pre">TrialFunction</span></code>,
and <code class="docutils literal"><span class="pre">TestFunction</span></code> to express in variational formulation in Python code
in a way that closely resembles the mathematics.</p>
</div></blockquote>
<div class="section" id="the-time-dependent-diffusion-equation">
<span id="ch-fundamentals-diffusion"></span><h2>The time-dependent diffusion equation<a class="headerlink" href="#the-time-dependent-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>The examples in the section <a class="reference internal" href="._ftut003.html#ch-poisson0-impl"><span class="std std-ref">FEniCS implementation</span></a>
illustrate that solving linear, stationary PDE problems with the aid
of FEniCS is easy and requires little programming.  FEniCS clearly
automates the spatial discretization by the finite element method. One
can use a separate, one-dimensional finite element method in the
domain as well, but very often, it is easier to just use a finite
difference method, or to formulate the problem as an ODE system and
leave the time-stepping to an ODE solver.</p>
<p>[<strong>hpl 7</strong>: Should exemplify all three approaches? With emphasis on simple finite differences?]</p>
<div class="section" id="variational-formulation-1">
<span id="ftut-timedep-diffusion1"></span><h3>Variational formulation<a class="headerlink" href="#variational-formulation-1" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Our model problem for time-dependent PDEs reads</p>
<div class="math" id="eq-ch-diffusion0-pde1">
\[\tag{17}
{\partial u\over\partial t} = \nabla^2 u + f\hbox{ in }\Omega,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-bc">
\[\tag{18}
u = u_0\hbox{ on } \partial \Omega,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-ic">
\[\tag{19}
u = I \mbox{ at } t=0{\thinspace .}\]</div>
<p>Here, <span class="math">\(u\)</span> varies with space and time, e.g., <span class="math">\(u=u(x,y,t)\)</span> if the spatial
domain <span class="math">\(\Omega\)</span> is two-dimensional. The source function <span class="math">\(f\)</span> and the
boundary values <span class="math">\(u_0\)</span> may also vary with space and time.
The initial condition <span class="math">\(I\)</span> is a function of space only.</p>
<p>A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a recursive set of
stationary problems, and then turn each stationary problem into a
variational formulation.</p>
<p>Let superscript <span class="math">\(k\)</span> denote a quantity at time <span class="math">\(t_k\)</span>, where <span class="math">\(k\)</span> is an
integer counting time levels. For example, <span class="math">\(u^k\)</span> means <span class="math">\(u\)</span> at time
level <span class="math">\(k\)</span>.  A finite difference discretization in time first consists
in sampling the PDE at some time level, say <span class="math">\(k\)</span>:</p>
<div class="math" id="eq-ch-diffusion0-pde1-tk">
\[\tag{20}
{\partial \over\partial t}u^k = \nabla^2 u^k + f^k{\thinspace .}\]</div>
<p>The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:</p>
<div class="math" id="eq-ch-diffusion0-be">
\[\tag{21}
{\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{{\Delta t}}},\]</div>
<p>where <span class="math">\({\Delta t}\)</span> is the time discretization parameter.
Inserting <a class="reference internal" href="#eq-ch-diffusion0-be"><span class="std std-ref">(21)</span></a> in <a class="reference internal" href="#eq-ch-diffusion0-pde1-tk"><span class="std std-ref">(20)</span></a> yields</p>
<div class="math" id="eq-ch-diffusion0-pde1-be">
\[\tag{22}
{u^k - u^{k-1}\over{{\Delta t}}} = \nabla^2 u^k + f^k{\thinspace .}\]</div>
<p>This is our time-discrete version of the diffusion PDE
<a class="reference internal" href="#eq-ch-diffusion0-pde1"><span class="std std-ref">(17)</span></a>.</p>
<p>We may reorder <a class="reference internal" href="#eq-ch-diffusion0-pde1-be"><span class="std std-ref">(22)</span></a> so
that the left-hand side contains the terms with the unknown <span class="math">\(u^k\)</span> and
the right-hand side contains computed terms only. The result
is a recursive set of spatial
(stationary) problems for <span class="math">\(u^k\)</span> (assuming <span class="math">\(u^{k-1}\)</span> is known from
computations at the previous time level):</p>
<div class="math" id="eq-ch-diffusion0-pde1-u0">
\[\tag{23}
u^0 = I,\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-uk">
\[\tag{24}
u^k - {{\Delta t}}\nabla^2 u^k =  u^{k-1} + {{\Delta t}} f^k,\quad k=1,2,\ldots\]</div>
<p>Given <span class="math">\(I\)</span>, we can solve for <span class="math">\(u^0\)</span>, <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and so on.</p>
<p>An alternative to <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a>, which can be
convenient in implementations, is to collect
all terms on one side of the equality sign:</p>
<div class="math" id="eq-ch-diffusion0-pde1-uk2">
\[\tag{25}
F(u;v) = u^k - {{\Delta t}}\nabla^2 u^k -  u^{k-1} - {{\Delta t}} f^k = 0,\quad k=1,2,\ldots\]</div>
<p>We use a finite element method to solve
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0"><span class="std std-ref">(23)</span></a> and either of the equations
<a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a> or <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk2"><span class="std std-ref">(25)</span></a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function <span class="math">\(v\in \hat V\)</span> and integrate second-derivatives by
parts. Introducing the symbol <span class="math">\(u\)</span> for <span class="math">\(u^k\)</span> (which is natural in the
program), the resulting weak form arising from
formulation <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk"><span class="std std-ref">(24)</span></a>
can be conveniently written in
the standard notation:</p>
<div class="math">
\[a(u,v)=L(v),\]</div>
<p>where</p>
<div class="math" id="eq-ch-diffusion0-pde1-a">
\[\tag{26}
a(u,v) = \int_\Omega\left( uv + {{\Delta t}}
    \nabla u\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-l">
\[\tag{27}
L(v) = \int_\Omega \left(u^{k-1} + {{\Delta t}}  f^k\right)v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The alternative form <a class="reference internal" href="#eq-ch-diffusion0-pde1-uk2"><span class="std std-ref">(25)</span></a> has an
abstract formulation</p>
<div class="math">
\[F(u;v) = 0,\]</div>
<p>where</p>
<div class="math" id="eq-ch-diffusion0-pde1-f">
\[\tag{28}
F = \int_\Omega\left( uv + {{\Delta t}}
    \nabla u\cdot \nabla v -
    \left(u^{k-1} - {{\Delta t}}  f^k\right)v\right) {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The initial condition <a class="reference internal" href="#eq-ch-diffusion0-pde1-u0"><span class="std std-ref">(23)</span></a>
can also be turned into a weak form,</p>
<div class="math">
\[a_0(u,v)=L_0(v),\]</div>
<p>with</p>
<div class="math" id="eq-ch-diffusion0-pde1-a0">
\[\tag{29}
a_0(u,v) = \int_\Omega uv {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-ch-diffusion0-pde1-l0">
\[\tag{30}
L_0(v) = \int_\Omega Iv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The alternative is to construct <span class="math">\(u_0\)</span> by just interpolating <span class="math">\(I\)</span>
(which is also a much cheaper operation since no linear system is
involved).</p>
<p>The continuous variational problem is to find
<span class="math">\(u^0\in V\)</span> such that <span class="math">\(a_0(u^0,v)=L_0(v)\)</span> holds for all <span class="math">\(v\in\hat V\)</span>,
and then find <span class="math">\(u^k\in V\)</span>
such that <span class="math">\(a(u^k,v)=L(v)\)</span> for all <span class="math">\(v\in\hat V\)</span>,
or alternatively, <span class="math">\(F(u^k,v)=0\)</span> for all <span class="math">\(v\in\hat V\)</span>,
<span class="math">\(k=1,2,\ldots\)</span>.</p>
<p>Approximate solutions in space are found by restricting the functional
spaces <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> to finite-dimensional spaces, exactly as we
have done in the Poisson problems.  We shall use the symbol <span class="math">\(u\)</span> for
the finite element approximation at time <span class="math">\(t_k\)</span>. In case we need to
distinguish this space-time discrete approximation from the exact
solution of the continuous diffusion problem, we use <span class="math">\({u_{\small\mbox{e}}}\)</span> for the
latter.  By <span class="math">\(u^{k-1}\)</span> we mean the finite element approximation of the
solution at time <span class="math">\(t_{k-1}\)</span>.</p>
<p>Instead of solving <a class="reference internal" href="#eq-ch-diffusion0-pde1-u0"><span class="std std-ref">(23)</span></a> by a finite element
method, i.e., projecting <span class="math">\(I\)</span> onto <span class="math">\(V\)</span> via the problem
<span class="math">\(a_0(u,v)=L_0(v)\)</span>, we could simply interpolate <span class="math">\(u^0\)</span> from <span class="math">\(I\)</span>. That
is, if <span class="math">\(u^0=\sum_{j=1}^N U^0_j\phi_j\)</span>, we simply set <span class="math">\(U_j=I(x_j,y_j)\)</span>,
where <span class="math">\((x_j,y_j)\)</span> are the coordinates of node number <span class="math">\(j\)</span>. We refer to
these two strategies as computing the initial condition by either
projecting <span class="math">\(I\)</span> or interpolating <span class="math">\(I\)</span>.  Both operations are easy to
compute through one statement, using either the <code class="docutils literal"><span class="pre">project</span></code> or
<code class="docutils literal"><span class="pre">interpolate</span></code> function.</p>
</div>
<div class="section" id="a-simple-implementation-1">
<span id="ftut-timedep-diffusion1-impl"></span><h3>A simple implementation<a class="headerlink" href="#a-simple-implementation-1" title="Permalink to this headline">¶</a></h3>
<p>Our program needs to implement the time stepping explicitly, but can
rely on FEniCS to easily compute <span class="math">\(a_0\)</span>, <span class="math">\(L_0\)</span>, <span class="math">\(F\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(L\)</span>, and solve
the linear systems for the unknowns.</p>
<div class="section" id="test-problem-1">
<h4>Test problem<a class="headerlink" href="#test-problem-1" title="Permalink to this headline">¶</a></h4>
<p>Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,</p>
<div class="math" id="eq-ch-diffusion0-pde1-u0test">
\[\tag{31}
u = 1 + x^2 + \alpha y^2 + \beta t,\]</div>
<p>yields a function whose computed values at the nodes will be exact,
regardless of the size of the elements and <span class="math">\({\Delta t}\)</span>, as long as the mesh
is uniformly partitioned.  By inserting
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a> in the PDE problem
<a class="reference internal" href="#eq-ch-diffusion0-pde1"><span class="std std-ref">(17)</span></a>, it follows that <span class="math">\(u_0\)</span> must be given as
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a> and that <span class="math">\(f(x,y,t)=\beta - 2 -
2\alpha\)</span> and <span class="math">\(I(x,y)=1+x^2+\alpha y^2\)</span>.</p>
</div>
<div class="section" id="the-code">
<span id="index-1"></span><h4>The code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h4>
<p>A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition <span class="math">\(u_0\)</span> given by
<a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a>.  A natural solution is to apply an
<code class="docutils literal"><span class="pre">Expression</span></code> object with time <span class="math">\(t\)</span> as a parameter, in addition to the
parameters <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This function expression has the components of <code class="docutils literal"><span class="pre">x</span></code> as independent
variables, while <code class="docutils literal"><span class="pre">alpha</span></code>, <code class="docutils literal"><span class="pre">beta</span></code>, and <code class="docutils literal"><span class="pre">t</span></code> are parameters.  The
parameters can later be updated as in</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>The essential boundary conditions, along the entire boundary in this case,
are set in the usual way,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>We shall use <code class="docutils literal"><span class="pre">u</span></code> for the unknown <span class="math">\(u\)</span> at the new time level and <code class="docutils literal"><span class="pre">u_1</span></code>
for <span class="math">\(u\)</span> at the previous time level.  The initial value of <code class="docutils literal"><span class="pre">u_1</span></code>,
implied by the initial condition on <span class="math">\(u\)</span>, can be computed by either
projecting or interpolating <span class="math">\(I\)</span>.  The <span class="math">\(I(x,y)\)</span> function is available
in the program through <code class="docutils literal"><span class="pre">u0</span></code>, as long as <code class="docutils literal"><span class="pre">u0.t</span></code> is zero.  We can then
do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-projecting-versus-interpolating-the-initial-condition admonition">
<p class="first admonition-title">Projecting versus interpolating the initial condition</p>
<p class="last">To actually recover the
exact solution <a class="reference internal" href="#eq-ch-diffusion0-pde1-u0test"><span class="std std-ref">(31)</span></a> to machine precision,
it is important not to compute the discrete initial condition by
projecting <span class="math">\(I\)</span>, but by interpolating <span class="math">\(I\)</span> so that the degrees of freedom have
exact values at <span class="math">\(t=0\)</span> (projection results in approximative values at the
nodes).</p>
</div>
<p>We may either define <span class="math">\(a\)</span> or <span class="math">\(L\)</span> according to the formulas above, or
we may just define <span class="math">\(F\)</span> and ask FEniCS to figure out which terms that
go into the bilinear form <span class="math">\(a\)</span> and which that go into the linear form
<span class="math">\(L\)</span>. The latter is convenient, especially in more complicated problems,
so we illustrate that construction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span>      <span class="c"># time step</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we perform the time stepping in a loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">2</span>             <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>

<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-remember-to-update-expression-objects-with-the-current-time admonition">
<p class="first admonition-title">Remember to update expression objects with the current time</p>
<p class="last">Inside the time loop,
observe that <code class="docutils literal"><span class="pre">u0.t</span></code> must be updated before the <code class="docutils literal"><span class="pre">solve</span></code> statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the <code class="docutils literal"><span class="pre">u0</span></code> object
for values.)</p>
</div>
<p>The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in the Poisson equation example in
the section <a class="reference internal" href="._ftut003.html#ch-poisson0-impl-dissect"><span class="std std-ref">Dissection of the program</span></a>, we compute the
difference between the array of nodal values of <code class="docutils literal"><span class="pre">u</span></code> and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after <code class="docutils literal"><span class="pre">u</span></code> is found:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
               <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;error, t=</span><span class="si">%.2f</span><span class="s">: </span><span class="si">%-10.3g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">max_error</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete program code for this time-dependent case goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Initial condition</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c">#project(u0, V) will not result in exact solution at the nodes!</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span>      <span class="c"># time step</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.9</span>           <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;time =&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="c"># Verify</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                   <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;error, t=</span><span class="si">%.2f</span><span class="s">: </span><span class="si">%-10.3g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>The code is available in the
file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/diffusion_flat1.py">ft02_diffusion_flat1.py</a>.</p>
</div>
</div>
<div class="section" id="diffusion-of-a-gaussian-function">
<h3>Diffusion of a Gaussian function<a class="headerlink" href="#diffusion-of-a-gaussian-function" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-mathematical-problem">
<h4>The mathematical problem<a class="headerlink" href="#the-mathematical-problem" title="Permalink to this headline">¶</a></h4>
<p>Now we want to solve a more physical problem, namely the diffusion of
a Gaussian hill. It means that the initial condition is given by</p>
<div class="math">
\[I(x,y)= e^{-ax^2 - ay^2}\]</div>
<p>on a domain <span class="math">\([-2,2]\times [2,2]\)</span>. A possible value of <span class="math">\(a\)</span> is 5.</p>
</div>
<div class="section" id="implementation-1">
<h4>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h4>
<p>What are the necessary changes to the previous program?</p>
<ol class="arabic simple">
<li>The domain is not the unit square and it needs much higher resolution: <code class="docutils literal"><span class="pre">mesh</span> <span class="pre">=</span> <span class="pre">RectangleMesh(Point(-2,-2),</span> <span class="pre">Point(2,2),</span> <span class="pre">30,</span> <span class="pre">30)</span></code>.</li>
<li>The boundary condition is zero everywhere: <code class="docutils literal"><span class="pre">DirichletBC(V,</span> <span class="pre">Constant(0),</span> <span class="pre">boundary)</span></code>.</li>
<li>The initial condition is different: <code class="docutils literal"><span class="pre">I</span> <span class="pre">=</span> <span class="pre">Expression('exp(...)')</span></code>.</li>
<li>The time step should be sufficiently small: <code class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">0.01</span></code> or <code class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">0.05</span></code>.</li>
<li>The right-hand side function <code class="docutils literal"><span class="pre">f</span></code> is zero: <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">Constant(0)</span></code> (just <code class="docutils literal"><span class="pre">0</span></code>
will given an error as functions in FEniCS must be <code class="docutils literal"><span class="pre">Expression</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>
(over a mesh) or <code class="docutils literal"><span class="pre">Constant</span></code>).</li>
<li>The end time for the simulation must be longer: <code class="docutils literal"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">0.8</span></code>.</li>
<li>The initial condition and the solution inside the time loop should be
stored to file in VTK format for visualization: <code class="docutils literal"><span class="pre">vtkfile</span> <span class="pre">&lt;&lt;</span> <span class="pre">(u,</span> <span class="pre">t)</span></code>.</li>
<li>We can add a <code class="docutils literal"><span class="pre">plot(u)</span></code> command inside the time loop as well.</li>
</ol>
<p>The complete program appears below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Initial condition</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;exp(-a*pow(x[0],2)-a*pow(x[1],2))&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">u_1</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;initial condition&#39;</span><span class="p">)</span>
<span class="n">vtkfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;diffusion.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="c">#project(u0, V) will not result in exact solution at the nodes!</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.01</span>    <span class="c"># time step</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>             <span class="c"># the unknown at a new time level</span>
<span class="n">u</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;solution&#39;</span><span class="p">)</span>   <span class="c"># name and label for u</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">0.5</span>                     <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;time =&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
    <span class="n">vtkfile</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualization-in-paraview">
<h4>Visualization in ParaView<a class="headerlink" href="#visualization-in-paraview" title="Permalink to this headline">¶</a></h4>
<p>Start ParaView, choose <strong>File - Open</strong>, open the file <code class="docutils literal"><span class="pre">diffusion.pvd</span></code>,
click the green <strong>Apply</strong> button on the left to see the initial condition
being plotting. Choose <strong>View - Animation View</strong>. Click on the play button
or (better) the next frame button in the row of buttons at the top of the GUI
to see the evolution of the scalar field you just have computed:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/paraview_animation_buttons.png"><img alt="_images/paraview_animation_buttons.png" src="_images/paraview_animation_buttons.png" style="width: 300px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>The cross in the middle of the plot can be turned off by the <strong>Show Center</strong>
button:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/paraview_show_center_button.png"><img alt="_images/paraview_show_center_button.png" src="_images/paraview_show_center_button.png" style="width: 150px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>Choose <strong>File - Save Animation...</strong> to save the animation to the OGG video format.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov/diffusion0.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><div class="figure">
<a class="reference internal image-reference" href="_images/diffusion0_paraview_animation.png"><img alt="_images/diffusion0_paraview_animation.png" src="_images/diffusion0_paraview_animation.png" style="width: 600px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/diffusion0_3snapshots.png"><img alt="_images/diffusion0_3snapshots.png" src="_images/diffusion0_3snapshots.png" style="width: 800px;" /></a>
</div>
</div>
</div>
</div>
<div class="section" id="a-nonlinear-poisson-equation">
<h2>A nonlinear Poisson equation<a class="headerlink" href="#a-nonlinear-poisson-equation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="variational-formulation-2">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-2" title="Permalink to this headline">¶</a></h3>
<p>Now we shall address how to solve nonlinear PDEs in FEniCS. Our
sample PDE for implementation is taken as a nonlinear Poisson equation:</p>
<div class="math" id="eq-auto5">
\[\tag{32}
-\nabla\cdot\left( q(u)\nabla u\right) = f,\]</div>
<p>in <span class="math">\(\Omega\)</span>, with <span class="math">\(u=u_0\)</span> on the boundary <span class="math">\(\partial\Omega\)</span>.
The coefficient <span class="math">\(q(u)\)</span> makes the equation nonlinear (unless <span class="math">\(q(u)\)</span>
is constant in <span class="math">\(u\)</span>).</p>
<p>The variational formulation of our model problem reads:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="eq-ch-poisson0-nonlinear1">
\[\tag{33}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>where</p>
<div class="math" id="eq-ch-poisson0-nonlinear2">
\[\tag{34}
F(u; v) = \int_\Omega (q(u)\nabla u\cdot \nabla v + fv){\, \mathrm{d}x},\]</div>
<p>and</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial Omega\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}{\thinspace .}\end{split}\]</div>
<p>The discrete problem arises as usual by restricting <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> to a
pair of discrete spaces. As usual, we omit any subscript on discrete
spaces and simply say <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> are chosen finite dimensional
according to some mesh with some element type.
Similarly, we let <span class="math">\(u\)</span> from now on be the discrete solution.</p>
<p>The discrete nonlinear problem is then written as: find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-ch-poisson0-nonlinear-d">
\[\tag{35}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>with <span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>. Since <span class="math">\(F\)</span> is a nonlinear function
of <span class="math">\(u\)</span>, the variational statement gives rise to a system of
nonlinear algebraic equations in the unknowns <span class="math">\(U_1,\ldots,U_N\)</span>.</p>
</div>
<div class="section" id="a-simple-implementation-2">
<span id="ftut-nonlinear-newton-auto"></span><h3>A simple implementation<a class="headerlink" href="#a-simple-implementation-2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="overview">
<h4>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>A working solver for the nonlinear Poisson equation is as easy to
implement as a solver for the corresponding linear problem.
All we need to do is the state the formula for <span class="math">\(F\)</span> and call
<code class="docutils literal"><span class="pre">solve(F</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> instead of <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> as we did
in the linear case. Here is a minimalistic code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>The major difference from a linear problem is that the unknown function
<code class="docutils literal"><span class="pre">u</span></code> in the variational form is in the nonlinear case
a <code class="docutils literal"><span class="pre">Function</span></code>, not a <code class="docutils literal"><span class="pre">TrialFunction</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">solve</span></code> function takes the nonlinear equations and derives symbolically
the Jacobian matrix and runs a Newton method.</p>
</div>
<div class="section" id="constructing-a-test-problem-with-sympy">
<h4>Constructing a test problem with SymPy<a class="headerlink" href="#constructing-a-test-problem-with-sympy" title="Permalink to this headline">¶</a></h4>
<p>Let us do a specific computation. We then need choices for <span class="math">\(f\)</span> and <span class="math">\(u_0\)</span>.
Previously, we have worked with manufactured solutions that can be
reproduced without approximation errors. This is more difficult in
nonlinear problems, and the algebra is more tedious. However, we may
utilize SymPy for symbolic computing and integrate such computations in the
FEniCS solver. This allows us to easily experiment with different
manufactured solutions. The forthcoming code with SymPy requires some
basic familiarity with this package (here, defining symbols, <code class="docutils literal"><span class="pre">diff</span></code> for
differentiation, <code class="docutils literal"><span class="pre">ccode</span></code> for C/C++ code generation).</p>
<p>We try out a two-dimensional manufactured
solution that is linear in the unknowns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Warning: from fenics import * imports f, q, and sym</span>
<span class="c"># (which overwrites our own f and q (function) objects</span>
<span class="c"># and also sym if we do import sympy as sym).</span>
<span class="c"># Therefore, do fenics import first and then overwrite</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonlinear coefficient in the PDE.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span>

<span class="c"># Use sympy to compute f given manufactured solution u</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x[0] x[1]&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="n">f</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> \
      <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-define-symbolic-coordinates-as-required-in-expression-objects admonition">
<p class="first admonition-title">Define symbolic coordinates as required in <code class="docutils literal"><span class="pre">Expression</span></code> objects</p>
<p class="last">Note that we would normally write <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x</span> <span class="pre">y')</span></code>, but
if we want the resulting expressions to be have valid syntax for
<code class="docutils literal"><span class="pre">Expression</span></code> objects, and then <span class="math">\(x\)</span> reads <code class="docutils literal"><span class="pre">x[0]</span></code> and <span class="math">\(y\)</span> must be <code class="docutils literal"><span class="pre">x[1]</span></code>.
This is easily accomplished with <code class="docutils literal"><span class="pre">sympy</span></code> by defining the names of <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">x[0]</span></code> and <code class="docutils literal"><span class="pre">x[1]</span></code>: <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">sym.symbols('x[0]</span> <span class="pre">x[1]')</span></code>.</p>
</div>
<p>Turning the expressions for <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">f</span></code> into C or C++ syntax for
<code class="docutils literal"><span class="pre">Expression</span></code> objects needs two steps. First we ask for the C code of
the expressions,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">f_code</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometimes we need some editing of the result to match the required syntax of
<code class="docutils literal"><span class="pre">Expression</span></code> objects, but not in this case. (The primary example is
that <code class="docutils literal"><span class="pre">M_PI</span></code> for <span class="math">\(\pi\)</span> in C/C++ must be replaced by <code class="docutils literal"><span class="pre">pi</span></code> for <code class="docutils literal"><span class="pre">Expression</span></code>
objects.) In our case here,
the output of <code class="docutils literal"><span class="pre">c_code</span></code> and <code class="docutils literal"><span class="pre">f_code</span></code> is</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">20</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
</pre></div>
</div>
<p>After having defined the mesh, the function space, and the boundary,
we define the boundary values, <code class="docutils literal"><span class="pre">u0</span></code>, as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">u_code</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we define the right-hand side function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_code</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file
<a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/ft03_poisson_flat_nonlinear.py">ft03_poisson_flat_nonlinear.py</a>.</p>
<div class="admonition-name-clash-between-fenics-and-program-variables admonition">
<p class="first admonition-title">Name clash between <code class="docutils literal"><span class="pre">fenics</span></code> and program variables</p>
<p class="last">In a program like the one above, strange errors may occur due to
name clashes. If you define <code class="docutils literal"><span class="pre">sym</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">f</span></code> prior to doing
<code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code>, the latter statement will also import
variables with the names <code class="docutils literal"><span class="pre">sym</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">f</span></code> and overwrite
the objects you had! This may lead to strange errors. The best
solution is to do <code class="docutils literal"><span class="pre">import</span> <span class="pre">fenics</span> <span class="pre">as</span> <span class="pre">fe</span></code> and prefix all FEniCS
object names by <code class="docutils literal"><span class="pre">fe</span></code>. The next best solution is to do the
<code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code> first and then define our own variables
that overwrite those imported from <code class="docutils literal"><span class="pre">fenics</span></code>. This is acceptable
if we do not need <code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">sym</span></code> from <code class="docutils literal"><span class="pre">fenics</span></code>.</p>
</div>
<p>Running the code gives output that tells how the Newton iteration
progresses. With <span class="math">\(2(6\times 4)\)</span> cells we get convergence in 7
iterations with a tolerance of <span class="math">\(10^{-9}\)</span>, and the error in the
numerical solution is about <span class="math">\(10^{-11}\)</span>. Using more elements, e.g.,
<span class="math">\(2(16\times 14)\)</span>, brings the error down to about <span class="math">\(10^{-15}\)</span>,
which provides evidence for a correct implementation.</p>
<p>The current example shows how easy it is to solve a nonlinear problem
in FEniCS. However, experts on numerical solution of nonlinear PDEs
know very well that automated procedures may fail in nonlinear
problems, and that it is often necessary to have much more manual
control of the solution process than what we have in the current
case. Therefore, we return to this problem in the chapter <a class="reference internal" href="._ftut007.html#ftut-nonlinear"><span class="std std-ref">The nonlinear Poisson solver revisited</span></a> and show how we can implement our own solution
algorithms for nonlinear equations and also how we can steer the
parameters in the automated Newton method used above. You will then
realize how easy it is to implement tailored solution strategies for
nonlinear problems in FEniCS.</p>
</div>
</div>
</div>
<div class="section" id="the-equations-of-linear-elasticity">
<span id="ftut-elast"></span><h2>The equations of linear elasticity<a class="headerlink" href="#the-equations-of-linear-elasticity" title="Permalink to this headline">¶</a></h2>
<p>Analysis of structures is one of the major activities in modern
engineering, thus making the PDEs for deformation of elastic bodies
most likely the most popular PDE model in the world.
It just takes a page of code to solve the equations of 2D or 3D
elasticity in FEniCS, and the details follows below.</p>
<div class="section" id="variational-formulation-3">
<span id="ftut-elast-varform"></span><h3>Variational formulation<a class="headerlink" href="#variational-formulation-3" title="Permalink to this headline">¶</a></h3>
<p>The equations governing small elastic deformations of a body <span class="math">\(\Omega\)</span>
can be written as</p>
<div class="math" id="eq-ftut-elast-varform-equilibrium">
\[\tag{36}
\nabla\cdot\sigma = \varrho f\hbox{ in }\Omega,\]</div>
<div class="math" id="eq-ftut-elast-varform-stresstrain">
\[\tag{37}
\sigma = \lambda\,\hbox{tr}\,\varepsilon I + 2\mu\varepsilon,\]</div>
<div class="math" id="eq-ftut-elast-varform-strainu">
\[\tag{38}
\varepsilon = \frac{1}{2}\left(\nabla u + (\nabla u)^T\right),\]</div>
<p>where <span class="math">\(\sigma\)</span> is the stress tensor, <span class="math">\(\varrho\)</span> is the density of the
material, <span class="math">\(f\)</span> is the body force, <span class="math">\(\lambda\)</span> and <span class="math">\(\mu\)</span> are Lame&#8217;s
elasticity coefficients for the material in <span class="math">\(\Omega\)</span> $I$ is the
identity tensor, tr is the trace operator on a tensor, <span class="math">\(\varepsilon\)</span>
is the strain tensor, and <span class="math">\(u\)</span> is the displacement vector field.</p>
<p>We shall combine <a class="reference internal" href="#eq-ftut-elast-varform-stresstrain"><span class="std std-ref">(37)</span></a> and
<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a> to</p>
<div class="math" id="eq-ftut-elast-varform-stressu">
\[\tag{39}
\sigma = \lambda\nabla\cdot u I + \mu(\nabla u + (\nabla u)^T){\thinspace .}\]</div>
<p>Note that <a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>-<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a>
can easily be transformed to a vector PDE for <span class="math">\(u\)</span>, which is the governing
PDE for the unknown <span class="math">\(u\)</span>. In the derivation of the variational formulation,
however, the splitting of the equations as done above is convenient.</p>
<p>The variational formulation of
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>-<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a>
consists of forming the inner product of
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a> and a <em>vector</em> test function
<span class="math">\(v\in \hat{V}\)</span>, where <span class="math">\(\hat{V}\)</span> is a test vector function space, and
integrating over the domain <span class="math">\(\Omega\)</span>:</p>
<div class="math">
\[\int_\Omega (\nabla\cdot\sigma) \cdot v {\, \mathrm{d}x} =
\int_\Omega \varrho f\cdot v{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Since <span class="math">\(\nabla\cdot\sigma\)</span> contains second-order derivatives of the primary
unknown <span class="math">\(u\)</span>, we integrate this term by parts:</p>
<div class="math">
\[\int_\Omega (\nabla\cdot\sigma) \cdot \nabla v {\, \mathrm{d}x}
-\int_\Omega \sigma : \nabla v{\, \mathrm{d}x} + \int_{\partial\Omega}
(\sigma\cdot n)\cdot v {\, \mathrm{d}s},\]</div>
<p>where the colon operator is the inner product between tensors, and <span class="math">\(n\)</span>
is the outward unit normal at the boundary. The quantity <span class="math">\(\sigma\cdot n\)</span>
is known as the <em>traction</em> or stress vector at the boundary, and is often
prescribed as a boundary condition. We assume that it is prescribed
at a part <span class="math">\(\partial\Omega_T\)</span> of the boundary and set <span class="math">\(T = \sigma\cdot n\)</span>.
We then have</p>
<div class="math">
\[\int_\Omega (\sigma : \nabla v + \varrho f\cdot v) = \int_{\partial\Omega_T}
T\cdot v{\, \mathrm{d}s}{\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-ftut-elast-varform-stressu"><span class="std std-ref">(39)</span></a> for <span class="math">\(\sigma\)</span> gives the
variational form with <span class="math">\(u\)</span> as unknown.</p>
<p>We can now summarize the variational formulation as find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-auto6">
\[\tag{40}
a(u,v) = L(v)\quad\forall v\in\hat{V},\]</div>
<p>where</p>
<div class="math" id="eq-auto7">
\[\tag{41}
a(u,v) = \int_\Omega\sigma(u) :\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto8">
\[\tag{42}
\sigma(u) = \lambda\nabla\cdot u I + \mu(\nabla u + (\nabla u)^T),\]</div>
<div class="math" id="eq-auto9">
\[\tag{43}
L(v) = -\int_\Omega \varrho f\cdot v{\, \mathrm{d}x} + \int_{\partial\Omega_T}
    T\cdot v{\, \mathrm{d}s}{\thinspace .}\]</div>
<p>One can show that the inner product of a symmetric tensor <span class="math">\(A\)</span> and a
non-symmetric tensor <span class="math">\(B\)</span> vanishes. If we express <span class="math">\(\nabla v\)</span> as a sum
of its symmetric and non-symmetric parts, only the symmetric part will
survive in the product <span class="math">\(\sigma :\nabla v\)</span> since <span class="math">\(\sigma\)</span> is a
symmetric tensor. This gives rise to the slightly different
variational form</p>
<div class="math" id="eq-auto10">
\[\tag{44}
a(u,v) = \int_\Omega\sigma(u) :\varepsilon(v) {\, \mathrm{d}x},\]</div>
<p>where <span class="math">\(\varepsilon(v)\)</span> is the symmetric part of <span class="math">\(v\)</span>:</p>
<div class="math">
\[\varepsilon(v) = \frac{1}{2}(\nabla v + (\nabla v)^T){\thinspace .}\]</div>
</div>
<div class="section" id="a-simple-implementation-3">
<h3>A simple implementation<a class="headerlink" href="#a-simple-implementation-3" title="Permalink to this headline">¶</a></h3>
<div class="section" id="test-problem-2">
<h4>Test problem<a class="headerlink" href="#test-problem-2" title="Permalink to this headline">¶</a></h4>
<p>As test example, we may look at a clamped beam deformed under its
own weight.  Then <span class="math">\(f=(0,0,-g)\)</span> is the body force with <span class="math">\(g\)</span> as the
acceleration of gravity. The beam is box-shaped with length <span class="math">\(L\)</span> and
square cross section of width <span class="math">\(W\)</span>. We set <span class="math">\(u=(0,0,0)\)</span> at the clamped
end, <span class="math">\(x=0\)</span>. The rest of the boundaries is traction free.</p>
<p>Let us scale the problem. [<strong>hpl 8</strong>: This was meant to simplify the problem so we don&#8217;t need values for <span class="math">\(\lambda\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho\)</span>, etc for a specific material, but the scaling requires some care.]
In the equation for <span class="math">\(u\)</span>, arising from inserting
<a class="reference internal" href="#eq-ftut-elast-varform-stresstrain"><span class="std std-ref">(37)</span></a> and
<a class="reference internal" href="#eq-ftut-elast-varform-strainu"><span class="std std-ref">(38)</span></a> in
<a class="reference internal" href="#eq-ftut-elast-varform-equilibrium"><span class="std std-ref">(36)</span></a>,</p>
<div class="math">
\[\nabla\cdot(\lambda\nabla\cdot u) + \mu\nabla^2 u = \varrho f,\]</div>
<p>we insert coordinates made dimensionless by <span class="math">\(L\)</span>, and <span class="math">\(\bar u=u/u_c\)</span>,
which results in the dimensionless governing equation</p>
<div class="math">
\[\bar\nabla\cdot(\bar\nabla\cdot \bar u) + \beta\bar\nabla^2 \bar u =
\bar f,\quad \bar f = (0,0,\gamma),\]</div>
<p>where <span class="math">\(\beta = \mu/\lambda\)</span> is a dimensionless elasticity parameter and</p>
<div class="math">
\[\gamma = \frac{\varrho gL^2}{u_c\lambda}{\thinspace .}\]</div>
<p>Sometimes, one will argue to chose <span class="math">\(u_c\)</span> to make <span class="math">\(\gamma\)</span> unity (<span class="math">\(u_c
= \varrho gL^2/\lambda\)</span>).  This is often the reasoning for getting a
<span class="math">\(\bar u\)</span> that is of order unity. However, in elasticity, this leads us
to displacements of the size of the geometry, which looks very strange
in plots.  We therefore want the characteristic displacement to be a
small fraction of the characteristic length of the geometry.
Actually, for a clamped beam, one has a deflection formula which gives
<span class="math">\(u_c = \frac{3}{2}\varrho gL^2\delta^2/E\)</span>, where <span class="math">\(\delta = L/W\)</span>.
Thus, the dimensionless parameter <span class="math">\(\delta\)</span> is very important in the
problem (as expected: <span class="math">\(\delta\gg 1\)</span> is what gives beam theory).
Taking <span class="math">\(E\)</span> to be of the same order of <span class="math">\(\lambda\)</span>, we realize that
<span class="math">\(\gamma \sim \delta^{-2}\)</span>.  Experiments with the code point to <span class="math">\(\gamma
= 0.25\delta^{-2}\)</span> as an appropriate choice.  We implement the code
with physical parameters, <span class="math">\(\lambda\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(g\)</span>, <span class="math">\(L\)</span>, and
<span class="math">\(W\)</span>, but set these to achieve the solution of the scaled problem:
<span class="math">\(\lambda = \varrho = L = 1\)</span>, <span class="math">\(W\)</span> as <span class="math">\(W/L\)</span>, <span class="math">\(g=\gamma\)</span>, and
<span class="math">\(\mu=\beta\)</span>.</p>
</div>
<div class="section" id="code">
<h4>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h4>
<p>[<strong>hpl 9</strong>: Must explain the code. New concepts here, though not many.]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Scaled variables</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">lambda_</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">W</span><span class="o">/</span><span class="n">L</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="n">mu</span> <span class="o">=</span> <span class="n">beta</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">gamma</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">W</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

<span class="k">def</span> <span class="nf">clamped_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">clamped_boundary</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="c">#return sym(nabla_grad(u))</span>

<span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="o">*</span><span class="n">nabla_div</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">epsilon</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span>  <span class="c"># no of space dim</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">g</span><span class="p">))</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Displacement&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;displacement&#39;</span><span class="p">)</span>

<span class="n">von_Mises</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">sigma</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">-</span> <span class="n">div</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">von_Mises</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">von_Mises</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">von_Mises</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Stress intensity&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;displacement&#39;</span><span class="p">)</span>
<span class="n">u_magnitude</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">u</span><span class="p">))</span>
<span class="n">u_magnitude</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u_magnitude</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u_magnitude</span><span class="p">,</span> <span class="s">&#39;Displacement magnitude&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;displacement&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;min/max u:&#39;</span><span class="p">,</span> <span class="n">u_magnitude</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
      <span class="n">u_magnitude</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
</pre></div>
</div>
<div class="figure" id="id1">
<a class="reference internal image-reference" href="_images/beam1.png"><img alt="_images/beam1.png" src="_images/beam1.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Gravity-induced deformation of a clamped beam: deflection (left) and stress intensity (right)</span></p>
</div>
</div>
</div>
</div>
<div class="section" id="the-navier-stokes-equations">
<h2>The Navier - Stokes equations<a class="headerlink" href="#the-navier-stokes-equations" title="Permalink to this headline">¶</a></h2>
<p>Should we here also include coupling to a transport equation? It shows
multi-physics capabilities.</p>
<div class="section" id="variational-formulation-4">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-4" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="a-simple-implementation-4">
<h3>A simple implementation<a class="headerlink" href="#a-simple-implementation-4" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>