<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Time-dependent and nonlinear problems</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Troubleshooting" href="._ftut005.html" />
    <link rel="prev" title="The fundamentals" href="._ftut003.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut003.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut005.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="time-dependent-and-nonlinear-problems">
<h1>Time-dependent and nonlinear problems<a class="headerlink" href="#time-dependent-and-nonlinear-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="time-dependent-problems">
<span id="tut-timedep"></span><h2>Time-dependent problems<a class="headerlink" href="#time-dependent-problems" title="Permalink to this headline">¶</a></h2>
<p>The examples in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl"><span class="std std-ref">A basic Poisson solver</span></a> illustrate that solving
linear, stationary PDE problems with the aid of FEniCS is easy and
requires little programming.  FEniCS clearly automates the spatial
discretization by the finite element method. One can use a separate,
one-dimensional finite element method in the domain as well, but very
often, it is easier to just use a finite difference method, or to
formulate the problem as an ODE system and leave the time-stepping to
an ODE solver.</p>
<p>[<strong>hpl 14</strong>: Should exemplify all three approaches? With emphasis on simple finite differences?]</p>
<div class="section" id="a-diffusion-problem-and-its-discretization">
<span id="tut-timedep-diffusion1"></span><h3>A diffusion problem and its discretization<a class="headerlink" href="#a-diffusion-problem-and-its-discretization" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Our time-dependent model problem for teaching purposes is naturally
the simplest extension of the Poisson problem into the time domain,
i.e., the diffusion problem</p>
<div class="math" id="eq-tut-diffusion-pde1">
\[\begin{split}\tag{47}
{\partial u\over\partial t} = \nabla^2 u + f \mbox{ in } \Omega, \hbox{ for } t&gt;0,\end{split}\]</div>
<div class="math" id="eq-tut-diffusion-pde1-bc">
\[\begin{split}\tag{48}
u = u_0 \mbox{ on } \partial \Omega,\hbox{ for } t&gt;0,\end{split}\]</div>
<div class="math" id="eq-tut-diffusion-pde1-ic">
\[\tag{49}
u = I   \mbox{ at } t=0{\thinspace .}\]</div>
<p>Here, <span class="math">\(u\)</span> varies with space and time, e.g., <span class="math">\(u=u(x,y,t)\)</span> if the spatial
domain <span class="math">\(\Omega\)</span> is two-dimensional. The source function <span class="math">\(f\)</span> and the
boundary values <span class="math">\(u_0\)</span> may also vary with space and time.
The initial condition <span class="math">\(I\)</span> is a function of space only.</p>
<p>A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a recursive set of
stationary problems, and then turn each stationary problem into a
variational formulation.</p>
<p>Let superscript <span class="math">\(k\)</span> denote a quantity at time <span class="math">\(t_k\)</span>, where <span class="math">\(k\)</span> is an
integer counting time levels. For example, <span class="math">\(u^k\)</span> means <span class="math">\(u\)</span> at time
level <span class="math">\(k\)</span>.  A finite difference discretization in time first consists
in sampling the PDE at some time level, say <span class="math">\(k\)</span>:</p>
<div class="math" id="eq-tut-diffusion-pde1-tk">
\[\tag{50}
{\partial \over\partial t}u^k = \nabla^2 u^k + f^k{\thinspace .}\]</div>
<p>The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:</p>
<div class="math" id="eq-tut-diffusion-be">
\[\tag{51}
{\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{{\Delta t}}},\]</div>
<p>where <span class="math">\({\Delta t}\)</span> is the time discretization parameter.
Inserting <a class="reference internal" href="#eq-tut-diffusion-be"><span class="std std-ref">(51)</span></a> in <a class="reference internal" href="#eq-tut-diffusion-pde1-tk"><span class="std std-ref">(50)</span></a> yields</p>
<div class="math" id="eq-tut-diffusion-pde1-be">
\[\tag{52}
{u^k - u^{k-1}\over{{\Delta t}}} = \nabla^2 u^k + f^k{\thinspace .}\]</div>
<p>This is our time-discrete version of the diffusion PDE
<a class="reference internal" href="#eq-tut-diffusion-pde1"><span class="std std-ref">(47)</span></a>.</p>
<p>We reorder <a class="reference internal" href="#eq-tut-diffusion-pde1-be"><span class="std std-ref">(52)</span></a> so
that the left-hand side contains the terms with the unknown <span class="math">\(u^k\)</span> and
the right-hand side contains computed terms only. The result
is a recursive set of spatial
(stationary) problems for <span class="math">\(u^k\)</span> (assuming <span class="math">\(u^{k-1}\)</span> is known from
computations at the previous time level):</p>
<div class="math" id="eq-tut-diffusion-pde1-u0">
\[\tag{53}
u^0 = I,\]</div>
<div class="math" id="eq-tut-diffusion-pde1-uk">
\[\tag{54}
u^k - {{\Delta t}}\nabla^2 u^k =  u^{k-1} + {{\Delta t}} f^k,\quad k=1,2,\ldots\]</div>
<p>Given <span class="math">\(I\)</span>, we can solve for <span class="math">\(u^0\)</span>, <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and so on.</p>
<p>We use a finite element method to solve the equations
<a class="reference internal" href="#eq-tut-diffusion-pde1-u0"><span class="std std-ref">(53)</span></a> and <a class="reference internal" href="#eq-tut-diffusion-pde1-uk"><span class="std std-ref">(54)</span></a>.  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function <span class="math">\(v\in \hat V\)</span> and integrate second-derivatives by
parts. Introducing the symbol <span class="math">\(u\)</span> for <span class="math">\(u^k\)</span> (which is natural in the
program too), the resulting weak form can be conveniently written in
the standard notation:</p>
<div class="math">
\[a_0(u,v)=L_0(v)\]</div>
<p>for
<a class="reference internal" href="#eq-tut-diffusion-pde1-u0"><span class="std std-ref">(53)</span></a> and</p>
<div class="math">
\[a(u,v)=L(v)\]</div>
<p>for <a class="reference internal" href="#eq-tut-diffusion-pde1-uk"><span class="std std-ref">(54)</span></a>, where</p>
<div class="math" id="eq-tut-diffusion-pde1-a0">
\[\tag{55}
a_0(u,v) = \int_\Omega uv {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-diffusion-pde1-l0">
\[\tag{56}
L_0(v) = \int_\Omega Iv {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-diffusion-pde1-a">
\[\tag{57}
a(u,v) = \int_\Omega\left( uv + {{\Delta t}}
    \nabla u\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-diffusion-pde1-l">
\[\tag{58}
L(v) = \int_\Omega \left(u^{k-1} + {{\Delta t}}  f^k\right)v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The continuous variational problem is to find
<span class="math">\(u^0\in V\)</span> such that <span class="math">\(a_0(u^0,v)=L_0(v)\)</span> holds for all <span class="math">\(v\in\hat V\)</span>,
and then find <span class="math">\(u^k\in V\)</span>
such that <span class="math">\(a(u^k,v)=L(v)\)</span> for all <span class="math">\(v\in\hat V\)</span>,
<span class="math">\(k=1,2,\ldots\)</span>.</p>
<p>Approximate solutions in space are found by restricting the functional
spaces <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> to finite-dimensional spaces, exactly as we
have done in the Poisson problems.  We shall use the symbol <span class="math">\(u\)</span> for
the finite element approximation at time <span class="math">\(t_k\)</span>. In case we need to
distinguish this space-time discrete approximation from the exact
solution of the continuous diffusion problem, we use <span class="math">\({u_{\small\mbox{e}}}\)</span> for the
latter.  By <span class="math">\(u^{k-1}\)</span> we mean the finite element approximation of the
solution at time <span class="math">\(t_{k-1}\)</span>.</p>
<p>Note that the forms <span class="math">\(a_0\)</span> and <span class="math">\(L_0\)</span> are identical to the forms met in
the section <a class="reference internal" href="._ftut003.html#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>, except that the test and trial
functions are now scalar fields and not vector fields.  Instead of
solving <a class="reference internal" href="#eq-tut-diffusion-pde1-u0"><span class="std std-ref">(53)</span></a> by a finite element method, i.e.,
projecting <span class="math">\(I\)</span> onto <span class="math">\(V\)</span> via the problem <span class="math">\(a_0(u,v)=L_0(v)\)</span>, we could
simply interpolate <span class="math">\(u^0\)</span> from <span class="math">\(I\)</span>. That is, if <span class="math">\(u^0=\sum_{j=1}^N
U^0_j\phi_j\)</span>, we simply set <span class="math">\(U_j=I(x_j,y_j)\)</span>, where <span class="math">\((x_j,y_j)\)</span> are
the coordinates of node number <span class="math">\(j\)</span>. We refer to these two strategies
as computing the initial condition by either projecting <span class="math">\(I\)</span> or
interpolating <span class="math">\(I\)</span>.  Both operations are easy to compute through one
statement, using either the <code class="docutils literal"><span class="pre">project</span></code> or <code class="docutils literal"><span class="pre">interpolate</span></code> function.</p>
</div>
<div class="section" id="implementation-3">
<span id="tut-timedep-diffusion1-impl"></span><h3>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h3>
<p>Our program needs to perform the time stepping explicitly, but can
rely on FEniCS to easily compute <span class="math">\(a_0\)</span>, <span class="math">\(L_0\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(L\)</span>, and solve
the linear systems for the unknowns.  We realize that <span class="math">\(a\)</span> does not
depend on time, which means that its associated matrix also will be
time independent. Therefore, it is wise to explicitly create matrices
and vectors as demonstrated in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-linalg"><span class="std std-ref">Creating the linear system explicitly</span></a>.  The
matrix <span class="math">\(A\)</span> arising from <span class="math">\(a\)</span> can be computed prior to the time
stepping, so that we only need to compute the right-hand side <span class="math">\(b\)</span>,
corresponding to <span class="math">\(L\)</span>, in each pass in the time loop. Let us express
the solution procedure in algorithmic form, writing <span class="math">\(u\)</span> for the
unknown spatial function at the new time level (<span class="math">\(u^k\)</span>) and <span class="math">\(u_1\)</span> for
the spatial solution at one earlier time level (<span class="math">\(u^{k-1}\)</span>):</p>
<blockquote>
<div><ul class="simple">
<li>define Dirichlet boundary condition (<span class="math">\(u_0\)</span>, Dirichlet boundary, etc.)</li>
<li>let <span class="math">\(u_1\)</span> interpolate <span class="math">\(I\)</span> or be the projection of <span class="math">\(I\)</span></li>
<li>define <span class="math">\(a\)</span> and <span class="math">\(L\)</span></li>
<li>assemble matrix <span class="math">\(A\)</span> from <span class="math">\(a\)</span></li>
<li>set some stopping time <span class="math">\(T\)</span></li>
<li><span class="math">\(t={{\Delta t}}\)</span></li>
<li>while <span class="math">\(t\leq T\)</span><ul>
<li>assemble vector <span class="math">\(b\)</span> from <span class="math">\(L\)</span></li>
<li>apply essential boundary conditions</li>
<li>solve <span class="math">\(AU=b\)</span> for <span class="math">\(U\)</span> and store in <span class="math">\(u\)</span></li>
<li><span class="math">\(t\leftarrow t + {{\Delta t}}\)</span></li>
<li><span class="math">\(u_1 \leftarrow u\)</span> (be ready for next step)</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,</p>
<div class="math" id="eq-tut-diffusion-pde1-u0test">
\[\tag{59}
u = 1 + x^2 + \alpha y^2 + \beta t,\]</div>
<p>yields a function whose computed values at the nodes will be exact,
regardless of the size of the elements and <span class="math">\({\Delta t}\)</span>, as long as the mesh
is uniformly partitioned.  By inserting
<a class="reference internal" href="#eq-tut-diffusion-pde1-u0test"><span class="std std-ref">(59)</span></a> in the PDE problem
<a class="reference internal" href="#eq-tut-diffusion-pde1"><span class="std std-ref">(47)</span></a>, it follows that <span class="math">\(u_0\)</span> must be given as
<a class="reference internal" href="#eq-tut-diffusion-pde1-u0test"><span class="std std-ref">(59)</span></a> and that <span class="math">\(f(x,y,t)=\beta - 2 -
2\alpha\)</span> and <span class="math">\(I(x,y)=1+x^2+\alpha y^2\)</span>.</p>
<p id="index-1">A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the boundary condition <span class="math">\(u_0\)</span> given by
<a class="reference internal" href="#eq-tut-diffusion-pde1-u0test"><span class="std std-ref">(59)</span></a>.  A natural solution is to apply an
<code class="docutils literal"><span class="pre">Expression</span></code> object with time <span class="math">\(t\)</span> as a parameter, in addition to the
parameters <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> (see the section <a class="reference internal" href="._ftut003.html#tut-poisson-membrane"><span class="std std-ref">Deflection of a circular membrane</span></a>
for <code class="docutils literal"><span class="pre">Expression</span></code> objects with parameters):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="p">{</span><span class="s">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span> <span class="s">&#39;beta&#39;</span><span class="p">:</span> <span class="n">beta</span><span class="p">})</span>
<span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This function expression has the components of <code class="docutils literal"><span class="pre">x</span></code> as independent
variables, while <code class="docutils literal"><span class="pre">alpha</span></code>, <code class="docutils literal"><span class="pre">beta</span></code>, and <code class="docutils literal"><span class="pre">t</span></code> are parameters.  The
parameters can either be set through a dictionary at construction
time, as demonstrated for <code class="docutils literal"><span class="pre">alpha</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>, or anytime through
attributes in the function object, as shown for the <code class="docutils literal"><span class="pre">t</span></code> parameter.</p>
<p>The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>We shall use <code class="docutils literal"><span class="pre">u</span></code> for the unknown <span class="math">\(u\)</span> at the new time level and <code class="docutils literal"><span class="pre">u_1</span></code>
for <span class="math">\(u\)</span> at the previous time level.  The initial value of <code class="docutils literal"><span class="pre">u_1</span></code>,
implied by the initial condition on <span class="math">\(u\)</span>, can be computed by either
projecting or interpolating <span class="math">\(I\)</span>.  The <span class="math">\(I(x,y)\)</span> function is available
in the program through <code class="docutils literal"><span class="pre">u0</span></code>, as long as <code class="docutils literal"><span class="pre">u0.t</span></code> is zero.  We can then
do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we could, as an equivalent alternative to using <code class="docutils literal"><span class="pre">project</span></code>,
define <span class="math">\(a_0\)</span> and <span class="math">\(L_0\)</span> as we did in the section <a class="reference internal" href="._ftut003.html#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a> and
form the associated variational problem.</p>
<div class="admonition-projecting-versus-interpolating-the-initial-condition admonition">
<p class="first admonition-title">Projecting versus interpolating the initial condition</p>
<p class="last">To actually recover the
exact solution <a class="reference internal" href="#eq-tut-diffusion-pde1-u0test"><span class="std std-ref">(59)</span></a> to machine precision,
it is important not to compute the discrete initial condition by
projecting <span class="math">\(I\)</span>, but by interpolating <span class="math">\(I\)</span> so that the nodal values are
exact at <span class="math">\(t=0\)</span> (projection results in approximative values at the
nodes).</p>
</div>
<p>The definition of <span class="math">\(a\)</span> and <span class="math">\(L\)</span> goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span>      <span class="c"># time step</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c"># assemble only once, before the time stepping</span>
</pre></div>
</div>
<p>Finally, we perform the time stepping in a loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">2</span>             <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>

<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-remember-to-update-expression-objects-with-the-current-time admonition">
<p class="first admonition-title">Remember to update expression objects with the current time</p>
<p class="last">Inside the time loop,
observe that <code class="docutils literal"><span class="pre">u0.t</span></code> must be updated before the <code class="docutils literal"><span class="pre">bc.apply</span></code>
statement, to enforce computation of Dirichlet conditions at the
current time level.</p>
</div>
<p>The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of <code class="docutils literal"><span class="pre">u</span></code> and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after <code class="docutils literal"><span class="pre">u</span></code> is found:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">maxdiff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">-</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error, t=</span><span class="si">%.2f</span><span class="s">: </span><span class="si">%-10.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">maxdiff</span><span class="p">))</span>
</pre></div>
</div>
<p id="index-2">The right-hand side vector <code class="docutils literal"><span class="pre">b</span></code> must obviously be recomputed at each
time level.  With the construction <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">assemble(L)</span></code>, a new vector for
<code class="docutils literal"><span class="pre">b</span></code> is allocated in memory in every pass of the time loop.  It would
be much more memory friendly to reuse the storage of the <code class="docutils literal"><span class="pre">b</span></code> we
already have.  This is easily accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, we send in our previous <code class="docutils literal"><span class="pre">b</span></code>, which is then filled with new values
and returned from <code class="docutils literal"><span class="pre">assemble</span></code>. Now there will be only a single
memory allocation of the right-hand side vector. Before the time loop
we set <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">None</span></code> such that <code class="docutils literal"><span class="pre">b</span></code> is defined in the first call to
<code class="docutils literal"><span class="pre">assemble</span></code>.</p>
<p>The complete program code for this time-dependent case goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Initial condition</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c">#u_1 = project(u0, V)  # will not result in exact solution!</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span>      <span class="c"># time step</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c"># assemble only once, before the time stepping</span>
<span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>          <span class="c"># necessary for memory saving assemeble call</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.9</span>           <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;time =&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Verify</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">maxdiff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error, t=</span><span class="si">%.2f</span><span class="s">: </span><span class="si">%-10.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">maxdiff</span><span class="p">))</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>The code
is available in the
file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/d2D_plain.py">d2D_plain.py</a>.</p>
</div>
<div class="section" id="avoiding-assembly">
<span id="tut-timedep-diffusion1-noassemble"></span><h3>Avoiding assembly<a class="headerlink" href="#avoiding-assembly" title="Permalink to this headline">¶</a></h3>
<p id="index-3">The purpose of this section is to present a technique for speeding up
FEniCS simulators for time-dependent problems where it is possible to
perform all assembly operations prior to the time loop.  There are two
costly operations in the time loop: assembly of the right-hand side
<span class="math">\(b\)</span> and solution of the linear system via the <code class="docutils literal"><span class="pre">solve</span></code> call. The
assembly process involves work proportional to the number of degrees
of freedom <span class="math">\(N\)</span>, while the solve operation has a work estimate of
<span class="math">\(\mathcal{O}( N^{\alpha})\)</span>, for some <span class="math">\(\alpha\geq 1\)</span>.  Typically,
<span class="math">\(\alpha\in [1,2]\)</span>.  As <span class="math">\(N\rightarrow\infty\)</span>, the solve operation will
dominate for <span class="math">\(\alpha&gt;1\)</span>, but for the values of <span class="math">\(N\)</span> typically used on
smaller computers, the assembly step may still represent a
considerable part of the total work at each time level. Avoiding
repeated assembly can therefore contribute to a significant speed-up
of a finite element code in time-dependent problems.</p>
<div class="section" id="deriving-recursive-linear-systems">
<h4>Deriving recursive linear systems<a class="headerlink" href="#deriving-recursive-linear-systems" title="Permalink to this headline">¶</a></h4>
<p>To see how repeated assembly can be avoided, we look at the <span class="math">\(L(v)\)</span>
form in  <a class="reference internal" href="#eq-tut-diffusion-pde1-l"><span class="std std-ref">(58)</span></a>,
which in general varies with
time through <span class="math">\(u^{k-1}\)</span>, <span class="math">\(f^k\)</span>, and possibly also with <span class="math">\({\Delta t}\)</span>
if the time step is adjusted during the simulation.
The technique for avoiding repeated assembly consists in
expanding the finite element functions in sums over the basis functions
<span class="math">\(\phi_i\)</span>, as explained
in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-linalg"><span class="std std-ref">Creating the linear system explicitly</span></a>, to identify matrix-vector
products that build up the complete system. We have
<span class="math">\(u^{k-1}=\sum_{j=1}^NU^{k-1}_j\phi_j\)</span>, and we can expand <span class="math">\(f^k\)</span> as
<span class="math">\(f^{k}=\sum_{j=1}^NF^{k}_j\phi_j\)</span>. Inserting these expressions in <span class="math">\(L(v)\)</span>
and using
<span class="math">\(v=\hat\phi_i\)</span> result in</p>
<div class="math">
\[\begin{split}\int_\Omega \left(u^{k-1} + {{\Delta t}}f^k\right)v {\, \mathrm{d}x} &amp;=
\int_\Omega \left(\sum_{j=1}^N U^{k-1}_j\phi_j + {{\Delta t}}\sum_{j=1}^N F^{k}_j\phi_j\right)\hat\phi_i {\, \mathrm{d}x},\\
&amp;=\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^{k-1}_j
 + {{\Delta t}}\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)F^{k}_j{\thinspace .}\end{split}\]</div>
<p>Introducing <span class="math">\(M_{ij} = \int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\)</span>, we see that
the last expression can be written</p>
<div class="math">
\[\sum_{j=1}^NM_{ij}U^{k-1}_j + {{\Delta t}} \sum_{j=1}^NM_{ij}F^{k}_j,\]</div>
<p>which is nothing but two matrix-vector products,</p>
<div class="math">
\[MU^{k-1} + {{\Delta t}} MF^k,\]</div>
<p>if <span class="math">\(M\)</span> is the matrix with entries <span class="math">\(M_{ij}\)</span>,</p>
<div class="math">
\[U^{k-1}=(U^{k-1}_1,\ldots,U^{k-1}_N)^T,\]</div>
<p>and</p>
<div class="math">
\[F^k=(F^{k}_1,\ldots,F^{k}_N)^T{\thinspace .}\]</div>
<p>We have immediate access to <span class="math">\(U^{k-1}\)</span>
in the program since that is the vector
in the <code class="docutils literal"><span class="pre">u_1</span></code> function. The <span class="math">\(F^k\)</span> vector can easily be
computed by interpolating the prescribed <span class="math">\(f\)</span> function (at each time level if
<span class="math">\(f\)</span> varies with time). Given <span class="math">\(M\)</span>, <span class="math">\(U^{k-1}\)</span>, and <span class="math">\(F^k\)</span>, the right-hand side
<span class="math">\(b\)</span> can be calculated as</p>
<div class="math">
\[b = MU^{k-1} + {{\Delta t}} MF^k {\thinspace .}\]</div>
<p>That is, no assembly is necessary to compute <span class="math">\(b\)</span>.</p>
<p>The coefficient matrix <span class="math">\(A\)</span> can also be split into two terms.
We insert <span class="math">\(v=\hat\phi_i\)</span> and <span class="math">\(u^k = \sum_{j=1}^N U^k_j\phi_j\)</span> in
the expression <a class="reference internal" href="#eq-tut-diffusion-pde1-a"><span class="std std-ref">(57)</span></a> to get</p>
<div class="math">
\[\sum_{j=1}^N \left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^k_j + {{\Delta t}}
\sum_{j=1}^N \left(\int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}\right)U^k_j,\]</div>
<p>which can be written as a sum of matrix-vector products,</p>
<div class="math">
\[MU^k + {{\Delta t}} KU^k = (M + {{\Delta t}} K)U^k,\]</div>
<p>if we identify the matrix <span class="math">\(M\)</span> with entries <span class="math">\(M_{ij}\)</span> as above and
the matrix <span class="math">\(K\)</span> with entries</p>
<div class="math" id="eq-auto19">
\[\tag{60}
K_{ij} = \int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The matrix <span class="math">\(M\)</span> is often called the &#8220;mass matrix&#8221; while &#8220;stiffness matrix&#8221;
is a common nickname for <span class="math">\(K\)</span>. The associated bilinear forms for these
matrices, as we need them for the assembly process in a FEniCS
program, become</p>
<div class="math" id="eq-tut-diffusion-pde1-ak">
\[\tag{61}
a_K(u,v) = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-diffusion-pde1-am">
\[\tag{62}
a_M(u,v) = \int_\Omega uv {\, \mathrm{d}x} {\thinspace .}\]</div>
<p>The linear system at each time level, written as <span class="math">\(AU^k=b\)</span>,
can now be computed by first computing <span class="math">\(M\)</span> and <span class="math">\(K\)</span>, and then forming
<span class="math">\(A=M+{{\Delta t}} K\)</span> at <span class="math">\(t=0\)</span>, while <span class="math">\(b\)</span> is computed as
<span class="math">\(b=MU^{k-1} + {{\Delta t}}MF^k\)</span> at each time level.</p>
</div>
<div class="section" id="implementation-4">
<h4>Implementation<a class="headerlink" href="#implementation-4" title="Permalink to this headline">¶</a></h4>
<p>The following modifications are needed in the <code class="docutils literal"><span class="pre">d1_d2D.py</span></code>
program from the previous section in order to implement the new
strategy of avoiding assembly at each time level:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Define separate forms <span class="math">\(a_M\)</span> and <span class="math">\(a_K\)</span></li>
<li>Assemble <span class="math">\(a_M\)</span> to <span class="math">\(M\)</span> and <span class="math">\(a_K\)</span> to <span class="math">\(K\)</span></li>
<li>Compute <span class="math">\(A=M+{{\Delta t}}\)</span>, <span class="math">\(K\)</span></li>
<li>Define <span class="math">\(f\)</span> as an <code class="docutils literal"><span class="pre">Expression</span></code></li>
<li>Interpolate the formula for <span class="math">\(f\)</span> to a finite element function <span class="math">\(F^k\)</span></li>
<li>Compute <span class="math">\(b=MU^{k-1} + {{\Delta t}}MF^k\)</span></li>
</ol>
</div></blockquote>
<p>The relevant code segments become</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1.</span>
<span class="n">a_K</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a_M</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="c"># No need for L</span>

<span class="c"># 2. and 3.</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_M</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_K</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">K</span>

<span class="c"># 4.</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;beta - 2 - 2*alpha&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

<span class="c"># 5. and 6.</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">f_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">f_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">u_1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">F_k</span>
</pre></div>
</div>
<p>[<strong>hpl 15</strong>: I wonder if the refactoring should have a function first and then a class or if we jump right to the class. From now on we could use classes as the packaging of FEniCS programs.]</p>
<p>We implement these modification in a refactored version of the
program <code class="docutils literal"><span class="pre">d2D_plain.py</span></code>, where the solver is a function
as explained in the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl2"><span class="std std-ref">Refactored implementation</span></a> rather than a
flat program.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_minimize_assembly</span><span class="p">(</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">I_project</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c"># Create mesh and define function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c"># Initial condition</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="k">if</span> <span class="n">I_project</span> <span class="k">else</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">user_action</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>

    <span class="c"># Define variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a_M</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">a_K</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_M</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_K</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">K</span>
    <span class="c"># Compute solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">f_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">F_k</span> <span class="o">=</span> <span class="n">f_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">u_1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">F_k</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c"># ok if no t attribute in u0</span>
        <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">user_action</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>A special feature in this program is the <code class="docutils literal"><span class="pre">user_action</span></code> callback function:
at every time level, the solution is sent to <code class="docutils literal"><span class="pre">user_action</span></code>, which is
some function provided by the user where the solution can be processed, e.g.,
stored, analyzed, or visualized. In a unit test for the test example without
numerical approximation errors, we can write a call to the solver function,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">solver_minimize_assembly</span><span class="p">(</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span>
        <span class="n">user_action</span><span class="o">=</span><span class="n">assert_max_error</span><span class="p">,</span> <span class="n">I_project</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">user_action</span></code> function asserts equality of the
exact and numerical solution at every time level:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">assert_max_error</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">max_error</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span>
                      <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">2E-12</span>
    <span class="k">assert</span> <span class="n">max_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max_error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">max_error</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="a-class-based-solver-for-a-general-diffusion-problem">
<h3>A class-based solver for a general diffusion problem<a class="headerlink" href="#a-class-based-solver-for-a-general-diffusion-problem" title="Permalink to this headline">¶</a></h3>
<p>When you want to apply some software tool for solving a PDE problem,
you usually want to explore a family of related problems. To this end,
you need to formulate some general form of the PDE problem and then</p>
<p>[<strong>hpl 16</strong>: I AM HERE!]</p>
</div>
<div class="section" id="a-physical-example">
<span id="tut-timedep-diffusion2-sin"></span><h3>A physical example<a class="headerlink" href="#a-physical-example" title="Permalink to this headline">¶</a></h3>
<p id="index-4">With the basic programming techniques for time-dependent problems from
the sections <a class="reference internal" href="#tut-timedep-diffusion1-noassemble"><span class="std std-ref">Avoiding assembly</span></a> and
<a class="reference internal" href="#tut-timedep-diffusion1-impl"><span class="std std-ref">Implementation</span></a> we are ready to attack more
physically realistic examples.  The next example concerns the
question: How is the temperature in the ground affected by day and
night variations at the earth&#8217;s surface?  We consider some box-shaped
domain <span class="math">\(\Omega\)</span> in <span class="math">\(d\)</span> dimensions with coordinates
<span class="math">\(x_0,\ldots,x_{d-1}\)</span> (the problem is meaningful in 1D, 2D, and 3D).
At the top of the domain, <span class="math">\(x_{0}=0\)</span>, we have an oscillating
temperature</p>
<div class="math">
\[T_0(t) = T_R + T_A\sin (\omega t),\]</div>
<p>where <span class="math">\(T_R\)</span> is some reference temperature, <span class="math">\(T_A\)</span> is the amplitude of
the temperature variations at the surface, and <span class="math">\(\omega\)</span> is the
frequency of the temperature oscillations.  At all other boundaries we
assume that the temperature does not change anymore when we move away
from the boundary, i.e., the normal derivative is zero.  Initially,
the temperature can be taken as <span class="math">\(T_R\)</span> everywhere.  The heat
conductivity properties of the soil in the ground may vary with space
so we introduce a variable coefficient <span class="math">\(\kappa\)</span> reflecting this
property.  Figure <a class="reference internal" href="#tut-timedep-diffusion2-sin-fig1"><span class="std std-ref">Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</span></a> shows a sketch
of the problem, with a small region where the heat conductivity is
much lower.  [<strong>hpl 17</strong>: All parameters <span class="math">\(\varrho\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(\kappa\)</span> are different!]</p>
<div class="figure" id="id22">
<span id="tut-timedep-diffusion2-sin-fig1"></span><a class="reference internal image-reference" href="_images/daynight.png"><img alt="_images/daynight.png" src="_images/daynight.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</em></span></p>
</div>
<p>The initial-boundary value problem for this problem reads</p>
<div class="math" id="eq-auto20">
\[\tag{63}
\varrho c{\partial T\over\partial t} = \nabla\cdot\left( \kappa\nabla T\right)\hbox{ in }\Omega\times (0,t_{\hbox{stop}}],\]</div>
<div class="math" id="eq-auto21">
\[\tag{64}
T = T_0(t)\hbox{ on }\Gamma_0,\]</div>
<div class="math" id="eq-auto22">
\[\tag{65}
{\partial T\over\partial n} = 0\hbox{ on }\partial\Omega\backslash\Gamma_0,\]</div>
<div class="math" id="eq-auto23">
\[\tag{66}
T = T_R\hbox{ at }t =0{\thinspace .}\]</div>
<p>Here, <span class="math">\(\varrho\)</span> is the density of the soil, <span class="math">\(c\)</span> is the
heat capacity, <span class="math">\(\kappa\)</span> is the thermal conductivity
(heat conduction coefficient)
in the soil, and <span class="math">\(\Gamma_0\)</span> is the surface boundary <span class="math">\(x_{0}=0\)</span>.</p>
<p>We use a <span class="math">\(\theta\)</span>-scheme in time, i.e., the evolution equation
<span class="math">\(\partial P/\partial t=Q(t)\)</span> is discretized as</p>
<div class="math">
\[{P^k - P^{k-1}\over{{\Delta t}}} = \theta Q^k + (1-\theta )Q^{k-1},\]</div>
<p>where <span class="math">\(\theta\in[0,1]\)</span> is a weighting factor: <span class="math">\(\theta =1\)</span> corresponds
to the backward difference scheme, <span class="math">\(\theta =1/2\)</span> to the Crank-Nicolson
scheme, and <span class="math">\(\theta =0\)</span> to a forward difference scheme.
The <span class="math">\(\theta\)</span>-scheme applied to our PDE results in</p>
<div class="math">
\[\varrho c{T^k-T^{k-1}\over{{\Delta t}}} =
\theta \nabla\cdot\left( \kappa\nabla T^k\right)
+ (1-\theta) \nabla\cdot\left( k\nabla T^{k-1}\right){\thinspace .}\]</div>
<p>Bringing this time-discrete PDE into weak form follows the technique shown
many times earlier in this tutorial. In the standard notation
<span class="math">\(a(T,v)=L(v)\)</span> the weak form has</p>
<div class="math" id="eq-auto24">
\[\tag{67}
a(T,v) = \int_\Omega
    \left( \varrho c Tv + \theta{{\Delta t}} \kappa\nabla T\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto25">
\[\tag{68}
L(v) = \int_\Omega \left( \varrho c T^{k-1}v - (1-\theta){{\Delta t}}
    \kappa\nabla T^{k-1}\cdot \nabla v\right) {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Observe that boundary integrals vanish because of the Neumann boundary
conditions.</p>
<span class="target" id="index-5"></span><p id="index-6">The size of a 3D box is taken as <span class="math">\(W\times W\times D\)</span>, where <span class="math">\(D\)</span> is
the depth and <span class="math">\(W=D/2\)</span> is the width.
We give the degree of the basis functions at the command line, then <span class="math">\(D\)</span>,
and then the divisions of the domain in the various directions.
To make a box, rectangle, or interval of arbitrary (not unit) size,
we have the classes <code class="docutils literal"><span class="pre">BoxMesh</span></code>, <code class="docutils literal"><span class="pre">RectangleMesh</span></code>, and
<code class="docutils literal"><span class="pre">IntervalMesh</span></code> at our disposal. The mesh and the function space
can be created by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">D</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">D</span><span class="o">/</span><span class="mf">2.0</span>
<span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">:]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>  <span class="c"># no of space dimensions</span>
<span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
               <span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">RectangleMesh</span></code> and <code class="docutils literal"><span class="pre">BoxMesh</span></code> objects are defined by the coordinates
of the &#8220;minimum&#8221; and &#8220;maximum&#8221; corners.</p>
<p>Setting Dirichlet conditions at the upper boundary can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T_R</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">T_A</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>

<span class="n">T_0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;T_R + T_A*sin(omega*t)&#39;</span><span class="p">,</span>
                 <span class="n">T_R</span><span class="o">=</span><span class="n">T_R</span><span class="p">,</span> <span class="n">T_A</span><span class="o">=</span><span class="n">T_A</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">T_0</span><span class="p">,</span> <span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="math">\(\kappa\)</span> function can be defined as a constant <span class="math">\(\kappa_1\)</span> inside
the particular rectangular area with a special soil composition, as
indicated in Figure <a class="reference internal" href="#tut-timedep-diffusion2-sin-fig1"><span class="std std-ref">Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</span></a>. Outside
this area <span class="math">\(\kappa\)</span> is a constant <span class="math">\(\kappa_0\)</span>.
The domain of the rectangular area is taken as</p>
<div class="math">
\[[-W/4, W/4]\times [-W/4, W/4]\times [-D/2, -D/2 + D/4]\]</div>
<p>in 3D, with <span class="math">\([-W/4, W/4]\times [-D/2, -D/2 + D/4]\)</span> in 2D and
<span class="math">\([-D/2, -D/2 + D/4]\)</span> in 1D.
Since we need some testing in the definition of the <span class="math">\(\kappa(\boldsymbol{x})\)</span>
function, the most straightforward approach is to define a subclass
of <code class="docutils literal"><span class="pre">Expression</span></code>, where we can use a full Python method instead of
just a C++ string formula for specifying a function.
The method that defines the function is called <code class="docutils literal"><span class="pre">eval</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Kappa</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c"># no of space dimensions</span>
        <span class="n">material</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># 0: outside, 1: inside</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> \
               <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> \
               <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa_0</span> <span class="k">if</span> <span class="n">material</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">kappa_1</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">eval</span></code> method gives great flexibility in defining functions,
but a downside is that C++ calls up <code class="docutils literal"><span class="pre">eval</span></code> in Python for
each point <code class="docutils literal"><span class="pre">x</span></code>, which is a slow process, and the number of calls
is proportional to the number of numerical
integration points in the mesh (about
the number of degrees of freedom).
Function expressions in terms of strings are compiled to efficient
C++ functions, being called from C++, so we should try to express functions
as string expressions if possible. (The <code class="docutils literal"><span class="pre">eval</span></code> method can also be
defined through C++ code, but this is much
more complicated and not covered here.)
Using inline if-tests in C++, we can make string expressions for
<span class="math">\(\kappa\)</span>, here stored in a Python dictionary so that <code class="docutils literal"><span class="pre">kappa_str[d-1]</span></code>
is the proper test in a <span class="math">\(d\)</span> dimensional problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">kappa_str</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -D/2 &amp;&amp; x[0] &lt; -D/2 + D/4 ? kappa_1 : kappa_0&#39;</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\
               <span class="s">&#39;&amp;&amp; x[1] &gt; -D/2 &amp;&amp; x[1] &lt; -D/2 + D/4 ? &#39;</span>\
               <span class="s">&#39;kappa_1 : kappa_0&#39;</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\
               <span class="s">&#39;x[1] &gt; -W/4 &amp;&amp; x[1] &lt; W/4 &#39;</span>\
               <span class="s">&#39;&amp;&amp; x[2] &gt; -D/2 &amp;&amp; x[2] &lt; -D/2 + D/4 ?&#39;</span>\
               <span class="s">&#39;kappa_1 : kappa_0&#39;</span>

<span class="n">kappa</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">kappa_str</span><span class="p">[</span><span class="n">d</span><span class="p">],</span>
                   <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">kappa_0</span><span class="o">=</span><span class="n">kappa_0</span><span class="p">,</span> <span class="n">kappa_1</span><span class="o">=</span><span class="n">kappa_1</span><span class="p">)</span>
</pre></div>
</div>
<p>Let <code class="docutils literal"><span class="pre">T</span></code> denote the unknown spatial temperature function at the
current time level, and let <code class="docutils literal"><span class="pre">T_1</span></code> be the corresponding function
at one earlier time level.
We are now ready to define the initial condition and the
<code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> forms of our problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T_prev</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">T_R</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>

<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">period</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>
<span class="n">t_stop</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">period</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">period</span><span class="o">/</span><span class="mi">20</span>  <span class="c"># 20 time steps per period</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span>\
    <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">T_prev</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">v</span> <span class="o">-</span>
     <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">T_1</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># variable used for memory savings in assemble calls</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># unknown at the current time level</span>
</pre></div>
</div>
<p>We could, alternatively, break <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> up in subexpressions
and assemble a mass matrix and stiffness matrix, as exemplified in
the section <a class="reference internal" href="#tut-timedep-diffusion1-noassemble"><span class="std std-ref">Avoiding assembly</span></a>, to avoid
assembly of <code class="docutils literal"><span class="pre">b</span></code> at every time level. This modification is
straightforward and left as an exercise. The speed-up can be significant
in 3D problems.</p>
<p>The time loop is very similar to what we have displayed in
the section <a class="reference internal" href="#tut-timedep-diffusion1-impl"><span class="std std-ref">Implementation</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># unknown at the current time level</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">t_stop</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
    <span class="n">T_0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
    <span class="c"># visualization statements</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">T_prev</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code in <code class="docutils literal"><span class="pre">sin_daD.py</span></code> contains several
statements related to visualization and animation of the solution, both as a
finite element field (<code class="docutils literal"><span class="pre">plot</span></code> calls) and as a curve in the
vertical direction. The code also plots the exact analytical solution,</p>
<div class="math">
\[T(x,t) = T_R + T_Ae^{ax}\sin (\omega t + ax),\quad a =\sqrt{\omega\varrho c\over 2\kappa},\]</div>
<p>which is valid when <span class="math">\(\kappa = \kappa_0=\kappa_1\)</span>.</p>
<p>Implementing this analytical solution as a Python function
taking scalars and numpy arrays as arguments requires a word of caution.
A straightforward function like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">T_exact</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kappa_0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">T_R</span> <span class="o">+</span> <span class="n">T_A</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>will not work and result in an error message from UFL. The reason is that
the names <code class="docutils literal"><span class="pre">exp</span></code> and <code class="docutils literal"><span class="pre">sin</span></code> are those imported
by the <code class="docutils literal"><span class="pre">from</span> <span class="pre">fenics</span> <span class="pre">import</span> <span class="pre">*</span></code> statement, and these names
come from UFL and are aimed at being used in variational forms.
In the <code class="docutils literal"><span class="pre">T_exact</span></code> function where <code class="docutils literal"><span class="pre">x</span></code> may be a scalar or a
<code class="docutils literal"><span class="pre">numpy</span></code> array, we therefore need to explicitly specify
<code class="docutils literal"><span class="pre">np.exp</span></code> and <code class="docutils literal"><span class="pre">np.sin</span></code> (if <code class="docutils literal"><span class="pre">numpy</span></code> is imported under the common name <code class="docutils literal"><span class="pre">np</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">T_exact</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kappa_0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">T_R</span> <span class="o">+</span> <span class="n">T_A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file The reader is encouraged to
play around with the code and test out various parameter sets:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0 = \kappa_1=0.2\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0=0.2\)</span>, <span class="math">\(\kappa_1=0.01\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0=0.2\)</span>, <span class="math">\(\kappa_1=0.001\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=10\)</span> C, <span class="math">\(T_A=10\)</span> C, <span class="math">\(\kappa_0= 2.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span>,
<span class="math">\(\kappa_1= 100 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span>,
<span class="math">\(\varrho = 1500\hbox{ kg/m}^3\)</span>,
<span class="math">\(c = 1480\hbox{ Nm}\cdot\hbox{kg}^{-1}\hbox{K}^{-1}\)</span>,
<span class="math">\(\omega = 2\pi/24\)</span> 1/h  <span class="math">\(= 7.27\cdot 10^{-5}\)</span> 1/s, <span class="math">\(D=1.5\)</span> m</li>
<li>As above, but <span class="math">\(\kappa_0= 12.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span> and
<span class="math">\(\kappa_1= 10^4 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span></li>
</ol>
</div></blockquote>
<p>Data set number 4 is relevant for real temperature variations in
the ground (not necessarily the large value of <span class="math">\(\kappa_1\)</span>),
while data set number 5
exaggerates the effect of a large heat conduction contrast so that
it becomes clearly visible in an animation.</p>
</div>
</div>
<div class="section" id="nonlinear-problems">
<span id="tut-poisson-nonlinear"></span><h2>Nonlinear problems<a class="headerlink" href="#nonlinear-problems" title="Permalink to this headline">¶</a></h2>
<p>Now we shall address how to solve nonlinear PDEs in FEniCS. Our
sample PDE for implementation is taken as a nonlinear Poisson equation:</p>
<div class="math" id="eq-auto26">
\[\tag{69}
-\nabla\cdot\left( q(u)\nabla u\right) = f{\thinspace .}\]</div>
<p>The coefficient <span class="math">\(q(u)\)</span> makes the equation nonlinear (unless <span class="math">\(q(u)\)</span>
is constant in <span class="math">\(u\)</span>).</p>
<p>To be able to easily verify our implementation,
we choose the domain, <span class="math">\(q(u)\)</span>, <span class="math">\(f\)</span>, and the boundary
conditions such that we have
a simple, exact solution <span class="math">\(u\)</span>. Let
<span class="math">\(\Omega\)</span> be the unit hypercube <span class="math">\([0, 1]^d\)</span>
in <span class="math">\(d\)</span> dimensions, <span class="math">\(q(u)=(1+u)^m\)</span>, <span class="math">\(f=0\)</span>, <span class="math">\(u=0\)</span> for <span class="math">\(x_0=0\)</span>, <span class="math">\(u=1\)</span>
for <span class="math">\(x_0=1\)</span>, and <span class="math">\(\partial u/\partial n=0\)</span> at all other boundaries
<span class="math">\(x_i=0\)</span> and <span class="math">\(x_i=1\)</span>, <span class="math">\(i=1,\ldots,d-1\)</span>. The coordinates are now represented by
the symbols <span class="math">\(x_0,\ldots,x_{d-1}\)</span>. The exact solution is then</p>
<div class="math" id="eq-auto27">
\[\tag{70}
u(x_0,\ldots,x_{d-1}) = \left((2^{m+1}-1)x_0 + 1\right)^{1/(m+1)} - 1{\thinspace .}\]</div>
<p>We refer to the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a> for details on formulating a PDE
problem in <span class="math">\(d\)</span> space dimensions.</p>
<p>The variational formulation of our model problem reads:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="eq-tut-poisson-nonlinear1">
\[\tag{71}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>where</p>
<div class="math" id="eq-tut-poisson-nonlinear2">
\[\tag{72}
F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v {\, \mathrm{d}x},\]</div>
<p>and</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and }x_0=1\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and } v = 1\mbox{ on }x_0=1\}{\thinspace .}\end{split}\]</div>
<p>The discrete problem arises as usual by restricting <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> to a
pair of discrete spaces. As usual, we omit any subscript on discrete
spaces and simply say <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> are chosen finite dimensional
according to some mesh with some element type.
Similarly, we let <span class="math">\(u\)</span> be the discrete solution and use <span class="math">\({u_{\small\mbox{e}}}\)</span> for
the exact solution if it becomes necessary to distinguish between the two.</p>
<p>The discrete nonlinear problem is then written as: find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-tut-poisson-nonlinear-d">
\[\tag{73}
F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>with <span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>. Since <span class="math">\(F\)</span> is a nonlinear function
of <span class="math">\(u\)</span>, the variational statement gives rise to a system of
nonlinear algebraic equations.</p>
<p>FEniCS can be used in alternative ways for solving a nonlinear PDE
problem. We shall in the following subsections go through four
solution strategies:</p>
<blockquote>
<div><ol class="arabic simple">
<li>a simple Picard-type iteration,</li>
<li>a Newton method at the algebraic level,</li>
<li>a Newton method at the PDE level, and</li>
<li>an automatic approach where FEniCS attacks the nonlinear variational
problem directly.</li>
</ol>
</div></blockquote>
<p>The &#8220;black box&#8221; strategy 4 is definitely the simplest one from a
programmer&#8217;s point of view, but the others give more manual control of
the solution process for nonlinear equations (which also has some
pedagogical advantages, especially for newcomers to nonlinear finite
element problems).</p>
<div class="section" id="picard-iteration">
<span id="tut-nonlinear-picard"></span><h3>Picard iteration<a class="headerlink" href="#picard-iteration" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-7"></span><p id="index-8">Picard iteration is an easy way of handling nonlinear PDEs: we simply
use a known, previous solution in the nonlinear terms so that these
terms become linear in the unknown <span class="math">\(u\)</span>. The strategy is also known as
the method of successive substitutions.
For our particular problem,
we use a known, previous solution in the coefficient <span class="math">\(q(u)\)</span>.
More precisely, given a solution <span class="math">\(u^k\)</span> from iteration <span class="math">\(k\)</span>, we seek a
new (hopefully improved) solution <span class="math">\(u^{k+1}\)</span> in iteration <span class="math">\(k+1\)</span> such
that <span class="math">\(u^{k+1}\)</span> solves the <em>linear problem</em>,</p>
<div class="math" id="eq-tut-poisson-nonlinear-picard1">
\[\tag{74}
\nabla\cdot \left(q(u^k)\nabla u^{k+1}\right) = 0,\quad k=0,1,\ldots\]</div>
<p>The iterations require an initial guess <span class="math">\(u^0\)</span>.
The hope is that <span class="math">\(u^{k} \rightarrow u\)</span> as <span class="math">\(k\rightarrow\infty\)</span>, and that
<span class="math">\(u^{k+1}\)</span> is sufficiently close to the exact
solution <span class="math">\(u\)</span> of the discrete problem after just a few iterations.</p>
<p>We can easily formulate a variational problem for <span class="math">\(u^{k+1}\)</span> from
<a class="reference internal" href="#eq-tut-poisson-nonlinear-picard1"><span class="std std-ref">(74)</span></a>.
Equivalently, we can approximate <span class="math">\(q(u)\)</span> by <span class="math">\(q(u^k)\)</span> in
<a class="reference internal" href="#eq-tut-poisson-nonlinear2"><span class="std std-ref">(72)</span></a>
to obtain the same linear variational problem.
In both cases, the problem consists of seeking
<span class="math">\(u^{k+1} \in V\)</span> such that</p>
<div class="math" id="eq-tut-poisson-nonlinear-picard2">
\[\tag{75}
\tilde F(u^{k+1}; v) = 0 \quad \forall v \in \hat{V},\quad k=0,1,\ldots,\]</div>
<p>with</p>
<div class="math" id="eq-tut-poisson-nonlinear-picard3">
\[\tag{76}
\tilde F(u^{k+1}; v) = \int_\Omega q(u^k)\nabla u^{k+1}\cdot \nabla v {\, \mathrm{d}x}
    {\thinspace .}\]</div>
<p>Since this is a linear problem in the unknown <span class="math">\(u^{k+1}\)</span>, we can equivalently
use the formulation</p>
<div class="math" id="eq-auto28">
\[\tag{77}
a(u^{k+1},v) = L(v),\]</div>
<p>with</p>
<div class="math" id="eq-auto29">
\[\tag{78}
a(u,v) = \int_\Omega q(u^k)\nabla u\cdot \nabla v {\, \mathrm{d}x}\]</div>
<div class="math" id="eq-auto30">
\[\tag{79}
L(v) = 0{\thinspace .}\]</div>
<p>The iterations can be stopped when
<span class="math">\(\epsilon\equiv ||u^{k+1}-u^k|| &lt; \mbox{tol}\)</span>,
where <span class="math">\(\mbox{tol}\)</span> is a small tolerance, say <span class="math">\(10^{-5}\)</span>, or
when the number of iterations exceed some critical limit. The latter
case will pick up divergence of the method or unacceptable slow
convergence.</p>
<p id="index-9">In the solution algorithm we only need to store <span class="math">\(u^k\)</span> and <span class="math">\(u^{k+1}\)</span>,
called <code class="docutils literal"><span class="pre">u_k</span></code> and <code class="docutils literal"><span class="pre">u</span></code> in the code below.
The algorithm can then be expressed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="n">m</span>

<span class="c"># Define variational problem for Picard iteration</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># previous (known) u</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Picard iterations</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># new unknown function</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>           <span class="c"># error measure ||u-u_k||</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0E-5</span>        <span class="c"># tolerance</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c"># iteration counter</span>
<span class="n">maxiter</span> <span class="o">=</span> <span class="mi">25</span>        <span class="c"># max no of iterations allowed</span>
<span class="k">while</span> <span class="n">eps</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
    <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">Inf</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;iter=</span><span class="si">%d</span><span class="s">: norm=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
    <span class="n">u_k</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>   <span class="c"># update for next iteration</span>
</pre></div>
</div>
<p>We need to define the previous solution in the iterations, <code class="docutils literal"><span class="pre">u_k</span></code>,
as a finite element function so that <code class="docutils literal"><span class="pre">u_k</span></code> can be updated with
<code class="docutils literal"><span class="pre">u</span></code> at the end of the loop. We may create the initial
<code class="docutils literal"><span class="pre">Function</span> <span class="pre">u_k</span></code>
by interpolating
an <code class="docutils literal"><span class="pre">Expression</span></code> or a <code class="docutils literal"><span class="pre">Constant</span></code>
to the same vector space as <code class="docutils literal"><span class="pre">u</span></code> lives in (<code class="docutils literal"><span class="pre">V</span></code>).</p>
<p>In the code above we demonstrate how to use
<code class="docutils literal"><span class="pre">numpy</span></code> functionality to compute the norm of
the difference between the two most recent solutions. Here we apply
the maximum norm (<span class="math">\(\ell_\infty\)</span> norm) on the difference of the solution vectors
(<code class="docutils literal"><span class="pre">ord=1</span></code> and <code class="docutils literal"><span class="pre">ord=2</span></code> give the <span class="math">\(\ell_1\)</span> and <span class="math">\(\ell_2\)</span> vector
norms - other norms are possible for <code class="docutils literal"><span class="pre">numpy</span></code> arrays,
see <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">numpy.linalg.norm</span></code>).</p>
<p>The file <code class="docutils literal"><span class="pre">picard_np.py</span></code> contains the complete code for
this nonlinear Poisson problem.
The implementation is <span class="math">\(d\)</span> dimensional, with mesh
construction and setting of Dirichlet conditions as explained in
the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>.
For a <span class="math">\(33\times 33\)</span> grid with <span class="math">\(m=2\)</span> we need 9 iterations for convergence
when the tolerance is <span class="math">\(10^{-5}\)</span>.</p>
</div>
<div class="section" id="a-newton-method-at-the-algebraic-level">
<span id="tut-nonlinear-newton-algebraic"></span><h3>A Newton method at the algebraic level<a class="headerlink" href="#a-newton-method-at-the-algebraic-level" title="Permalink to this headline">¶</a></h3>
<p id="index-10">After having discretized our nonlinear PDE problem, we may
use Newton&#8217;s method to solve the system of nonlinear algebraic equations.
From the continuous variational problem <a class="reference internal" href="#eq-tut-poisson-nonlinear1"><span class="std std-ref">(71)</span></a>,
the discrete version <a class="reference internal" href="#eq-tut-poisson-nonlinear-d"><span class="std std-ref">(73)</span></a> results in a
system of equations for the unknown parameters <span class="math">\(U_1,\ldots, U_N\)</span>
(by inserting <span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>
and <span class="math">\(v=\hat\phi_i\)</span> in <a class="reference internal" href="#eq-tut-poisson-nonlinear-d"><span class="std std-ref">(73)</span></a>):</p>
<div class="math" id="eq-tut-nonlinear-newton-f1">
\[\tag{80}
F_i(U_1,\ldots,U_N) \equiv
    \sum_{j=1}^N
    \int_\Omega \left( q\left(\sum_{\ell=1}^NU_\ell\phi_\ell\right)
    \nabla \phi_j U_j\right)\cdot \nabla \hat\phi_i {\, \mathrm{d}x} = 0,\quad i=1,\ldots,N{\thinspace .}\]</div>
<p>Newton&#8217;s method for the system <span class="math">\(F_i(U_1,\ldots,U_j)=0\)</span>, <span class="math">\(i=1,\ldots,N\)</span>
can be formulated as</p>
<div class="math" id="eq-auto31">
\[\tag{81}
\sum_{j=1}^N
    {\partial \over\partial U_j} F_i(U_1^k,\ldots,U_N^k)\delta U_j
    = -F_i(U_1^k,\ldots,U_N^k),\quad i=1,\ldots,N,\]</div>
<div class="math" id="eq-auto32">
\[\tag{82}
U_j^{k+1} = U_j^k + \omega\delta U_j,\quad j=1,\ldots,N,\]</div>
<p>where <span class="math">\(\omega\in [0,1]\)</span> is a relaxation parameter, and <span class="math">\(k\)</span> is
an iteration index. An initial guess <span class="math">\(u^0\)</span> must
be provided to start the algorithm.</p>
<p id="index-11">The original Newton method has <span class="math">\(\omega=1\)</span>, but in problems where it is
difficult to obtain convergence,
so-called <em>under-relaxation</em> with <span class="math">\(\omega &lt; 1\)</span> may help. It means that
one takes a smaller step than what is suggested by Newton&#8217;s method.</p>
<p id="index-12">We need, in a program, to compute the Jacobian
matrix <span class="math">\(\partial F_i/\partial U_j\)</span>
and the right-hand side vector <span class="math">\(-F_i\)</span>.
Our present problem has <span class="math">\(F_i\)</span> given by <a class="reference internal" href="#eq-tut-nonlinear-newton-f1"><span class="std std-ref">(80)</span></a>.
The derivative <span class="math">\(\partial F_i/\partial U_j\)</span> becomes</p>
<div class="math" id="eq-tut-poisson-nonlinear-dfdu">
\[\tag{83}
\int\limits_\Omega \left\lbrack
     q'(\sum_{\ell=1}^NU_\ell^k\phi_\ell)\phi_j
    \nabla (\sum_{j=1}^NU_j^k\phi_j)\cdot \nabla \hat\phi_i
    +
    q\left(\sum_{\ell=1}^NU_\ell^k\phi_\ell\right)
    \nabla \phi_j \cdot \nabla \hat\phi_i
    \right\rbrack
     {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The following results were used to obtain <a class="reference internal" href="#eq-tut-poisson-nonlinear-dfdu"><span class="std std-ref">(83)</span></a>:</p>
<div class="math" id="eq-auto33">
\[\tag{84}
{\partial u\over\partial U_j} = {\partial\over\partial U_j}
    \sum_{j=1}^NU_j\phi_j = \phi_j,\quad {\partial\over\partial U_j}\nabla u = \nabla\phi_j,\quad {\partial\over\partial U_j}q(u) = q'(u)\phi_j{\thinspace .}\]</div>
<p>We can reformulate the Jacobian matrix
in <a class="reference internal" href="#eq-tut-poisson-nonlinear-dfdu"><span class="std std-ref">(83)</span></a>
by introducing the short
notation <span class="math">\(u^k = \sum_{j=1}^NU_j^k\phi_j\)</span>:</p>
<div class="math" id="eq-auto34">
\[\tag{85}
{\partial F_i\over\partial U_j} =
    \int_\Omega \left\lbrack
    q'(u^k)\phi_j
    \nabla u^k \cdot \nabla \hat\phi_i
    +
    q(u^k)
    \nabla \phi_j \cdot \nabla \hat\phi_i
    \right\rbrack {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>In order to make FEniCS compute this matrix, we need to formulate a
corresponding variational problem. Looking at the
linear system of equations in Newton&#8217;s method,</p>
<div class="math">
\[\sum_{j=1}^N {\partial F_i\over\partial U_j}\delta U_j = -F_i,\quad
i=1,\ldots,N,\]</div>
<p>we can introduce <span class="math">\(v\)</span> as a general test function replacing <span class="math">\(\hat\phi_i\)</span>,
and we can identify the unknown
<span class="math">\(\delta u = \sum_{j=1}^N\delta U_j\phi_j\)</span>. From the linear system
we can now go &#8220;backwards&#8221; to construct the corresponding linear
discrete weak form to be solved in each Newton iteration:</p>
<div class="math" id="eq-tut-nonlinear-newton-alf">
\[\tag{86}
\int_\Omega \left\lbrack
    q'(u^k)\delta u
    \nabla u^k \cdot \nabla v
    +
    q(u^k)
    \nabla \delta u\cdot \nabla v
    \right\rbrack {\, \mathrm{d}x} = - \int_\Omega q(u^k)
    \nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>This variational form fits the standard notation
<span class="math">\(a(\delta u,v)=L(v)\)</span> with</p>
<div class="math">
\[\begin{split}a(\delta u,v) &amp;=
\int_\Omega \left\lbrack
q'(u^k)\delta u
\nabla u^k \cdot \nabla v
+
q(u^k)
\nabla \delta u \cdot \nabla v
\right\rbrack
 {\, \mathrm{d}x}\\
L(v) &amp;= - \int_\Omega q(u^k)
\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace .}\end{split}\]</div>
<p>Note the important feature in Newton&#8217;s method
that the
previous solution <span class="math">\(u^k\)</span> replaces <span class="math">\(u\)</span>
in the formulas when computing the matrix
<span class="math">\(\partial F_i/\partial U_j\)</span> and vector <span class="math">\(F_i\)</span> for the linear system in
each Newton iteration.</p>
<p id="index-13">We now turn to the implementation.
To obtain a good initial guess <span class="math">\(u^0\)</span>, we can solve a simplified, linear
problem, typically with <span class="math">\(q(u)=1\)</span>, which yields the standard Laplace
equation <span class="math">\(\nabla^2 u^0 =0\)</span>. The recipe for solving this problem
appears in the sections <a class="reference internal" href="._ftut003.html#tut-poisson1-varform"><span class="std std-ref">Variational formulation</span></a>,
<a class="reference internal" href="._ftut003.html#tut-poisson1-impl"><span class="std std-ref">A basic Poisson solver</span></a>, and <a class="reference internal" href="._ftut003.html#tut-poisson1-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a>.
The code for computing <span class="math">\(u^0\)</span> becomes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">left_boundary</span><span class="p">)</span>
<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">right_boundary</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>

<span class="c"># Define variational problem for initial guess (q(u)=1, i.e., m=0)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">u_k</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U_k</span> <span class="o">=</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U_k</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">u_k</span></code> denotes the solution function for the previous
iteration, so that the solution
after each Newton iteration is <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_k</span> <span class="pre">+</span> <span class="pre">omega*du</span></code>.
Initially, <code class="docutils literal"><span class="pre">u_k</span></code> is the initial guess we call <span class="math">\(u^0\)</span> in the mathematics.</p>
<p>The Dirichlet boundary conditions for <span class="math">\(\delta u\)</span>, in
the problem to be solved in each Newton
iteration, are somewhat different than the conditions for <span class="math">\(u\)</span>.
Assuming that <span class="math">\(u^k\)</span> fulfills the
Dirichlet conditions for <span class="math">\(u\)</span>, <span class="math">\(\delta u\)</span> must be zero at the boundaries
where the Dirichlet conditions apply, in order for <span class="math">\(u^{k+1}=u^k + \omega\delta u\)</span> to fulfill
the right boundary values. We therefore define an additional list of
Dirichlet boundary conditions objects for <span class="math">\(\delta u\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Gamma_0_du</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left_boundary</span><span class="p">)</span>
<span class="n">Gamma_1_du</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">right_boundary</span><span class="p">)</span>
<span class="n">bcs_du</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0_du</span><span class="p">,</span> <span class="n">Gamma_1_du</span><span class="p">]</span>
</pre></div>
</div>
<p>The nonlinear coefficient and its derivative must be defined
before coding the weak form of the Newton system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="n">m</span>

<span class="k">def</span> <span class="nf">Dq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="c"># u = u_k + omega*du</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">du</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_k</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_k</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The Newton iteration loop is very similar to the Picard iteration loop
in the section <a class="reference internal" href="#tut-nonlinear-picard"><span class="std std-ref">Picard iteration</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>  <span class="c"># u = u_k + omega*du</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>       <span class="c"># relaxation parameter</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0E-5</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">maxiter</span> <span class="o">=</span> <span class="mi">25</span>
<span class="k">while</span> <span class="n">eps</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
    <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs_du</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">Inf</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Norm:&#39;</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">omega</span><span class="o">*</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">u_k</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other ways of implementing the
update of the solution as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span>  <span class="c"># u = u_k</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>

<span class="c"># or</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">+=</span> <span class="n">omega</span><span class="o">*</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">axpy(a,</span> <span class="pre">y)</span></code> operation adds a scalar <code class="docutils literal"><span class="pre">a</span></code> times a <code class="docutils literal"><span class="pre">Vector</span></code>
<code class="docutils literal"><span class="pre">y</span></code> to a <code class="docutils literal"><span class="pre">Vector</span></code> object.  It is usually a fast operation
calling up an optimized BLAS routine for the calculation.</p>
<p>Mesh construction for a <span class="math">\(d\)</span>-dimensional problem with arbitrary degree of
the Lagrange elements can be done as
explained in the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>.
The complete program appears in the file <code class="docutils literal"><span class="pre">alg_newton_np.py</span></code>.</p>
</div>
<div class="section" id="a-newton-method-at-the-pde-level">
<span id="tut-nonlinear-newton-pdelevel"></span><h3>A Newton method at the PDE level<a class="headerlink" href="#a-newton-method-at-the-pde-level" title="Permalink to this headline">¶</a></h3>
<p id="index-14">Although Newton&#8217;s method in PDE problems is normally formulated at the
linear algebra level, i.e., as a solution method for systems of nonlinear
algebraic equations, we can also formulate the method at the PDE level.
This approach yields a linearization of the PDEs before they are discretized.
FEniCS users will probably find this technique simpler to apply than
the more standard method in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><span class="std std-ref">A Newton method at the algebraic level</span></a>.</p>
<p>Given an approximation to the solution field, <span class="math">\(u^k\)</span>, we seek a
perturbation <span class="math">\(\delta u\)</span> so that</p>
<div class="math" id="eq-auto35">
\[\tag{87}
u^{k+1} = u^k + \delta u\]</div>
<p>fulfills the nonlinear PDE.
However, the problem for <span class="math">\(\delta u\)</span> is still nonlinear and nothing is
gained. The idea is therefore to assume that <span class="math">\(\delta u\)</span> is sufficiently
small so that we can linearize the problem with respect to <span class="math">\(\delta u\)</span>.
Inserting <span class="math">\(u^{k+1}\)</span> in the PDE,
linearizing the <span class="math">\(q\)</span> term as</p>
<div class="math" id="eq-auto36">
\[\tag{88}
q(u^{k+1}) = q(u^k) + q'(u^k)\delta u + {\cal O}((\delta u)^2)
    \approx q(u^k) + q'(u^k)\delta u,\]</div>
<p>and dropping nonlinear terms in <span class="math">\(\delta u\)</span>,
we get</p>
<div class="math">
\[\nabla\cdot\left( q(u^k)\nabla u^k\right) +
\nabla\cdot\left( q(u^k)\nabla\delta u\right) +
\nabla\cdot\left( q'(u^k)\delta u\nabla u^k\right) = 0{\thinspace .}\]</div>
<p>We may collect the terms with the unknown <span class="math">\(\delta u\)</span> on the left-hand side,</p>
<div class="math" id="eq-auto37">
\[\tag{89}
\nabla\cdot\left( q(u^k)\nabla\delta u\right) +
    \nabla\cdot\left( q'(u^k)\delta u\nabla u^k\right) =
    -\nabla\cdot\left( q(u^k)\nabla u^k\right),\]</div>
<p>The weak form of this PDE is derived by multiplying by a test function <span class="math">\(v\)</span>
and integrating over <span class="math">\(\Omega\)</span>, integrating as usual
the second-order derivatives by parts:</p>
<div class="math" id="eq-auto38">
\[\tag{90}
\int_\Omega \left(
    q(u^k)\nabla\delta u\cdot \nabla v
    + q'(u^k)\delta u\nabla u^k\cdot \nabla v\right) {\, \mathrm{d}x}
    = -\int_\Omega q(u^k)\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The variational problem reads: find <span class="math">\(\delta u\in V\)</span> such that
<span class="math">\(a(\delta u,v) = L(v)\)</span> for all <span class="math">\(v\in \hat V\)</span>, where</p>
<div class="math" id="eq-tut-nonlinear-poisson-pdelevel-eqa">
\[\tag{91}
a(\delta u,v) =
    \int_\Omega \left(
    q(u^k)\nabla\delta u\cdot \nabla v
    + q'(u^k)\delta u\nabla u^k\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-nonlinear-poisson-pdelevel-eql">
\[\tag{92}
L(v) = -
    \int_\Omega q(u^k)\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>, being continuous or discrete,
are as in the
linear Poisson problem from the section <a class="reference internal" href="._ftut003.html#tut-poisson1-varform"><span class="std std-ref">Variational formulation</span></a>.</p>
<p>We must provide some initial guess, e.g., the solution of the
PDE with <span class="math">\(q(u)=1\)</span>. The corresponding weak form <span class="math">\(a_0(u^0,v)=L_0(v)\)</span>
has</p>
<div class="math">
\[a_0(u,v)=\int_\Omega\nabla u\cdot \nabla v {\, \mathrm{d}x},\quad L_0(v)=0{\thinspace .}\]</div>
<p>Thereafter, we enter a loop and solve
<span class="math">\(a(\delta u,v)=L(v)\)</span> for <span class="math">\(\delta u\)</span> and compute a new approximation
<span class="math">\(u^{k+1} = u^k + \delta u\)</span>. Note that <span class="math">\(\delta u\)</span> is a correction, so if
<span class="math">\(u^0\)</span> satisfies the prescribed
Dirichlet conditions on some part <span class="math">\(\Gamma_D\)</span> of the boundary,
we must demand <span class="math">\(\delta u=0\)</span> on <span class="math">\(\Gamma_D\)</span>.</p>
<p>Looking at <a class="reference internal" href="#eq-tut-nonlinear-poisson-pdelevel-eqa"><span class="std std-ref">(91)</span></a> and
<a class="reference internal" href="#eq-tut-nonlinear-poisson-pdelevel-eql"><span class="std std-ref">(92)</span></a>,
we see that the variational form is the same as for the Newton method
at the algebraic level in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><span class="std std-ref">A Newton method at the algebraic level</span></a>. Since Newton&#8217;s method at the
algebraic level required some &#8220;backward&#8221; construction of the
underlying weak forms, FEniCS users may prefer Newton&#8217;s method at the
PDE level, which this author finds more straightforward, although not so
commonly documented in the literature on numerical methods for PDEs.
There is seemingly no need for differentiations to derive a Jacobian
matrix, but a mathematically equivalent derivation is done when
nonlinear terms are linearized using the first two Taylor series terms
and when products in the perturbation <span class="math">\(\delta u\)</span> are neglected.</p>
<p id="index-15">The implementation is identical to the one in
the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><span class="std std-ref">A Newton method at the algebraic level</span></a> and is found in
the file <code class="docutils literal"><span class="pre">pde_newton_np.py</span></code>. The reader is encouraged to go
through this code to be convinced that the present method actually
ends up with the same program as needed for the Newton method at
the linear algebra level in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><span class="std std-ref">A Newton method at the algebraic level</span></a>.</p>
</div>
<div class="section" id="solving-the-nonlinear-variational-problem-directly">
<span id="tut-nonlinear-newton-auto"></span><h3>Solving the nonlinear variational problem directly<a class="headerlink" href="#solving-the-nonlinear-variational-problem-directly" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-16"></span><p id="index-17">The previous hand-calculations and manual implementation of
Picard or Newton methods can be automated by tools in FEniCS.
In a nutshell, one can just write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">F</span></code> corresponds to the nonlinear form <span class="math">\(F(u;v)\)</span>,
<code class="docutils literal"><span class="pre">u</span></code> is the unknown <code class="docutils literal"><span class="pre">Function</span></code> object, <code class="docutils literal"><span class="pre">bcs</span></code>
represents the essential boundary conditions (in general a list of
<code class="docutils literal"><span class="pre">DirichletBC</span></code> objects), and
<code class="docutils literal"><span class="pre">J</span></code> is a variational form for the Jacobian of <code class="docutils literal"><span class="pre">F</span></code>.</p>
<p>Let us explain in detail how to use the built-in tools for
nonlinear variational problems and their solution.
The <code class="docutils literal"><span class="pre">F</span></code> form corresponding to <a class="reference internal" href="#eq-tut-poisson-nonlinear2"><span class="std std-ref">(72)</span></a>
is straightforwardly defined as follows, assuming <code class="docutils literal"><span class="pre">q(u)</span></code> is
coded as a Python function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># most recently computed solution</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Note here that <code class="docutils literal"><span class="pre">u_</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code> (not a <code class="docutils literal"><span class="pre">TrialFunction</span></code>).
An alternative and perhaps more intuitive formula for <span class="math">\(F\)</span> is to
define <span class="math">\(F(u;v)\)</span> directly in terms of
a trial function for <span class="math">\(u\)</span> and a test function for <span class="math">\(v\)</span>, and then
create the proper <code class="docutils literal"><span class="pre">F</span></code> by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>
</pre></div>
</div>
<p>The latter statement is equivalent to <span class="math">\(F(u=u_{-}; v)\)</span>, where <span class="math">\(u_{-}\)</span> is
an existing finite element function representing the most recently
computed approximation to the solution.
(Note that <span class="math">\(u^k\)</span> and <span class="math">\(u^{k+1}\)</span> in the previous notation
correspond to <span class="math">\(u_{-}\)</span> and <span class="math">\(u\)</span> in the present
notation. We have changed notation to better align the mathematics with
the associated UFL code.)</p>
<p id="index-18">The derivative <span class="math">\(J\)</span> (<code class="docutils literal"><span class="pre">J</span></code>) of <span class="math">\(F\)</span> (<code class="docutils literal"><span class="pre">F</span></code>) is formally the
Gateaux derivative <span class="math">\(DF(u^k; \delta u, v)\)</span>
of <span class="math">\(F(u;v)\)</span> at <span class="math">\(u=u_{-}\)</span> in the direction of <span class="math">\(\delta u\)</span>.
Technically, this Gateaux derivative is derived by computing</p>
<div class="math" id="eq-tut-poisson-nonlinear-gateaux1">
\[\tag{93}
\lim_{\epsilon\rightarrow 0}{d\over d\epsilon} F_i(u_{-} + \epsilon\delta u; v)
    {\thinspace .}\]</div>
<p>The <span class="math">\(\delta u\)</span> is now the trial function and <span class="math">\(u_{-}\)</span> is the previous
approximation to the solution <span class="math">\(u\)</span>.
We start with</p>
<div class="math">
\[{d\over d\epsilon}\int_\Omega \nabla v\cdot\left( q(u_{-} + \epsilon\delta u)
\nabla (u_{-} + \epsilon\delta u)\right) {\, \mathrm{d}x}\]</div>
<p>and obtain</p>
<div class="math">
\[\int_\Omega \nabla v\cdot\left\lbrack
q'(u_{-} + \epsilon\delta u)\delta u
\nabla (u_{-} + \epsilon\delta u)
+
q(u_{-} + \epsilon\delta u)
\nabla \delta u
\right\rbrack {\, \mathrm{d}x},\]</div>
<p>which leads to</p>
<div class="math" id="eq-auto39">
\[\tag{94}
\int_\Omega \nabla v\cdot\left\lbrack
    q'(u_{-})\delta u
    \nabla (u_{-})
    +
    q(u_{-})
    \nabla \delta u
    \right\rbrack {\, \mathrm{d}x},\]</div>
<p>as <span class="math">\(\epsilon\rightarrow 0\)</span>.
This last expression is the Gateaux derivative of <span class="math">\(F\)</span>. We may use <span class="math">\(J\)</span> or
<span class="math">\(a(\delta u, v)\)</span> for this derivative, the latter having the advantage
that we easily recognize the expression as a bilinear form. However, in
the forthcoming code examples <code class="docutils literal"><span class="pre">J</span></code> is used as variable name for
the Jacobian.</p>
<p>The specification of <code class="docutils literal"><span class="pre">J</span></code>
goes as follows if <code class="docutils literal"><span class="pre">du</span></code> is the <code class="docutils literal"><span class="pre">TrialFunction</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">du</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The alternative specification of <code class="docutils literal"><span class="pre">F</span></code>, with <code class="docutils literal"><span class="pre">u</span></code> as
<code class="docutils literal"><span class="pre">TrialFunction</span></code>, leads to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<span class="target" id="index-19"></span><span class="target" id="index-20"></span><p id="index-21">The UFL language, used to specify weak forms, supports differentiation
of forms. This feature facilitates automatic <em>symbolic</em> computation of the
Jacobian <code class="docutils literal"><span class="pre">J</span></code> by calling the function <code class="docutils literal"><span class="pre">derivative</span></code> with <code class="docutils literal"><span class="pre">F</span></code>, the most
recently computed solution (<code class="docutils literal"><span class="pre">Function</span></code>), and the unknown
(<code class="docutils literal"><span class="pre">TrialFunction</span></code>) as parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">J</span>  <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>  <span class="c"># Gateaux derivative in dir. of du</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>

<span class="n">J</span>  <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>   <span class="c"># Gateaux derivative in dir. of u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">derivative</span></code> function is obviously
very convenient in problems where differentiating <code class="docutils literal"><span class="pre">F</span></code> by hand
implies lengthy calculations.</p>
<p>The preferred implementation of <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">J</span></code>, depending on whether
<code class="docutils literal"><span class="pre">du</span></code> or <code class="docutils literal"><span class="pre">u</span></code> is the <code class="docutils literal"><span class="pre">TrialFunction</span></code> object,
is a matter of personal taste. Derivation of the Gateaux derivative
by hand, as shown above, is most naturally matched by an
implementation where <code class="docutils literal"><span class="pre">du</span></code> is the <code class="docutils literal"><span class="pre">TrialFunction</span></code>, while
use of automatic symbolic differentiation with the aid of the <code class="docutils literal"><span class="pre">derivative</span></code>
function is most naturally matched by an implementation where
<code class="docutils literal"><span class="pre">u</span></code> is the <code class="docutils literal"><span class="pre">TrialFunction</span></code>.
We have implemented both approaches in two files:
<code class="docutils literal"><span class="pre">vp1_np.py</span></code> with
<code class="docutils literal"><span class="pre">u</span></code> as <code class="docutils literal"><span class="pre">TrialFunction</span></code>, and
<code class="docutils literal"><span class="pre">vp2_np.py</span></code> with <code class="docutils literal"><span class="pre">du</span></code> as <code class="docutils literal"><span class="pre">TrialFunction</span></code>.
The first command-line argument determines if the Jacobian is to
be automatically derived or computed from the hand-derived formula.</p>
<span class="target" id="index-22"></span><span class="target" id="index-23"></span><p id="index-24">The following code defines the nonlinear variational problem and
an associated solver based on Newton&#8217;s method. We here demonstrate
how key parameters in
Newton&#8217;s method can be set, as well as the choice of
solver and preconditioner, and associated parameters, for the
linear system occurring in the Newton iterations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>

<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
<span class="n">info</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">prm_n</span> <span class="o">=</span> <span class="n">prm</span><span class="p">[</span><span class="s">&#39;newton_solver&#39;</span><span class="p">]</span>
<span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-8</span>
<span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;relaxation_parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="k">if</span> <span class="n">iterative_solver</span><span class="p">:</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="s">&#39;jacobi&#39;</span> <span class="k">if</span> <span class="s">&#39;jacobi&#39;</span> <span class="ow">in</span> \
           <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">krylov_solver_preconditioners</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span> \
           <span class="k">else</span> <span class="s">&#39;ilu&#39;</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;gmres&#39;</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-9</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;monitor_convergence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;gmres&#39;</span><span class="p">][</span><span class="s">&#39;restart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;preconditioner&#39;</span><span class="p">][</span><span class="s">&#39;structure&#39;</span><span class="p">]</span> <span class="o">=</span> \
                                        <span class="s">&#39;same_nonzero_pattern&#39;</span>
    <span class="n">prm_n</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;preconditioner&#39;</span><span class="p">][</span><span class="s">&#39;ilu&#39;</span><span class="p">][</span><span class="s">&#39;fill_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">PROGRESS</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>A list of available parameters and their default values can as
usual be printed by calling <code class="docutils literal"><span class="pre">info(prm,</span> <span class="pre">True)</span></code>.
The <code class="docutils literal"><span class="pre">u_</span></code> we feed to the nonlinear variational problem object
is filled with the solution by the call <code class="docutils literal"><span class="pre">solver.solve()</span></code>.</p>
</div>
</div>
<div class="section" id="creating-more-complex-domains">
<span id="tut-prepro"></span><h2>Creating more complex domains<a class="headerlink" href="#creating-more-complex-domains" title="Permalink to this headline">¶</a></h2>
<p>Up to now we have been very fond of the unit square as domain,
which is an appropriate choice for initial versions of a
PDE solver. The strength of the finite element method, however, is its
ease of handling domains with complex shapes. This section
shows some methods that can be used to create different types of
domains and meshes.</p>
<p>Domains of complex shape must normally be constructed in separate
preprocessor programs. Two relevant preprocessors are Triangle for
2D domains and NETGEN for 3D domains.</p>
<div class="section" id="built-in-mesh-generation-tools">
<span id="tut-prepro-builtin"></span><h3>Built-in mesh generation tools<a class="headerlink" href="#built-in-mesh-generation-tools" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-25"></span><span class="target" id="index-26"></span><span class="target" id="index-27"></span><span class="target" id="index-28"></span><span class="target" id="index-29"></span><p id="index-30">DOLFIN has a few tools for creating various types of meshes over
domains with simple
shape:
<code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>,
<code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>,
<code class="docutils literal"><span class="pre">UnitCubeMesh</span></code>,
<code class="docutils literal"><span class="pre">IntervalMesh</span></code>,
<code class="docutils literal"><span class="pre">RectangleMesh</span></code>, and
<code class="docutils literal"><span class="pre">BoxMesh</span></code>.
Some of these names have been briefly met in previous sections.
The hopefully self-explanatory code snippet below summarizes
typical constructions of meshes with the aid of these tools:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1D domains</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>     <span class="c"># 20 cells, 21 vertices</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># domain [-1,1]</span>

<span class="c"># 2D domains (6x10 divisions, 120 cells, 77 vertices)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># &#39;right&#39; diagonal is default</span>
<span class="c"># The diagonals can be right, left or crossed</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># Domain [0,3]x[0,2] with 6x10 divisions and left diagonals</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>

<span class="c"># 6x10x5 boxes in the unit cube, each box gets 6 tetrahedra:</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c"># Domain [-1,1]x[-1,0]x[-1,2] with 6x10x5 divisions</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transforming-mesh-coordinates">
<span id="tut-mesh-transform-cyl"></span><h3>Transforming mesh coordinates<a class="headerlink" href="#transforming-mesh-coordinates" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-31"></span><span class="target" id="index-32"></span><div class="section" id="coordinate-stretching">
<span id="index-33"></span><h4>Coordinate stretching<a class="headerlink" href="#coordinate-stretching" title="Permalink to this headline">¶</a></h4>
<p>A mesh that is denser toward a boundary is often desired to increase
accuracy in that region. Given a mesh with uniformly spaced
coordinates <span class="math">\(x_0,\ldots,x_{M-1}\)</span> in <span class="math">\([a,b]\)</span>, the coordinate transformation
<span class="math">\(\xi = (x-a)/(b-a)\)</span> maps <span class="math">\(x\)</span> onto <span class="math">\(\xi\in [0,1]\)</span>. A new mapping
<span class="math">\(\eta = \xi^s\)</span>, for some <span class="math">\(s&gt;1\)</span>, stretches the mesh toward <span class="math">\(\xi=0\)</span> (<span class="math">\(x=a\)</span>),
while <span class="math">\(\eta = \xi^{1/s}\)</span> makes a stretching toward <span class="math">\(\xi=1\)</span> (<span class="math">\(x=b\)</span>).
Mapping the <span class="math">\(\eta\in[0,1]\)</span> coordinates back to <span class="math">\([a,b]\)</span> gives new,
stretched <span class="math">\(x\)</span> coordinates,</p>
<div class="math" id="eq-auto40">
\[\tag{95}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^s\]</div>
<p>toward <span class="math">\(x=a\)</span>, or</p>
<div class="math" id="eq-auto41">
\[\tag{96}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^{1/s}\]</div>
<p>toward <span class="math">\(x=b\)</span>. Figure <a class="reference internal" href="#tut-mesh-transform-cyl-fig1"><span class="std std-ref">Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</span></a> shows the
effect of making a rectangular mesh denser toward <span class="math">\(x=0\)</span> (prior to
the coordinate transformation below).</p>
</div>
<div class="section" id="rectangle-to-hollow-circle-mapping">
<h4>Rectangle to hollow circle mapping<a class="headerlink" href="#rectangle-to-hollow-circle-mapping" title="Permalink to this headline">¶</a></h4>
<p>One way of creating more complex geometries is to transform the
vertex coordinates in a rectangular mesh according to some formula.
Say we want to create a part of a hollow cylinder of <span class="math">\(\Theta\)</span> degrees,
with inner radius <span class="math">\(a\)</span> and outer radius <span class="math">\(b\)</span>. A standard mapping from polar
coordinates to Cartesian coordinates can be used to generate the
hollow cylinder. Given a rectangle in <span class="math">\((\bar x, \bar y)\)</span> space such that
<span class="math">\(a\leq \bar x\leq b\)</span> and <span class="math">\(0\leq \bar y\leq 1\)</span>, the mapping</p>
<div class="math">
\[\hat x = \bar x\cos (\Theta \bar y),\quad \hat y = \bar x\sin (\Theta \bar y),\]</div>
<p>takes a point in the rectangular <span class="math">\((\bar x,\bar y)\)</span>
geometry and maps it to a point
<span class="math">\((\hat x, \hat y)\)</span> in a hollow cylinder.</p>
<p>The corresponding Python code for first stretching the mesh and
then mapping it onto a hollow cylinder looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Theta</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">5.0</span>
<span class="n">nr</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c"># divisions in r direction</span>
<span class="n">nt</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c"># divisions in theta direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># First make a denser mesh towards r=a</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">1.3</span>

<span class="k">def</span> <span class="nf">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">))</span><span class="o">**</span><span class="n">s</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span> <span class="o">=</span> <span class="n">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">xy_bar_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_bar_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;stretched mesh&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">)]</span>

<span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span> <span class="o">=</span> <span class="n">cylinder</span><span class="p">(</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">)</span>
<span class="n">xy_hat_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_hat_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;hollow cylinder&#39;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The result of calling <code class="docutils literal"><span class="pre">denser</span></code> and <code class="docutils literal"><span class="pre">cylinder</span></code> above is a list of two
vectors, with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates, respectively.
Turning this list into a <code class="docutils literal"><span class="pre">numpy</span></code> array object results in a <span class="math">\(2\times M\)</span>
array, <span class="math">\(M\)</span> being the number of vertices in the mesh. However,
<code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> is by a convention an <span class="math">\(M\times 2\)</span> array so we
need to take the transpose. The resulting mesh is displayed
in Figure <a class="reference internal" href="#tut-mesh-transform-cyl-fig1"><span class="std std-ref">Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</span></a>.</p>
<div class="figure" id="id23">
<span id="tut-mesh-transform-cyl-fig1"></span><a class="reference internal image-reference" href="_images/hollow_cylinder.png"><img alt="_images/hollow_cylinder.png" src="_images/hollow_cylinder.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</em></span></p>
</div>
<p>Setting boundary conditions in meshes created from mappings like the one
illustrated above is most conveniently done by using a mesh function
to mark parts of the boundary. The marking is easiest to perform
before the mesh is mapped since one can then conceptually work with
the sides in a pure rectangle.</p>
</div>
</div>
</div>
<div class="section" id="a-general-dimensional-multi-material-test-problem">
<span id="tut-possion-nd-nmat"></span><h2>A General <span class="math">\(d\)</span>-Dimensional multi-material test problem<a class="headerlink" href="#a-general-dimensional-multi-material-test-problem" title="Permalink to this headline">¶</a></h2>
<p><strong>This section is in a preliminary state!</strong></p>
<p>The purpose of the present section is to generalize the basic
ideas from the previous section to a problem involving
an arbitrary number of materials in 1D, 2D, or 3D domains.
The example also highlights how to build more general and flexible
FEniCS applications.</p>
<p>More to be done:</p>
<blockquote>
<div><ul class="simple">
<li>Batch compilation of subdomains, see mailinglist.txt, lots of
useful stuff in Hake&#8217;s example with &#8220;pointwise&#8221;, see what the
bcs are etc.</li>
<li>Use of <code class="docutils literal"><span class="pre">near</span></code> or similar function (better: user-adjusted tolerance)</li>
</ul>
</div></blockquote>
<div class="section" id="the-pde-problem">
<span id="tut-possion-nd-nmat-pde"></span><h3>The PDE problem<a class="headerlink" href="#the-pde-problem" title="Permalink to this headline">¶</a></h3>
<p>We generalize the problem in the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>
to the case where there are <span class="math">\(s\)</span> materials <span class="math">\(\Omega_0,\ldots,\Omega_{s-1}\)</span>,
with associated constant <span class="math">\(k\)</span> values <span class="math">\(k_0,k_1,\ldots,k_{s-1}\)</span>,
as illustrated in Figure <a class="reference internal" href="#tut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a>.</p>
<div class="figure" id="id24">
<span id="tut-possion-nd-nmat-fig1"></span><a class="reference internal image-reference" href="_images/layers.sh"><img alt="_images/layers.sh" src="_images/layers.sh" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a multi-material problem</em></span></p>
</div>
<p>Although the sketch of the domain is in two dimensions, we can easily
define this problem in any number of dimensions, using
the ideas of the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>, but the layer
boundaries are planes <span class="math">\(x_0=\hbox{const}\)</span> and <span class="math">\(u\)</span> varies with
<span class="math">\(x_0\)</span> only.</p>
<p>The PDE reads</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff2">
\[\tag{97}
\nabla\cdot (k\nabla u) =0 {\thinspace .}\]</div>
<p>To construct a problem where we can find an analytical solution that can
be computed to machine precision regardless of the element size,
we choose <span class="math">\(\Omega\)</span> as a hypercube <span class="math">\([0,1]^d\)</span>, and the materials as
layers in the <span class="math">\(x_0\)</span> direction, as depicted in
Figure <a class="reference internal" href="#tut-possion-nd-nmat-fig1"><span class="std std-ref">Sketch of a multi-material problem</span></a> for a 2D case with four materials.
The boundaries <span class="math">\(x_0=0\)</span> and <span class="math">\(x_0=1\)</span> have Dirichlet conditions
<span class="math">\(u=0\)</span> and <span class="math">\(u=1\)</span>, respectively, while Neumann conditions
<span class="math">\(\partial u/\partial n=0\)</span> are set on the remaining boundaries.
The complete boundary-value problem is then</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff3">
\[\begin{split}\tag{98}
\begin{array}{rcll}
        \nabla\cdot \left(k(x_0)\nabla u(x_0,\ldots,x_{d-1})\right)
          &amp;= 0 &amp;\mbox{in } \Omega, \\
        u &amp;= 0 &amp;\mbox{on } \Gamma_0,\\
        u &amp;= 1 &amp;\mbox{on } \Gamma_1,\\
        {\partial u\over\partial n} &amp;= 0 &amp;\mbox{on } \Gamma_N{\thinspace .}
      \end{array}\end{split}\]</div>
<p>The domain <span class="math">\(\Omega\)</span> is divided into <span class="math">\(s\)</span> materials <span class="math">\(\Omega_i\)</span>, <span class="math">\(i=0,\ldots,s-1\)</span>,
where</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i \leq x_0 &lt; L_{i+1}\}\end{split}\]</div>
<p>for given <span class="math">\(x_0\)</span> values <span class="math">\(0=L_0&lt;L_1&lt;\cdots&lt; L_s=1\)</span>
of the material (subdomain) boundaries.
The <span class="math">\(k(x_0)\)</span> function takes on the value <span class="math">\(k_i\)</span> in <span class="math">\(\Omega_i\)</span>.</p>
<p>The exact solution of the basic PDE
in <a class="reference internal" href="#eq-tut-poisson-2d-varcoeff3"><span class="std std-ref">(98)</span></a></p>
<div class="math">
\[u(x_0,\ldots,x_{d-1}) =
{\int_0^{x_0} (k(\tau ))^{-1}d\tau\over
\int_0^1 (k(\tau ))^{-1}d\tau}{\thinspace .}\]</div>
<p>For a piecewise constant <span class="math">\(k(x_0)\)</span> as explained, we get</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff2-exact">
\[\tag{99}
u(x_0,\ldots,x_{d-1}) =
    {(x_0-L_i)k_i^{-1} + \sum_{j=0}^{i-1} (L_{j+1}-L_j)k_j^{-1}\over
    \sum_{j=0}^{s-1} (L_{j+1}-L_j)k_j^{-1}},\quad L_i\leq x_0 \leq L_{i+1}{\thinspace .}\]</div>
<p>That is, <span class="math">\(u(x_0,\ldots,x_{d-1})\)</span> is piecewise linear in <span class="math">\(x_0\)</span> and
constant in all other directions.
If <span class="math">\(L_i\)</span>
coincides with the element boundaries, Lagrange elements will
reproduce this exact solution to machine precision, which is ideal
for a test case.</p>
</div>
<div class="section" id="preparing-a-mesh-with-subdomains">
<span id="tut-possion-nd-nmat-prepro"></span><h3>Preparing a mesh with subdomains<a class="headerlink" href="#preparing-a-mesh-with-subdomains" title="Permalink to this headline">¶</a></h3>
<p>Our first task is to generate a mesh for <span class="math">\(\Omega = [0,1]^d\)</span> and divide
it into subdomains</p>
<div class="math">
\[\begin{split}\Omega_i = \{ (x_0,\ldots,x_{d-1})\, |\, L_i &lt; x_0 &lt; L_{i+1}\}\end{split}\]</div>
<p>for given subdomain boundaries <span class="math">\(x_0=L_i\)</span>, <span class="math">\(i=0,\ldots,s\)</span>, <span class="math">\(L_0=0\)</span>, <span class="math">\(L_s=1\)</span>.
Note that the boundaries <span class="math">\(x_0=L_i\)</span> are points in 1D, lines in 2D, and
planes in 3D.</p>
<p>Let us, on the command line, specify the polynomial degree of Lagrange
elements and the number of element divisions in the various space
directions, as explained in detail in
the section <a class="reference internal" href="._ftut003.html#tut-poisson-nd"><span class="std std-ref">Parameterizing the number of space dimensions</span></a>. This results in an object <code class="docutils literal"><span class="pre">mesh</span></code>
representing the interval <span class="math">\([0,1]\)</span> in 1D, the unit square in 2D, or the
unit cube in 3D.</p>
<p>Specification of subdomains (and boundary parts, if desired) is
done using a user-defined subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code>, as
explained in the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>.
We could, in principle,
introduce one subclass of <code class="docutils literal"><span class="pre">SubDomain</span></code> for each subdomain, and
this would be feasible if one has a small and fixed number of
subdomains as in the example in the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a> with
two subdomains. Our present case is more general as we
have <span class="math">\(s\)</span> subdomains. It then makes sense to create one
subclass <code class="docutils literal"><span class="pre">Material</span></code> of <code class="docutils literal"><span class="pre">SubDomain</span></code> and have an attribute
to reflect the subdomain (material) number. We use this number
in the test whether a spatial point <code class="docutils literal"><span class="pre">x</span></code> is inside a subdomain or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Material</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define material (subdomain) no. i.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomain_number</span><span class="p">,</span> <span class="n">subdomain_boundaries</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">subdomain_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">subdomain_boundaries</span>
        <span class="n">SubDomain</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span>         <span class="c"># short form (cf. the math)</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&lt;=</span></code> in the test if a point is inside a subdomain is important as
<code class="docutils literal"><span class="pre">x</span></code> will equal vertex coordinates in the cells, and all vertices
of a cell must lead to a <code class="docutils literal"><span class="pre">True</span></code> return value from the <code class="docutils literal"><span class="pre">inside</span></code>
method
for the cell to be a part of the actual subdomain. That is, the
more mathematically natural test <code class="docutils literal"><span class="pre">L[i]</span> <span class="pre">&lt;=</span> <span class="pre">x[0]</span> <span class="pre">&lt;</span> <span class="pre">L[i+1]</span></code> fails to
include elements with <span class="math">\(x=L_{i+1}\)</span> as boundary in subdomain <span class="math">\(\Omega_i\)</span>.</p>
<p>The marking and numbering of all subdomains
goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cell_entity_dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c"># = d</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">cell_entity_dim</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers i=0,1,\ldots,s (=len(L)-1)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">material_i</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">material_i</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>We have now all the geometric information about subdomains in
a <code class="docutils literal"><span class="pre">MeshFunction</span></code> object <code class="docutils literal"><span class="pre">subdomains</span></code>. The subdomain number
of mesh entity number <code class="docutils literal"><span class="pre">e</span></code>, here cell <code class="docutils literal"><span class="pre">e</span></code>, is given
by <code class="docutils literal"><span class="pre">subdomains.array()[e]</span></code>.</p>
<p id="index-34">The code presented so far had the purpose of preparing a mesh and
a mesh function defining the subdomain. It is smart to put this code
in a separate file, say <code class="docutils literal"><span class="pre">define_layers.py</span></code>,
and view the code as a preprocessing step.
We must then store the computed mesh and mesh function in files.
Another program may load the files and perform the actually
solve the boundary-value problem.</p>
<p>Storing the mesh itself and the mesh function in XML format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">subdomains</span>
</pre></div>
</div>
<p>This preprocessing code knows about the layer geometries and
the corresponding <span class="math">\(k\)</span>, which
must be propagated to the solver code. One idea is to let the
preprocessing code write a Python module containing
the <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">k</span></code> lists as well as an implementation of a
function that evaluates the exact solution.
The solver code can import this module to get access to <code class="docutils literal"><span class="pre">L</span></code>,
<code class="docutils literal"><span class="pre">k</span></code>, and the exact solution (for comparison).
The relevant Python code for generating a Python module may take
the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;u_layered.py&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">import numpy</span>
<span class="s">L = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">k = numpy.array(</span>
<span class="s">#s, float)</span>
<span class="s">s = len(L)-1</span>

<span class="s">def u_e(x):</span>
<span class="s">    # First find which subdomain x0 is located in</span>
<span class="s">    for i in range(len(L)-1):</span>
<span class="s">        if L[i] &lt;= x &lt;= L[i+1]:</span>
<span class="s">            break</span>

<span class="s">    # Vectorized implementation of summation:</span>
<span class="s">    s2 = sum((L[1:s+1] - L[0:s])*(1.0/k[:]))</span>
<span class="s">    if i == 0:</span>
<span class="s">        u = (x - L[i])*(1.0/k[0])/s2</span>
<span class="s">    else:</span>
<span class="s">        s1 = sum((L[1:i+1] - L[0:i])*(1.0/k[0:i]))</span>
<span class="s">        u = ((x - L[i])*(1.0/k[i]) + s1)/s2</span>
<span class="s">    return u</span>

<span class="s">if __name__ == &#39;__main__&#39;:</span>
<span class="s">    # Plot the exact solution</span>
<span class="s">    from scitools.std import linspace, plot, array</span>
<span class="s">    x = linspace(0, 1, 101)</span>
<span class="s">    u = array([u_e(xi) for xi in x])</span>
<span class="s">    print(u)</span>
<span class="s">    plot(x, u)</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># (L, k))</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-the-pde-problem">
<span id="tut-possion-nd-nmat-solve"></span><h3>Solving the PDE problem<a class="headerlink" href="#solving-the-pde-problem" title="Permalink to this headline">¶</a></h3>
<p>The solver program starts with loading a prepared mesh with a mesh
function representing the subdomains:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s">&#39;hypercube_mesh.xml.gz&#39;</span><span class="p">)</span>
<span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;layers.xml.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the <span class="math">\(k\)</span> function as a finite element function.
As we recall from the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>, a <span class="math">\(k\)</span> that
is constant in each element is suitable.
We then follow the recipe from the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>
to compute <span class="math">\(k\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>

<span class="c"># Vectorized calculation</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The essential boundary conditions are defined in the same way is
in <code class="docutils literal"><span class="pre">dn2_p2D.py</span></code> from the section <a class="reference internal" href="._ftut003.html#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>
and therefore not repeated here.
The variational problem is defined and solved in a standard manner,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">VariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Plotting the discontinuous <code class="docutils literal"><span class="pre">k</span></code> is often desired. Just a <code class="docutils literal"><span class="pre">plot(k)</span></code>
makes a continuous function out of <code class="docutils literal"><span class="pre">k</span></code>, which is not what we want.
Making a <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells and filling in the right <span class="math">\(k\)</span>
values results in an object that can be displayed as a discontinuous field.
A relevant code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_meshfunc</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;double&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>

<span class="c"># Scalar version</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">i</span><span class="p">]]</span>

<span class="c"># Vectorized version</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k_meshfunc</span><span class="o">.</span><span class="n">array</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">k_meshfunc</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;k as mesh function&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <code class="docutils literal"><span class="pre">Poisson_layers.py</span></code> contains the complete code.</p>
</div>
</div>
<div class="section" id="more-examples">
<h2>More Examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h2>
<p>Many more topics could be treated in a FEniCS tutorial, e.g., how
to solve systems of PDEs, how to work with mixed finite element
methods, how to create more complicated meshes and mark boundaries,
and how to create more advanced visualizations.  However, to limit the
size of this tutorial, the examples end here.
There are, fortunately, a rich set of FEniCS demos.
The FEniCS documentation explains a collection of PDE solvers in detail:
the Poisson equation, the mixed formulation for the Poission equation,
the Biharmonic equation, the equations of hyperelasticity, the
Cahn-Hilliard equation, and the incompressible Navier-Stokes equations.
Both Python and C++ versions of these solvers are explained.
An eigenvalue solver is also documented.
In the <code class="docutils literal"><span class="pre">fenics/demo</span></code> directory of the DOLFIN source code tree you can
find programs for these and many other examples, including
the advection-diffusion equation,
the equations of elastodynamics,
a reaction-diffusion equation,
various finite element methods for the Stokes problem,
discontinuous Galerkin methods for
the Poisson and advection-diffusion equations,
and an eigenvalue problem arising from electromagnetic waveguide
problem with Nedelec elements.
There are also numerous demos on how to apply various functionality in
FEniCS, e.g., mesh refinement and error control,
moving meshes (for ALE methods),
computing functionals over subsets of the mesh (such as
lift and drag on bodies in flow), and
creating separate subdomain meshes from a parent mesh.</p>
<p>The project cbc.solve (<a class="reference external" href="https://launchpad.net/cbc.solve">https://launchpad.net/cbc.solve</a>) offers
more complete PDE solvers for the Navier-Stokes equations, the
equations of hyperelasticity, fluid-structure interaction, viscous
mantle flow, and the bidomain model of electrophysiology.  Most of
these solvers are described in the &#8220;FEniCS book&#8221; <a class="reference internal" href="._ftut005.html#ref01" id="id1">[Ref01]</a>
(<a class="reference external" href="https://launchpad.net/fenics-book">https://launchpad.net/fenics-book</a>).  Another project, cbc.rans
(<a class="reference external" href="https://launchpad.net/cbc.rans">https://launchpad.net/cbc.rans</a>), offers an environment for very
flexible and easy implementation of Navier-Stokes solvers and
turbulence <a class="reference internal" href="._ftut005.html#ref04" id="id2">[Ref04]</a> <a class="reference internal" href="._ftut005.html#ref05" id="id3">[Ref05]</a>. For example, cbc.rans
contains an elliptic relaxation model for turbulent flow involving 18
nonlinear PDEs.  FEniCS proved to be an ideal environment for
implementing such complicated PDE models.  The easy construction of
systems of nonlinear PDEs in cbc.rans has been further generalized to
simplify the implementation of large systems of nonlinear PDEs in
general.  The functionality is found in the cbc.pdesys package
(<a class="reference external" href="https://launchpad.net/cbcpdesys">https://launchpad.net/cbcpdesys</a>).</p>
</div>
<div class="section" id="miscellaneous-topics">
<h2>Miscellaneous topics<a class="headerlink" href="#miscellaneous-topics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="glossary">
<h3>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-35"></span><span class="target" id="index-36"></span><span class="target" id="index-37"></span><span class="target" id="index-38"></span><span class="target" id="index-39"></span><span class="target" id="index-40"></span><span class="target" id="index-41"></span><span class="target" id="index-42"></span><p id="index-43">Below we explain some key terms used in this tutorial.</p>
<blockquote>
<div><dl class="docutils">
<dt>FEniCS: name of a software suite composed of many individual software</dt>
<dd>components (see <code class="docutils literal"><span class="pre">fenicsproject.org</span></code>). Some components are DOLFIN and
Viper, explicitly referred to in this tutorial. Others are
FFC and FIAT, heavily used by the programs appearing in this tutorial,
but never explicitly used from the programs.</dd>
<dt>DOLFIN: a FEniCS component, more precisely a C++ library, with</dt>
<dd>a Python interface, for performing important actions in finite element
programs. DOLFIN makes use of many other FEniCS components and
many external software packages.</dd>
<dt>Viper:  a FEniCS component for quick visualization of finite element</dt>
<dd>meshes and solutions.</dd>
<dt>UFL:    a FEniCS component implementing the <em>unified form language</em></dt>
<dd>for specifying finite element forms in FEniCS programs.
The definition of the forms, typically called <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> in
this tutorial, must have legal UFL syntax. The same applies to
the definition of functionals (see the section <a class="reference internal" href="._ftut003.html#tut-poisson1-functionals"><span class="std std-ref">Computing functionals</span></a>).</dd>
<dt>Class (Python): a programming construction for creating objects</dt>
<dd>containing a set of variables and functions. Most
types of FEniCS objects are defined through the class concept.</dd>
<dt>Instance (Python): an object of a particular type, where the type is</dt>
<dd>implemented as a class. For instance,
<code class="docutils literal"><span class="pre">mesh</span> <span class="pre">=</span> <span class="pre">UnitIntervalMesh(10)</span></code> creates
an instance of class <code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>, which is reached by the
name <code class="docutils literal"><span class="pre">mesh</span></code>. (Class <code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code> is actually just
an interface to a corresponding C++ class in the DOLFIN C++ library.)</dd>
<dt>Class method (Python): a function in a class, reached by dot</dt>
<dd>notation: <code class="docutils literal"><span class="pre">instance_name.method_name</span></code></dd>
<dt>argument <code class="docutils literal"><span class="pre">self</span></code> (Python): required first parameter in class methods,</dt>
<dd>representing a particular object of the class.
Used in method definitions, but never in calls to a method.
For example, if <code class="docutils literal"><span class="pre">method(self,</span> <span class="pre">x)</span></code> is the definition of
<code class="docutils literal"><span class="pre">method</span></code> in a class <code class="docutils literal"><span class="pre">Y</span></code>, <code class="docutils literal"><span class="pre">method</span></code> is called as
<code class="docutils literal"><span class="pre">y.method(x)</span></code>, where <code class="docutils literal"><span class="pre">y</span></code> is an instance of class <code class="docutils literal"><span class="pre">Y</span></code>.
In a call like <code class="docutils literal"><span class="pre">y.method(x)</span></code>, <code class="docutils literal"><span class="pre">method</span></code> is invoked with
<code class="docutils literal"><span class="pre">self=y</span></code>.</dd>
<dt>Class attribute (Python): a variable in a class, reached by</dt>
<dd>dot notation: <code class="docutils literal"><span class="pre">instance_name.attribute_name</span></code></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="overview-of-objects-and-functions">
<h3>Overview of objects and functions<a class="headerlink" href="#overview-of-objects-and-functions" title="Permalink to this headline">¶</a></h3>
<p>Most classes in FEniCS have an explanation of the purpose and usage
that can be seen by using the general documentation command
<code class="docutils literal"><span class="pre">pydoc</span></code> for Python objects. You can type</p>
<div class="highlight-text" id="index-44"><div class="highlight"><pre>pydoc fenics.X
</pre></div>
</div>
<p>to look up documentation of a Python class <code class="docutils literal"><span class="pre">X</span></code> from the DOLFIN
library (<code class="docutils literal"><span class="pre">X</span></code> can be <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>,
<code class="docutils literal"><span class="pre">Viper</span></code>, etc.). Below is an overview of the most important classes
and functions
in FEniCS programs, in the order they typically appear within programs.</p>
<p><code class="docutils literal"><span class="pre">UnitSquareMesh(nx,</span> <span class="pre">ny)</span></code>: generate mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span> using <code class="docutils literal"><span class="pre">nx</span></code> divisions in <span class="math">\(x\)</span> direction and
<code class="docutils literal"><span class="pre">ny</span></code> divisions in <span class="math">\(y\)</span> direction. Each of the <code class="docutils literal"><span class="pre">nx*ny</span></code> squares
are divided into two cells of triangular shape.</p>
<p><code class="docutils literal"><span class="pre">UnitIntervalMesh</span></code>, <code class="docutils literal"><span class="pre">UnitCubeMesh</span></code>, <code class="docutils literal"><span class="pre">UnitCircleMesh</span></code>, <code class="docutils literal"><span class="pre">UnitSphere</span></code>,
<code class="docutils literal"><span class="pre">IntervalMesh</span></code>, <code class="docutils literal"><span class="pre">RectangleMesh</span></code>, and <code class="docutils literal"><span class="pre">BoxMesh</span></code>: generate mesh over
domains of simple geometric shape, see the section <a class="reference internal" href="#tut-prepro"><span class="std std-ref">Creating more complex domains</span></a>.</p>
<p><code class="docutils literal"><span class="pre">FunctionSpace(mesh,</span> <span class="pre">element_type,</span> <span class="pre">degree)</span></code>:
a function space defined over a mesh, with a given element type
(e.g., <code class="docutils literal"><span class="pre">'Lagrange'</span></code> or <code class="docutils literal"><span class="pre">'DG'</span></code>), with basis functions as polynomials of
a specified degree.</p>
<p><code class="docutils literal"><span class="pre">Expression(formula,</span> <span class="pre">p1=v1,</span> <span class="pre">p2=v2,</span> <span class="pre">...)</span></code>:
a scalar- or vector-valued function, given as a
mathematical expression <code class="docutils literal"><span class="pre">formula</span></code> (string) written in C++ syntax.
The spatial coordinates in the expression are named
<code class="docutils literal"><span class="pre">x[0]</span></code>, <code class="docutils literal"><span class="pre">x[1]</span></code>, and <code class="docutils literal"><span class="pre">x[2]</span></code>, while time and other
physical parameters can be represented as symbols <code class="docutils literal"><span class="pre">p1</span></code>, <code class="docutils literal"><span class="pre">p2</span></code>,
etc., with corresponding values <code class="docutils literal"><span class="pre">v1</span></code>, <code class="docutils literal"><span class="pre">v2</span></code>, etc., initialized
through keyword arguments. These parameters become attributes,
whose values can be modified when desired.</p>
<p><code class="docutils literal"><span class="pre">Function(V)</span></code>: a scalar- or vector-valued finite element field in
the function space <code class="docutils literal"><span class="pre">V</span></code>. If <code class="docutils literal"><span class="pre">V</span></code> is a <code class="docutils literal"><span class="pre">FunctionSpace</span></code> object,
<code class="docutils literal"><span class="pre">Function(V)</span></code> becomes a scalar field, and with <code class="docutils literal"><span class="pre">V</span></code> as a
<code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> object, <code class="docutils literal"><span class="pre">Function(V)</span></code> becomes a
vector field.</p>
<p><code class="docutils literal"><span class="pre">SubDomain</span></code>: class for defining a subdomain, either a part of the
boundary, an internal boundary, or a part of the domain.
The programmer must subclass <code class="docutils literal"><span class="pre">SubDomain</span></code> and implement the
<code class="docutils literal"><span class="pre">inside(self,</span> <span class="pre">x,</span> <span class="pre">on_boundary)</span></code> function
(see the section <a class="reference internal" href="._ftut003.html#tut-poisson1-impl"><span class="std std-ref">A basic Poisson solver</span></a>) for telling whether a
point <code class="docutils literal"><span class="pre">x</span></code> is inside the subdomain or not.</p>
<p><code class="docutils literal"><span class="pre">Mesh</span></code>: class for representing a finite element mesh, consisting of
cells, vertices, and optionally faces, edges, and facets.</p>
<p><code class="docutils literal"><span class="pre">MeshFunction</span></code>: tool for marking parts of the domain or the boundary.
Used for variable coefficients (&#8220;material properties&#8221;, see
the section <a class="reference internal" href="._ftut003.html#tut-possion-2d-2mat-impl"><span class="std std-ref">Working with subdomains</span></a>) or for
boundary conditions (see the section <a class="reference internal" href="._ftut003.html#tut-poisson-multi-bc"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>).</p>
<p><code class="docutils literal"><span class="pre">DirichletBC(V,</span> <span class="pre">value,</span> <span class="pre">where)</span></code>: specification of Dirichlet (essential)
boundary conditions via a function space <code class="docutils literal"><span class="pre">V</span></code>, a function
<code class="docutils literal"><span class="pre">value(x)</span></code> for computing the value of the condition at a point <code class="docutils literal"><span class="pre">x</span></code>,
and a specification <code class="docutils literal"><span class="pre">where</span></code> of the boundary, either as a
<code class="docutils literal"><span class="pre">SubDomain</span></code> subclass instance, a plain function, or as a
<code class="docutils literal"><span class="pre">MeshFunction</span></code> instance.
In the latter case, a 4th argument is provided to describe which subdomain
number that describes the relevant boundary.</p>
<p><code class="docutils literal"><span class="pre">TestFunction(V)</span></code>: define a test function on a space <code class="docutils literal"><span class="pre">V</span></code> to be used
in a variational form.</p>
<p><code class="docutils literal"><span class="pre">TrialFunction(V)</span></code>: define a trial function on a space <code class="docutils literal"><span class="pre">V</span></code> to be used
in a variational form to represent the unknown in a finite element problem.</p>
<p><code class="docutils literal"><span class="pre">assemble(X)</span></code>: assemble a matrix, a right-hand side, or a functional,
given a from <code class="docutils literal"><span class="pre">X</span></code> written with UFL syntax.</p>
<p><code class="docutils literal"><span class="pre">assemble_system(a,</span> <span class="pre">L,</span> <span class="pre">bcs)</span></code>: assemble the matrix and the right-hand
side from a bilinear (<code class="docutils literal"><span class="pre">a</span></code>) and linear (<code class="docutils literal"><span class="pre">L</span></code>) form written with UFL
syntax. The <code class="docutils literal"><span class="pre">bcs</span></code> parameter holds one or more <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects.</p>
<p><code class="docutils literal"><span class="pre">LinearVariationalProblem(a,</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bcs)</span></code>: define a variational problem,
given a bilinear (<code class="docutils literal"><span class="pre">a</span></code>) and linear (<code class="docutils literal"><span class="pre">L</span></code>) form, written with UFL
syntax, and one or more <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects stored in <code class="docutils literal"><span class="pre">bcs</span></code>.</p>
<p><code class="docutils literal"><span class="pre">LinearVariationalSolver(problem)</span></code>: create solver object for a linear
variational problem object (<code class="docutils literal"><span class="pre">problem</span></code>).</p>
<p><code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code>: solve a linear system with <code class="docutils literal"><span class="pre">A</span></code> as coefficient
matrix (<code class="docutils literal"><span class="pre">Matrix</span></code> object), <code class="docutils literal"><span class="pre">U</span></code> as unknown (<code class="docutils literal"><span class="pre">Vector</span></code> object),
and <code class="docutils literal"><span class="pre">b</span></code> as right-hand side (<code class="docutils literal"><span class="pre">Vector</span></code> object).
Usually, <code class="docutils literal"><span class="pre">U</span> <span class="pre">=</span> <span class="pre">u.vector()</span></code>, where
<code class="docutils literal"><span class="pre">u</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code> object representing the unknown finite
element function of the problem, while
<code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are computed by calls to <code class="docutils literal"><span class="pre">assemble</span></code>
or <code class="docutils literal"><span class="pre">assemble_system</span></code>.</p>
<p><code class="docutils literal"><span class="pre">plot(q)</span></code>: quick visualization of a mesh, function, or mesh function
<code class="docutils literal"><span class="pre">q</span></code>, using the Viper component in FEniCS.</p>
<p><code class="docutils literal"><span class="pre">interpolate(func,</span> <span class="pre">V)</span></code>: interpolate a formula or finite
element function <code class="docutils literal"><span class="pre">func</span></code> onto the function space <code class="docutils literal"><span class="pre">V</span></code>.</p>
<p><code class="docutils literal"><span class="pre">project(func,</span> <span class="pre">V)</span></code>: project a formula or finite element function <code class="docutils literal"><span class="pre">func</span></code>
onto the function space <code class="docutils literal"><span class="pre">V</span></code>.</p>
</div>
<div class="section" id="linear-solvers-and-preconditioners">
<span id="tut-app-solver-prec"></span><h3>Linear solvers and preconditioners<a class="headerlink" href="#linear-solvers-and-preconditioners" title="Permalink to this headline">¶</a></h3>
<p>The following solution methods for linear
systems can be accessed in FEniCS programs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'lu'</span></code></td>
<td>sparse LU factorization (Gaussian elim.)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'cholesky'</span></code></td>
<td>sparse Cholesky factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'cg'</span></code></td>
<td>Conjugate gradient method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'gmres'</span></code></td>
<td>Generalized minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'bicgstab'</span></code></td>
<td>Biconjugate gradient stabilized method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'minres'</span></code></td>
<td>Minimal residual method</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'tfqmr'</span></code></td>
<td>Transpose-free quasi-minimal residual method</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'richardson'</span></code></td>
<td>Richardson method</td>
</tr>
</tbody>
</table>
<p>Possible choices of preconditioners include</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'none'</span></code></td>
<td>No preconditioner</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ilu'</span></code></td>
<td>Incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'icc'</span></code></td>
<td>Incomplete Cholesky factorization</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'jacobi'</span></code></td>
<td>Jacobi iteration</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'bjacobi'</span></code></td>
<td>Block Jacobi iteration</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'sor'</span></code></td>
<td>Successive over-relaxation</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'amg'</span></code></td>
<td>Algebraic multigrid (BoomerAMG or ML)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'additive_schwarz'</span></code></td>
<td>Additive Schwarz</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'hypre_amg'</span></code></td>
<td>Hypre algebraic multigrid (BoomerAMG)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'hypre_euclid'</span></code></td>
<td>Hypre parallel incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'hypre_parasails'</span></code></td>
<td>Hypre parallel sparse approximate inverse</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ml_amg'</span></code></td>
<td>ML algebraic multigrid</td>
</tr>
</tbody>
</table>
<p>Many of the choices listed above
are only offered by a specific backend, so setting the backend
appropriately is necessary for being able to choose a desired
linear solver or preconditioner. You can also use constructions like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prec</span> <span class="o">=</span> <span class="s">&#39;amg&#39;</span> <span class="k">if</span> <span class="n">has_krylov_solver_preconditioner</span><span class="p">(</span><span class="s">&#39;amg&#39;</span><span class="p">)</span> \
       <span class="k">else</span> <span class="s">&#39;default&#39;</span>
</pre></div>
</div>
<p>An up-to-date list of the available solvers and preconditioners
in FEniCS can be produced by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_solver_methods</span><span class="p">()</span>
<span class="n">list_krylov_solver_preconditioners</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-backend-specific-solver">
<span id="tut-epetra"></span><h3>Using a backend-specific solver<a class="headerlink" href="#using-a-backend-specific-solver" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The linear algebra backends in FEniCS have recently changed. This
section is not yet up-to-date.</p>
</div>
<span class="target" id="index-45"></span><p id="index-46">The linear algebra backend determines the specific data structures
that are used in the <code class="docutils literal"><span class="pre">Matrix</span></code> and <code class="docutils literal"><span class="pre">Vector</span></code> classes. For example, with
the PETSc backend, <code class="docutils literal"><span class="pre">Matrix</span></code> encapsulates a PETSc matrix storage
structure, and <code class="docutils literal"><span class="pre">Vector</span></code> encapsulates a PETSc vector storage structure.
Sometimes one wants to perform operations directly on (say) the
underlying PETSc objects. These can be fetched by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span> <span class="n">b_PETSc</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span> <span class="n">U_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">u</span></code> is a <code class="docutils literal"><span class="pre">Function</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is a
<code class="docutils literal"><span class="pre">Matrix</span></code>, and <code class="docutils literal"><span class="pre">b</span></code> is a <code class="docutils literal"><span class="pre">Vector</span></code>.  The same syntax applies if we want
to fetch the underlying Epetra, uBLAS, or MTL4 matrices and vectors.</p>
<span class="target" id="index-47"></span><p id="index-48">Sometimes one wants to implement tailored solution algorithms, using
special features of the underlying numerical packages.
Here is an example where we create an ML preconditioned Conjugate
Gradient solver by programming with Trilinos-specific objects directly.
Given a linear system
<span class="math">\(AU=b\)</span>, represented by a <code class="docutils literal"><span class="pre">Matrix</span></code> object <code class="docutils literal"><span class="pre">A</span></code>,
and two <code class="docutils literal"><span class="pre">Vector</span></code> objects <code class="docutils literal"><span class="pre">U</span></code> and <code class="docutils literal"><span class="pre">b</span></code> in a
Python program, the purpose is to
set up a solver using the Aztec Conjugate Gradient method from
Trilinos&#8217; Aztec library and combine that solver with the
algebraic multigrid preconditioner ML
from the ML library in Trilinos. Since the various parts of
Trilinos are mirrored in Python through the PyTrilinos package,
we can operate directly
on Trilinos-specific objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">PyTrilinos</span> <span class="kn">import</span> <span class="n">Epetra</span><span class="p">,</span> <span class="n">AztecOO</span><span class="p">,</span> <span class="n">TriUtils</span><span class="p">,</span> <span class="n">ML</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;&#39;&#39;You Need to have PyTrilinos with</span>
<span class="s">Epetra, AztecOO, TriUtils and ML installed</span>
<span class="s">for this demo to run&#39;&#39;&#39;</span><span class="p">)</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">has_la_backend</span><span class="p">(</span><span class="s">&#39;Epetra&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Warning: Dolfin is not compiled with Trilinos&#39;</span><span class="p">)</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Epetra&#39;</span>

<span class="c"># create matrix A and vector b in the usual way</span>
<span class="c"># u is a Function</span>

<span class="c"># Fetch underlying Epetra objects</span>
<span class="n">A_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
<span class="n">b_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
<span class="n">U_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>

<span class="c"># Sets up the parameters for ML using a python dictionary</span>
<span class="n">ML_param</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;max levels&quot;</span>        <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s">&quot;output&quot;</span>            <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s">&quot;smoother: type&quot;</span>    <span class="p">:</span> <span class="s">&quot;ML symmetric Gauss-Seidel&quot;</span><span class="p">,</span>
            <span class="s">&quot;aggregation: type&quot;</span> <span class="p">:</span> <span class="s">&quot;Uncoupled&quot;</span><span class="p">,</span>
            <span class="s">&quot;ML validate parameter list&quot;</span> <span class="p">:</span> <span class="bp">False</span>
<span class="p">}</span>

<span class="c"># Create the preconditioner</span>
<span class="n">prec</span> <span class="o">=</span> <span class="n">ML</span><span class="o">.</span><span class="n">MultiLevelPreconditioner</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">SetParameterList</span><span class="p">(</span><span class="n">ML_param</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">ComputePreconditioner</span><span class="p">()</span>

<span class="c"># Create solver and solve system</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AztecOO</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="n">U_epetra</span><span class="p">,</span> <span class="n">b_epetra</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetPrecOperator</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_solver</span><span class="p">,</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_cg</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_output</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">Iterate</span><span class="p">(</span><span class="n">MaxIters</span><span class="o">=</span><span class="mi">1550</span><span class="p">,</span> <span class="n">Tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="installing-fenics">
<span id="tut-app-install"></span><h3>Installing FEniCS<a class="headerlink" href="#installing-fenics" title="Permalink to this headline">¶</a></h3>
<p id="index-49">The FEniCS software components are available for Linux, Windows and Mac OS
X platforms. Detailed information on how to get FEniCS running on such
machines are available at the <code class="docutils literal"><span class="pre">fenicsproject.org</span></code> website.
Here are just some quick descriptions and recommendations by the author.</p>
<p>To make the installation of FEniCS as painless and reliable as
possible, I strongly recommend to use Ubuntu Linux.  (Even though Mac
users now can get FEniCS by a one-click install, I recommend using
Ubuntu on Mac, unless you have significant experience with compiling
and linking C++ libraries on Mac OS X.)  Any standard PC can easily be
equipped with Ubuntu Linux, which may live side by side with either
Windows or Mac OS X or another Linux installation.</p>
<p>On Windows you can use the tool <a class="reference external" href="http://www.ubuntu.com/download/desktop/windows-installer">Wubi</a> to
automatically install Ubuntu in a dual boot fashion.  A very popular
alternative is to run Ubuntu in a separate window in your existing
operation system, using a <em>virtual machine</em>.  There are several
virtual machine solutions to chose among, e.g., the free <a class="reference external" href="https://www.virtualbox.org/">VirtualBoxMesh</a> or the commercial tool <a class="reference external" href="http://www.vmware.com/products/fusion/">VMWare Fusion</a>. VirtualBoxMesh works well for
many, but there might be hardware integration problems on Mac, so the
superior VMWare Fusion tool is often worth the investment.  The author
has a description of <a class="reference external" href="http://hplgit.github.io/teamods/ubuntu/vmware/index.html">how to install Ubuntu in a VMWare Fusion virtual
machine</a>.</p>
<p>Once Ubuntu
is up and running, FEniCS is painlessly installed by</p>
<div class="highlight-text"><div class="highlight"><pre>sudo apt-get install fenics
</pre></div>
</div>
<p>Sometimes the FEniCS software in a standard Ubuntu installation
lacks some recent features and bug fixes. Go to
<a class="reference external" href="http://fenicsproject.org">fenicsproject.org</a>, click on <em>Download</em>
and then the Ubuntu logo, move down to <em>Ubuntu PPA</em> and copy a few Unix
commands to install the newest version of the FEniCS software.</p>
<p>A different type of virtual machine technology is <a class="reference external" href="http://www.vagrantup.com/">Vagrant</a>, which allows you to download a big file
with a complete Ubuntu environment and run that environment in a
terminal window on your Mac or Windows computer. This Ubuntu machine
is integrated with the file system on your computer. The author has
made a Vagrant box with most of the scientific computing
software you need for programming
with FEniCS, see a preliminary <a class="reference external" href="http://hplgit.github.io/INF5620/doc/web/vagrant_inf5620.html">guide</a>
for download, installation, and usage.</p>
<p>The FEniCS installation also features a set of demo programs.
These are stored in locations depending on the type of operating system.
For Ubuntu the programs are stored in <code class="docutils literal"><span class="pre">/usr/share/fenics/demo</span></code>.</p>
<p>The graphical user interface (GUI) of Ubuntu is quite similar to both
Windows and Mac OS X, but to be efficient when doing science with
FEniCS I recommend to run programs in a terminal window and write them
in a text editor like Emacs or Vim. You can employ an integrated
development environment such as Eclipse, but intensive FEniCS
developers and users tend to find terminal windows and plain text
editors more efficient and user friendly.</p>
</div>
<div class="section" id="books-on-the-finite-element-method">
<span id="tut-appendix-books"></span><h3>Books on the finite element method<a class="headerlink" href="#books-on-the-finite-element-method" title="Permalink to this headline">¶</a></h3>
<p>There are a large number of books on the finite element method.  The
books typically fall in either of two categories: the abstract
mathematical version of the method and the engineering &#8220;structural
analysis&#8221; formulation. FEniCS builds heavily on concepts in the
abstract mathematical exposition. The author has in development
a <a class="reference external" href="http://tinyurl.com/opdfafk/">book</a>
that explains all details of the finite element method with
the abstract mathematical formulations that FEniCS employ.</p>
<p>An easy-to-read book, which
provides a good general background for using FEniCS, is Gockenbach
<a class="reference internal" href="._ftut005.html#ref06" id="id4">[Ref06]</a>. The book by Donea and Huerta
<a class="reference internal" href="._ftut005.html#ref07" id="id5">[Ref07]</a> has a similar style, but aims at readers with
interest in fluid flow problems. Hughes <a class="reference internal" href="._ftut005.html#ref08" id="id6">[Ref08]</a> is also
highly recommended, especially for those interested in solid mechanics
and heat transfer applications.</p>
<p>Readers with background in the engineering &#8220;structural analysis&#8221;
version of the finite element method may find Bickford
<a class="reference internal" href="._ftut005.html#ref09" id="id7">[Ref09]</a> as an attractive bridge over to the abstract
mathematical formulation that FEniCS builds upon.  Those who have a
weak background in differential equations in general should consult a
more fundamental book, and Eriksson {em et
al}. <a class="reference internal" href="._ftut005.html#ref10" id="id8">[Ref10]</a> is a very good choice.  On the
other hand, FEniCS users with a strong background in mathematics and
interest in the mathematical properties of the finite element method,
will appreciate the texts by Brenner and Scott <a class="reference internal" href="._ftut005.html#ref11" id="id9">[Ref11]</a>,
Braess <a class="reference internal" href="._ftut005.html#ref12" id="id10">[Ref12]</a>, Ern and Guermond <a class="reference internal" href="._ftut005.html#ref13" id="id11">[Ref13]</a>,
Quarteroni and Valli <a class="reference internal" href="._ftut005.html#ref14" id="id12">[Ref14]</a>, or Ciarlet <a class="reference internal" href="._ftut005.html#ref15" id="id13">[Ref15]</a>.</p>
</div>
<div class="section" id="books-on-python">
<span id="tut-appendix-pybooks"></span><h3>Books on Python<a class="headerlink" href="#books-on-python" title="Permalink to this headline">¶</a></h3>
<p>Two very popular introductory books on Python are
&#8220;Learning Python&#8221;  by Lutz <a class="reference internal" href="._ftut005.html#ref16" id="id14">[Ref16]</a> and
&#8220;Practical Python&#8221;  by Hetland <a class="reference internal" href="._ftut005.html#ref17" id="id15">[Ref17]</a>.
More advanced and comprehensive books include
&#8220;Programming Python&#8221; by Lutz <a class="reference internal" href="._ftut005.html#ref18" id="id16">[Ref18]</a>,
and &#8220;Python Cookbook&#8221; <a class="reference internal" href="._ftut005.html#ref19" id="id17">[Ref19]</a> and &#8220;Python in a Nutshell&#8221;
<a class="reference internal" href="._ftut005.html#ref20" id="id18">[Ref20]</a> by Martelli.
The web page <code class="docutils literal"><span class="pre">http://wiki.python.org/moin/PythonBooks</span></code>
lists numerous additional books.
Very few texts teach Python in a mathematical and numerical context,
but the references <a class="reference internal" href="._ftut005.html#ref21" id="id19">[Ref21]</a> <a class="reference internal" href="._ftut005.html#ref22" id="id20">[Ref22]</a> <a class="reference internal" href="._ftut005.html#ref23" id="id21">[Ref23]</a>
are exceptions.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>