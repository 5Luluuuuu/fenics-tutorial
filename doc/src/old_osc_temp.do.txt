# This is from the original tutorial. No longer used.

===== A physical example =====
label{ftut:timedep:diffusion2:sin}

idx{`${prog["sin_daD"]}.py`}

With the basic programming techniques for time-dependent problems from
Sections ref{ch:diffusion:opt:noassembly} and
ref{ftut:timedep:diffusion1:impl} we are ready to attack more
physically realistic examples.    We consider some box-shaped
domain $\Omega$ in $d$ dimensions with coordinates
$x_0,\ldots,x_{d-1}$ (the problem is meaningful in 1D, 2D, and 3D).
At the top of the domain, $x_{0}=0$, we have an oscillating
temperature

!bt
\begin{equation*}
T_0(t) = T_R + T_A\sin (\omega t),
\end{equation*}
!et
where $T_R$ is some reference temperature, $T_A$ is the amplitude of
the temperature variations at the surface, and $\omega$ is the
frequency of the temperature oscillations.  At all other boundaries we
assume that the temperature does not change anymore when we move away
from the boundary, i.e., the normal derivative is zero.  Initially,
the temperature can be taken as $T_R$ everywhere.  The heat
conductivity properties of the soil in the ground may vary with space
so we introduce a variable coefficient $\kappa$ reflecting this
property.  Figure ref{ftut:timedep:diffusion2:sin:fig1} shows a sketch
of the problem, with a small region where the heat conductivity is
much lower.  [hpl: All parameters $\varrho$, $c$, and $\kappa$ are
different!]

FIGURE:[fig/daynight, width=480] Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature. label{ftut:timedep:diffusion2:sin:fig1}

The initial-boundary value problem for this problem reads

!bt
\begin{align}
\varrho c{\partial T\over\partial t} &= \nabla\cdot\left( \kappa\nabla T\right)\hbox{ in }\Omega\times (0,t_{\hbox{stop}}],\\
T &= T_0(t)\hbox{ on }\Gamma_0,\\
{\partial T\over\partial n} &= 0\hbox{ on }\partial\Omega\backslash\Gamma_0,\\
T &= T_R\hbox{ at }t =0\tp
\end{align}
!et
Here, $\varrho$ is the density of the soil, $c$ is the
heat capacity, $\kappa$ is the thermal conductivity
(heat conduction coefficient)
in the soil, and $\Gamma_0$ is the surface boundary $x_{0}=0$.

We use a $\theta$-scheme in time, i.e., the evolution equation
$\partial P/\partial t=Q(t)$ is discretized as

!bt
\begin{equation*}
{P^k - P^{k-1}\over{\dt}} = \theta Q^k + (1-\theta )Q^{k-1},
\end{equation*}
!et
where $\theta\in[0,1]$ is a weighting factor: $\theta =1$ corresponds
to the backward difference scheme, $\theta =1/2$ to the Crank-Nicolson
scheme, and $\theta =0$ to a forward difference scheme.
The $\theta$-scheme applied to our PDE results in

!bt
\begin{equation*}
\varrho c{T^k-T^{k-1}\over{\dt}} =
\theta \nabla\cdot\left( \kappa\nabla T^k\right)
+ (1-\theta) \nabla\cdot\left( k\nabla T^{k-1}\right)\tp
\end{equation*}
!et
Bringing this time-discrete PDE into weak form follows the technique shown
many times earlier in this tutorial. In the standard notation
$a(T,v)=L(v)$ the weak form has

!bt
\begin{align}
a(T,v) &= \int_\Omega
\left( \varrho c Tv + \theta{\dt} \kappa\nabla T\cdot \nabla v\right) \dx,\\
L(v) &= \int_\Omega \left( \varrho c T^{k-1}v - (1-\theta){\dt}
\kappa\nabla T^{k-1}\cdot \nabla v\right) \dx\tp
\end{align}
!et

Observe that boundary integrals vanish because of the Neumann boundary
conditions.

idx{heterogeneous medium}
idx{multi-material domain}

The size of a 3D box is taken as $W\times W\times D$, where $D$ is
the depth and $W=D/2$ is the width.
We give the degree of the basis functions at the command line, then $D$,
and then the divisions of the domain in the various directions.
To make a box, rectangle, or interval of arbitrary (not unit) size,
we have the classes `BoxMesh`, `RectangleMesh`, and
`IntervalMesh` at our disposal. The mesh and the function space
can be created by the following code:

!bc pycod
degree = int(sys.argv[1])
D = float(sys.argv[2])
W = D/2.0
divisions = [int(arg) for arg in sys.argv[3:]]
d = len(divisions)  # no of space dimensions
if d == 1:
    mesh = IntervalMesh(divisions[0], -D, 0)
elif d == 2:
    mesh = RectangleMesh(-W/2, -D, W/2, 0, divisions[0], divisions[1])
elif d == 3:
    mesh = BoxMesh(-W/2, -W/2, -D, W/2, W/2, 0,
               divisions[0], divisions[1], divisions[2])
V = FunctionSpace(mesh, 'P', degree)
!ec
The `RectangleMesh` and `BoxMesh` objects are defined by the coordinates
of the "minimum" and "maximum" corners.

Setting Dirichlet conditions at the upper boundary can be done by

!bc pycod
T_R = 0; T_A = 1.0; omega = 2*pi

T_0 = Expression('T_R + T_A*sin(omega*t)',
                 T_R=T_R, T_A=T_A, omega=omega, t=0.0)

def surface(x, on_boundary):
    return on_boundary and abs(x[d-1]) < 1E-14

bc = DirichletBC(V, T_0, surface)
!ec

The $\kappa$ function can be defined as a constant $\kappa_1$ inside
the particular rectangular area with a special soil composition, as
indicated in Figure ref{ftut:timedep:diffusion2:sin:fig1}. Outside
this area $\kappa$ is a constant $\kappa_0$.
The domain of the rectangular area is taken as

!bt
\begin{equation*}
[-W/4, W/4]\times [-W/4, W/4]\times [-D/2, -D/2 + D/4]
\end{equation*}
!et
in 3D, with $[-W/4, W/4]\times [-D/2, -D/2 + D/4]$ in 2D and
$[-D/2, -D/2 + D/4]$ in 1D.
Since we need some testing in the definition of the $\kappa(\x)$
function, the most straightforward approach is to define a subclass
of `Expression`, where we can use a full Python method instead of
just a C++ string formula for specifying a function.
The method that defines the function is called `eval`:

!bc pycod
class Kappa(Expression):
    def eval(self, value, x):
        """x: spatial point, value[0]: function value."""
        d = len(x)  # no of space dimensions
        material = 0  # 0: outside, 1: inside
        if d == 1:
            if -D/2. < x[d-1] < -D/2. + D/4.:
                material = 1
        elif d == 2:
            if -D/2. < x[d-1] < -D/2. + D/4. and \
               -W/4. < x[0] < W/4.:
                material = 1
        elif d == 3:
            if -D/2. < x[d-1] < -D/2. + D/4. and \
               -W/4. < x[0] < W/4. and -W/4. < x[1] < W/4.:
                material = 1
        value[0] = kappa_0 if material == 0 else kappa_1
!ec
The `eval` method gives great flexibility in defining functions,
but a downside is that C++ calls up `eval` in Python for
each point `x`, which is a slow process, and the number of calls
is proportional to the number of numerical
integration points in the mesh (about
the number of degrees of freedom).
Function expressions in terms of strings are compiled to efficient
C++ functions, being called from C++, so we should try to express functions
as string expressions if possible. (The `eval` method can also be
defined through C++ code, but this is much
more complicated and not covered here.)
Using inline if-tests in C++, we can make string expressions for
$\kappa$, here stored in a Python dictionary so that `kappa_str[d-1]`
is the proper test in a $d$ dimensional problem:

!bc pycod
kappa_str = {}
kappa_str[1] = 'x[0] > -D/2 && x[0] < -D/2 + D/4 ? kappa_1 : kappa_0'
kappa_str[2] = 'x[0] > -W/4 && x[0] < W/4 '\
               '&& x[1] > -D/2 && x[1] < -D/2 + D/4 ? '\
               'kappa_1 : kappa_0'
kappa_str[3] = 'x[0] > -W/4 && x[0] < W/4 '\
               'x[1] > -W/4 && x[1] < W/4 '\
               '&& x[2] > -D/2 && x[2] < -D/2 + D/4 ?'\
               'kappa_1 : kappa_0'

kappa = Expression(kappa_str[d],
                   D=D, W=W, kappa_0=kappa_0, kappa_1=kappa_1)
!ec

Let `T` denote the unknown spatial temperature function at the
current time level, and let `T_1` be the corresponding function
at one earlier time level.
We are now ready to define the initial condition and the
`a` and `L` forms of our problem:

!bc pycod
T_prev = interpolate(Constant(T_R), V)

rho = 1
c = 1
period = 2*pi/omega
t_stop = 5*period
dt = period/20  # 20 time steps per period
theta = 1

T = TrialFunction(V)
v = TestFunction(V)
f = Constant(0)
a = rho*c*T*v*dx + theta*dt*kappa*\
    dot(grad(T), grad(v))*dx
L = (rho*c*T_prev*v + dt*f*v -
     (1-theta)*dt*kappa*dot(grad(T_1), grad(v)))*dx

A = assemble(a)
b = None  # variable used for memory savings in assemble calls
T = Function(V)   # unknown at the current time level
!ec
We could, alternatively, break `a` and `L` up in subexpressions
and assemble a mass matrix and stiffness matrix, as exemplified in
Section ref{ch:diffusion:opt:noassembly}, to avoid
assembly of `b` at every time level. This modification is
straightforward and left as an exercise. The speed-up can be significant
in 3D problems.

The time loop is very similar to what we have displayed in
Section ref{ftut:timedep:diffusion1:impl}:

!bc pycod
T = Function(V)   # unknown at the current time level
t = dt
while t <= t_stop:
    b = assemble(L, tensor=b)
    T_0.t = t
    bc.apply(A, b)
    solve(A, T.vector(), b)
    # visualization statements
    t += dt
    T_prev.assign(T)
!ec
The complete code in `${prog["sin_daD"]}.py` contains several
statements related to visualization and animation of the solution, both as a
finite element field (`plot` calls) and as a curve in the
vertical direction. The code also plots the exact analytical solution,

!bt
\[
T(x,t) = T_R + T_Ae^{ax}\sin (\omega t + ax),\quad a =\sqrt{\omega\varrho c\over 2\kappa},
\]
!et
which is valid when $\kappa = \kappa_0=\kappa_1$.

Implementing this analytical solution as a Python function
taking scalars and numpy arrays as arguments requires a word of caution.
A straightforward function like

!bc pycod
def T_exact(x):
    a = sqrt(omega*rho*c/(2*kappa_0))
    return T_R + T_A*exp(a*x)*sin(omega*t + a*x)
!ec
will not work and result in an error message from UFL. The reason is that
the names `exp` and `sin` are those imported
by the `from fenics import *` statement, and these names
come from UFL and are aimed at being used in variational forms.
In the `T_exact` function where `x` may be a scalar or a
`numpy` array, we therefore need to explicitly specify
`np.exp` and `np.sin` (if `numpy` is imported under the common name `np`):

!bc pycod
def T_exact(x):
    a = sqrt(omega*rho*c/(2*kappa_0))
    return T_R + T_A*np.exp(a*x)*np.sin(omega*t + a*x)
!ec

The complete code is found in the file The reader is encouraged to
play around with the code and test out various parameter sets:

  o $T_R=0$, $T_A=1$, $\kappa_0 = \kappa_1=0.2$, $\varrho = c = 1$, $\omega = 2\pi$
  o $T_R=0$, $T_A=1$, $\kappa_0=0.2$, $\kappa_1=0.01$, $\varrho = c = 1$, $\omega = 2\pi$
  o $T_R=0$, $T_A=1$, $\kappa_0=0.2$, $\kappa_1=0.001$, $\varrho = c = 1$, $\omega = 2\pi$
  o $T_R=10$ C, $T_A=10$ C, $\kappa_0= 2.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}$,
    $\kappa_1= 100 \hbox{ K}^{-1}\hbox{Ns}^{-1}$,
    $\varrho = 1500\hbox{ kg/m}^3$,
    $c = 1480\hbox{ Nm}\cdot\hbox{kg}^{-1}\hbox{K}^{-1}$,
    $\omega = 2\pi/24$ 1/h  $= 7.27\cdot 10^{-5}$ 1/s, $D=1.5$ m
  o As above, but $\kappa_0= 12.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}$ and
    $\kappa_1= 10^4 \hbox{ K}^{-1}\hbox{Ns}^{-1}$

Data set number 4 is relevant for real temperature variations in
the ground (not necessarily the large value of $\kappa_1$),
while data set number 5
exaggerates the effect of a large heat conduction contrast so that
it becomes clearly visible in an animation.

#  kappa_1 = 1.1, varrho_1 = 1200, c_1 = 1000 => 9.17E-7
#  kappa_0 = 2.3, varrho_0 = 1800, c_0 = 1500 => 8.52E-7
