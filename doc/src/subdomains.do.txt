!split
========= Subdomains and boundary conditions =========
label{ch:subdomains}

!bquote
So far, we have only looked briefly at how to specify boundary
conditions. In this chapter, we look more closely at how to specify
boundary conditions on specific parts (subdomains) of the boundary and
how to combine multiple boundary conditions. We will also look at how to
generate meshes with subdomains and how to define coefficients and
variational problems that look different in different subdomains.
!equote

======= Combining Dirichlet and Neumann conditions =======
label{ch:poisson0:DN}

Let's return to our Poisson solver from Chapter ref{ch:fundamentals}
and see how to extend the mathematics and the implementation to handle
a Dirichlet condition in combination with a Neumann condition. The
domain is still the unit square, but now we set the Dirichlet
condition $u=\ub$ at the left and right sides, $x=0$ and $x=1$, while
the Neumann condition

!bt
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
!et
is applied to the remaining
sides $y=0$ and $y=1$.

#The Neumann condition is also known as a *natural boundary condition*
#(in contrast to an essential boundary condition).

idx{Neumann boundary conditions}

===== PDE problem =====

Let $\GD$ and $\GN$ denote the parts of the boundary $\partial\Omega$
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

[AL: Fixed alignment of in, on etc here. Needs to be done in other
places too, using `{alignat}{2}`.]

!bt
\begin{alignat}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega,  \\
    u &= \ub &&\mbox{on } \GD,       \\
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN  \tp
\end{alignat}
!et
Again we choose $u=1+x^2 + 2y^2$ as the exact solution and adjust $f$, $g$, and
$\ub$ accordingly:

!bt
\begin{align*}
f &= -6,\\
g &= \left\lbrace\begin{array}{ll}
0, & y=0\\
4, & y=1
\end{array}\right.\\
\ub &= 1 + x^2 + 2y^2\tp
\end{align*}
!et
For ease of programming we may introduce a $g$ function defined over the whole
of $\Omega$ such that $g$ takes on the right values at $y=0$ and
$y=1$. One possible extension is

!bt
\begin{equation*}
g(x,y) = 4y\tp
\end{equation*}
!et

===== Variational formulation =====

The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
$v$ is only zero on $\GD$. We have

!bt
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
!et
and since $v=0$ on $\GD$,

!bt
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\GN}{\partial u\over
\partial n}v \ds
= \int_{\GN}gv \ds,
\end{equation*}
!et
by applying the boundary condition on $\GN$.
The resulting weak form reads

!bt
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx
= \int_{\Omega} fv \dx - \int_{\GN} gv \ds\tp
label{ch:poisson0:2D:DN:weak}
\end{equation}
!et
Expressing this equation
in the standard notation $a(u,v)=L(v)$ is straightforward with

!bt
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
label{ftut:poisson2:vard:a}\\
L(v) &= \int_{\Omega} fv \dx -
\int_{\GN} gv \ds\tp  label{ftut:poisson2:vard:L}
\end{align}
!et

===== FEniCS implementation =====

How does the Neumann condition impact the implementation?  Let us
revisit our previous implementation `${prog["poisson"]}.py`, from
ref[Section ref{ch:poisson0:impl}][ in cite{ftut1}][the section
"FEniCS implementation": "" in cite{ftut1}] and examine which changes
we need to make to incorporate the Neumann condition. It runs out that
only two are necessary.Ã–

  * The function `boundary` defining the Dirichlet boundary
    must be modified.
  * The new boundary term must be added to the expression for `L`.

The first adjustment can be coded as

!bc pycod
def boundary_D(x, on_boundary):
    if on_boundary:
        if x[0] == 0 or x[0] == 1:
            return True
        else:
            return False
    else:
        return False
!ec
A more compact implementation reads

!bc pycod
def boundary_D(x, on_boundary):
    return on_boundary and (x[0] == 0 or x[0] == 1)
!ec

!bwarning Never use `==` for comparing real numbers!
A comparison like `x[0] == 1` should never be used if `x[0]` is a real
number, because rounding errors in `x[0]` may make the test fail even
when it is mathematically correct. Consider

!bc pycod
>>> 0.1 + 0.2 == 0.3
False
>>> 0.1 + 0.2
0.30000000000000004
!ec

Comparison of real numbers needs to be made with tolerances! The
values of the tolerances depend on the size of the numbers involved in
arithmetic operations:

!bc pycod
>>> abs(0.1+0.2 - 0.3)
5.551115123125783e-17
>>> abs(1.1+1.2 - 2.3)
0.0
>>> abs(10.1+10.2 - 20.3)
3.552713678800501e-15
>>> abs(100.1+100.2 - 200.3)
0.0
>>> abs(1000.1+1000.2 - 2000.3)
2.2737367544323206e-13
>>> abs(10000.1+10000.2 - 20000.3)
3.637978807091713e-12
!ec
For numbers of unit size, tolerances as low as $3\cdot 10^{-16}$ can be used
(in fact, this tolerance is known as the constant `DOLFIN_EPS` in FEniCS).
Otherwise, an appropriate scaled tolerance must be used.

Here is a better way to test fo `x[0] == 1`:

!bc pycod
tol = 1E-14
if abs(x[0] - 1) < tol:
    ...
!ec
!ewarning

idx{`near`}

A modified version of the boundary definition using a tolernace
instead of exact comparison can easily be implemented as follows:

!bc pycod
def boundary_D(x, on_boundary):
    tol = 1E-14
    return on_boundary and (abs(x[0]) < tol or abs(x[0] - 1) < tol)
!ec
This function can be written a bit more elegantly using the `near`
function in FEniCS:

!bc pycod
def boundary_D(x, on_boundary):
    tol = 1E-14
    return on_boundary and (near(x[0], 0, tol) or near(x[1], 1, tol))
!ec

[AL: Use 1E-14 or 1e-14? Need to be consistent throughout the book.]

The second adjustment of our program concerns the definition of `L`,
which needs to include the Neumann condition:

!bc pycod
g = Expression('4*x[1]')
L = f*v*dx - g*v*ds
!ec
The `ds` variable implies a boundary integral, while `dx`
implies an integral over the domain $\Omega$.
No other modifications are necessary.

======= Setting multiple Dirichlet conditions =======
label{ch:poisson0:multiple:Dirichlet}

In the previous section, we used a single functions $\ub(x,y)$ for
setting Dirichlet conditions at two parts of the boundary.  Often it
is more practical to use multiple functions, one for subdomain of the
boundary. Let us return to the case from Section ref{ch:poisson0:DN}
and redefine the problem in terms of two Dirichlet conditions:

!bt
\begin{alignat*}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega, \\
    u &= u_{_\mathrm{L}} &&\mbox{on } \GD^{^{\mathrm{L}}}, \\
    u &= u_{_\mathrm{R}} &&\mbox{on } \GD^{^{\mathrm{R}}}, \\
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN \tp
\end{alignat*}
!et
Here, $\GD^{^{\mathrm{L}}}$ is the left boundary $x=0$, while
$\GD^{^{\mathrm{R}}}$ is the right boundary $x=1$. We note that
$u_{_\mathrm{L}} = 1 + 2y^2$, $u_{_\mathrm{R}} = 2 + 2y^2$, and $g=4y$.

For the boundary condition on $\GD^{^{\mathrm{L}}}$, we define the
usual triple of an expression for the boundary value, a function
defining the location of the boundary, and a `DirichletBC` object:

!bc pycod
u_L = Expression('1 + 2*x[1]*x[1]')

def boundary_L(x, on_boundary):
    tol = 1E-14
    return on_boundary and abs(x[0]) < tol

bc_L = DirichletBC(V, u_L, boundary_L)
!ec
For the boundary condition on $\GD^{^{\mathrm{R}}}$, we write a
similar code snippet:

!bc pycod
u_R = Expression('2 + 2*x[1]*x[1]')

def boundary_R(x, on_boundary):
    tol = 1E-14
    return on_boundary and abs(x[0] - 1) < tol

bc_R = DirichletBC(V, u_R, boundary_R)
!ec
We collect the two boundary conditions in a list which
we can pass to the `solve` function to compute the solution:

!bc pycod
bcs = [bc_L, bc_R]
...
solve(a == L, u, bcs)
# or
problem = LinearVariationalProblem(a, L, u, bcs)
solver  = LinearVariationalSolver(problem)
solver.solve()
!ec

Note that for boundary values that do not depend on $x$ or $y$, we
might replace the `Expression` objects `Constant` objects.

# #ifdef EXTRA
# We come to this in a minute with internal subdomains...

===== Classes for marking Dirichlet boundaries =====

Instead of using a function like `left_boundary(x, on_boundary)` to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class `SubDomain` and has a method `inside(self, x, on_boundary)` for the code that returns whether the `point` is on the
boundary in question or not. Our previous `left_boundary` function
takes this form in its class version:

!bc pycod
class LeftBoundary(SubDomain):
    def inside(self, x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and abs(x[0]) < tol

left_boundary = LeftBoundary()
Gamma_0 = DirichletBC(V, u_L, left_boundary)
!ec
# #endif

======= Working with subdomains =======
label{ftut:possion:2D:2mat:impl}

idx{heterogeneous media}
idx{multi-material domain}

Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kinds of problems are handled by
defining subdomains inside the domain. A simple example with two
materials (subdomains) in 2D will demonstrate the idea.

FIGURE: [fig/layered_medium_2, width=400 frac=0.5] Medium with discontinuous material properties. label{ftut:possion:2D:2mat:fig1}

Suppose we want to solve

!bt
\begin{equation} label{ch:poisson0:2D:2mat:varcoeff2}
    \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,
\end{equation}
!et
in a domain $\Omega$ consisting of two subdomains where $k$ takes on
a different value in each subdomain.
We take $\Omega = [0,1]\times [0,1]$ and divide it into two equal
subdomains, as depicted in Figure ref{ftut:possion:2D:2mat:fig1},

!bt
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
!et
We define $k(x,y)=k_0$ in $\Omega_0$ and $k(x,y)=k_1$ in $\Omega_1$,
where $k_0>0$ and $k_1>0$ are given constants.

Physically, this problem may be viewed as a model of heat conduction,
where the heat conduction in $\Omega_1$ is more efficient than in
$\Omega_0$. An alternative interpretation is flow in porous media with
two geological layers, where the layers' ability to transport the
fluid differ.

===== Expression objects with if test =====

The simplest way of implementing a variable coefficient $k$ is to
define an `Expression` object where we return the appropriate $k$
value depending on the position in space.  Since we need some testing
on the coordinates, the most straightforward approach is to define a
subclass of `Expression`, where we can use a full Python method
instead of just a C++ string formula for specifying a function.  The
method that defines the function is called `eval`:

!bc pycod
class K(Expression):
    def set_k_values(self, k0, k1):
        self.k0, self.k1 = k0, k1

    def eval(self, value, x):
        "Set value[0] to value at point x"
	tol = 1E-14
        if x[1] <= 0.5 + tol:
	    value[0] = self.k0
	else:
	    value[0] = self.k1

# Initialize
k = K()
k.set_k_values(1, 0.01)
!ec
The `eval` method gives great flexibility in defining functions, but a
downside is that C++ calls up `eval` in Python for each node `x`,
which is a slow process.

An alternative method is to use a C++ string expression as we have
seen before, which is much more efficient in FEniCS. This can be done
usin inline if tests in C++:

!bc pycod
tol = 1E-14
k0 = 1.0
k1 = 0.01
k = Expression('x[1] <= 0.5 + tol ? k0 : k1',
               tol=tol, k0=k0, k1=k1)
!ec

This method of defining variable coefficients works if the subdomains
are simple shapes that can be expressed in terms of geometric
inequalities. However, for more complex subdomains, we will need to
use a more general technique, as we will see next.

idx{boundary specification (class)}

===== Mesh functions =====

We now address how to specify the subdomains $\Omega_0$ and $\Omega_1$
using a more general technique. This technique involves the use of two
classes that are essential in FEniCS when working with subdomains:
`SubDomain` and `MeshFunction`. Consider the following definition of the
boundary $x = 0$:

!bc pycod
def boundary(x, on_boundary):
    tol = 1E-14
    return on_boundary and abs(x[0]) < tol
!ec
This boundary definition is actually a shortcut to the more general
FEniCS concept `SubDomain`. A `SubDomain` is a class which defines a
region in space (a subdomain) in terms of a member function `inside`
which returns `True` for points that belong to the subdomain and
`False` for points that don't belong to the subdomain. Here is how to
specify the boundary $x = 0$ as a `SubDomain`:

!bc pycod
class Boundary(SubDomain):
    def inside(self, x, on_boundary):
        tol = 1E-14
        return on_boundary and abs(x[0]) < tol

boundary = Boundary()
bc = DirichletBC(V, Constant(0), boundary)
!ec
We notice that the `inside` function of the class `Boundary` is
(almost) identical to the previous boundary definition in terms of the
`boundary` function. Technically, our class `Boundary` is a
*subclass* of the FEniCS class `SubDomain`.

#A word about computer science terminology may be in order here: The term
#*instance* means a Python object of a particular type (such as
#`SubDomain`, `Function`, `FunctionSpace`, etc.).  Many use *instance*
#and *object* as interchangeable terms. In other computer programming
#languages one may also use the term *variable* for the same thing. We
#mostly use the well-known term *object* in this text.

We will use two `SubDomain` subclasses to define the two subdomains
$\Omega_0$ and $\Omega_1$:

!bc pycod
tol = 1E-14

class Omega0(SubDomain):
    def inside(self, x, on_boundary):
        return x[1] <= 0.5 + tol

class Omega1(SubDomain):
    def inside(self, x, on_boundary):
        return x[1] >= 0.5 - tol
!ec
Notice the use of `<=` and `>=` in both tests. FEniCS will call the
`inside` function for each vertex in a cell to determine whether or
not the cell belongs to a particular subdomain. For this reason, it is
important that the test holds for all vertices in cells aligned with
the boundary. In adition, we use a tolerance to make sure that
vertices on the internal boundary at $y = 0.5$ will belong to *both*
subdomains. This is a little counter-intuitive, but is necessary to
make the cells both above and below the interal boundary belong to
either $\Omega_0$ or $\Omega_1$.

To define the variable coefficient $k$, we will use a powerful tool in
FEniCS called a `MeshFunction`. A `MeshFunction` is a discrete
function that can be evaluated at a set of so-called *mesh
entities*. A mesh entity in FEniCS is either a vertex, an edge, a
face, or a cell (triangle or tetrahedron). A `MeshFunction` over cells
is suitable to represent subdomains (materials), while a
`MeshFunction` over facets (edges or faces) is used to represent
pieces of external or internal boundaries. A `MeshFunction` over cells
can also be used to represent boundary markers for mesh refinement. A
FEniCS `MeshFunction` is parametrized both over its datatype (like
integers or booleans) and its dimension (0 = vertex, 1 = edge
etc). Special subclasses `VertexFunction`, `EdgeFunction` etc are
provided for easy definition of a `MeshFunction` of a particular
dimension.

Since we need to define subdomains of $\Omega$ in the present example,
we make use of a `CellFunction`. The constructor
is fed with two arguments: 1) the type of value: `'int'` for integers,
`'size_t'` for positive (unsigned) integers, `'double'` for real
numbers, and `'bool'` for logical values; 2) a `Mesh` object.
Alternatively, the constructor can take just a filename and initialize
the `CellFunction` from data in a file.
#  #ifdef BOOK
We shall
demonstrate the file functionality in the next multi-material problem
in Section ref{ftut:possion:nD:nmat}.
#  #endif

We start with creating a `CellFunction` whose values are non-negative
integers (`'size_t'`) for numbering the subdomains:

!bc pycod
materials = CellFunction('size_t', mesh)
!ec

Next, we use the two subdomains to *mark* the cells belonging to each
subdomain:
!bc
# Mark subdomains with numbers 0 and 1
subdomain0 = Omega0()
subdomain0.mark(materials, 0)
subdomain1 = Omega1()
subdomain1.mark(materials, 1)
!ec

This will set the values of the mesh function `materials` to $0$ on
each cell belonging to $\Omega_0$ and $1$ on all cells belonging to
$\Omega_1$. Alternatively, we can use the following equivalent code to
mark the cells:

!bc
materials.set_all(0)
subdomain1.mark(materials, 1)
!ec
To examine the values of the mesh function and see that we have indeed
defined our subdomains correctly, we can simply plot the mesh
function:

!bc pycod
plot(materials, interactive=True)
!ec
We may also wish to store the values of the mesh function for later
use:
!bc pycod
File('materials.xml.gz') << materials
!ec
which can later be read back from file as follows:
!bc pycod
File('materials.xml.gz') >> materials
!ec

Now, to use the values of the mesh function `materials` to define the
variable coefficient $k$, we create a FEniCS `Expression`:

!bc pycod
class K(Expression):
    def __init__(self, materials, k0, k1, **kwargs):
        self.materials = materials
        self.k0 = k0
        self.k1 = k1
    def eval_cell(self, values, x, cell):
        if materials[cell.index] == 0:
            values[0] = self.k0
        else:
            values[0] = self.k1

k = K(materials, k0, k1, degree=0)
!ec

This is similar to the `Expression` subclass we defined above, but we
make use of the member function `eval_cell` in place of the regular
`eval` function. This version of the evaluation function has an
addition `cell` argument which we can use to check on which cell we are
currently evaluating the function.

idx{`CompiledSubDomain`}

===== C++ strings for subdomain definitions =====

The `SubDomain` and `Expression` Python classes are very convenient,
but their use leads to function calls from C++ to Python for each node
in the mesh. Since this involves a significant cost, we need to make
use of C++ code for large problems.

If we have defined `SubDomain` sublass in Python, we may instead use
the `CompiledSubDomain` tool in FEniCS to speed up our code. Consider
the definition of the classes `Omega0` and `Omega1` above in Python. The
key strings that define these subdomain can be expressed in C++ syntax
and fed to `CompiledSubDomain` as follows:

!bc pycod
tol = 1E-14  # Tolerance for coordinate comparisons

subdomain0 = CompiledSubDomain('x[1] <= 0.5 + tol', tol=1E-14)
subdomain1 = CompiledSubDomain('x[1] >= 0.5 - tol', tol=1E-14)
!ec
As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, `subdomain0` and `subdomain1`, can be used
as ordinary `SubDomain` objects.

Compiled subdomain strings can be applied for specifying boundaries as
well, e.g.,

!bc pycod
boundary_R = CompiledSubDomain('on_boundary && abs(x[0] - 1) < tol',
                                tol=1E-14)
!ec

It is also possible to feed the C++ string (without parameters)
directly as the third argument to `DirichletBC` without explicitly
constructing a `CompiledSubDomain` object:

!bc pycod
bc1 = DirichletBC(V, value, 'on_boundary && abs(x[0] - 1) < tol')
!ec

Python `Expression` classes may also be redefined using C++ for more
effcient code. Consider again the definition of the class `K` above
for the variable coefficient $k = k(x)$. This may be redefined using a
C++ code snippet and the keyword `cppcode` to the regular FEniCS
`Expression` class:

!bc
cppcode = """
class K : public Expression
{
public:

  void eval(Array<double>& values,
            const Array<double>& x,
            const ufc::cell& cell) const
  {
    if ((*materials)[cell.index] == 0)
      values[0] = k0;
    else
      values[0] = k1;
  }

  std::shared_ptr<MeshFunction<std::size_t> > materials;
  double k0;
  double k1;

};
"""
k = Expression(cppcode=cppcode, degree=0)
k.materials = materials
k.k0 = k0
k.k1 = k1
!ec

% if EXV:
======= Exercise: Efficiency of Python vs C++ expressions =======
label{ch:poisson0:exer:eff:expression}
file=Expression_efficiency

Consider a cube mesh with $N$ cells in each spatial direction.
We want to define a `Function` on this mesh where the
values are given by the mathematical function $f(x,y,z)=a\sin(bxyz)$,
where $a$ and $b$ are two parameters. Write a `class SineXYZ`:

!bc pycod
class SineXYZ(Expression):
    def __init__(self, a, b):
        self.a, self.b = a, b

    def eval(self, value, x):
        value[0] = self.a*sin(self.b*x[0]*x[1]*x[2])
!ec
Create an alternative `Expression` based on giving the formula for $f(x,y,z)$
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using `time.clock()` to measure the CPU time).

The `sin` function used in class `SineXYZ.eval` can mean many things.
This is an advanced FEniCS function if imported from `fenics`.
Much more efficient versions for sin of numbers are found in `math.sin`
and `numpy.sin`. Compare the use `sin` from `fenics`, `math`, `numpy`, and
`sympy` (note that `sin` from `sympy` is very slow).

!bsol
Here is an appropriate program:

@@@CODE exer/Expression_efficiency.py
Running the program shows that `sin` from `math` is the most efficient choice,
but a string C++ runs 40 times faster. Note that `fenics.sin`, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the `sin`
functions for numbers in `math` and `numpy`.
!esol
% endif

======= Setting multiple Neumann, Robin, and Dirichlet conditions =======
label{ch:poisson0:multi:bc}
idx{Dirichlet boundary conditions}
idx{Neumann boundary conditions}
idx{Robin boundary conditions}
idx{boundary conditions}

Consider again the model problem from Section
ref{ch:poisson0:multiple:Dirichlet} where we had both Dirichlet and
Neumann conditions. The term `g*v*ds` in the expression for `L`
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all *exterior facets*. This means that the
boundary integral extends also over the part of the boundary $\GD$
where we have Dirichlet conditions. However, only the integral over
$\GN$ will contribute since $v = 0$ on $\GD$ (which happens when we
apply the Dirichlet boundary condition).

From an efficiency point of view, we would ideally like to integrate
`g*v*ds` only over the part of the boundary where we actually have
Neumann conditions. More importantly, in other problems one may have
different Neumann conditions or other conditions like the Robin type
condition. This can be handled in FEniCS by defining a `MeshFunction`
that marks different portions of the boundary. The same technique
can also be used to treat multiple Dirichlet conditions.

===== Three types of boundary conditions =====

We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin. Dirichlet conditions apply to some
parts $\GD^0$, $\GD^1$, $...$, of the boundary:

!bt
\[ \ub^0\hbox{ on }\GD^0,\quad
\ub^1\hbox{ on }\GD^1, \quad \ldots\]
!et
where $\ub^i$ are prescribed functions, $i=0,1,\ldots$
On other parts, $\GN^0$, $\GN^1$, and so on, we have
Neumann conditions:

[AL: Inconsistent naming of coefficient: sometimes $k$ and sometimes
$p$. Suggestion: $\kappa$.]

!bt
\[ -p{\partial u\over\partial n} = g_{0}\hbox{ on }\GN^0,\quad
-p{\partial u\over\partial n} = g_{1}\hbox{ on }\GN^1,\quad \ldots
\]
!et
Finally, we have *Robin conditions*:

!bt
\begin{equation*}
-p{\partial u\over\partial n} = r(u-s),
label{ch:poisson0:multi:bc:Robin}
\end{equation*}
!et
where $r$ and $s$ are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, $r$ is a heat
transfer coefficient, and $s$ is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts $\GR^0$, $\GR^1$, and so forth:

!bt
\[ -p{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\GR^0,\quad
-p{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\GR^1,\quad \ldots
\]
!et

idx{Robin condition}

===== PDE problem =====

With the notation above, the model problem to be solved with multiple
Dirichlet, Neumann, and Robin conditions can be formulated as follows:

!bt
\begin{align}
-\nabla\cdot(p\nabla u) &= -f, \mbox{ in } \Omega, label{ch:poisson0:2D:DN3}\\
u &= \ub^i \mbox{ on } \GD^i,\quad i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcD}\\
-p{\partial u\over\partial n} &= g_i \mbox{ on } \GN^i,\quad
i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcN}\\
-p{\partial u\over\partial n} &= r_i(u-s_i) \mbox{ on } \GR^i,\quad
i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcR}
\end{align}
!et

===== Variational formulation =====

As usual, we multiply by a test function $v$ and integrate by parts:

!bt
\begin{equation*}
 -\int_\Omega \nabla\cdot(p\nabla u) v \dx
= \int_\Omega p\nabla u\cdot \nabla v \dx -
\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds\tp
\end{equation*}
!et
On the Dirichlet part of the boundary ($\GD^i$), the boundary integral
vanishes since $v = 0$. On the remaining part of the boundary, we
split the boundary integral into contribution from the Neumann part
($\GN^i$) and Robin part ($\GR^i$). Inserting the boundary conditions,
we obtain

!bt
\begin{align*}
-\int_{\partial\Omega}p\frac{\partial u}{\partial n}v \ds
&=
-\sum_i\int_{\GN^i}p\frac{\partial u}{\partial n} \ds
-\sum_i\int_{\GR^i}p\frac{\partial u}{\partial n} \ds\\
&=
\sum_i\int_{\GN^i}g_i \ds +
\sum_i\int_{\GR^i}r_i(u-s_i) \ds\tp
\end{align*}
!et
We thus obtain the following variational problem:

!bt
\begin{equation}
F = \int_{\Omega} p\nabla u\cdot \nabla v \dx +
\sum_i\int_{\GN^i} g_iv \ds +
\sum_i\int_{\GR^i}r_i(u-s_i)v \ds
- \int_{\Omega} fv \dx =0\tp
label{ch:poisson0:multi:bc:varform}
\end{equation}
!et

We have been used to writing
this variational formulation in the standard notation
$a(u,v)=L(v)$, which requires that we identify all integrals with
*both* $u$ and $v$, and collect these in $a(u,v)$, while the remaining
integrals with $v$ and not $u$ go into $L(v)$. The integrals from the
Robin condition must for this reason be split in two parts:

!bt
\begin{equation*}
\int_{\Gamma_{R,i}}r_i(u-s_i)v \ds
= \int_{\Gamma_{R,i}} r_iuv \ds - \int_{\Gamma_{R,i}}r_is_iv \ds\tp
\end{equation*}
!et
We then have

!bt
\begin{align}
a(u, v) &= \int_{\Omega} p\nabla u\cdot \nabla v \dx
+ \sum_i\int_{\GR^i}r_iuv \ds,
label{ch:poisson0:2D:DN3:var:a}\\
L(v) &= \int_{\Omega} fv \dx -
\sum_i\int_{\GN^i} g_i v \ds + \sum_i\int_{\GR^i}r_is_iv \ds\tp
label{ch:poisson0:2D:DN3:var:L}
\end{align}
!et
Alternatively, we may keep the formulation
(ref{ch:poisson0:multi:bc:varform}) and either solve the variational
problem as a nonlinear problem (`F == 0`) in FEniCS or use the FEniCS
functions `lhs` and `rhs` to extract the bilinear and linear parts of
`F`:

!bc pycod
a = lhs(F)
L = rhs(F)
!ec
Note that if we choose the solve this linear problem as a nonlinear
problem, the Newton iteration will converge in a single iteration.

## /usr/share/fenics/demo/documented/subdomains/python/demo_subdomains.py
## contains a good example, followed up in stokes solvers

===== FEniCS implementation =====

Let us examine how to extend our Poisson solver to handle general
combinations of Dirichlet, Neumann, and Robin boundary conditions.
Compared to our previous code, we must consider the following
extensions:

  o defining markers for the different parts of the boundary,
  o splitting the boundary integral into parts using the markers.

A general approach to the first task is to mark each of the desired
boundary parts with markers 0, 1, 2, and so forth. Here we aim at the
four sides of the unit square, marked with 0 ($x=0$), 1 ($x=1$), 2
($y=0$), and 3 ($y=1$).  The markers will be defined using a
`MeshFunction`, but contrary to Section
ref{ftut:possion:2D:2mat:impl}, this is not a function over cells, but
a function over facets of the mesh. We use a `FacetFunction` for
this purpose:

!bc pycod
boundary_markers = FacetFunction('size_t', mesh)
!ec
As in Section ref{ftut:possion:2D:2mat:impl} we use a subclass of
`SubDomain` to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the $x=0$ boundary can be marked by

!bc pycod
class BoundaryX0(SubDomain):
    tol = 1e-14
    def inside(self, x, on_boundary):
        return on_boundary and abs(x[0]) < tol

bx0 = BoundaryX0()
bx0.mark(boundary_markers, 0)
!ec
Similarly, we make the classes `BoundaryX1` for the $x=1$ boundary,
`BoundaryY0` for the $y=0$ boundary, and `BoundaryY1` for the $y=1$
boundary, and mark these as subdomains 1, 2, and 3, respectively.

For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

!bc
boundary_conditions = {0: {'Dirichlet': u_b},
                       1: {'Robin':     (r, s)},
                       2: {'Neumann:    g},
                       3: {'Neumann',   0}}
!ec
specifies

 * a Dirichlet condition $u = \ub$ for $x = 0$;
 * a Robin condition $-p\partial_n u = r(u-s)$ for $x = 1$;
 * a Neumann condition $-p\partial_n u = g$ for $y = 0$;
 * a Neumann condition $-p\partial_n u = 0$ for $y = 1$.

As explained in Section ref{ch:poisson0:multiple:Dirichlet}, multiple
Dirichlet conditions must be collected in a list of `DirichletBC`
objects. Based on the `boundary_conditions` data structure above, we
can construct this list by the following code snippet:

@@@CODE-4 src/poisson_vc.py fromto: bcs = \[@if debug:

A new aspect of the variational problem is the two distinct
boundary integrals over $\GN^i$ and $\GR^i$.
Having a mesh function over exterior cell facets (our
`boundary_markers` object), where subdomains (boundary parts) are
numbered as $0,1,2,\ldots$, the special symbol `ds(0)`
implies integration over subdomain (part) 0, `ds(1)` denotes
integration over subdomain (part) 1, and so on.
The idea of multiple `ds`-type objects generalizes to volume
integrals too: `dx(0)`, `dx(1)`, etc., are used to
integrate over subdomain 0, 1, etc.,  inside $\Omega$.

To express integrals over the boundary parts using `ds(n)`, we must
first redefine the measures `ds` in terms of our boundary markers:

!bc pycod
ds = Measure('ds', domain=mesh, subdomain_data=boundary_markers)
!ec
Similarly, if we want integration of different parts of the domain,
we redefine `dx` as

!bc pycod
dx = Measure('dx', domain=mesh, subdomain_data=domain_markers)
!ec
where `domain_markers` is a `CellFunction` defining subdomains in $\Omega$.

Suppose we have a Robin condition with values `r` and `s` on subdomain
`R`, a Neumann condition with value `g` on subdomain `N`, the
variational form can be written

!bc pycod
a = dot(grad(u), grad(v))*dx + r*u*v*ds(R)
L = f*v*dx - g*v*ds(N) + r*s*v*ds(R)
!ec

In our case, things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the `boundary_conditions` data structure. We can collect
all Neumann conditions by the following code snippet:

@@@CODE-4 src/poisson_vc.py from-to: # Collect Neumann@# Collect Robin
Applying `sum(Nemann_integrals)` will apply the `+` operator to
the variational forms in the `Numeann_integrals` list and result
in the integrals we need for the right-hand side `L` of the
variational form.

The integrals in the Robin condition can similarly be collected
in lists:

@@@CODE-4 src/poisson_vc.py from-to: # Collect Robin@# Simpler Robin

We are now in a position to define the `a` and `L` expressions
in the variational formulation:

@@@CODE-4 src/poisson_vc.py from-to: # Define variational problem, solver_bc@# Simpler variational

idx{`lhs`}
idx{`rhs`}

Alternatively, we may use the FEniCS functions `lhs` and `rhs` as
mentioned above to simplify the extraction of terms for the Robin
integrals:

!bc pycod
integrals_R = []
for n in boundary_conditions:
    if 'Robin' in boundary_conditions[n]:
        r, s = boundary_conditions[n]['Robin']
        integrals_R.append(r*(u-s)*v*ds(n))

F = p*dot(grad(u), grad(v))*dx + \
    sum(integrals_R) - f*v*dx + sum(integrals_N)
a, L = lhs(F), rhs(F)
!ec

The complete code for this example can be found in the function
`solver_bc` in the program `${prog["poisson_vc"]}.py`.

===== Test problem =====

Let us continue to use $\uex=1+x^2+2y^2$ as the exact solution, and
set $p=1$ and $f=-6$. Our domain is the unit square, and
we assign Dirichlet conditions at $x=0$ and $x=1$, a Neumann condition
at $y=1$, and a Robin condition at $y=0$. With the given $\uex$, we
realize that the Neumann condition is $4y$ (which means $4$ at
$y=1$), while the Robin
condition can be selected in many ways. Since $\partial u/\partial
n=-\partial u/\partial y=0$ at $y=0$, we can select $s=u$ and specify
$r \neq 0$ arbitrarily in the Robin condition.

The boundary parts are thus $\GD^0$: $x=0$, $\GD^1$: $x=1$,
$\GR^0$: $y=0$, and $\GN^0$: $y=1$.

When implementing this test problem, and especially other test
problems with more complicated expressions, it is advantageous to use
symbolic computing. Below we define the exact solution as a `sympy`
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can be fed into `Expression` objects.

@@@CODE src/poisson_vc.py fromto: def application_bc_test\(@# Compute
This simple test problem is turned into a real unit test for different
function spaces in the function `test_solver_bc`.

===== Debugging boundary conditions =====

It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the `SubDomain.inside` method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
elements, add the corresponding vertex coordinate to the
output.

@@@CODE-4 src/poisson_vc.py fromto: if debug:@# Define trial and

======= Generating meshes with subdomains =======
