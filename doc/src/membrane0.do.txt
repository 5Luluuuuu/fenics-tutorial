===== Deflection of a membrane =====
label{ftut:poisson:membrane}

The previous problem and code targeted a simple test problem where we
can easily verify the implementation. Now we turn the attention to
a more physically relevant problem, in a non-trivial geometry, and
that results in solutions of somewhat more exciting shape.

We want to compute the deflection $w$ of a two-dimensional, circular membrane,
subject to a load $p$ over the membrane.
A scaled form of this problem
(see Section ref{tut:poisson:membrane} for mathematical details) has
the governing equation
$-\nabla^2 w = p$ over the unit circle, with $w=0$ on the boundary, and
the load given as

!bt
\[ p = - 4\exp{\left(-\beta^2(x^2 + (y-R_0)^2)\right)},\]
!et
where $\beta$ and $R_0$ are dimensionless numbers reflecting the
extent of the load and its location, respectively. Let us work with
a quite peak-shaped load, for which $\beta=8$ and $R_0=0.6$ are
relevant parameters.

Just a few modifications are necessary in our previous program to solve
this new problem.

=== Generating the mesh ===

A mesh over the unit circle can be created by the `mshr` tool in
FEniCS:

!bc pycod
from mshr import *
domain = Circle(Point(0.0, 0.0), 1.0)
mesh = generate_mesh(domain, n)
!ec
The `Circle` shape from `mshr` takes the center and radius of the circle
as the two first arguments, while `n` is the resolution, here the
suggested number of cells per radius.

=== The expression for the load ===

idx{`Expresion`}
idx{Expression with parameters}

The right-hand side pressure function
is represented by an `Expression` object. There
are two physical parameters in the formula for $f$ that enter the
expression string and these parameters must have their values set
by keyword arguments:

!bc pycod
p = Expression(
    '4*exp(-pow(beta,2)*(pow(x[0], 2) + pow(x[1]-R0, 2)))',
    beta=beta, R0=R0)
!ec
The coordinates in `Expression` objects *must* be a vector
with indices 0, 1, and 2, and with the name `x`. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set

!bc pycod
f.beta = 12
f.R0 = 0.3
!ec

idx{interpolation}

=== Variational form ===

We may introduce `w` instead of `u` as primary unknown and `p` instead
of `f` as right-hand side function:

!bc pycod
w = TrialFunction(V)
v = TestFunction(V)
a = dot(grad(w), grad(v))*dx
L = p*v*dx

w = Function(V)
solve(a == L, w, bc)
!ec

=== Visualization ===

It would be of interest to visualize $p$ along with $w$ so that we can
examine the pressure force and the membrane's response.  We must then transform
the formula (`Expression`) to a finite element function
(`Function`).  The most natural approach is to construct a finite
element function whose degrees of freedom are
calculated from $p$. That is, we interpolate $p$:

!bc pycod
p = interpolate(p, V)
!ec
Calling `plot(p)` will produce a plot of $p$. Note that the assignment
to `p` destroys the previous `Expression` object `p`, so if
it is of interest to still have access to this object, another name must be used
for the `Function` object returned by `interpolate`.

We can now plot `w` and `p` as well as dump the fields to file in VTK format:

!bc pycod
plot(w, title='Deflection')
plot(p, title='Load')

vtkfile = File('membrane.pvd')
vtkfile << w
vtkfile << p
!ec
Figure ref{ftut:poisson:membrane:fig} shows the result of the `plot`
commands.

FIGURE: [fig/membrane_fenics_viz, width=800 frac=1] Load (left) and resulting deflection (right) of a circular membrane. label{ftut:poisson:membrane:fig}
