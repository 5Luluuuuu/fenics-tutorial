!split
======= Mathematical problem formulation =======

[AL: I AM HERE]

[hpl: Need a little intro.]

===== The Poisson equation =====
label{tut:poisson1:bvp}
idx{Poisson's equation}

Let us start with a ``Hello, World!'' program in the world of PDEs - it
must be a program that solves the Laplace or Poisson equation.
Our first example regards the following Poisson problem,

!bt
\begin{align}
- \nabla^2 u(\x) &= f(\x),\quad \x\mbox{ in } \Omega,
label{tut:poisson1}\\
u(\x) &= u_0(\x),\quad \x\mbox{ on } \partial \Omega\tp label{tut:poisson1:bc}
\end{align}
!et
Here, $u(\x)$ is the unknown function, $f(\x)$ is a
prescribed function, $\nabla^2$ is the Laplace operator (also
often written as $\Delta$), $\Omega$ is the spatial domain, and
$\partial\Omega$ is the boundary of $\Omega$. A stationary PDE like
this, together with a complete set of boundary conditions, constitute
a *boundary-value problem*, which must be precisely stated before
it makes sense to start solving it with FEniCS.

In two space dimensions with coordinates $x$ and $y$, we can write out
the Poisson equation as

!bt
\begin{equation}
- {\partial^2 u\over\partial x^2} -
{\partial^2 u\over\partial y^2} = f(x,y)\tp
\end{equation}
!et
The unknown $u$ is now a function of two variables, $u(x,y)$, defined
over a two-dimensional domain $\Omega$.

The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier-Stokes equations.


Solving a physical problem with FEniCS consists of the following steps:

  o Identify the PDE and its boundary conditions.
  o Reformulate the PDE problem as a variational problem.
  o Make a Python program where the formulas in the variational
    problem are coded, along with definitions of input data such as
    $f$, $u_0$, and a mesh for the spatial domain $\Omega$.
  o Add statements in the program for solving the variational
    problem, computing derived quantities such as $\nabla u$, and
    visualizing the results.

We shall now go through steps 2-4 in detail.  The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.


===== Variational formulation =====
label{tut:poisson1:varform}
idx{variational formulation}

FEniCS makes it easy to solve PDEs if finite elements are used for
discretization in space and the problem is expressed as a *variational
problem*. Readers who are not familiar with variational problems will
get a brief introduction to the topic in this tutorial, but getting
and reading a proper book on the finite element method in addition is
encouraged.  Section ref{tut:appendix:books} contains a list of some
suitable books.


idx{test function}
idx{trial function}

The core of the recipe for turning a PDE into a variational problem is
to multiply the PDE by a function $v$, integrate the resulting
equation over $\Omega$, and perform integration by parts of terms with
second-order derivatives. The function $v$ which multiplies the PDE is
in the mathematical finite element literature called a *test
function*. The unknown function $u$ to be approximated is referred to
as a *trial function*. The terms test and trial function are used in
FEniCS programs too.  Suitable function spaces must be specified for
the test and trial functions.  For standard PDEs arising in physics
and mechanics such spaces are well known.

In the present case, we first multiply the Poisson equation
by the test function $v$ and integrate,

!bt
\begin{equation}
label{tut:poisson1:multbyv}
 -\int_\Omega (\nabla^2 u)v \dx = \int_\Omega fv \dx\tp \end{equation}
!et
Then we apply integration by parts to the integrand with
second-order derivatives,

!bt
\begin{equation}
label{tut:poisson1:eqbyparts}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds ,
\end{equation}
!et
where $\frac{\partial u}{\partial n}$ is the derivative of $u$ in the
outward normal direction at the boundary.  The test function $v$ is
required to vanish on the parts of the boundary where $u$ is known,
which in the present problem implies that $v=0$ on the whole boundary
$\partial\Omega$.  The second term on the right-hand side of
(ref{tut:poisson1:eqbyparts}) therefore vanishes.  From
(ref{tut:poisson1:multbyv}) and (ref{tut:poisson1:eqbyparts}) it
follows that

!bt
\begin{equation}
\int_\Omega\nabla u\cdot\nabla v \dx = \int_\Omega fv \dx\tp
label{tut:poisson1:weak1}
\end{equation}
!et
This equation is supposed to hold for all $v$ in some function space
$\hat V$. The trial function $u$ lies in some (possibly different)
function space $V$.  We refer to (ref{tut:poisson1:weak1}) as the
*weak form* or *variational form* of the original boundary-value
problem (ref{tut:poisson1})-(ref{tut:poisson1:bc}).

The proper statement of
our variational problem now goes as follows:
Find $u \in V$ such that

!bt
\begin{equation} label{tut:poisson1:var}
  \int_{\Omega} \nabla u \cdot \nabla v \dx =
  \int_{\Omega} fv \dx
  \quad \forall v \in \hat{V}.
\end{equation}
!et
The test and trial spaces $\hat{V}$ and $V$ are in the present
problem defined as

!bt
\begin{align*}
    \hat{V} &= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}, \\
     V      &= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}\tp
\end{align*}
!et
In short, $H^1(\Omega)$ is the mathematically well-known Sobolev space
containing functions $v$ such that $v^2$ and $||\nabla v||^2$ have
finite integrals over $\Omega$. The solution of the underlying PDE
must lie in a function space where also the derivatives are
continuous, but the Sobolev space $H^1(\Omega)$ allows functions with
discontinuous derivatives.  This weaker continuity requirement of $u$
in the variational statement (ref{tut:poisson1:var}), caused by the
integration by parts, has great practical consequences when it comes
to constructing finite elements.

To solve the Poisson equation numerically, we need to transform the
continuous variational problem (ref{tut:poisson1:var}) to a discrete
variational problem. This is done by introducing *finite-dimensional*
test and trial spaces, often denoted as $\hat{V}_h\subset\hat{V}$ and
$V_h\subset{V}$. The discrete variational problem reads: Find $u_h \in
V_h \subset V$ such that

!bt
\begin{equation} label{tut:poisson1:vard}
  \int_{\Omega} \nabla u_h \cdot \nabla v \dx =
  \int_{\Omega} fv \dx
  \quad \forall v \in \hat{V}_h \subset \hat{V}\tp
\end{equation}
!et
The choice of $\hat{V}_h$ and $V_h$ follows directly from the kind of
finite elements we want to apply in our problem. For example, choosing
the well-known linear triangular element with three nodes implies that
$\hat V_h$ and $V_h$ are the spaces of all piecewise linear functions
over a mesh of triangles, where the functions in $\hat V_h$ are zero
on the boundary and those in $V_h$ equal $u_0$ on the boundary.

!bwarning What we mean by the notation $u$ and $V$
The mathematics literature on variational problems writes $u_h$ for
the solution of the discrete problem and $u$ for the solution of the
continuous problem. To obtain (almost) a one-to-one relationship
between the mathematical formulation of a problem and the
corresponding FEniCS program, we shall use $u$ for the solution of
the discrete problem and $\uex$ for the exact solution of the
continuous problem, *if* we need to explicitly distinguish
between the two.

In most cases, we will introduce the PDE problem with
$u$ as unknown, derive a variational equation $a(u,v)=L(v)$ with $u\in
V$ and $v\in \hat V$, and then simply discretize the problem by saying
that we choose finite-dimensional spaces for $V$ and $\hat V$, without
adding any subscript to $V$ or $\hat V$. This
restriction of $V$ simply implies that $u$ becomes a discrete finite element
function.  In practice, this means that we turn our PDE problem into a
continuous variational problem, create a mesh and specify an element
type, and then let $V$ correspond to this mesh and element choice.
Depending upon whether $V$ is infinite- or finite-dimensional, $u$
will be the exact or approximate solution.
!ewarning

It turns out to be convenient to introduce the following unified
notation for linear weak forms:

!bt
\begin{equation}
a(u, v) = L(v)\tp
\end{equation}
!et
In the present problem we have that

!bt
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
label{tut:poisson1:vard:a}\\
L(v) &= \int_{\Omega} fv \dx\tp  label{tut:poisson1:vard:L}
\end{align}
!et
From the mathematics literature, $a(u,v)$ is known as a *bilinear
form* and $L(v)$ as a *linear form*.  We shall in every linear problem
we solve identify the terms with the unknown $u$ and collect them in
$a(u,v)$, and similarly collect all terms with only known functions in
$L(v)$. The formulas for $a$ and $L$ are then coded directly in the
program.

To summarize, before making a FEniCS program for solving a PDE,
we must first perform two steps:

  * Turn the PDE problem into a discrete
    variational problem: find $u\in V$
    such that $a(u,v) = L(v)\quad\forall v\in \hat{V}$.
  * Specify the choice of spaces ($V$ and $\hat V$), which means
    specifying the mesh and type of finite elements.


# Suggested: var coeff as early as possible!
# A basic Poisson solver
# Useful extensions/Useful stuff/: var coeff here
# Visualization: membrane, vtk, paraview, structured mesh
# Postprocessing computations: var coeff, functionals, conv rates
# Multiple domains and boundaries

!split
======= A basic Poisson solver =======
label{tut:poisson1:impl}

The test problem so far has a general domain $\Omega$ and general
functions $u_0$ and $f$. For our first implementation we must decide
on specific choices of $\Omega$, $u_0$, and $f$.  It will be wise to
construct a specific problem where we can easily check that the
computed solution is correct. Let us start with specifying an exact
solution $\uex(x,y)$:

!bt
\begin{equation}
\label{tut:poisson1:impl:uex}
\uex(x,y) = 1 +x^2 + 2y^2
\end{equation}
!et
on some 2D domain.  By inserting (ref{tut:poisson1:impl:uex}) in
our Poisson problem, we find that $\uex(x,y)$ is a solution if

!bt
\[ f(x,y) = -6,\quad u_0(x,y)=\uex(x,y)=1 + x^2 + 2y^2,\]
!et
regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,

!bt
\[ \Omega = [0,1]\times [0,1] .\]
!et
The reason for specifying the solution (ref{tut:poisson1:impl:uex}) is
that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution ($u$) with the exact
solution ($\uex$). These quantities should be equal to machine
precision *at the nodes*.

!bnotice Tip: Try to verify your code with exact numerical solutions!
The classical way of testing a program is to compare the numerical
solution with an exact analytical solution of the test problem
and conclude that the program works if the error is ``small enough''.
Unfortunately, it is impossible to tell if an error $10^{-5}$ on
a $20\times 20$ mesh of P1 elements is just all the numerical
approximation errors in the method or if this error also contains
the effect of a bug in the code. All we usually know about the
numerical error is its *asymptotic properties*, for instance that
it goes like $h^2$ if $h$ is the size of a cell in the mesh. Then we
can compare the error on meshes with different $h$ values to see if
the asymptotic behavior is correct. This is a very powerful
verification technique and is explained in detail in Section
ref{tut:poisson1:convrates}. However, if we have a test problem where
we know that there are no numerical approximation errors, we know that
the analytical solution of the PDE problem should be reproduced to
machine precision by the program. That is why we emphasize this kind
of test problems throughout this tutorial.
Typically, elements of degree $d$ can reproduce polynomials of
degree $d+1$ exactly, so this is the starting point for constructing
a solution without numerical approximation errors. Then we fit the
data in the problem (like $u_0$ and $f$) to this solution.
!enotice

===== The simplest possible code =====
label{tut:poisson1:impl:code}

A FEniCS program for solving the Poisson equation in 2D with the given
choices of $u_0$, $f$, and $\Omega$ may look as follows:

@@@CODE ../../src/poisson/${prog['p2D_plain']}.py fromto: from fenics import@

The complete code can be found in the file "`${prog['p2D_plain']}.py`":
"${src_url}/${prog['p2D_plain']}.py".

===== Running the program =====
label{tut:poisson1:impl:run}

To run the program `${prog["p2D_plain"]}.py`, open a terminal window, move to
the directory containing the program and write

!bc sys
Terminal> python ${prog['p2D_plain']}.py
!ec
A plot window pops up showing how the solution $u$ looks like as a surface.
With the left mouse button you can tilt the figure. Click `m` to bring
up the underlying mesh. Click `p` to save to a PNG file `fenics_plot_0.png`
and `P` to save to a PDF file `fenics_plot_1.pdf`. To kill the
plot window and terminate the application, click `Ctrl+q` (hold down
the `Ctrl` key and press `q`).
Figure ref{tut:poisson:2D:fig:ex1:u} displays the surface and the mesh below.
Since $u$ is a simple quadratic function,
constructed for testing our solver, the
surface looks quite boring.

FIGURE:[fig/ex1_u, width=600 frac=0.8] Plot of the solution in the first FEniCS example. label{tut:poisson:2D:fig:ex1:u}


===== Dissection of the program =====
label{tut:poisson1:impl:dissect}

We shall now dissect this FEniCS program in detail. The program is
written in the Python programming language.  You may either take a
quick look at the "official Python tutorial":
"http://docs.python.org/tutorial/" to pick up the basics of Python if
you are unfamiliar with the language, or you may learn enough Python
as you go along with the examples in the present tutorial. The latter
strategy has proven to work for many newcomers to FEniCS. (The
requirement of using Python and an abstract mathematical formulation
of the finite element problem may seem difficult for those who are
unfamiliar with these topics.  However, the amount of mathematics and
Python that is really demanded to get you productive with FEniCS is
quite limited.  And Python is an easy-to-learn language that you
certainly will love and use far beyond FEniCS programming.)  Section
ref{tut:appendix:pybooks} lists some relevant Python books.

The listed FEniCS program defines a finite element mesh, the discrete
function spaces $V$ and $\hat{V}$ corresponding to this mesh and the
element type, boundary conditions for $u$ (the function $u_0$),
$a(u,v)$, and $L(v)$.  Thereafter, the unknown trial function $u$ is
computed. Then we can compare the numerical and exact solution
as well as investigate $u$ visually.

=== The key import line ===

The first line in the program,

!bc pycod
from fenics import *
!ec
imports the key classes `UnitSquareMesh`, `FunctionSpace`, `Function`,
and so forth, from the FEniCS library.  All FEniCS programs for
solving PDEs by the finite element method normally start with this
line.

[hpl: The following paragraph was natural when we did `from dolfin import *`,
but is not longer relevant to explain that syntax. However, it should
be somewhere: we should in the tutorial explain the various components
of FEniCS since they appear so frequently in all the official demo
programs.]

DOLFIN is a software library with efficient and convenient C++
classes for finite element computing, and `dolfin` is a Python package
providing access to this C++ library from Python programs.  You can
think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The `from fenics import *` statement
imports other components too, but newcomers to FEniCS programming do
not need to care about this.

## NOTE: index entries *must* become before paragraph/subsubsection
## headings, otherwise sphinx output will be malformed

idx{`Mesh`}

=== Generating simple meshes ===

The statement

!bc pycod
mesh = UnitSquareMesh(6, 4)
!ec
defines a uniform finite element mesh over the unit square
$[0,1]\times [0,1]$. The mesh consists of *cells*, which are triangles
with straight sides. The parameters 6 and 4 tell that the square is
first divided into $6\times 4$ rectangles, and then each rectangle is
divided into two triangles. The total number of triangles then becomes
48. The total number of vertices in this mesh is $7\cdot 5=35$.
FEniCS offers some classes for creating meshes over very simple
geometries. For domains of more complicated shape one needs to use a
separate *preprocessor* program to create the mesh.  The FEniCS
program will then read the mesh from file.

idx{`FunctionSpace`}
idx{finite element specifications}
idx{CG finite element family}
idx{Lagrange finite element family}
idx{P1 element}

=== Defining a function space corresponding to a mesh ===

Having a mesh, we can define a discrete function space `V` over this mesh:

!bc pycod
V = FunctionSpace(mesh, 'Lagrange', 1)
!ec
The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.  The
type of element is here ``Lagrange'', implying the standard Lagrange
family of elements.  (Some FEniCS programs use `'CG'`, for Continuous
Galerkin, as a synonym for `'Lagrange'`.)  With degree 1, we simply
get the standard linear Lagrange element, which is a triangle with
nodes at the three vertices.  Some finite element practitioners refer
to this element as the ``linear triangle'' or the P1 element.  The
computed $u$ will be continuous and linearly varying in $x$ and $y$
over each cell in the mesh.  Higher-degree polynomial approximations
over each cell are trivially obtained by increasing the third
parameter in `FunctionSpace`, which will then generate P2, P3, and so
forth, type of elements. Changing the second parameter to `'DG'`
creates a function space for discontinuous Galerkin methods.

idx{`TestFunction`} idx{`TrialFunction`}
idx{`DirichletBC`}
idx{Dirichlet boundary conditions}

=== Defining test and trial functions ===

In mathematics, we distinguish between the trial and test spaces $V$
and $\hat{V}$. The only difference in the present problem is the
boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space `V` for the and trial and test functions in the
program:

!bc pycod
u = TrialFunction(V)
v = TestFunction(V)
!ec

idx{boundary specification (function)}

=== Specifying the boundary and boundary conditions ===

The next step is to specify the boundary condition: $u=u_0$ on
$\partial\Omega$. This is done by

!bc pycod
bc = DirichletBC(V, u0, u0_boundary)
!ec
where `u0` is an instance holding the $u_0$ values, and `u0_boundary`
is a function (or object) describing whether a point lies on the
boundary where $u$ is specified.

Boundary conditions of the type $u=u_0$ are known as *Dirichlet
conditions*, and also as *essential boundary conditions* in a finite
element context.  Naturally, the name of the class holding the
information about Dirichlet boundary conditions is `DirichletBC`.

idx{`Expression`}

The `u0` variable refers to an `Expression` object, which is used to
represent a mathematical function. The typical construction is

!bc pycod
u0 = Expression(formula)
!ec
where `formula` is a string containing the mathematical expression.
This formula is written with C++ syntax. The expression is
automatically turned into an efficient, compiled C++ function. The
independent variables in the function expression are supposed to be
available as a point vector `x`, where the first element `x[0]`
corresponds to the $x$ coordinate, the second element `x[1]` to the
$y$ coordinate, and (in a three-dimensional problem) `x[2]` to the $z$
coordinate. With our choice of $u_0(x,y)=1 + x^2 + 2y^2$, the formula
string must be written as `1 + x[0]*x[0] + 2*x[1]*x[1]`:

!bc pycod
u0 = Expression('1 + x[0]*x[0] + 2*x[1]*x[1]')
!ec

idx{C++ expression syntax}
idx{expression syntax (C++)}

!bnotice String expressions must have valid C++ syntax!
The string argument to an `Expression` object must obey C++ syntax.
Most Python syntax for mathematical expressions are also valid C++ syntax,
but power expressions make an exception: `p**a` must be written as
`pow(p,a)` in C++ (this is also an alternative Python syntax).
The following mathematical functions can be used directly
in C++
expressions when defining `Expression` objects:
`cos`, `sin`, `tan`, `acos`, `asin`,
`atan`, `atan2`, `cosh`, `sinh`, `tanh`, `exp`,
`frexp`, `ldexp`, `log`, `log10`, `modf`,
`pow`, `sqrt`, `ceil`, `fabs`, `floor`, and `fmod`.
Moreover, the number $\pi$ is available as the symbol `pi`.
All the listed functions are taken from the `cmath` C++ header file, and
one may hence
consult documentation of `cmath` for more information on the
various functions.

If tests are possible using the C syntax for inline branching. The
function

!bt
\[ f(x,y) = \left\lbrace\begin{array}{ll} x^2, & x, y\geq 0\\
2, & \hbox{otherwise}\end{array}\right.\]
!et
is implemented as

!bc pycod
f = Expression('x[0] >= 0 && x[1] >= 0? pow(x[0], 2) : 2')
!ec

Parameters in expression strings are allowed, but
must be initialized via keyword
arguments when creating the `Expression` object. For example, the
function $f(x)=e^{-\kappa\pi^2t}\sin(\pi k x)$ can be coded as

!bc pycod
f = Expression('exp(-kappa*pow(pi,2)*t)*sin(pi*k*x[0])',
               kappa=1.0, t=0, k=4)
!ec
At any time, parameters can be updated:

!bc pycod
f.t += dt
f.k = 10
!ec
!enotice

idx{boundary specification (function)}

The information about where to apply the `u0` function as boundary
condition is coded in a function `u0_boundary`:

!bc pycod
def u0_boundary(x, on_boundary):
    return on_boundary
!ec
A function like `u0_boundary` for marking the boundary must return a
boolean value: `True` if the given point `x` lies on the Dirichlet
boundary and `False` otherwise.  The argument `on_boundary` is `True`
if `x` is on the physical boundary of the mesh, so in the present
case, where we are supposed to return `True` for all points on the
boundary, we can just return the supplied value of `on_boundary`.  The
`u0_boundary` function will be called for every discrete point in the
mesh, which allows us to have boundaries where $u$ are known also
inside the domain, if desired.

One can also omit the `on_boundary` argument, but in that case we need
to test on the value of the coordinates in `x`:

!bc pycod
def u0_boundary(x):
    return x[0] == 0 or x[1] == 0 or x[0] == 1 or x[1] == 1
!ec
As for the formula in `Expression` objects, `x` in the `u0_boundary`
function represents a point in space with coordinates `x[0]`, `x[1]`,
etc. Comparing floating-point values using an exact match test with
`==` is not good programming practice, because small round-off errors
in the computations of the `x` values could make a test `x[0] == 1`
become false even though `x` lies on the boundary.  A better test is
to check for equality with a tolerance:

!bc pycod
def u0_boundary(x):
    tol = 1E-15
    return abs(x[0]) < tol or \
           abs(x[1]) < tol or \
           abs(x[0] - 1) < tol or \
           abs(x[1] - 1) < tol
!ec

idx{UFL}

=== Specifying the right-hand side function ===

Before defining $a(u,v)$ and $L(v)$ we have to specify the $f$ function:

!bc pycod
f = Expression('-6')
!ec
When $f$ is constant over the domain, `f` can be
more efficiently represented as a `Constant` object:

!bc pycod
f = Constant(-6.0)
!ec

=== Specifying the variational formulation ===

Now we have all the objects we need in order to specify this problem's
$a(u,v)$ and $L(v)$:

!bc pycod
a = inner(nabla_grad(u), nabla_grad(v))*dx
L = f*v*dx
!ec
In essence, these two lines specify the PDE to be solved.  Note the
very close correspondence between the Python syntax and the
mathematical formulas $\nabla u\cdot\nabla v \dx$ and $fv \dx$.  This
is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.  The language used to express weak
forms is called UFL (Unified Form Language) cite{UFL_2014,FEniCS}
and is an integral part of FEniCS.

Instead of `nabla_grad` we could also just have written `grad` in the
examples in this tutorial. However, when taking gradients of vector
fields, `grad` and `nabla_grad` differ. The latter is consistent with
the tensor algebra commonly used to derive vector and tensor PDEs,
where $\nabla$ (``nabla'') acts as a vector operator, and therefore
this author prefers to always use `nabla_grad`.

=== Forming and solving the linear system ===

Having `a` and `L` defined, and information about essential
(Dirichlet) boundary conditions in `bc`, we can compute the solution,
a finite element function `u`, by

!bc pycod
u = Function(V)
solve(a == L, u, bc)
!ec
Some prefer to replace `a` and `L` by an `equation`
variable, which is accomplished by this equivalent code:

!bc pycod
equation = inner(nabla_grad(u), nabla_grad(v))*dx == f*v*dx
u = Function(V)
solve(equation, u, bc)
!ec

Note that we first defined the variable `u` as a `TrialFunction` and
used it to represent the unknown in the form `a`.  Thereafter, we
redefined `u` to be a `Function` object representing the solution,
i.e., the computed finite element function $u$.  This redefinition of
the variable `u` is possible in Python and often done in FEniCS
applications. The two types of objects that `u` refers to are equal
from a mathematical point of view, and hence it is natural to use the
same variable name for both objects. In a program, however,
`TrialFunction` objects must always be used for the unknowns in the
problem specification (the form `a`), while `Function` objects must be
used for quantities that are computed (known).

idx{degrees of freedom}

=== Examining the values of the solution ===

The present test problem should produce a numerical solution that
equals the exact solution to machine precision. That is, there are
no approximation errors in our test problem. We can use this property
to ``prove'' that our implementation is correct, a necessary first step
before we try to apply our code to more complicated problems.
For such verification, we need
to compare the computed `u` function to `u0`.

A finite element function like $u$ is expressed as a linear combination
of basis functions $\phi_j$, spanning the space $V$:

!bt
\begin{equation}
u = \sum_{j=1}^N U_j \phi_j label{tut:poisson1:ufem}\tp
\end{equation}
!et
By writing `solve(a == L, u, bc)` in the program, a linear system
will be formed from $a$ and $L$, and this system is solved for the
$U_1,\ldots,U_N$ values. The $U_1,\ldots,U_N$ values are known
as *degrees of freedom* of $u$. For Lagrange elements (and many other
element types) $U_k$ is simply the value of $u$ at the node
with global number $k$.
The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there are additional nodes at
the facets and maybe also in the interior of cells.

Having `u` represented as a `Function` object, we can either evaluate
`u(x)` at any point `x` in the mesh (expensive operation!),
or we can grab all the degrees of
freedom values $U_j$ directly by

!bc pycod
u_nodal_values = u.vector()
!ec
The result is a `Vector` object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
`Vector` object to a standard `numpy` array for further
processing:

idx{degrees of freedom array}
idx{nodal values array}
idx{numbering!degrees of freedom}
idx{numbering!cell vertices}

!bc pycod
u_array = u_nodal_values.array()
!ec
With `numpy` arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: `u_array[i]`,
where the index `i` always starts at `0`. However, `i` corresponds
to $u$ at some point in the mesh and the correspondence requires
knowledge of the numbering of degrees of freedom and the numbering of
vertices in elements in the mesh, see Section ref{tut:poisson1:verify1}
for details.

idx{`interpolate`}

For now, we want to check that the values in `u_array` are correct:
they should equal our `u0` function. The most natural approach is
to interpolate our `u0` expression onto our space
(i.e., the finite element mesh),

!bc pycod
u0_Function = interpolate(u0, V)
!ec
The `interpolate` function returns a `Function` object, whose degrees
of freedom values can be obtained by `.vector().array()`.  Our goal is
to show that the degrees of freedom arrays of `u` and `u0_Function`
are equal. One safe of doing this is to compute the maximum error,

!bc pycod
u0_array = u0_Function.vector().array()  # dof values
max_error = (u0_array - u.vector().array()).max()
print('max error:', max_error)
!ec

!bnotice How to check that the error vanishes?
With inexact arithmetics, as we always have on a computer,
this maximum error is not zero, but should be a small number.
The machine precision is about $10^{-16}$, but in finite element
calculations, rounding errors of this size may accumulate, so
the expected accuracy of `max_error` smaller. Experiments show
that increasing the number of elements and increasing the degree
of the finite element polynomials increase `max_error`.
For a mesh with $2(20\times 20)$ cubic Lagrange elements (degree 3)
`max_error` is about $2\cdot 10^{-12}$, while for 18 linear elements
the maximum error is about $2\cdot 10^{-15}$.
!enotice

=== Plotting the solution ===

The simplest way of quickly looking at `u` is to say

!bc pycod
plot(u, interactive=True)
# or
plot(u)
interactive()
!ec
Clicking on `Help` in the plot windows brings up a list of commands.
For example, typing `m` brings up the mesh.  With the left, middle,
and right mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution
looks like. You must click `Ctrl+q` to kill the plot window and
continue execution beyond the `plot(u, interactive=True)` command or
`interactive()`.  Figure ref{tut:poisson:2D:fig:ex1:u} displays the
resulting $u$ function.

Plotting both the solution and the mesh is accomplished by

!bc pycod
plot(u)
plot(mesh)
# Hold plot
interactive()
!ec
Type `Ctrl+w` to kill all plot windows and continue execution.

It is also possible to dump the computed solution to file, e.g., in the
VTK format:

!bc pycod
file = File('poisson.pvd')
file << u
!ec
The `poisson.pvd` file can now be loaded into any front-end to VTK,
say ParaView or VisIt. The `plot` function is intended for quick
examination of the solution during program development.  More in-depth
visual investigations of finite element solutions will normally
benefit from using highly professional tools such as ParaView and
VisIt.
