
======= The time-dependent diffusion equation =======
label{tut:timedep}

The examples in Section ref{tut:poisson1:impl} illustrate that solving
linear, stationary PDE problems with the aid of FEniCS is easy and
requires little programming.  FEniCS clearly automates the spatial
discretization by the finite element method. One can use a separate,
one-dimensional finite element method in the domain as well, but very
often, it is easier to just use a finite difference method, or to
formulate the problem as an ODE system and leave the time-stepping to
an ODE solver.
#The solution of
#nonlinear problems, as we showed in Section
#ref{tut:poisson:nonlinear}, can also be automated (cf. Section
#ref{tut:nonlinear:Newton:auto}), but many scientists will prefer to
#code the solution strategy of the nonlinear problem themselves and
#experiment with various combinations of strategies in difficult
#problems. Time-dependent problems are somewhat similar in this
#respect: we have to add a time discretization scheme, which is often
#quite simple, making it natural to explicitly code the details of the
#scheme so that the programmer has full control.
#We shall explain how
#easily this is accomplished through examples.

[hpl: Should exemplify all three approaches? With emphasis on
simple finite differences?]

===== Variational formulation =====
label{tut:timedep:diffusion1}
idx{time-dependent PDEs}

Our time-dependent model problem for teaching purposes is naturally
the simplest extension of the Poisson problem into the time domain,
i.e., the diffusion problem

!bt
\begin{align}
{\partial u\over\partial t} &= \nabla^2 u + f\hbox{ in }\Omega,
label{tut:diffusion:pde1}\\
u &= u_0\hbox{ on } \partial \Omega,
label{tut:diffusion:pde1:bc}\\
u &= I \mbox{ at } t=0\tp
label{tut:diffusion:pde1:ic}
\end{align}
!et
Here, $u$ varies with space and time, e.g., $u=u(x,y,t)$ if the spatial
domain $\Omega$ is two-dimensional. The source function $f$ and the
boundary values $u_0$ may also vary with space and time.
The initial condition $I$ is a function of space only.

A straightforward approach to solving time-dependent PDEs by the
finite element method is to first discretize the time derivative by a
finite difference approximation, which yields a recursive set of
stationary problems, and then turn each stationary problem into a
variational formulation.

Let superscript $k$ denote a quantity at time $t_k$, where $k$ is an
integer counting time levels. For example, $u^k$ means $u$ at time
level $k$.  A finite difference discretization in time first consists
in sampling the PDE at some time level, say $k$:

!bt
\begin{equation} {\partial \over\partial t}u^k = \nabla^2 u^k + f^k\tp
label{tut:diffusion:pde1:tk}
\end{equation}
!et
The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:

!bt
\begin{equation} {\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{\dt}},
label{tut:diffusion:BE}
\end{equation}
!et
where $\dt$ is the time discretization parameter.
Inserting (ref{tut:diffusion:BE}) in (ref{tut:diffusion:pde1:tk}) yields

!bt
\begin{equation}
{u^k - u^{k-1}\over{\dt}} = \nabla^2 u^k + f^k\tp
label{tut:diffusion:pde1:BE}
\end{equation}
!et
This is our time-discrete version of the diffusion PDE
(ref{tut:diffusion:pde1}).

We may reorder (ref{tut:diffusion:pde1:BE}) so
that the left-hand side contains the terms with the unknown $u^k$ and
the right-hand side contains computed terms only. The result
is a recursive set of spatial
(stationary) problems for $u^k$ (assuming $u^{k-1}$ is known from
computations at the previous time level):

!bt
\begin{align}
u^0 &= I, label{tut:diffusion:pde1:u0}\\
u^k - {\dt}\nabla^2 u^k &=  u^{k-1} + {\dt} f^k,\quad k=1,2,\ldots
label{tut:diffusion:pde1:uk}
\end{align}
!et
Given $I$, we can solve for $u^0$, $u^1$, $u^2$, and so on.

As an alternative to (ref{tut:diffusion:pde1:uk}), which can be
convenient in implementations, we may collect
all terms on one side of the equality sign:

!bt
\begin{equation}
u^k - {\dt}\nabla^2 u^k -  u^{k-1} - {\dt} f^k = ,\quad k=1,2,\ldots
label{tut:diffusion:pde1:uk2}
\end{equation}
!et

We use a finite element method to solve
(ref{tut:diffusion:pde1:u0}) and either of the equations
(ref{tut:diffusion:pde1:uk}) or (ref{tut:diffusion:pde1:uk2}).  This
requires turning the equations into weak forms.  As usual, we multiply
by a test function $v\in \hat V$ and integrate second-derivatives by
parts. Introducing the symbol $u$ for $u^k$ (which is natural in the
program), the resulting weak form can be conveniently written in
the standard notation:

!bt
\[ a_0(u,v)=L_0(v),\]
!et
for
(ref{tut:diffusion:pde1:u0}). The formulation (ref{tut:diffusion:pde1:uk})
gives rise to

!bt
\[ a(u,v)=L(v),\]
!et
where

!bt
\begin{align}
a_0(u,v) &= \int_\Omega uv \dx, label{tut:diffusion:pde1:a0}\\
L_0(v) &= \int_\Omega Iv \dx, label{tut:diffusion:pde1:L0}\\
a(u,v) &= \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v\right) \dx, label{tut:diffusion:pde1:a}\\
L(v) &= \int_\Omega \left(u^{k-1} + {\dt}  f^k\right)v \dx\tp
label{tut:diffusion:pde1:L}
\end{align}
!et
The alternative formulation (ref{tut:diffusion:pde1:uk2})
has a formulation

!bt
\[ F(u,v) = 0,\]
!et
where

!bt
\begin{equation}
F = \int_\Omega\left( uv + {\dt}
\nabla u\cdot \nabla v -
\left(u^{k-1} - {\dt}  f^k\right)v\right) \dx\tp
label{tut:diffusion:pde1:F}
\end{equation}
!et

The continuous variational problem is to find
$u^0\in V$ such that $a_0(u^0,v)=L_0(v)$ holds for all $v\in\hat V$,
and then find $u^k\in V$
such that $a(u^k,v)=L(v)$ for all $v\in\hat V$,
or alternatively, $F(u^k,v)=0$ for all $v\in\hat V$,
$k=1,2,\ldots$.

Approximate solutions in space are found by restricting the functional
spaces $V$ and $\hat V$ to finite-dimensional spaces, exactly as we
have done in the Poisson problems.  We shall use the symbol $u$ for
the finite element approximation at time $t_k$. In case we need to
distinguish this space-time discrete approximation from the exact
solution of the continuous diffusion problem, we use $\uex$ for the
latter.  By $u^{k-1}$ we mean the finite element approximation of the
solution at time $t_{k-1}$.

Instead of solving (ref{tut:diffusion:pde1:u0}) by a finite element
method, i.e., projecting $I$ onto $V$ via the problem
$a_0(u,v)=L_0(v)$, we could simply interpolate $u^0$ from $I$. That
is, if $u^0=\sum_{j=1}^N U^0_j\phi_j$, we simply set $U_j=I(x_j,y_j)$,
where $(x_j,y_j)$ are the coordinates of node number $j$. We refer to
these two strategies as computing the initial condition by either
projecting $I$ or interpolating $I$.  Both operations are easy to
compute through one statement, using either the `project` or
`interpolate` function.

===== A simple implementation =====
label{tut:timedep:diffusion1:impl}

Our program needs to implement the time stepping explicitly, but can
rely on FEniCS to easily compute $a_0$, $L_0$, $F$, $a$, and $L$, and solve
the linear systems for the unknowns.

=== Test problem ===

Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,

!bt
\begin{equation} u = 1 + x^2 + \alpha y^2 + \beta t,
label{tut:diffusion:pde1:u0test}
\end{equation}
!et
yields a function whose computed values at the nodes will be exact,
regardless of the size of the elements and $\dt$, as long as the mesh
is uniformly partitioned.  By inserting
(ref{tut:diffusion:pde1:u0test}) in the PDE problem
(ref{tut:diffusion:pde1}), it follows that $u_0$ must be given as
(ref{tut:diffusion:pde1:u0test}) and that $f(x,y,t)=\beta - 2 -
2\alpha$ and $I(x,y)=1+x^2+\alpha y^2$.

idx{`${prog["diffusion_flat1"]}.py`}

=== The code ===

% if FORMAT == 'ipynb':
We first create a mesh:

!bc pycod
from __future__ import print_function
from fenics import *

# Create mesh and define function space
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)
V = FunctionSpace(mesh, 'P', 1)
!ec
% endif

A new programming issue is how to deal with functions that vary in
space *and time*, such as the boundary condition $u_0$ given by
(ref{tut:diffusion:pde1:u0test}).  A natural solution is to apply an
`Expression` object with time $t$ as a parameter, in addition to the
parameters $\alpha$ and $\beta$
for `Expression` objects with parameters):

!bc pycod
% if FORMAT == 'ipynb':
# Create mesh and define function space
% endif
alpha = 3; beta = 1.2
u0 = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t',
                {'alpha': alpha, 'beta': beta})
u0.t = 0
!ec
This function expression has the components of `x` as independent
variables, while `alpha`, `beta`, and `t` are parameters.  The
parameters can either be set through a dictionary at construction
time, as demonstrated for `alpha` and `beta`, or anytime through
attributes in the function object, as shown for the `t` parameter.

The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,

!bc pycod
def boundary(x, on_boundary):  # define the Dirichlet boundary
    return on_boundary

bc = DirichletBC(V, u0, boundary)
!ec

We shall use `u` for the unknown $u$ at the new time level and `u_1`
for $u$ at the previous time level.  The initial value of `u_1`,
implied by the initial condition on $u$, can be computed by either
projecting or interpolating $I$.  The $I(x,y)$ function is available
in the program through `u0`, as long as `u0.t` is zero.  We can then
do

!bc pycod-t
u_1 = interpolate(u0, V)
# or
u_1 = project(u0, V)
!ec
Note that we could, as an equivalent alternative to using `project`,
define $a_0$ and $L_0$ as we did in Section ref{tut:poisson:gradu} and
form the associated variational problem.

!bc pyhid
u_1 = interpolate(u0, V)
!ec

!bwarning Projecting versus interpolating the initial condition
To actually recover the
exact solution (ref{tut:diffusion:pde1:u0test}) to machine precision,
it is important not to compute the discrete initial condition by
projecting $I$, but by interpolating $I$ so that the nodal values are
exact at $t=0$ (projection results in approximative values at the
nodes).
!ewarning

We may either define $a$ or $L$ according to the formulas above, or
we may just define $F$ and ask FEniCS to figure out which terms that
go into the bilinear form $a$ and which that go into the linear form
$L$. The latter is convenient, especially in more complicated problems,
so we illustrate that construction:

!bc pycod
dt = 0.3      # time step

u = TrialFunction(V)
v = TestFunction(V)
f = Constant(beta - 2 - 2*alpha)

F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_1 + dt*f)*v*dx
a, L = lhs(F), rhs(F)
!ec

Finally, we perform the time stepping in a loop:

!bc pycod
u = Function(V)   # the unknown at a new time level
T = 2             # total simulation time
t = dt

while t <= T:
    u0.t = t
    solve(a == L, u, bc)

% if FORMAT == 'ipynb':
    # Verify
    u_e = interpolate(u0, V)
    max_error = np.abs(u_e.vector().array() -
                       u.vector().array()).max()
    print('max error, t=%.2f: %-10.3g' % (t, max_error))
% endif
    t += dt
    u_1.assign(u)
!ec

!bwarning Remember to update expression objects with the current time!
Inside the time loop,
observe that `u0.t` must be updated before the `solve` statement
to enforce computation of Dirichlet conditions at the
current time level. (The Dirichlet conditions look up the `u0` object
for values.)
!ewarning

% if FORMAT != 'ipynb':
The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of `u` and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after `u` is found:

!bc pycod
u_e = interpolate(u0, V)
max_error = np.abs(u_e.vector().array() -
                   u.vector().array()).max()
print('max error, t=%.2f: %-10.3g' % (t, max_error))
!ec

The complete program code for this time-dependent case goes as follows:

@@@CODE src/diffusion_flat1.py fromto: from fenics import@
The code is available in the
file "`${prog['diffusion_flat1']}.py`": "${src_url}/diffusion_flat1.py".
% endif


===== Diffusion of a Gaussian function =====

Add dumping to file and some plots.
