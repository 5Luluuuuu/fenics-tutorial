======= To-do list =======

Remember: cannot exceed 150 pages (as reported at the end of `ftut.log`).
Solutions to exercises will not appear in the printed book. If we run
out of pages, we can also remove the exercises by putting if-else
constructs around them. There will be one short printed tutorial and
then extended e-versions with exercises (and optionally solution) on our
github web site.

Regarding layout, we must use `svmono.cls` for the printed book, but
are allowed to use gray background in code boxes and lmodern instead
of Courier for monospace font. Springer's official ebook has exactly
the same layout. For all other versions on our github
web site, we can choose whatever layout we want.

 * Reorganize sections into chapters. (HPL)
 * Rethink how to organize example programs in directories.
   Find a naming convention. (AL)
   HPL suggestion: Drop the `stationary` and `transient` directories,
   have at most separate directories for each PDE.
 * Programs are now flat demos. Educate the reader with
   better software engineering habits: functions, classes, unit tests.
   Avoid copy-and-edit flat programs implied by today's collection. (HPL)
 * Compute maximum error already in the first example so we can create
   a unit test as early as possible. (Done, HPL)
 * Find successful exercises from various tutorials (AL) and add as
   exercises in the book (HPL/AL). Exercises are key for learning
   software so having them (in an extended version?) sends an important
   signal about their relevance.
 * Write about installation in a way that does not get outdated.
   More as a guide to a newcomer: What to choose? (AL)
 * Multi-boundary examples do not work with FEniCS 1.6: `dnr*.py`. (AL)
 * `membrane2.py` referred to, but it is still in sandbox. (HPL)
 * Meshr domains. Set up some common continuum mechanics examples first. (HPL/AL)
 * Decide on an elasticity problem.
 * Simple Navier-Stokes solver. Do backward facing step and flow around a
   cylinder.
 * According to the `plot` doc string, it should be easy to
   plot the element a la `plot(u.function_space().ufl_element())` but I
   did not get this to work. Not crucial, but plotting the element is a
   nice feature :-)
 * Show how the definition of boundaries can be done via strings
   compiled to C++ (as soon as we have an example with non-trivial
   boundary segments), cf. Navier-Stokes FEniCS demo.
 * Can we change the value of `DOLFIN_EPS`? `imort dolfin; dolfin.DOLFIN_EPS=...` will work, but then all modules in the simulator must do `import dolfin`. Note that its value is very strict, e.g., `10.1+10.2` has rounding $3.5 10^{-15}$, so `DOLFIN_EPS` is strictly for scaled problems only where all variables are in $[0,1]$.
 * Comment regarding FEniCS demos: The documented demos mention a lot
   of packages: DOLFIN, FFC, Fiat, ... Make sure the reader of the tutorial
   does not get lost in the jungle of packages and make sure this is
   explained somewhere such that the tutorial is a good background for
   understanding every demo in every detail.

===== HPL questions =====

=== Iterative linear solvers info ===

We can get this printed out on the screen, but is there any method to
extract this text inside the program, such that we can see how many
Krylov iterations we do etc.? Any way for Python to capture the standard
output stream in C++?

Easy to write a script that post-processes
the output, but we have to wait until the simulator has terminated, or
we can pipe to a script `process.py` that treats the output in some
desired way (could append some into to a file and that is reopened
by the simulator):

!bc sys
Terminal> python mysolver.py | process.py
!ec
where the simplest `process.py` is

!bc pypro
import sys, time
t0 = time.clock()
while True:
    line = sys.stdin.readline()
    if not line:
        break
    t1 = time.clock()
    print 'after %g seconds: %s' % (t1-t0, line.rstrip())
print 'END'
!ec