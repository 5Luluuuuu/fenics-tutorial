
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Subdomains and boundary conditions</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="The FEniCS Tutorial Volume I" href="index.html" />
    <link rel="next" title="Extensions: Improving the Poisson solver" href="._ftut1006.html" />
    <link rel="prev" title="A Gallery of finite element solvers" href="._ftut1004.html" />

  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <!-- Default Bootstrap-->
  <link rel="stylesheet" href="_static/css/bootstrap.min.css"/>
  <link rel="shortcut icon" href="_static/fenics.ico" />
  <!-- Template styles CSS-->
  <link rel="stylesheet" href="_static/css/main.css"/>
  <link rel="stylesheet" href="_static/css/custom.css"/>
  <link rel="stylesheet" href="_static/css/font-awesome.min.css"/>
  <link rel="stylesheet" href="_static/css/animate.min.css"/>
  <link rel="stylesheet" href="_static/css/responsive.css"/>

  <!-- Template styles JS-->
  <script src="_static/slides.min.jquery.js"></script>
  <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
  <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
  <script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <script type="text/javascript" src="_static/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="_static/js/wow.min.js"></script>
  <script type="text/javascript" src="_static/js/main.js"></script>
  <script type="text/javascript" src="_static/js/jquery.bcSwipe.js"></script>
  <script>
    $(document).ready(function() {
         $("#mycarousel").swiperight(function() {
            $(this).carousel('prev');
            });
         $("#mycarousel").swipeleft(function() {
            $(this).carousel('next');
       });
    });
  </script>

  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<header id="header">
      <div class="navbar navbar-inverse" role="banner">
          <div class="container">
              <div class="navbar-header">
                  <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#headernavbar">
                      <span class="sr-only">Toggle navigation</span>
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                  </button>

                  <a class="navbar-brand" href="http://fenicsproject.org/index.html">
                      <h1><img src="_static/fenics_banner.png" alt="FEniCS Project Logo" class="img-responsive center-block banner-image"></h1>
                  </a>

              </div>
              <div class="collapse navbar-collapse" id="headernavbar">
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="._ftut1004.html" title="Previous page">Prev</a></li>
                    <li><a href="._ftut1006.html" title="Next page">Next</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/index.html">Home</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
                    <li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
                  </ul>
              </div>
          </div>
      </div>
  </header>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="subdomains-and-boundary-conditions">
<span id="ch-subdomains"></span><h1>Subdomains and boundary conditions<a class="headerlink" href="#subdomains-and-boundary-conditions" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>So far, we have only looked briefly at how to specify boundary
conditions. In this chapter, we look more closely at how to specify
boundary conditions on specific parts (subdomains) of the boundary and
how to combine multiple boundary conditions. We will also look at how to
generate meshes with subdomains and how to define coefficients and
variational problems that look different in different subdomains.</div></blockquote>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="ch-poisson0-dn"></span><h2>Combining Dirichlet and Neumann conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s return to our Poisson solver from the chapter <a class="reference internal" href="._ftut1003.html#ch-fundamentals"><span class="std std-ref">Fundamentals: Solving the Poisson equation</span></a>
and see how to extend the mathematics and the implementation to handle
a Dirichlet condition in combination with a Neumann condition. The
domain is still the unit square, but now we set the Dirichlet
condition <span class="math">\(u=u_{_\mathrm{D}}\)</span> at the left and right sides, <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, while
the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.</p>
<div class="section" id="pde-problem-6">
<span id="index-0"></span><h3>PDE problem<a class="headerlink" href="#pde-problem-6" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(\Gamma_{_\mathrm{D}}\)</span> and <span class="math">\(\Gamma_{_\mathrm{N}}\)</span> denote the parts of the boundary <span class="math">\(\partial\Omega\)</span>
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as</p>
<div class="math" id="eq-auto19">
\[\tag{66}
- \nabla^2 u = f \quad\mbox{in } \Omega,\]</div>
<div class="math" id="eq-auto20">
\[\tag{67}
u = u_{_\mathrm{D}} \mbox{on } \Gamma_{_\mathrm{D}},\]</div>
<div class="math" id="eq-auto21">
\[\tag{68}
- {\partial u\over\partial n} = g \mbox{on } \Gamma_{_\mathrm{N}}  {\thinspace .}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_{_\mathrm{D}}\)</span> accordingly:</p>
<div class="math">
\[\begin{split}\begin{align*}
f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
0, &amp; y=0\\
4, &amp; y=1
\end{array}\right.\\
u_{_\mathrm{D}} &amp;= 1 + x^2 + 2y^2{\thinspace .}
\end{align*}\end{split}\]</div>
<p>For ease of programming, we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = 4y{\thinspace .}\]</div>
</div>
<div class="section" id="variational-formulation-6">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-6" title="Permalink to this headline">¶</a></h3>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_{_\mathrm{D}}\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_{_\mathrm{D}}\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_{_\mathrm{N}}}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_{_\mathrm{N}}}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_{_\mathrm{N}}\)</span>.
The resulting weak form reads</p>
<div class="math" id="eq-ch-poisson0-2d-dn-weak">
\[\tag{69}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x}
    = \int_{\Omega} fv {\, \mathrm{d}x} - \int_{\Gamma_{_\mathrm{N}}} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="eq-ftut-poisson2-vard-a">
\[\tag{70}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-ftut-poisson2-vard-l">
\[\tag{71}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \int_{\Gamma_{_\mathrm{N}}} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
</div>
<div class="section" id="fenics-implementation-12">
<h3>FEniCS implementation<a class="headerlink" href="#fenics-implementation-12" title="Permalink to this headline">¶</a></h3>
<p>How does the Neumann condition impact the implementation?  Let us
revisit our previous implementation <code class="docutils literal"><span class="pre">ft01_poisson.py</span></code> from
the section <a class="reference internal" href="._ftut1003.html#ch-poisson0-impl"><span class="std std-ref">FEniCS implementation</span></a> and examine which changes
we need to make to incorporate the Neumann condition. It turns out that
only two are necessary.</p>
<blockquote>
<div><ul class="simple">
<li>The function <code class="docutils literal"><span class="pre">boundary</span></code> defining the Dirichlet boundary
must be modified.</li>
<li>The new boundary term must be added to the expression for <code class="docutils literal"><span class="pre">L</span></code>.</li>
</ul>
</div></blockquote>
<p>The first adjustment can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

<span class="k">def</span> <span class="nf">boundary_D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary_D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
</pre></div>
</div>
<p id="index-1">The second adjustment of our program concerns the definition of <code class="docutils literal"><span class="pre">L</span></code>,
which needs to include the Neumann condition:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ds</span></code> variable implies a boundary integral, while <code class="docutils literal"><span class="pre">dx</span></code>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No other modifications are necessary.</p>
<p>Note that the integration <code class="docutils literal"><span class="pre">*ds</span></code> is carried out over the entire
boundary, including the Dirichlet boundary. However, since the test
function <code class="docutils literal"><span class="pre">v</span></code> vanishes on the Dirichlet boundary (as a result
specifying a <code class="docutils literal"><span class="pre">DirichletBC</span></code>), the integral will only include the
contribution from the Neumann boundary.</p>
</div>
</div>
<div class="section" id="setting-multiple-dirichlet-conditions">
<span id="ch-poisson0-multiple-dirichlet"></span><h2>Setting multiple Dirichlet conditions<a class="headerlink" href="#setting-multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>In the previous section, we used a single function <span class="math">\(u_{_\mathrm{D}}(x,y)\)</span> for
setting Dirichlet conditions at two parts of the boundary.  Often it
is more practical to use multiple functions, one for each subdomain of the
boundary. Let us return to the case from the section <a class="reference internal" href="#ch-poisson0-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a>
and redefine the problem in terms of two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}\begin{alignat*}{2}
    - \nabla^2 u &amp;= f \quad&amp;&amp;\mbox{in } \Omega, \\
    u &amp;= u_{_\mathrm{L}} &amp;&amp;\mbox{on } \Gamma_{_\mathrm{D}}^{^{\mathrm{L}}}, \\
    u &amp;= u_{_\mathrm{R}} &amp;&amp;\mbox{on } \Gamma_{_\mathrm{D}}^{^{\mathrm{R}}}, \\
    - {\partial u\over\partial n} &amp;= g &amp;&amp;\mbox{on } \Gamma_{_\mathrm{N}} {\thinspace .}
\end{alignat*}\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_{_\mathrm{D}}^{^{\mathrm{L}}}\)</span> is the left boundary <span class="math">\(x=0\)</span>, while
<span class="math">\(\Gamma_{_\mathrm{D}}^{^{\mathrm{R}}}\)</span> is the right boundary <span class="math">\(x=1\)</span>. We note that
<span class="math">\(u_{_\mathrm{L}} = 1 + 2y^2\)</span>, <span class="math">\(u_{_\mathrm{R}} = 2 + 2y^2\)</span>, and <span class="math">\(g=4y\)</span>.</p>
<p>For the boundary condition on <span class="math">\(\Gamma_{_\mathrm{D}}^{^{\mathrm{L}}}\)</span>, we define the
usual triple of an expression for the boundary value, a function
defining the location of the boundary, and a <code class="docutils literal"><span class="pre">DirichletBC</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary_L</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">bc_L</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">boundary_L</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary condition on <span class="math">\(\Gamma_{_\mathrm{D}}^{^{\mathrm{R}}}\)</span>, we write a
similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary_R</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">bc_R</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">boundary_R</span><span class="p">)</span>
</pre></div>
</div>
<p>We collect the two boundary conditions in a list which
we can pass to the <code class="docutils literal"><span class="pre">solve</span></code> function to compute the solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc_L</span><span class="p">,</span> <span class="n">bc_R</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that for boundary values that do not depend on <span class="math">\(x\)</span> or <span class="math">\(y\)</span>, we
might replace the <code class="docutils literal"><span class="pre">Expression</span></code> objects by <code class="docutils literal"><span class="pre">Constant</span></code> objects.</p>
</div>
<div class="section" id="defining-subdomains-for-different-materials">
<span id="ftut-possion-2d-2mat-impl"></span><h2>Defining subdomains for different materials<a class="headerlink" href="#defining-subdomains-for-different-materials" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><p id="index-3">Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kinds of problems are handled by
defining subdomains inside the domain. A simple example with two
materials (subdomains) in 2D will demonstrate the idea.</p>
<div class="figure" id="id1">
<span id="ftut-possion-2d-2mat-fig1"></span><a class="reference internal image-reference" href="_images/layered_medium_2.png"><img alt="_images/layered_medium_2.png" src="_images/layered_medium_2.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Medium with discontinuous material properties</em></span></p>
</div>
<p>Suppose we want to solve</p>
<div class="math" id="eq-ch-poisson0-2d-2mat-varcoeff2">
\[\tag{72}
\nabla\cdot \left\lbrack \kappa(x,y)\nabla u(x,y)\right\rbrack = 0,\]</div>
<p>in a domain <span class="math">\(\Omega\)</span> consisting of two subdomains where <span class="math">\(\kappa\)</span> takes on
a different value in each subdomain.
We take <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> and divide it into two equal
subdomains, as depicted in Figure <a class="reference internal" href="#ftut-possion-2d-2mat-fig1"><span class="std std-ref">Medium with discontinuous material properties</span></a>,</p>
<div class="math">
\[\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]{\thinspace .}\]</div>
<p>We define <span class="math">\(\kappa(x,y)=\kappa_0\)</span> in <span class="math">\(\Omega_0\)</span> and <span class="math">\(\kappa(x,y)=\kappa_1\)</span> in <span class="math">\(\Omega_1\)</span>,
where <span class="math">\(\kappa_0&gt;0\)</span> and <span class="math">\(\kappa_1&gt;0\)</span> are given constants.</p>
<p>Physically, this problem may be viewed as a model of heat conduction,
where the heat conduction in <span class="math">\(\Omega_1\)</span> is more efficient than in
<span class="math">\(\Omega_0\)</span>. An alternative interpretation is flow in porous media with
two geological layers, where the layers&#8217; ability to transport the
fluid differ.</p>
<div class="section" id="using-expressions-to-define-subdomains">
<h3>Using expressions to define subdomains<a class="headerlink" href="#using-expressions-to-define-subdomains" title="Permalink to this headline">¶</a></h3>
<p>The simplest way of implementing a variable coefficient <span class="math">\(\kappa\)</span> is to
define an <code class="docutils literal"><span class="pre">Expression</span></code> object where we return the appropriate <span class="math">\(\kappa\)</span>
value depending on the position in space. Since we need some testing
on the coordinates, the most straightforward approach is to define a
subclass of <code class="docutils literal"><span class="pre">Expression</span></code>, where we can use a full Python method
instead of just a C++ string formula for specifying a function.  The
method that defines the function is called <code class="docutils literal"><span class="pre">eval</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">K</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_k_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_0</span><span class="p">,</span> <span class="n">k_1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_1</span> <span class="o">=</span> <span class="n">k_0</span><span class="p">,</span> <span class="n">k_1</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Set value[0] to value at point x&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_1</span>

<span class="c1"># Initialize k</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">()</span>
<span class="n">k</span><span class="o">.</span><span class="n">set_k_values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">eval</span></code> method gives great flexibility in defining functions, but a
downside is that FEniCS will call <code class="docutils literal"><span class="pre">eval</span></code> in Python for each node <code class="docutils literal"><span class="pre">x</span></code>,
which is a slow process.</p>
<p>An alternative method is to use a C++ string expression as we have
seen before, which is much more efficient in FEniCS. This can be done
using inline if tests in C++:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="n">k_0</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">k_1</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;x[1] &lt;= 0.5 + tol ? k_0 : k_1&#39;</span><span class="p">,</span>
               <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">k_0</span><span class="o">=</span><span class="n">k_0</span><span class="p">,</span> <span class="n">k_1</span><span class="o">=</span><span class="n">k_1</span><span class="p">)</span>
</pre></div>
</div>
<p>This method of defining variable coefficients works if the subdomains
are simple shapes that can be expressed in terms of geometric
inequalities. However, for more complex subdomains, we will need to
use a more general technique, as we will see next.</p>
</div>
<div class="section" id="using-mesh-functions-to-define-subdomains">
<span id="index-4"></span><h3>Using mesh functions to define subdomains<a class="headerlink" href="#using-mesh-functions-to-define-subdomains" title="Permalink to this headline">¶</a></h3>
<p>We now address how to specify the subdomains <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>
using a more general technique. This technique involves the use of two
classes that are essential in FEniCS when working with subdomains:
<code class="docutils literal"><span class="pre">SubDomain</span></code> and <code class="docutils literal"><span class="pre">MeshFunction</span></code>. Consider the following definition of the
boundary <span class="math">\(x = 0\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>This boundary definition is actually a shortcut to the more general
FEniCS concept <code class="docutils literal"><span class="pre">SubDomain</span></code>. A <code class="docutils literal"><span class="pre">SubDomain</span></code> is a class which defines a
region in space (a subdomain) in terms of a member function <code class="docutils literal"><span class="pre">inside</span></code>
which returns <code class="docutils literal"><span class="pre">True</span></code> for points that belong to the subdomain and
<code class="docutils literal"><span class="pre">False</span></code> for points that don&#8217;t belong to the subdomain. Here is how to
specify the boundary <span class="math">\(x = 0\)</span> as a <code class="docutils literal"><span class="pre">SubDomain</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>We notice that the <code class="docutils literal"><span class="pre">inside</span></code> function of the class <code class="docutils literal"><span class="pre">Boundary</span></code> is
(almost) identical to the previous boundary definition in terms of the
<code class="docutils literal"><span class="pre">boundary</span></code> function. Technically, our class <code class="docutils literal"><span class="pre">Boundary</span></code> is a
<em>subclass</em> of the FEniCS class <code class="docutils literal"><span class="pre">SubDomain</span></code>.</p>
<p>We will use two <code class="docutils literal"><span class="pre">SubDomain</span></code> subclasses to define the two subdomains
<span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>

<span class="k">class</span> <span class="nc">Omega_0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">tol</span>

<span class="k">class</span> <span class="nc">Omega_1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Notice the use of <code class="docutils literal"><span class="pre">&lt;=</span></code> and <code class="docutils literal"><span class="pre">&gt;=</span></code> in both tests. FEniCS will call the
<code class="docutils literal"><span class="pre">inside</span></code> function for each vertex in a cell to determine whether or
not the cell belongs to a particular subdomain. For this reason, it is
important that the test holds for all vertices in cells aligned with
the boundary. In addition, we use a tolerance to make sure that
vertices on the internal boundary at <span class="math">\(y = 0.5\)</span> will belong to <em>both</em>
subdomains. This is a little counter-intuitive, but is necessary to
make the cells both above and below the internal boundary belong to
either <span class="math">\(\Omega_0\)</span> or <span class="math">\(\Omega_1\)</span>.</p>
<p>To define the variable coefficient <span class="math">\(\kappa\)</span>, we will use a powerful tool in
FEniCS called a <code class="docutils literal"><span class="pre">MeshFunction</span></code>. A <code class="docutils literal"><span class="pre">MeshFunction</span></code> is a discrete
function that can be evaluated at a set of so-called <em>mesh
entities</em>. A mesh entity in FEniCS is either a vertex, an edge, a
face, or a cell (triangle or tetrahedron). A <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells
is suitable to represent subdomains (materials), while a
<code class="docutils literal"><span class="pre">MeshFunction</span></code> over facets (edges or faces) is used to represent
pieces of external or internal boundaries. A <code class="docutils literal"><span class="pre">MeshFunction</span></code> over cells
can also be used to represent boundary markers for mesh refinement. A
FEniCS <code class="docutils literal"><span class="pre">MeshFunction</span></code> is parameterized both over its data type (like
integers or booleans) and its dimension (0 = vertex, 1 = edge
etc.). Special subclasses <code class="docutils literal"><span class="pre">VertexFunction</span></code>, <code class="docutils literal"><span class="pre">EdgeFunction</span></code> etc. are
provided for easy definition of a <code class="docutils literal"><span class="pre">MeshFunction</span></code> of a particular
dimension.</p>
<p>Since we need to define subdomains of <span class="math">\(\Omega\)</span> in the present example,
we make use of a <code class="docutils literal"><span class="pre">CellFunction</span></code>. The constructor
is fed with two arguments: 1) the type of value: <code class="docutils literal"><span class="pre">'int'</span></code> for integers,
<code class="docutils literal"><span class="pre">'size_t'</span></code> for non-negative (unsigned) integers, <code class="docutils literal"><span class="pre">'double'</span></code> for real
numbers, and <code class="docutils literal"><span class="pre">'bool'</span></code> for logical values; 2) a <code class="docutils literal"><span class="pre">Mesh</span></code> object.
Alternatively, the constructor can take just a filename and initialize
the <code class="docutils literal"><span class="pre">CellFunction</span></code> from data in a file.</p>
<p>We start with creating a <code class="docutils literal"><span class="pre">CellFunction</span></code> whose values are non-negative
integers (<code class="docutils literal"><span class="pre">'size_t'</span></code>) for numbering the subdomains:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we use the two subdomains to <em>mark</em> the cells belonging to each
subdomain:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span># Mark subdomains with numbers 0 and 1
subdomain0 = Omega_0()
subdomain1 = Omega_1()
subdomain0.mark(materials, 0)
subdomain1.mark(materials, 1)
</pre></div>
</div>
<p>This will set the values of the mesh function <code class="docutils literal"><span class="pre">materials</span></code> to <span class="math">\(0\)</span> on
each cell belonging to <span class="math">\(\Omega_0\)</span> and <span class="math">\(1\)</span> on all cells belonging to
<span class="math">\(\Omega_1\)</span>. Alternatively, we can use the following equivalent code to
mark the cells:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>materials.set_all(0)
subdomain1.mark(materials, 1)
</pre></div>
</div>
<p>To examine the values of the mesh function and see that we have indeed
defined our subdomains correctly, we can simply plot the mesh
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We may also wish to store the values of the mesh function for later
use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;materials.xml.gz&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">materials</span>
</pre></div>
</div>
<p>which can later be read back from file as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;materials.xml.gz&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">materials</span>
</pre></div>
</div>
<p>Now, to use the values of the mesh function <code class="docutils literal"><span class="pre">materials</span></code> to define the
variable coefficient <span class="math">\(\kappa\)</span>, we create a FEniCS <code class="docutils literal"><span class="pre">Expression</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">K</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">materials</span><span class="p">,</span> <span class="n">k_0</span><span class="p">,</span> <span class="n">k_1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="o">=</span> <span class="n">materials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_0</span> <span class="o">=</span> <span class="n">k_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_1</span> <span class="o">=</span> <span class="n">k_1</span>

<span class="k">def</span> <span class="nf">eval_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_1</span>

<span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="n">k_0</span><span class="p">,</span> <span class="n">k_1</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This is similar to the <code class="docutils literal"><span class="pre">Expression</span></code> subclass we defined above, but we
make use of the member function <code class="docutils literal"><span class="pre">eval_cell</span></code> in place of the regular
<code class="docutils literal"><span class="pre">eval</span></code> function. This version of the evaluation function has an
addition <code class="docutils literal"><span class="pre">cell</span></code> argument which we can use to check on which cell we are
currently evaluating the function.</p>
<p>Since we make use of geometric tests to define the two <code class="docutils literal"><span class="pre">SubDomains</span></code>
for <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>, the <code class="docutils literal"><span class="pre">MeshFunction</span></code> method may seem like
an unnecessary complication of the simple method using an
<code class="docutils literal"><span class="pre">Expression</span></code> with an if-test. However, in general the definition of
subdomains may be available as a <code class="docutils literal"><span class="pre">MeshFunction</span></code> (from a data file),
perhaps generated as part of the mesh generation process, and not as a
simple geometric test. In such cases the method demonstrated here is
the recommended way to define subdomains.</p>
</div>
<div class="section" id="vectorized-version-of-subdomain-definitions">
<span id="index-5"></span><h3>Vectorized version of subdomain definitions<a class="headerlink" href="#vectorized-version-of-subdomain-definitions" title="Permalink to this headline">¶</a></h3>
<p>To speed up this code, we can vectorize the expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">materials</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">materials</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># &quot;the rest&quot;</span>
<span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">subdomain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subdomains</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">subdomain</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

<span class="n">kappa_values</span> <span class="o">=</span> <span class="n">kappa</span>
<span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
<span class="n">help</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">kappa</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">kappa_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">help</span></code> array is required since <code class="docutils literal"><span class="pre">choose</span></code> cannot work with
<code class="docutils literal"><span class="pre">materials.array()</span></code> because this array has elements of
type <code class="docutils literal"><span class="pre">uint32</span></code>. We must therefore transform this array to an array
<code class="docutils literal"><span class="pre">help</span></code> with standard <code class="docutils literal"><span class="pre">int32</span></code> integers.</p>
</div>
<div class="section" id="using-c-code-snippets-to-define-subdomains">
<h3>Using C++ code snippets to define subdomains<a class="headerlink" href="#using-c-code-snippets-to-define-subdomains" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">SubDomain</span></code> and <code class="docutils literal"><span class="pre">Expression</span></code> Python classes are very convenient,
but their use leads to function calls from C++ to Python for each node
in the mesh. Since this involves a significant cost, we need to make
use of C++ code for large-scale computational problems.</p>
<p>Instead of writing the <code class="docutils literal"><span class="pre">SubDomain</span></code> subclass in Python, we may instead use
the <code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> tool in FEniCS to specify the subdomain in C++
code and thereby speed up our code. Consider
the definition of the classes <code class="docutils literal"><span class="pre">Omega_0</span></code> and <code class="docutils literal"><span class="pre">Omega_1</span></code> above in Python. The
key strings that define these subdomains can be expressed in C++ syntax
and fed to <code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span><span class="s1">&#39;x[1] &lt;= 0.5 + tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span><span class="s1">&#39;x[1] &gt;= 0.5 - tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, <code class="docutils literal"><span class="pre">subdomain0</span></code> and <code class="docutils literal"><span class="pre">subdomain1</span></code>, can be used
as ordinary <code class="docutils literal"><span class="pre">SubDomain</span></code> objects.</p>
<p>Compiled subdomain strings can be applied for specifying boundaries as
well:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">boundary_R</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span><span class="s1">&#39;on_boundary &amp;&amp; near(x[0], 1, tol)&#39;</span><span class="p">,</span>
                               <span class="n">tol</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to feed the C++ string (without parameters)
directly as the third argument to <code class="docutils literal"><span class="pre">DirichletBC</span></code> without explicitly
constructing a <code class="docutils literal"><span class="pre">CompiledSubDomain</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;on_boundary &amp;&amp; near(x[0], 1, tol)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Python <code class="docutils literal"><span class="pre">Expression</span></code> classes may also be redefined using C++ for more
efficient code. Consider again the definition of the class <code class="docutils literal"><span class="pre">K</span></code> above
for the variable coefficient <span class="math">\(\kappa = \kappa(x)\)</span>. This may be redefined using a
C++ code snippet and the keyword <code class="docutils literal"><span class="pre">cppcode</span></code> to the regular FEniCS
<code class="docutils literal"><span class="pre">Expression</span></code> class:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>cppcode = &quot;&quot;&quot;
class K : public Expression
{
public:

  void eval(Array&lt;double&gt;&amp; values,
            const Array&lt;double&gt;&amp; x,
            const ufc::cell&amp; cell) const
  {
    if ((*materials)[cell.index] == 0)
      values[0] = k_0;
    else
      values[0] = k_1;
  }

  std::shared_ptr&lt;MeshFunction&lt;std::size_t&gt;&gt; materials;
  double k_0;
  double k_1;

};
&quot;&quot;&quot;

k = Expression(cppcode=cppcode, degree=0)
k.materials = materials
k.k_0 = k_0
k.k_1 = k_1
</pre></div>
</div>
</div>
<div class="section" id="exercise-3-efficiency-of-python-vs-c-expressions">
<span id="ch-poisson0-exer-eff-expression"></span><h3>Exercise 3: Efficiency of Python vs C++ expressions<a class="headerlink" href="#exercise-3-efficiency-of-python-vs-c-expressions" title="Permalink to this headline">¶</a></h3>
<p>Consider a cube mesh with <span class="math">\(N\)</span> cells in each spatial direction.
We want to define a <code class="docutils literal"><span class="pre">Function</span></code> on this mesh where the
values are given by the mathematical function <span class="math">\(f(x,y,z)=a\sin(bxyz)\)</span>,
where <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are two parameters. Write a <code class="docutils literal"><span class="pre">class</span> <span class="pre">SineXYZ</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SineXYZ</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Create an alternative <code class="docutils literal"><span class="pre">Expression</span></code> based on giving the formula for <span class="math">\(f(x,y,z)\)</span>
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using <code class="docutils literal"><span class="pre">time.clock()</span></code> to measure the CPU time).</p>
<p>The <code class="docutils literal"><span class="pre">sin</span></code> function used in class <code class="docutils literal"><span class="pre">SineXYZ.eval</span></code> can mean many things.
This is an advanced FEniCS function if imported from <code class="docutils literal"><span class="pre">fenics</span></code>.
Much more efficient versions for sin of numbers are found in <code class="docutils literal"><span class="pre">math.sin</span></code>
and <code class="docutils literal"><span class="pre">numpy.sin</span></code>. Compare the use <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">fenics</span></code>, <code class="docutils literal"><span class="pre">math</span></code>, <code class="docutils literal"><span class="pre">numpy</span></code>, and
<code class="docutils literal"><span class="pre">sympy</span></code> (note that <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">sympy</span></code> is very slow).</p>
<p><strong>Solution.</strong>
Here is an appropriate program:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill a Function with sin(x*y*z) values.&quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Python&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;fenics.sin&#39;</span><span class="p">):</span>
            <span class="c1"># Need sin as local variable in this function</span>
            <span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;math.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;numpy.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;sympy.sin&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;method=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;sin:&#39;</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">sin</span><span class="p">))</span>

        <span class="k">class</span> <span class="nc">SineXYZ</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

            <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">SineXYZ</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;a*sin(b*x[0]*x[1]*x[2])&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_fenics</span>  <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;Python-fenics.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_math</span>    <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;Python-math.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_numpy</span>   <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;Python-numpy.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_py_sympy</span>   <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;Python-sympy.sin&#39;</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">cpu_cpp</span> <span class="o">=</span> <span class="n">make_sine_Function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;C++&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;DOFs: </span><span class="si">%d</span><span class="s2"></span>
<span class="s2">Python:</span>
<span class="s2">fenics.sin: </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">math.sin:   </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">numpy.sin:  </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">sympy.sin:  </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">C++:        </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">Speed-up:   math: </span><span class="si">%.2f</span><span class="s2">  sympy: </span><span class="si">%.2f</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
           <span class="n">cpu_py_fenics</span><span class="p">,</span> <span class="n">cpu_py_math</span><span class="p">,</span>
           <span class="n">cpu_py_numpy</span><span class="p">,</span> <span class="n">cpu_py_sympy</span><span class="p">,</span>
           <span class="n">cpu_cpp</span><span class="p">,</span>
           <span class="n">cpu_py_math</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">cpu_cpp</span><span class="p">),</span>
           <span class="n">cpu_py_sympy</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">cpu_cpp</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">profile</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">cProfile</span>
    <span class="n">prof</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
    <span class="n">prof</span><span class="o">.</span><span class="n">runcall</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">prof</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s2">&quot;tmp.profile&quot;</span><span class="p">)</span>
    <span class="c1"># http://docs.python.org/2/library/profile.html</span>

<span class="n">main</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="c1">#profile()</span>
</pre></div>
</div>
<p>Running the program shows that <code class="docutils literal"><span class="pre">sin</span></code> from <code class="docutils literal"><span class="pre">math</span></code> is the most efficient choice,
but a string C++ runs 40 times faster. Note that <code class="docutils literal"><span class="pre">fenics.sin</span></code>, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the <code class="docutils literal"><span class="pre">sin</span></code>
functions for numbers in <code class="docutils literal"><span class="pre">math</span></code> and <code class="docutils literal"><span class="pre">numpy</span></code>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Expression_efficiency</span></code>.</p>
</div>
</div>
<div class="section" id="setting-multiple-dirichlet-neumann-and-robin-conditions">
<span id="ch-poisson0-multi-bc"></span><h2>Setting multiple Dirichlet, Neumann, and Robin conditions<a class="headerlink" href="#setting-multiple-dirichlet-neumann-and-robin-conditions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-6"></span><span class="target" id="index-7"></span><span class="target" id="index-8"></span><p id="index-9">Consider again the model problem from the section <a class="reference internal" href="#ch-poisson0-multiple-dirichlet"><span class="std std-ref">Setting multiple Dirichlet conditions</span></a> where we had both Dirichlet and
Neumann conditions. The term <code class="docutils literal"><span class="pre">g*v*ds</span></code> in the expression for <code class="docutils literal"><span class="pre">L</span></code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all <em>exterior facets</em>. This means that the
boundary integral extends also over the part of the boundary <span class="math">\(\Gamma_{_\mathrm{D}}\)</span>
where we have Dirichlet conditions. However, only the integral over
<span class="math">\(\Gamma_{_\mathrm{N}}\)</span> will contribute since <span class="math">\(v = 0\)</span> on <span class="math">\(\Gamma_{_\mathrm{D}}\)</span> (which happens when we
apply the Dirichlet boundary condition).</p>
<p>From an efficiency point of view, we would ideally like to compute the
integral <code class="docutils literal"><span class="pre">g*v*ds</span></code> only over the part of the boundary where we actually
have Neumann conditions. More importantly, in other problems one may
have different Neumann conditions or other conditions like the Robin
type condition. This can be handled in FEniCS by defining a
<code class="docutils literal"><span class="pre">MeshFunction</span></code> that marks different portions of the boundary. The same
technique can also be used to treat multiple Dirichlet conditions.</p>
<div class="section" id="three-types-of-boundary-conditions">
<h3>Three types of boundary conditions<a class="headerlink" href="#three-types-of-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin. Dirichlet conditions apply to some
parts <span class="math">\(\Gamma_{_\mathrm{D}}^0\)</span>, <span class="math">\(\Gamma_{_\mathrm{D}}^1\)</span>, <span class="math">\(...\)</span>, of the boundary:</p>
<div class="math">
\[u_{_\mathrm{D}}^0\hbox{ on }\Gamma_{_\mathrm{D}}^0,\quad
u_{_\mathrm{D}}^1\hbox{ on }\Gamma_{_\mathrm{D}}^1, \quad \ldots\]</div>
<p>where <span class="math">\(u_{_\mathrm{D}}^i\)</span> are prescribed functions, <span class="math">\(i=0,1,\ldots\)</span>
On other parts, <span class="math">\(\Gamma_{_\mathrm{N}}^0\)</span>, <span class="math">\(\Gamma_{_\mathrm{N}}^1\)</span>, and so on, we have
Neumann conditions:</p>
<div class="math">
\[-\kappa{\partial u\over\partial n} = g_{0}\hbox{ on }\Gamma_{_\mathrm{N}}^0,\quad
-\kappa{\partial u\over\partial n} = g_{1}\hbox{ on }\Gamma_{_\mathrm{N}}^1,\quad \ldots\]</div>
<p>Finally, we have <em>Robin conditions</em>:</p>
<div class="math" id="eq-ch-poisson0-multi-bc-robin">
\[\tag{73}
-\kappa{\partial u\over\partial n} = r(u-s),\]</div>
<p>where <span class="math">\(r\)</span> and <span class="math">\(s\)</span> are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton&#8217;s cooling law. In that case, <span class="math">\(r\)</span> is a heat
transfer coefficient, and <span class="math">\(s\)</span> is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts <span class="math">\(\Gamma_{_\mathrm{R}}^0\)</span>, <span class="math">\(\Gamma_{_\mathrm{R}}^1\)</span>, and so forth:</p>
<div class="math">
\[-\kappa{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\Gamma_{_\mathrm{R}}^0,\quad
-\kappa{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\Gamma_{_\mathrm{R}}^1,\quad \ldots\]</div>
</div>
<div class="section" id="pde-problem-7">
<span id="index-10"></span><h3>PDE problem<a class="headerlink" href="#pde-problem-7" title="Permalink to this headline">¶</a></h3>
<p>With the notation above, the model problem to be solved with multiple
Dirichlet, Neumann, and Robin conditions can be formulated as follows:</p>
<div class="math" id="eq-ch-poisson0-2d-dn3">
\[\tag{74}
-\nabla\cdot(\kappa\nabla u) = -f, \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-ch-poisson0-2d-dn3-bcd">
\[\tag{75}
u = u_{_\mathrm{D}}^i \mbox{ on } \Gamma_{_\mathrm{D}}^i,\quad i=0,1,\ldots\]</div>
<div class="math" id="eq-ch-poisson0-2d-dn3-bcn">
\[\tag{76}
-\kappa{\partial u\over\partial n} = g_i \mbox{ on } \Gamma_{_\mathrm{N}}^i,\quad
    i=0,1,\ldots\]</div>
<div class="math" id="eq-ch-poisson0-2d-dn3-bcr">
\[\tag{77}
-\kappa{\partial u\over\partial n} = r_i(u-s_i) \mbox{ on } \Gamma_{_\mathrm{R}}^i,\quad
    i=0,1,\ldots\]</div>
</div>
<div class="section" id="variational-formulation-7">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-7" title="Permalink to this headline">¶</a></h3>
<p>As usual, we multiply by a test function <span class="math">\(v\)</span> and integrate by parts:</p>
<div class="math">
\[ -\int_\Omega \nabla\cdot(\kappa\nabla u) v {\, \mathrm{d}x}
= \int_\Omega \kappa\nabla u\cdot \nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega}\kappa\frac{\partial u}{\partial n}v {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>On the Dirichlet part of the boundary (<span class="math">\(\Gamma_{_\mathrm{D}}^i\)</span>), the boundary integral
vanishes since <span class="math">\(v = 0\)</span>. On the remaining part of the boundary, we
split the boundary integral into contributions from the Neumann part
(<span class="math">\(\Gamma_{_\mathrm{N}}^i\)</span>) and Robin part (<span class="math">\(\Gamma_{_\mathrm{R}}^i\)</span>). Inserting the boundary conditions,
we obtain</p>
<div class="math">
\[\begin{split}\begin{align*}
-\int_{\partial\Omega} \kappa\frac{\partial u}{\partial n}v {\, \mathrm{d}s}
&amp;=
-\sum_i\int_{\Gamma_{_\mathrm{N}}^i} \kappa\frac{\partial u}{\partial n} {\, \mathrm{d}s}
-\sum_i\int_{\Gamma_{_\mathrm{R}}^i} \kappa\frac{\partial u}{\partial n} {\, \mathrm{d}s}\\
&amp;=
\sum_i\int_{\Gamma_{_\mathrm{N}}^i}g_i {\, \mathrm{d}s} +
\sum_i\int_{\Gamma_{_\mathrm{R}}^i}r_i(u-s_i) {\, \mathrm{d}s}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>We thus obtain the following variational problem:</p>
<div class="math" id="eq-ch-poisson0-multi-bc-varform">
\[\tag{78}
F = \int_{\Omega} \kappa\nabla u\cdot \nabla v {\, \mathrm{d}x} +
    \sum_i\int_{\Gamma_{_\mathrm{N}}^i} g_iv {\, \mathrm{d}s} +
    \sum_i\int_{\Gamma_{_\mathrm{R}}^i}r_i(u-s_i)v {\, \mathrm{d}s}
    - \int_{\Omega} fv {\, \mathrm{d}x} =0{\thinspace .}\]</div>
<p>We have been used to writing this variational formulation in the
standard notation <span class="math">\(a(u,v)=L(v)\)</span>, which requires that we identify all
integrals with <em>both</em> <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, and collect these in <span class="math">\(a(u,v)\)</span>,
while the remaining integrals with <span class="math">\(v\)</span> and not <span class="math">\(u\)</span> go into <span class="math">\(L(v)\)</span>. The
integrals from the Robin condition must for this reason be split in
two parts:</p>
<div class="math">
\[\int_{\Gamma_{_\mathrm{R}}^i}r_i(u-s_i)v {\, \mathrm{d}s}
= \int_{\Gamma_{_\mathrm{R}}^i} r_iuv {\, \mathrm{d}s} - \int_{\Gamma_{_\mathrm{R}}^i}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>We then have</p>
<div class="math" id="eq-ch-poisson0-2d-dn3-var-a">
\[\tag{79}
a(u, v) = \int_{\Omega} \kappa\nabla u\cdot \nabla v {\, \mathrm{d}x}
    + \sum_i\int_{\Gamma_{_\mathrm{R}}^i}r_iuv {\, \mathrm{d}s},\]</div>
<div class="math" id="eq-ch-poisson0-2d-dn3-var-l">
\[\tag{80}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \sum_i\int_{\Gamma_{_\mathrm{N}}^i} g_i v {\, \mathrm{d}s} + \sum_i\int_{\Gamma_{_\mathrm{R}}^i}r_is_iv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p>Alternatively, we may keep the formulation
<a class="reference internal" href="#eq-ch-poisson0-multi-bc-varform"><span class="std std-ref">(78)</span></a> and either solve the variational
problem as a nonlinear problem (<code class="docutils literal"><span class="pre">F</span> <span class="pre">==</span> <span class="pre">0</span></code>) in FEniCS or use the FEniCS
functions <code class="docutils literal"><span class="pre">lhs</span></code> and <code class="docutils literal"><span class="pre">rhs</span></code> to extract the bilinear and linear parts of
<code class="docutils literal"><span class="pre">F</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that if we choose the solve this linear problem as a nonlinear
problem, the Newton iteration will converge in a single iteration.</p>
</div>
<div class="section" id="fenics-implementation-13">
<h3>FEniCS implementation<a class="headerlink" href="#fenics-implementation-13" title="Permalink to this headline">¶</a></h3>
<p>Let us examine how to extend our Poisson solver to handle general
combinations of Dirichlet, Neumann, and Robin boundary conditions.
Compared to our previous code, we must consider the following
extensions:</p>
<blockquote>
<div><ul class="simple">
<li>Defining markers for the different parts of the boundary.</li>
<li>Splitting the boundary integral into parts using the markers.</li>
</ul>
</div></blockquote>
<p>A general approach to the first task is to mark each of the desired
boundary parts with markers 0, 1, 2, and so forth. Here we aim at the
four sides of the unit square, marked with 0 (<span class="math">\(x=0\)</span>), 1 (<span class="math">\(x=1\)</span>), 2
(<span class="math">\(y=0\)</span>), and 3 (<span class="math">\(y=1\)</span>).  The markers will be defined using a
<code class="docutils literal"><span class="pre">MeshFunction</span></code>, but contrary to the section <a class="reference internal" href="#ftut-possion-2d-2mat-impl"><span class="std std-ref">Defining subdomains for different materials</span></a>, this is not a function over cells, but
a function over the facets of the mesh. We use a <code class="docutils literal"><span class="pre">FacetFunction</span></code> for
this purpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">boundary_markers</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#ftut-possion-2d-2mat-impl"><span class="std std-ref">Defining subdomains for different materials</span></a> we use a subclass of
<code class="docutils literal"><span class="pre">SubDomain</span></code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the <span class="math">\(x=0\)</span> boundary can be marked by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BoundaryX0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">bx0</span> <span class="o">=</span> <span class="n">BoundaryX0</span><span class="p">()</span>
<span class="n">bx0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_markers</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we make the classes <code class="docutils literal"><span class="pre">BoundaryX1</span></code> for the <span class="math">\(x=1\)</span> boundary,
<code class="docutils literal"><span class="pre">BoundaryY0</span></code> for the <span class="math">\(y=0\)</span> boundary, and <code class="docutils literal"><span class="pre">BoundaryY1</span></code> for the <span class="math">\(y=1\)</span>
boundary, and mark these as subdomains 1, 2, and 3, respectively.</p>
<p>For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>boundary_conditions = {0: {&#39;Dirichlet&#39;: u_D},
                       1: {&#39;Robin&#39;:     (r, s)},
                       2: {&#39;Neumann&#39;:   g},
                       3: {&#39;Neumann&#39;,   0}}
</pre></div>
</div>
<p>specifies</p>
<blockquote>
<div><ul class="simple">
<li>a Dirichlet condition <span class="math">\(u = u_{_\mathrm{D}}\)</span> for <span class="math">\(x = 0\)</span>;</li>
<li>a Robin condition <span class="math">\(-\kappa\partial_n u = r(u-s)\)</span> for <span class="math">\(x = 1\)</span>;</li>
<li>a Neumann condition <span class="math">\(-\kappa\partial_n u = g\)</span> for <span class="math">\(y = 0\)</span>;</li>
<li>a Neumann condition <span class="math">\(-\kappa\partial_n u = 0\)</span> for <span class="math">\(y = 1\)</span>.</li>
</ul>
</div></blockquote>
<p>As explained in the section <a class="reference internal" href="#ch-poisson0-multiple-dirichlet"><span class="std std-ref">Setting multiple Dirichlet conditions</span></a>, multiple
Dirichlet conditions must be collected in a list of <code class="docutils literal"><span class="pre">DirichletBC</span></code>
objects. Based on the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data structure above, we
can construct this list by the following code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;Dirichlet&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Dirichlet&#39;</span><span class="p">],</span>
                         <span class="n">boundary_markers</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>A new aspect of the variational problem is the two distinct
boundary integrals over <span class="math">\(\Gamma_{_\mathrm{N}}^i\)</span> and <span class="math">\(\Gamma_{_\mathrm{R}}^i\)</span>.
Having a mesh function over exterior cell facets (our
<code class="docutils literal"><span class="pre">boundary_markers</span></code> object), where subdomains (boundary parts) are
numbered as <span class="math">\(0,1,2,\ldots\)</span>, the special symbol <code class="docutils literal"><span class="pre">ds(0)</span></code>
implies integration over subdomain (part) 0, <code class="docutils literal"><span class="pre">ds(1)</span></code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code class="docutils literal"><span class="pre">ds</span></code>-type objects generalizes to volume
integrals too: <code class="docutils literal"><span class="pre">dx(0)</span></code>, <code class="docutils literal"><span class="pre">dx(1)</span></code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside <span class="math">\(\Omega\)</span>.</p>
<p>To express integrals over the boundary parts using <code class="docutils literal"><span class="pre">ds(i)</span></code>, we must
first redefine the measure <code class="docutils literal"><span class="pre">ds</span></code> in terms of our boundary markers:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundary_markers</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, if we want integration over different parts of the domain,
we redefine <code class="docutils literal"><span class="pre">dx</span></code> as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domain_markers</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">domain_markers</span></code> is a <code class="docutils literal"><span class="pre">CellFunction</span></code> defining subdomains in <span class="math">\(\Omega\)</span>.</p>
<p>Suppose we have a Robin condition with values <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code> on subdomain
<code class="docutils literal"><span class="pre">R</span></code>, a Neumann condition with value <code class="docutils literal"><span class="pre">g</span></code> on subdomain <code class="docutils literal"><span class="pre">N</span></code>. The
variational form can then be written</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">kappa</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>In our case, things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code class="docutils literal"><span class="pre">boundary_conditions</span></code> data structure. We can collect
all Neumann conditions by the following code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">integrals_N</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;Neumann&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Neumann&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Neumann&#39;</span><span class="p">]</span>
            <span class="n">integrals_N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>Applying <code class="docutils literal"><span class="pre">sum(integrals_N)</span></code> will apply the <code class="docutils literal"><span class="pre">+</span></code> operator to
the variational forms in the <code class="docutils literal"><span class="pre">integrals_N</span></code> list and result
in the integrals we need for the right-hand side <code class="docutils literal"><span class="pre">L</span></code> of the
variational form.</p>
<p>The integrals in the Robin condition can similarly be collected
in lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">integrals_R_a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">integrals_R_L</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">integrals_R_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">integrals_R_L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>We are now in a position to define the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> expressions
in the variational formulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">kappa</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">integrals_R_a</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">integrals_N</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">integrals_R_L</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="index-11"></span><p id="index-12">Alternatively, we may use the FEniCS functions <code class="docutils literal"><span class="pre">lhs</span></code> and <code class="docutils literal"><span class="pre">rhs</span></code> as
mentioned above to simplify the extraction of terms for the Robin
integrals:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">integrals_R</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;Robin&#39;</span> <span class="ow">in</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Robin&#39;</span><span class="p">]</span>
        <span class="n">integrals_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">kappa</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">integrals_R</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">integrals_N</span><span class="p">)</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>This time we can more naturally define the integrals from the
Robin condition as <code class="docutils literal"><span class="pre">r*(u</span> <span class="pre">-</span> <span class="pre">s)*v*ds(i)</span></code>:</p>
<p>The complete code for this example can be found in the function
<code class="docutils literal"><span class="pre">solver_bc</span></code> in the program <code class="docutils literal"><span class="pre">ft11_poisson_bcs.py</span></code>.</p>
</div>
<div class="section" id="test-problem-4">
<h3>Test problem<a class="headerlink" href="#test-problem-4" title="Permalink to this headline">¶</a></h3>
<p>We will use the same exact solution <span class="math">\({u_{\small\mbox{e}}}=1+x^2+2y^2\)</span> as in the chapter <a class="reference internal" href="._ftut1003.html#ch-fundamentals"><span class="std std-ref">Fundamentals: Solving the Poisson equation</span></a>, and thus take <span class="math">\(\kappa=1\)</span> and <span class="math">\(f=-6\)</span>. Our domain
is the unit square, and we assign Dirichlet conditions at <span class="math">\(x=0\)</span> and
<span class="math">\(x=1\)</span>, a Neumann condition at <span class="math">\(y=1\)</span>, and a Robin condition at
<span class="math">\(y=0\)</span>. With the given <span class="math">\({u_{\small\mbox{e}}}\)</span>, we realize that the Neumann condition is
<span class="math">\(-\partial u / \partial n = - \partial u / \partial y = 4y = 4\)</span>, while
the Robin condition can be selected in many ways. Since <span class="math">\(\partial
u/\partial n=-\partial u/\partial y=0\)</span> at <span class="math">\(y=0\)</span>, we can select <span class="math">\(s=u\)</span>
and specify <span class="math">\(r \neq 0\)</span> arbitrarily in the Robin condition. We will set
<span class="math">\(r = 1000\)</span> and <span class="math">\(s = u\)</span>.</p>
<p>The boundary parts are thus <span class="math">\(\Gamma_{_\mathrm{D}}^0\)</span>: <span class="math">\(x=0\)</span>, <span class="math">\(\Gamma_{_\mathrm{D}}^1\)</span>: <span class="math">\(x=1\)</span>,
<span class="math">\(\Gamma_{_\mathrm{R}}^0\)</span>: <span class="math">\(y=0\)</span>, and <span class="math">\(\Gamma_{_\mathrm{N}}^0\)</span>: <span class="math">\(y=1\)</span>.</p>
<p>When implementing this test problem, and especially other test
problems with more complicated expressions, it is advantageous to use
symbolic computing. Below we define the exact solution as a <code class="docutils literal"><span class="pre">sympy</span></code>
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can be fed into <code class="docutils literal"><span class="pre">Expression</span></code> objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define manufactured solution in sympy and derive f, g, etc.</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x[0] x[1]&#39;</span><span class="p">)</span>             <span class="c1"># needed by UFL</span>
<span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>                       <span class="c1"># exact solution</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">u</span>                                     <span class="c1"># exact solution</span>
<span class="n">u_00</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                         <span class="c1"># restrict to x = 0</span>
<span class="n">u_01</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>                         <span class="c1"># restrict to x = 1</span>
<span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># -Laplace(u)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>                         <span class="c1"># simplify f</span>
<span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>              <span class="c1"># compute g = -du/dn</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1000</span>                                    <span class="c1"># Robin data, arbitrary</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">u</span>                                       <span class="c1"># Robin data, u = s</span>

<span class="c1"># Collect variables</span>
<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

<span class="c1"># Turn into C/C++ code strings</span>
<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">ccode</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>

<span class="c1"># Turn into FEniCS Expression</span>
<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">Expression</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>

<span class="c1"># Extract variables</span>
<span class="n">u_e</span><span class="p">,</span> <span class="n">u_00</span><span class="p">,</span> <span class="n">u_01</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">variables</span>

<span class="c1"># Define boundary conditions</span>
<span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_00</span><span class="p">},</span>   <span class="c1"># x=0</span>
                       <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Dirichlet&#39;</span><span class="p">:</span> <span class="n">u_01</span><span class="p">},</span>   <span class="c1"># x=1</span>
                       <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Robin&#39;</span><span class="p">:</span>     <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)},</span> <span class="c1"># y=0</span>
                       <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Neumann&#39;</span><span class="p">:</span>   <span class="n">g</span><span class="p">}}</span>      <span class="c1"># y=1</span>
</pre></div>
</div>
<p>This simple test problem is turned into a real unit test for different
function spaces in the function <code class="docutils literal"><span class="pre">test_solver_bc</span></code>.</p>
</div>
<div class="section" id="debugging-boundary-conditions">
<h3>Debugging boundary conditions<a class="headerlink" href="#debugging-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code class="docutils literal"><span class="pre">SubDomain.inside</span></code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
(<span class="math">\(\mathsf{P}_1\)</span>) elements, add the corresponding vertex coordinate to the
output.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="c1"># Print all vertices that belong to the boundary parts</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">bx0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is on x = 0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bx1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is on x = 1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by0</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is on y = 0&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by1</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is on y = 1&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Print the Dirichlet conditions</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Number of Dirichlet conditions:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># P1 elements</span>
        <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bcs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Dirichlet condition </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">boundary_values</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">boundary_values</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;   dof </span><span class="si">%2d</span><span class="s1">: u=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">boundary_values</span><span class="p">[</span><span class="n">dof</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;    at point </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generating-meshes-with-subdomains">
<h2>Generating meshes with subdomains<a class="headerlink" href="#generating-meshes-with-subdomains" title="Permalink to this headline">¶</a></h2>
<p>So far, we have worked mostly with simple meshes (the unit square) and
defined boundaries and subdomains in terms of simple geometric tests
like <span class="math">\(x = 0\)</span> or <span class="math">\(y \leq 0.5\)</span>. For more complex geometries, it is not
realistic to specify boundaries and subdomains in this way. Instead,
the boundaries and subdomains must be defined as part of the mesh
generation process. We will now look at how to use the FEniCS mesh
generation tool <code class="docutils literal"><span class="pre">mshr</span></code> to generate meshes and define subdomains.</p>
<div class="section" id="pde-problem-8">
<h3>PDE problem<a class="headerlink" href="#pde-problem-8" title="Permalink to this headline">¶</a></h3>
<p>We will again solve the Poisson equation, but this time for a
different application. Consider an iron cylinder with copper wires
wound around the cylinder as in Figure
<a class="reference internal" href="#ftut1-fig-magnetostatics-geometry"><span class="std std-ref">Cross-section of an iron cylinder with copper wires wound around the cylinder, here with  \( n = 8 \)  windings. The inner circles are cross-sections of the copper wire coming up (&#8220;north&#8221;) and the outer circles are cross-sections of the copper wire going down into the plane (&#8220;south&#8221;)</span></a>. Through the copper wires a
static current <span class="math">\(J = 1\,\mathrm{A}\)</span> is flowing and we want to compute
the magnetic field <span class="math">\(B\)</span> in the iron cylinder, the copper wires, and the
surrounding vacuum.</p>
<div class="figure" id="id2">
<span id="ftut1-fig-magnetostatics-geometry"></span><a class="reference internal image-reference" href="_images/magnetostatics_geometry.png"><img alt="_images/magnetostatics_geometry.png" src="_images/magnetostatics_geometry.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Cross-section of an iron cylinder with copper wires wound around the cylinder, here with  \( n = 8 \)  windings. The inner circles are cross-sections of the copper wire coming up (&#8220;north&#8221;) and the outer circles are cross-sections of the copper wire going down into the plane (&#8220;south&#8221;)</em></span></p>
</div>
<p>First, we simplify the problem to a 2D problem. We can do this by
assuming that the cylinder extends far along the <span class="math">\(z\)</span>-axis and as a
consequence the field is virtually independent of the
<span class="math">\(z\)</span>-coordinate. Next, we consider Maxwell&#8217;s equation to derive a
Poisson equation for the magnetic field (or rather its potential):</p>
<div class="math" id="eq-auto22">
\[\tag{81}
\nabla\cdot  D = \varrho,\]</div>
<div class="math" id="eq-auto23">
\[\tag{82}
\nabla\cdot  B = 0,\]</div>
<div class="math" id="eq-auto24">
\[\tag{83}
\nabla\times E = -\frac{\partial B}{\partial t},\]</div>
<div class="math" id="eq-auto25">
\[\tag{84}
\nabla\times H = \frac{\partial D}{\partial t} + J.\]</div>
<p>Here, <span class="math">\(D\)</span> is the displacement field, <span class="math">\(B\)</span> is the magnetic
field, <span class="math">\(E\)</span> is the electric field, and <span class="math">\(H\)</span> is the magnetizing field. In
addition to Maxwell&#8217;s equations, we also need a constitutive relation
between <span class="math">\(B\)</span> and <span class="math">\(H\)</span>,</p>
<div class="math" id="eq-auto26">
\[\tag{85}
B = \mu H,\]</div>
<p>which holds for an isotropic linear magnetic medium. Here, <span class="math">\(\mu\)</span> is the
magnetic permeability of the material. Now, since <span class="math">\(B\)</span> is solenoidal
(divergence free) according to Maxwell&#8217;s equations, we know that <span class="math">\(B\)</span>
must be the curl of some vector field <span class="math">\(A\)</span>. This field is called the
magnetic vector potential. Since <span class="math">\(\partial D/\partial t = 0\)</span>, it
follows that</p>
<div class="math" id="eq-auto27">
\[\tag{86}
J = \nabla \times H
        = \nabla \times (\mu^{-1} B)
        = \nabla \times (\mu^{-1} \nabla \times A)
        = -\nabla \cdot (\mu^{-1} \nabla A).\]</div>
<p>In the last step, we have expanded the second derivatives and used the
gauge freedom of <span class="math">\(A\)</span> to simplify the equations to a simple
vector-valued Poisson problem for the magnetic vector potential; if <span class="math">\(B
= \nabla \times A\)</span>, then <span class="math">\(B = \nabla \times (A + \nabla \psi)\)</span> for any
scalar field <span class="math">\(\psi\)</span> (the gauge function). For the current problem, we
thus need to solve the following 2D Poisson problem for the
<span class="math">\(z\)</span>-component <span class="math">\(A_z\)</span> of the magnetic vector potential:</p>
<div class="math" id="eq-auto28">
\[\tag{87}
- \nabla \cdot (\mu^{-1} \nabla A_z) = J_z \quad \text{in } \mathbb{R}^2,\]</div>
<div class="math" id="eq-auto29">
\[\tag{88}
\lim_{|(x, y)| \rightarrow \infty} A_z = 0.\]</div>
<p>Since we cannot solve this problem on an infinite domain, we will
truncate the domain using a large disk and set <span class="math">\(A_z = 0\)</span> on the
boundary. The current <span class="math">\(J_z\)</span> is set to <span class="math">\(+1\,\mathrm{A}\)</span> in the interior
set of circles (copper wire cross-sections) and to <span class="math">\(-1\,\mathrm{A}\)</span> in
the exterior set of circles in Figure <a class="reference internal" href="#ftut1-fig-magnetostatics-geometry"><span class="std std-ref">Cross-section of an iron cylinder with copper wires wound around the cylinder, here with  \( n = 8 \)  windings. The inner circles are cross-sections of the copper wire coming up (&#8220;north&#8221;) and the outer circles are cross-sections of the copper wire going down into the plane (&#8220;south&#8221;)</span></a>.</p>
<p>Once the magnetic vector potential has been computed, we can
compute the magnetic field <span class="math">\(B = B(x, y)\)</span> by</p>
<div class="math" id="eq-auto30">
\[\tag{89}
B(x, y) =
      \left(\frac{\partial A_z}{\partial y},
           -\frac{\partial A_z}{\partial x}\right).\]</div>
</div>
<div class="section" id="variational-formulation-8">
<h3>Variational formulation<a class="headerlink" href="#variational-formulation-8" title="Permalink to this headline">¶</a></h3>
<p>The variational problem is derived as before by multiplying the PDE
with a test function <span class="math">\(v\)</span> and integrating by parts. Since the boundary
integral vanishes due to the Dirichlet condition, we obtain</p>
<div class="math" id="eq-auto31">
\[\tag{90}
\int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v {\, \mathrm{d}x}
      = \int_{\Omega} J_z v {\, \mathrm{d}x},\]</div>
<p>or, in other words, <span class="math">\(a(A_z, v) = L(v)\)</span> with</p>
<div class="math" id="eq-auto32">
\[\tag{91}
a(A_z, v) = \int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto33">
\[\tag{92}
L(v) = \int_{\Omega} J_z v {\, \mathrm{d}x}.\]</div>
</div>
<div class="section" id="fenics-implementation-14">
<h3>FEniCS implementation<a class="headerlink" href="#fenics-implementation-14" title="Permalink to this headline">¶</a></h3>
<p>The first step is to generate a mesh for the geometry described in
Figure <a class="reference internal" href="#ftut1-fig-magnetostatics-geometry"><span class="std std-ref">Cross-section of an iron cylinder with copper wires wound around the cylinder, here with  \( n = 8 \)  windings. The inner circles are cross-sections of the copper wire coming up (&#8220;north&#8221;) and the outer circles are cross-sections of the copper wire going down into the plane (&#8220;south&#8221;)</span></a>. We let <span class="math">\(a\)</span> and <span class="math">\(b\)</span> be the
inner and outer radii of the iron cylinder and let <span class="math">\(c_1\)</span> and <span class="math">\(c_2\)</span>
be the radii of the two concentric distributions of copper wire
cross-sections. Furthermore, we let <span class="math">\(r\)</span> be the radius of a copper
wire, <span class="math">\(R\)</span> be the radius of our domain, and <span class="math">\(n\)</span> be the number of
windings (giving a total of <span class="math">\(2n\)</span> copper-wire cross-sections). This
geometry can be described easily using <code class="docutils literal"><span class="pre">mshr</span></code> and a little bit of
Python programming:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define geometry for background</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="p">)</span>

<span class="c1"># Define geometry for iron cylinder</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>

<span class="c1"># Define geometry for wires (N = North (up), S = South (down))</span>
<span class="n">angles_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">angles_S</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">wires_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c_1</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">c_1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">angles_N</span><span class="p">]</span>
<span class="n">wires_S</span> <span class="o">=</span> <span class="p">[</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c_2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">c_2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">angles_S</span><span class="p">]</span>
</pre></div>
</div>
<p>The mesh that we generate will be a mesh of the entire disk with
radius <span class="math">\(R\)</span> but we need the mesh generation to respect the internal
boundaries defined by the iron cylinder and the copper wires. We also
want <code class="docutils literal"><span class="pre">mshr</span></code> to label the subdomains so that we can easily specify
material parameters (<span class="math">\(\mu\)</span>) and currents. To do this, we use the
<code class="docutils literal"><span class="pre">mshr</span></code> function <code class="docutils literal"><span class="pre">set_subdomain</span></code> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Set subdomain for iron cylinder</span>
<span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cylinder</span><span class="p">)</span>

<span class="c1"># Set subdomains for wires</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wires_N</span><span class="p">):</span>
    <span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wires_S</span><span class="p">):</span>
    <span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>
</pre></div>
</div>
<p>Once the subdomains have been created, we can generate the mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>A detail of the mesh is shown in Figure
<a class="reference internal" href="#ftut1-fig-magnetostatics-mesh"><span class="std std-ref">Plot of the mesh generated for the magnetostatics test problem. The subdomains for the iron cylinder and copper wires are clearly visible</span></a>.</p>
<div class="figure" id="id3">
<span id="ftut1-fig-magnetostatics-mesh"></span><a class="reference internal image-reference" href="_images/magnetostatics_mesh.png"><img alt="_images/magnetostatics_mesh.png" src="_images/magnetostatics_mesh.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the mesh generated for the magnetostatics test problem. The subdomains for the iron cylinder and copper wires are clearly visible</em></span></p>
</div>
<p>The mesh generated with <code class="docutils literal"><span class="pre">mshr</span></code> will contain information about the
subdomains we have defined. To use this information in the definition of
our variational problem and subdomain-dependent parameters, we will need to
create a <code class="docutils literal"><span class="pre">MeshFunction</span></code> that marks the subdomains. This can be easily
created by a call to the member function <code class="docutils literal"><span class="pre">mesh.domains()</span></code>, which holds
the subdomain data generated by <code class="docutils literal"><span class="pre">mshr</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">markers</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">domains</span><span class="p">())</span>
</pre></div>
</div>
<p>This line creates a <code class="docutils literal"><span class="pre">MeshFunction</span></code> with unsigned integer values (the
subdomain numbers) with dimension 2, which is the cell dimension for
this 2D problem.</p>
<p>We can now use the markers as we have done before to redefine the
integration measure <code class="docutils literal"><span class="pre">dx</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">markers</span><span class="p">)</span>
</pre></div>
</div>
<p>Integrals over subdomains can then be expressed by <code class="docutils literal"><span class="pre">dx(0)</span></code>, <code class="docutils literal"><span class="pre">dx(1)</span></code>,
and so on. We use this to define the current <span class="math">\(J_z = \pm 1\,\mathrm{A}\)</span>
in the coppper wires:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">J_N</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">J_S</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">A_z</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L_N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">J_N</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
<span class="n">L_S</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">J_S</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">L_N</span> <span class="o">+</span> <span class="n">L_S</span>
</pre></div>
</div>
<p>The permeability is defined as an <code class="docutils literal"><span class="pre">Expression</span></code> that depends on the
subdomain number:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>class Permeability(Expression):
    def __init__(self, mesh, **kwargs):
        self.markers = markers
    def eval_cell(self, values, x, ufc_cell):
        if markers[ufc_cell.index] == 0:
            values[0] = 4*pi*1e-7 # vacuum
        elif markers[ufc_cell.index] == 1:
            values[0] = 1e-5      # iron (should really be 2.5e-1)
        else:
            values[0] = -6.4e-6   # copper

mu = Permeability(mesh, degree=1)
</pre></div>
</div>
<p>As seen in this code snippet, we have used a somewhat less extreme
value for the magnetic permeability of iron. This is to make the
solution a little more interesting. It would otherwise be completely
dominated by the field in the iron cylinder.</p>
<p>Finally, when <span class="math">\(A_z\)</span> has been computed, we can compute the magnetic
field:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">as_vector</span><span class="p">((</span><span class="n">A_z</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">A_z</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">))),</span> <span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p>We use <code class="docutils literal"><span class="pre">as_vector()</span></code> to interpret the tuple
<code class="docutils literal"><span class="pre">(A_z.dx(1),</span> <span class="pre">-A_z.dx(0))</span></code> as a vector. The resulting plots of the
magnetic vector potential and magnetic field are shown in Figures
<a class="reference internal" href="#ftut1-fig-magnetostatics-potential"><span class="std std-ref">Plot of the -component  of the magnetic vector potential</span></a> and
<a class="reference internal" href="#ftut1-fig-magnetostatics-field"><span class="std std-ref">Plot of the magnetic field  \( B \)  in the  \( xy \) -plane</span></a>.</p>
<div class="figure" id="id4">
<span id="ftut1-fig-magnetostatics-potential"></span><a class="reference internal image-reference" href="_images/magnetostatics_potential.png"><img alt="_images/magnetostatics_potential.png" src="_images/magnetostatics_potential.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">Plot of the <span class="math">\(z\)</span>-component <span class="math">\(A_z\)</span> of the magnetic vector potential</span></p>
</div>
<div class="figure" id="id5">
<span id="ftut1-fig-magnetostatics-field"></span><a class="reference internal image-reference" href="_images/magnetostatics_field.png"><img alt="_images/magnetostatics_field.png" src="_images/magnetostatics_field.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the magnetic field  \( B \)  in the  \( xy \) -plane</em></span></p>
</div>
<p>The complete code for computing the magnetic field follows below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c1"># inner radius of iron cylinder</span>
<span class="n">b</span> <span class="o">=</span> <span class="mf">1.2</span>   <span class="c1"># outer radius of iron cylinder</span>
<span class="n">c_1</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="c1"># radius for inner circle of copper wires</span>
<span class="n">c_2</span> <span class="o">=</span> <span class="mf">1.4</span> <span class="c1"># radius for outer circle of copper wires</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.1</span>   <span class="c1"># radius of copper wires</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">5.0</span>   <span class="c1"># radius of domain</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>    <span class="c1"># number of windings</span>

<span class="c1"># FIXME: Use &#39;domain&#39; instead of &#39;geometry&#39; in other examples</span>

<span class="c1"># Define geometry for background</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="p">)</span>

<span class="c1"># Define geometry for iron cylinder</span>
<span class="n">cylinder</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>

<span class="c1"># Define geometry for wires (N = North (up), S = South (down))</span>
<span class="n">angles_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">angles_S</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">wires_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c_1</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">c_1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">angles_N</span><span class="p">]</span>
<span class="n">wires_S</span> <span class="o">=</span> <span class="p">[</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c_2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">c_2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">angles_S</span><span class="p">]</span>

<span class="c1"># Set subdomain for iron cylinder</span>
<span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cylinder</span><span class="p">)</span>

<span class="c1"># Set subdomains for wires</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wires_N</span><span class="p">):</span>
    <span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wires_S</span><span class="p">):</span>
    <span class="n">domain</span><span class="o">.</span><span class="n">set_subdomain</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>

<span class="c1"># Create mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># FIXME: Remove when working</span>
<span class="c1">#File(&#39;magnetostatics.xml.gz&#39;) &lt;&lt; mesh</span>
<span class="c1">#mesh = Mesh(&#39;magnetostatics.xml.gz&#39;)</span>

<span class="c1"># Define function space</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define boundary condition</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;on_boundary&#39;</span><span class="p">)</span>

<span class="c1"># Define subdomain markers and integration measure</span>
<span class="n">markers</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">domains</span><span class="p">())</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">markers</span><span class="p">)</span>

<span class="c1"># Define current densities</span>
<span class="n">J_N</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">J_S</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Define magnetic permeability</span>
<span class="k">class</span> <span class="nc">Permeability</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">markers</span> <span class="o">=</span> <span class="n">markers</span>
    <span class="k">def</span> <span class="nf">eval_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ufc_cell</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">markers</span><span class="p">[</span><span class="n">ufc_cell</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mf">1e-7</span> <span class="c1"># vacuum</span>
        <span class="k">elif</span> <span class="n">markers</span><span class="p">[</span><span class="n">ufc_cell</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-5</span>      <span class="c1"># iron (should really be 2.5e-1)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.4e-6</span>   <span class="c1"># copper</span>

<span class="n">mu</span> <span class="o">=</span> <span class="n">Permeability</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define variational problem</span>
<span class="n">A_z</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L_N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">J_N</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
<span class="n">L_S</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">J_S</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">L_N</span> <span class="o">+</span> <span class="n">L_S</span>

<span class="c1"># Solve variational problem</span>
<span class="n">A_z</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">A_z</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c1"># Compute magnetic field (B = curl A)</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">as_vector</span><span class="p">((</span><span class="n">A_z</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">A_z</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">))),</span> <span class="n">W</span><span class="p">)</span>

<span class="c1"># Plot solution</span>
<span class="n">plot</span><span class="p">(</span><span class="n">A_z</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

<span class="c1"># Save solution to file</span>
<span class="n">vtkfile_A_z</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;magneticpotential.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_B</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;magneticfield.pvd&#39;</span><span class="p">)</span>
<span class="n">vtkfile_A_z</span> <span class="o">&lt;&lt;</span> <span class="n">A_z</span>
<span class="n">vtkfile_B</span> <span class="o">&lt;&lt;</span> <span class="n">B</span>

<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code can be found in the file <code class="docutils literal"><span class="pre">ft12_magnetostatics.py</span></code>.</p>
</div>
</div>
</div>


    </div>
  </div>
</div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>