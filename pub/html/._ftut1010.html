<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I">
<meta name="keywords" content="Poisson's equation,variational formulation,test function,trial function,abstract variational formulation,finite element specifications,CG finite element family,Lagrange finite element family,P1 element,Periodic Table of the Finite Elements,Dirichlet boundary conditions,boundary specification (function),C++ expression syntax,expression syntax (C++),boundary specification (function),UFL,degrees of freedom,degrees of freedom array,nodal values array,numbering degrees of freedom,numbering cell vertices,Expression with parameters,interpolation,visualization,plotting,VTK,rotate PDF plots,time-dependent PDEs,Neumann boundary conditions,heterogeneous media,multi-material domain,boundary specification (class),Dirichlet boundary conditions,Neumann boundary conditions,Robin boundary conditions,boundary conditions,Robin condition,unit testing,dimension-independent code,linear algebra backend,PETSc,Eigen,LinearVariationalProblem,LinearVariationalSolver,linear systems (in FEniCS),assembly of linear systems,random start vector (linear systems),SLEPc,compute vertex values,vertex values,vertex to dof map,dof to vertex map,Poisson's equation with variable coefficient,Postprocessing,projection,projection,degrees of freedom array,nodal values array,degrees of freedom array (vector field),functionals,energy functional,error functional,flux functional,structured mesh,visualization, structured mesh,surface plot (structured mesh),contour plot">

<title>Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, None, '___sec0'),
              (u'Preliminaries', 0, u'ch:prelim', u'ch:prelim'),
              (u'The FEniCS Project', 1, None, '___sec2'),
              (u'What you will learn', 1, None, '___sec3'),
              (u'Working with this tutorial', 1, None, '___sec4'),
              (u'Obtaining the software', 1, None, '___sec5'),
              (u'Installation using Docker containers', 2, None, '___sec6'),
              (u'Installation using Ubuntu packages', 2, None, '___sec7'),
              (u'Testing your installation', 2, None, '___sec8'),
              (u'Obtaining the tutorial examples', 1, None, '___sec9'),
              (u'Background knowledge', 1, None, '___sec10'),
              (u'Programming in Python', 2, u'ftut:pybooks', u'ftut:pybooks'),
              (u'The finite element method',
               2,
               u'ftut:fembooks',
               u'ftut:fembooks'),
              (u'Fundamentals: Solving the Poisson equation',
               0,
               u'ch:fundamentals',
               u'ch:fundamentals'),
              (u'Mathematical problem formulation',
               1,
               u'ftut:poisson1:bvp',
               u'ftut:poisson1:bvp'),
              (u'Finite element variational formulation',
               2,
               u'ch:poisson0:varform',
               u'ch:poisson0:varform'),
              (u'Abstract finite element variational formulation',
               2,
               u'ch:poisson0:abstrat',
               u'ch:poisson0:abstrat'),
              (u'Choosing a test problem',
               2,
               u'ch:poisson0:testproblem',
               u'ch:poisson0:testproblem'),
              (u'FEniCS implementation',
               1,
               u'ch:poisson0:impl',
               u'ch:poisson0:impl'),
              (u'The complete program', 2, None, '___sec19'),
              (u'Running the program',
               2,
               u'ch:poisson0:impl:run',
               u'ch:poisson0:impl:run'),
              (u'Terminal window', 3, None, '___sec21'),
              (u'Spyder', 3, None, '___sec22'),
              (u'Jupyter notebooks', 3, None, '___sec23'),
              (u'Dissection of the program',
               1,
               u'ch:poisson0:impl:dissect',
               u'ch:poisson0:impl:dissect'),
              (u'The important first line', 2, None, '___sec25'),
              (u'Generating simple meshes', 2, None, '___sec26'),
              (u'Defining the finite element function space',
               2,
               None,
               '___sec27'),
              (u'Defining the trial and test functions', 2, None, '___sec28'),
              (u'Defining the boundary and the boundary conditions',
               2,
               None,
               '___sec29'),
              (u'Defining the source term', 2, None, '___sec30'),
              (u'Defining the variational problem', 2, None, '___sec31'),
              (u'Forming and solving the linear system', 2, None, '___sec32'),
              (u'Plotting the solution', 2, None, '___sec33'),
              (u'Exporting and post-processing the solution',
               2,
               None,
               '___sec34'),
              (u'Computing the error', 2, None, '___sec35'),
              (u'Examining degrees of freedom and vertex values',
               2,
               u'ch:poisson0:impl:dofmap',
               u'ch:poisson0:impl:dofmap'),
              (u'Deflection of a membrane',
               1,
               u'ch:poisson0:membrane',
               u'ch:poisson0:membrane'),
              (u'Scaling the equation', 2, None, '___sec38'),
              (u'Defining the mesh', 2, None, '___sec39'),
              (u'Defining the load', 2, None, '___sec40'),
              (u'Defining the variational problem', 2, None, '___sec41'),
              (u'Plotting the solution', 2, None, '___sec42'),
              (u'Making curve plots through the domain', 2, None, '___sec43'),
              (u'Visualizing the solution in ParaView',
               2,
               u'ftut:paraview',
               u'ftut:paraview'),
              (u'Using the built-in visualization tool',
               2,
               u'ftut:quickviz',
               u'ftut:quickviz'),
              (u'Exercise 1: Visualize a solution in a cube',
               2,
               None,
               '___sec46'),
              (u'A Gallery of finite element solvers',
               0,
               u'ch:gallery',
               u'ch:gallery'),
              (u'The heat equation',
               1,
               u'ch:fundamentals:diffusion',
               u'ch:fundamentals:diffusion'),
              (u'PDE problem', 2, None, '___sec49'),
              (u'Variational formulation',
               2,
               u'ftut:timedep:diffusion1',
               u'ftut:timedep:diffusion1'),
              (u'FEniCS implementation',
               2,
               u'ftut:timedep:diffusion1:impl',
               u'ftut:timedep:diffusion1:impl'),
              (u'Test problem', 3, None, '___sec52'),
              (u'FEniCS implementation', 3, None, '___sec53'),
              (u'Diffusion of a Gaussian function', 2, None, '___sec54'),
              (u'The mathematical problem', 3, None, '___sec55'),
              (u'FEniCS implementation', 3, None, '___sec56'),
              (u'Visualization in ParaView', 3, None, '___sec57'),
              (u'A nonlinear Poisson equation',
               1,
               u'ftut1:gallery:nonlinearpoisson',
               u'ftut1:gallery:nonlinearpoisson'),
              (u'PDE problem', 2, None, '___sec59'),
              (u'Variational formulation', 2, None, '___sec60'),
              (u'FEniCS implementation',
               2,
               u'ftut:nonlinear:Newton:auto',
               u'ftut:nonlinear:Newton:auto'),
              (u'Test problem', 3, None, '___sec62'),
              (u'FEniCS implementation', 3, None, '___sec63'),
              (u'The equations of linear elasticity',
               1,
               u'ftut:elast',
               u'ftut:elast'),
              (u'PDE problem', 2, None, '___sec65'),
              (u'Variational formulation',
               2,
               u'ftut:elast:varform',
               u'ftut:elast:varform'),
              (u'FEniCS implementation', 2, None, '___sec67'),
              (u'Test problem', 3, None, '___sec68'),
              (u'The code', 3, None, '___sec69'),
              (u'Vector function spaces', 3, None, '___sec70'),
              (u'Constant vectors', 3, None, '___sec71'),
              (u'`nabla_grad`', 3, None, '___sec72'),
              (u'Stress computation', 3, None, '___sec73'),
              (u'Scaling', 3, None, '___sec74'),
              (u'The Navier--Stokes equations', 1, u'ftut1:NS', u'ftut1:NS'),
              (u'PDE problem', 2, None, '___sec76'),
              (u'Variational formulation',
               2,
               u'ftut1:NS:varform',
               u'ftut1:NS:varform'),
              (u'FEniCS implementation', 2, None, '___sec78'),
              (u'Test problem 1: Channel flow', 3, None, '___sec79'),
              (u'FEniCS implementation', 3, None, '___sec80'),
              (u'Verification', 3, None, '___sec81'),
              (u'Exercise 2: Simulate channel flow in a 3D geometry',
               2,
               None,
               '___sec82'),
              (u'Flow past a cylinder', 2, None, '___sec83'),
              (u'FEniCS implementation', 3, None, '___sec84'),
              (u'A system of advection--diffusion--reaction equations',
               1,
               u'ftut1:reactionsystem',
               u'ftut1:reactionsystem'),
              (u'PDE problem', 2, None, '___sec86'),
              (u'Variational formulation', 2, None, '___sec87'),
              (u'FEniCS implementation', 2, None, '___sec88'),
              (u'Setting initial conditions for mixed systems',
               2,
               None,
               '___sec89'),
              (u'Setting boundary conditions for mixed systems',
               2,
               None,
               '___sec90'),
              (u'Accessing components of mixed systems', 2, None, '___sec91'),
              (u'Subdomains and boundary conditions',
               0,
               u'ch:subdomains',
               u'ch:subdomains'),
              (u'Combining Dirichlet and Neumann conditions',
               1,
               u'ch:poisson0:DN',
               u'ch:poisson0:DN'),
              (u'PDE problem', 2, None, '___sec94'),
              (u'Variational formulation', 2, None, '___sec95'),
              (u'FEniCS implementation', 2, None, '___sec96'),
              (u'Setting multiple Dirichlet conditions',
               1,
               u'ch:poisson0:multiple:Dirichlet',
               u'ch:poisson0:multiple:Dirichlet'),
              (u'Defining subdomains for different materials',
               1,
               u'ftut:possion:2D:2mat:impl',
               u'ftut:possion:2D:2mat:impl'),
              (u'Using expressions to define subdomains',
               2,
               None,
               '___sec99'),
              (u'Using mesh functions to define subdomains',
               2,
               None,
               '___sec100'),
              (u'Vectorized version of subdomain definitions',
               2,
               None,
               '___sec101'),
              (u'Using C++ code snippets to define subdomains',
               2,
               None,
               '___sec102'),
              (u'Exercise 3: Efficiency of Python vs C++ expressions',
               2,
               u'ch:poisson0:exer:eff:expression',
               u'ch:poisson0:exer:eff:expression'),
              (u'Setting multiple Dirichlet, Neumann, and Robin conditions',
               1,
               u'ch:poisson0:multi:bc',
               u'ch:poisson0:multi:bc'),
              (u'Three types of boundary conditions', 2, None, '___sec105'),
              (u'PDE problem', 2, None, '___sec106'),
              (u'Variational formulation', 2, None, '___sec107'),
              (u'FEniCS implementation', 2, None, '___sec108'),
              (u'Test problem', 2, None, '___sec109'),
              (u'Debugging boundary conditions', 2, None, '___sec110'),
              (u'Generating meshes with subdomains', 1, None, '___sec111'),
              (u'PDE problem', 2, None, '___sec112'),
              (u'Variational formulation', 2, None, '___sec113'),
              (u'FEniCS implementation', 2, None, '___sec114'),
              (u'Extensions: Improving the Poisson solver',
               0,
               u'ch:poisson',
               u'ch:poisson'),
              (u'Refactoring the Poisson solver',
               1,
               u'ch:poisson0:impl2',
               u'ch:poisson0:impl2'),
              (u'A more general solver function',
               2,
               u'ch:poisson0:impl2:func',
               u'ch:poisson0:impl2:func'),
              (u'Writing the solver as a Python module',
               2,
               None,
               '___sec118'),
              (u'Verification and unit tests', 2, None, '___sec119'),
              (u'Parameterizing the number of space dimensions',
               2,
               u'ch:poisson0:nD',
               u'ch:poisson0:nD'),
              (u'Exercise 4: Solve a Poisson problem', 2, None, '___sec121'),
              (u'Remarks', 3, None, '___sec122'),
              (u'Exercise 5: Refactor the code for membrane deflection',
               2,
               u'ch:poisson0:exer:membrane',
               u'ch:poisson0:exer:membrane'),
              (u'Working with linear solvers', 1, None, '___sec124'),
              (u'Controlling the solution process',
               2,
               u'ch:poisson0:solve:prm',
               u'ch:poisson0:solve:prm'),
              (u'Choosing a linear solver and preconditioner',
               3,
               None,
               '___sec126'),
              (u'Choosing a linear algebra backend', 3, None, '___sec127'),
              (u'Setting solver parameters', 3, None, '___sec128'),
              (u'An extended solver function', 3, None, '___sec129'),
              (u'A remark regarding unit tests', 3, None, '___sec130'),
              (u'List of linear solver methods and preconditioners',
               2,
               u'ftut:app:solver:prec',
               u'ftut:app:solver:prec'),
              (u'Linear variational problem and solver objects',
               2,
               u'ch:poisson0:solver:problem',
               u'ch:poisson0:solver:problem'),
              (u'Explicit assembly and solve',
               2,
               u'ch:poisson0:linalg',
               u'ch:poisson0:linalg'),
              (u'Examining matrix and vector values', 2, None, '___sec134'),
              (u'Examining the degrees of freedom',
               2,
               u'ch:poisson0:verify1',
               u'ch:poisson0:verify1'),
              (u'Postprocessing computations',
               1,
               u'ftut:possion:2D:varcoeff',
               u'ftut:possion:2D:varcoeff'),
              (u'A variable-coefficient Poisson problem',
               2,
               None,
               '___sec137'),
              (u'Flux computations',
               2,
               u'ch:poisson0:gradu',
               u'ch:poisson0:gradu'),
              (u'Computing functionals',
               2,
               u'ch:poisson0:functionals',
               u'ch:poisson0:functionals'),
              (u'Energy functional', 3, None, '___sec140'),
              (u'Error functional', 3, None, '___sec141'),
              (u'Flux Functional', 3, None, '___sec142'),
              (u'Computing convergence rates',
               2,
               u'ch:poisson0:convrates',
               u'ch:poisson0:convrates'),
              (u'Computing error norms', 3, None, '___sec144'),
              (u'Computing convergence rates', 3, None, '___sec145'),
              (u'Test problem', 3, None, '___sec146'),
              (u'Experiments', 3, None, '___sec147'),
              (u'Taking advantage of structured mesh data',
               2,
               u'ftut:structviz',
               u'ftut:structviz'),
              (u'Iterating over points and values', 3, None, '___sec149'),
              (u'Computing finite difference approximations',
               3,
               None,
               '___sec150'),
              (u'Making surface plots', 3, None, '___sec151'),
              (u'Making contour plots', 3, None, '___sec152'),
              (u'Making curve plots through the domain',
               3,
               None,
               '___sec153'),
              (u'Making curve plots of the flux', 3, None, '___sec154'),
              (u'Test problem', 3, None, '___sec155'),
              (u'Bibliography', 1, None, '___sec156')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\dt}{\Delta t}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\ub}{u_{_\mathrm{D}}}
\newcommand{\GD}{\Gamma_{_\mathrm{D}}}
\newcommand{\GN}{\Gamma_{_\mathrm{N}}}
\newcommand{\GR}{\Gamma_{_\mathrm{R}}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\renni}[2]{\langle #2, #1 \rangle}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="ftut1.html">Solving PDEs in Minutes - <br> The FEniCS Tutorial Volume I</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._ftut1001.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ch:prelim" style="font-size: 80%;"><b>Preliminaries</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The FEniCS Project</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What you will learn</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with this tutorial</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the software</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Docker containers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation using Ubuntu packages</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing your installation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Obtaining the tutorial examples</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:pybooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming in Python</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1002.html#ftut:fembooks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:fundamentals" style="font-size: 80%;"><b>Fundamentals: Solving the Poisson equation</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ftut:poisson1:bvp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1004.html#ch:poisson0:abstrat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract finite element variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1005.html#ch:poisson0:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:run" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jupyter notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dissect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The important first line</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating simple meshes</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the finite element function space</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the trial and test functions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the boundary and the boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the source term</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming and solving the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exporting and post-processing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:impl:dofmap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining degrees of freedom and vertex values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ch:poisson0:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Deflection of a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling the equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the load</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining the variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:paraview" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualizing the solution in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#ftut:quickviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using the built-in visualization tool</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1006.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Visualize a solution in a cube</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:gallery" style="font-size: 80%;"><b>A Gallery of finite element solvers</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ch:fundamentals:diffusion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The heat equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:timedep:diffusion1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a Gaussian function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization in ParaView</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:gallery:nonlinearpoisson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A nonlinear Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec59" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:nonlinear:Newton:auto" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut:elast:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector function spaces</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant vectors</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`nabla_grad`</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stress computation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Navier--Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:NS:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem 1: Channel flow</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Simulate channel flow in a 3D geometry</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow past a cylinder</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#ftut1:reactionsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A system of advection--diffusion--reaction equations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting initial conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting boundary conditions for mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1008.html#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessing components of mixed systems</a></li>
     <!-- navigation toc: --> <li><a href="#ch:subdomains" style="font-size: 80%;"><b>Subdomains and boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:DN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Combining Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:multiple:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="#ftut:possion:2D:2mat:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Defining subdomains for different materials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using expressions to define subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using mesh functions to define subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized version of subdomain definitions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using C++ code snippets to define subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:exer:eff:expression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Efficiency of Python vs C++ expressions</a></li>
     <!-- navigation toc: --> <li><a href="#ch:poisson0:multi:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Setting multiple Dirichlet, Neumann, and Robin conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three types of boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generating meshes with subdomains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDE problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FEniCS implementation</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson" style="font-size: 80%;"><b>Extensions: Improving the Poisson solver</b></a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Refactoring the Poisson solver</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:impl2:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing the solver as a Python module</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification and unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:nD" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameterizing the number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Solve a Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1011.html#ch:poisson0:exer:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Refactor the code for membrane deflection</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with linear solvers</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solve:prm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controlling the solution process</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec126" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear solver and preconditioner</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec127" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choosing a linear algebra backend</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec128" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting solver parameters</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended solver function</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec130" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A remark regarding unit tests</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:app:solver:prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List of linear solver methods and preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:solver:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear variational problem and solver objects</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:linalg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit assembly and solve</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining matrix and vector values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:verify1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examining the degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:possion:2D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Postprocessing computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec137" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variable-coefficient Poisson problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:gradu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux computations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:functionals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing functionals</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec140" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec141" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec142" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flux Functional</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ch:poisson0:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing error norms</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#ftut:structviz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taking advantage of structured mesh data</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterating over points and values</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making surface plots</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making contour plots</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making curve plots through the domain</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making curve plots of the flux</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1012.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem</a></li>
     <!-- navigation toc: --> <li><a href="._ftut1013.html#___sec156" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0010"></a>
<!-- !split -->

<center><h1 id="ch:subdomains" class="anchor">Subdomains and boundary conditions</h1></center> <!-- chapter heading -->

<p>
<blockquote>
    So far, we have only looked briefly at how to specify boundary
    conditions. In this chapter, we look more closely at how to specify
    boundary conditions on specific parts (subdomains) of the boundary and
    how to combine multiple boundary conditions. We will also look at how to
    generate meshes with subdomains and how to define coefficients and
    variational problems that look different in different subdomains.
</blockquote>


<p>
<!-- ========= Multiple domains and boundaries ========= -->

<h1 id="ch:poisson0:DN" class="anchor">Combining Dirichlet and Neumann conditions</h1>

<p>
Let's return to our Poisson solver from the chapter <a href="._ftut1004.html#ch:fundamentals">Fundamentals: Solving the Poisson equation</a>
and see how to extend the mathematics and the implementation to handle
a Dirichlet condition in combination with a Neumann condition. The
domain is still the unit square, but now we set the Dirichlet
condition \( u=\ub \) at the left and right sides, \( x=0 \) and \( x=1 \), while
the Neumann condition

$$
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
$$

is applied to the remaining
sides \( y=0 \) and \( y=1 \).

<p>
<!-- The Neumann condition is also known as a <em>natural boundary condition</em> -->
<!-- (in contrast to an essential boundary condition). -->

<h2 id="___sec94" class="anchor">PDE problem </h2>

<p>
Let \( \GD \) and \( \GN \) denote the parts of the boundary \( \partial\Omega \)
where the Dirichlet and Neumann conditions apply, respectively.  The
complete boundary-value problem can be written as

$$
\begin{alignat}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega,  \\ 
    u &= \ub &&\mbox{on } \GD,       \\ 
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN  \tp
\end{alignat}
$$

Again we choose \( u=1+x^2 + 2y^2 \) as the exact solution and adjust \( f \), \( g \), and
\( \ub \) accordingly:

$$
\begin{align*}
f &= -6,\\ 
g &= \left\lbrace\begin{array}{ll}
0, & y=0\\ 
4, & y=1
\end{array}\right.\\ 
\ub &= 1 + x^2 + 2y^2\tp
\end{align*}
$$

For ease of programming, we may introduce a \( g \) function defined over the whole
of \( \Omega \) such that \( g \) takes on the right values at \( y=0 \) and
\( y=1 \). One possible extension is

$$
\begin{equation*}
g(x,y) = 4y\tp
\end{equation*}
$$

<h2 id="___sec95" class="anchor">Variational formulation </h2>

<p>
The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
\( v \) is only zero on \( \GD \). We have

$$
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
$$

and since \( v=0 \) on \( \GD \),

$$
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\GN}{\partial u\over
\partial n}v \ds
= \int_{\GN}gv \ds,
\end{equation*}
$$

by applying the boundary condition on \( \GN \).
The resulting weak form reads

$$
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx
= \int_{\Omega} fv \dx - \int_{\GN} gv \ds\tp
\tag{4.1}
\end{equation}
$$

Expressing this equation
in the standard notation \( a(u,v)=L(v) \) is straightforward with

$$
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
\tag{4.2}\\ 
L(v) &= \int_{\Omega} fv \dx -
\int_{\GN} gv \ds\tp  \tag{4.3}
\end{align}
$$

<h2 id="___sec96" class="anchor">FEniCS implementation </h2>

<p>
How does the Neumann condition impact the implementation?  Let us
revisit our previous implementation <code>ft01_poisson.py</code> from
the section <a href="._ftut1006.html#ch:poisson0:impl">FEniCS implementation</a> and examine which changes
we need to make to incorporate the Neumann condition. It turns out that
only two are necessary.

<ul>
  <li> The function <code>boundary</code> defining the Dirichlet boundary
    must be modified.</li>
  <li> The new boundary term must be added to the expression for <code>L</code>.</li>
</ul>

The first adjustment can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary_D</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">if</span> on_boundary:
        <span style="color: #008000; font-weight: bold">if</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol) <span style="color: #AA22FF; font-weight: bold">or</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">1</span>, tol):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
</pre></div>
<p>
A more compact implementation reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary_D</span>(x, on_boundary):
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> (near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol) <span style="color: #AA22FF; font-weight: bold">or</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">1</span>, tol))
</pre></div>
<p>
The second adjustment of our program concerns the definition of <code>L</code>,
which needs to include the Neumann condition:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>g <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;4*x[1]&#39;</span>)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds
</pre></div>
<p>
The <code>ds</code> variable implies a boundary integral, while <code>dx</code>
implies an integral over the domain \( \Omega \).
No other modifications are necessary.

<p>
Note that the integration <code>*ds</code> is carried out over the entire
boundary, including the Dirichlet boundary. However, since the test
function <code>v</code> vanishes on the Dirichlet boundary (as a result
specifying a <code>DirichletBC</code>), the integral will only include the
contribution from the Neumann boundary.

<h1 id="ch:poisson0:multiple:Dirichlet" class="anchor">Setting multiple Dirichlet conditions</h1>

<p>
In the previous section, we used a single function \( \ub(x,y) \) for
setting Dirichlet conditions at two parts of the boundary.  Often it
is more practical to use multiple functions, one for each subdomain of the
boundary. Let us return to the case from the section <a href="#ch:poisson0:DN">Combining Dirichlet and Neumann conditions</a>
and redefine the problem in terms of two Dirichlet conditions:

$$
\begin{alignat*}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega, \\ 
    u &= u_{_\mathrm{L}} &&\mbox{on } \GD^{^{\mathrm{L}}}, \\ 
    u &= u_{_\mathrm{R}} &&\mbox{on } \GD^{^{\mathrm{R}}}, \\ 
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN \tp
\end{alignat*}
$$

Here, \( \GD^{^{\mathrm{L}}} \) is the left boundary \( x=0 \), while
\( \GD^{^{\mathrm{R}}} \) is the right boundary \( x=1 \). We note that
\( u_{_\mathrm{L}} = 1 + 2y^2 \), \( u_{_\mathrm{R}} = 2 + 2y^2 \), and \( g=4y \).

<p>
For the boundary condition on \( \GD^{^{\mathrm{L}}} \), we define the
usual triple of an expression for the boundary value, a function
defining the location of the boundary, and a <code>DirichletBC</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_L <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;1 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary_L</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol)

bc_L <span style="color: #666666">=</span> DirichletBC(V, u_L, boundary_L)
</pre></div>
<p>
For the boundary condition on \( \GD^{^{\mathrm{R}}} \), we write a
similar code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u_R <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2 + 2*x[1]*x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary_R</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">1</span>, tol)

bc_R <span style="color: #666666">=</span> DirichletBC(V, u_R, boundary_R)
</pre></div>
<p>
We collect the two boundary conditions in a list which
we can pass to the <code>solve</code> function to compute the solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>bcs <span style="color: #666666">=</span> [bc_L, bc_R]
<span style="color: #666666">...</span>
solve(a <span style="color: #666666">==</span> L, u, bcs)
</pre></div>
<p>
Note that for boundary values that do not depend on \( x \) or \( y \), we
might replace the <code>Expression</code> objects by <code>Constant</code> objects.

<h1 id="ftut:possion:2D:2mat:impl" class="anchor">Defining subdomains for different materials</h1>

<p>
Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kinds of problems are handled by
defining subdomains inside the domain. A simple example with two
materials (subdomains) in 2D will demonstrate the idea.

<p>
<center> <!-- figure label: --> <div id="ftut:possion:2D:2mat:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 14:  Medium with discontinuous material properties.  <!-- caption label: ftut:possion:2D:2mat:fig1 --> </p></center>
<p><img src="fig/layered_medium_2.png" align="bottom" width=400></p>
</center>

<p>
Suppose we want to solve

$$
\begin{equation} \tag{4.4}
    \nabla\cdot \left\lbrack \kappa(x,y)\nabla u(x,y)\right\rbrack = 0,
\end{equation}
$$

in a domain \( \Omega \) consisting of two subdomains where \( \kappa \) takes on
a different value in each subdomain.
We take \( \Omega = [0,1]\times [0,1] \) and divide it into two equal
subdomains, as depicted in Figure <a href="#ftut:possion:2D:2mat:fig1">14</a>,

$$
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
$$

We define \( \kappa(x,y)=\kappa_0 \) in \( \Omega_0 \) and \( \kappa(x,y)=\kappa_1 \) in \( \Omega_1 \),
where \( \kappa_0>0 \) and \( \kappa_1>0 \) are given constants.

<p>
Physically, this problem may be viewed as a model of heat conduction,
where the heat conduction in \( \Omega_1 \) is more efficient than in
\( \Omega_0 \). An alternative interpretation is flow in porous media with
two geological layers, where the layers' ability to transport the
fluid differ.

<h2 id="___sec99" class="anchor">Using expressions to define subdomains </h2>

<p>
The simplest way of implementing a variable coefficient \( \kappa \) is to
define an <code>Expression</code> object where we return the appropriate \( \kappa \)
value depending on the position in space. Since we need some testing
on the coordinates, the most straightforward approach is to define a
subclass of <code>Expression</code>, where we can use a full Python method
instead of just a C++ string formula for specifying a function.  The
method that defines the function is called <code>eval</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">K</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_k_values</span>(<span style="color: #008000">self</span>, k_0, k_1):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k_0, <span style="color: #008000">self</span><span style="color: #666666">.</span>k_1 <span style="color: #666666">=</span> k_0, k_1

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        <span style="color: #BA2121">&quot;Set value[0] to value at point x&quot;</span>
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span> <span style="color: #666666">+</span> tol:
            value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k_0
        <span style="color: #008000; font-weight: bold">else</span>:
            value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k_1

<span style="color: #408080; font-style: italic"># Initialize k</span>
k <span style="color: #666666">=</span> K()
k<span style="color: #666666">.</span>set_k_values(<span style="color: #666666">1</span>, <span style="color: #666666">0.01</span>)
</pre></div>
<p>
The <code>eval</code> method gives great flexibility in defining functions, but a
downside is that FEniCS will call <code>eval</code> in Python for each node <code>x</code>,
which is a slow process.

<p>
An alternative method is to use a C++ string expression as we have
seen before, which is much more efficient in FEniCS. This can be done
using inline if tests in C++:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
k_0 <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
k_1 <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
k <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;x[1] &lt;= 0.5 + tol ? k_0 : k_1&#39;</span>,
               tol<span style="color: #666666">=</span>tol, k_0<span style="color: #666666">=</span>k_0, k_1<span style="color: #666666">=</span>k_1)
</pre></div>
<p>
This method of defining variable coefficients works if the subdomains
are simple shapes that can be expressed in terms of geometric
inequalities. However, for more complex subdomains, we will need to
use a more general technique, as we will see next.

<h2 id="___sec100" class="anchor">Using mesh functions to define subdomains </h2>

<p>
We now address how to specify the subdomains \( \Omega_0 \) and \( \Omega_1 \)
using a more general technique. This technique involves the use of two
classes that are essential in FEniCS when working with subdomains:
<code>SubDomain</code> and <code>MeshFunction</code>. Consider the following definition of the
boundary \( x = 0 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol)
</pre></div>
<p>
This boundary definition is actually a shortcut to the more general
FEniCS concept <code>SubDomain</code>. A <code>SubDomain</code> is a class which defines a
region in space (a subdomain) in terms of a member function <code>inside</code>
which returns <code>True</code> for points that belong to the subdomain and
<code>False</code> for points that don't belong to the subdomain. Here is how to
specify the boundary \( x = 0 \) as a <code>SubDomain</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Boundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol)

boundary <span style="color: #666666">=</span> Boundary()
bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)
</pre></div>
<p>
We notice that the <code>inside</code> function of the class <code>Boundary</code> is
(almost) identical to the previous boundary definition in terms of the
<code>boundary</code> function. Technically, our class <code>Boundary</code> is a
<em>subclass</em> of the FEniCS class <code>SubDomain</code>.

<p>
<!-- A word about computer science terminology may be in order here: The term -->
<!-- <em>instance</em> means a Python object of a particular type (such as -->
<!-- <code>SubDomain</code>, <code>Function</code>, <code>FunctionSpace</code>, etc.).  Many use <em>instance</em> -->
<!-- and <em>object</em> as interchangeable terms. In other computer programming -->
<!-- languages one may also use the term <em>variable</em> for the same thing. We -->
<!-- mostly use the well-known term <em>object</em> in this text. -->

<p>
We will use two <code>SubDomain</code> subclasses to define the two subdomains
\( \Omega_0 \) and \( \Omega_1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega_0</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span> <span style="color: #666666">+</span> tol

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Omega_1</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5</span> <span style="color: #666666">-</span> tol
</pre></div>
<p>
Notice the use of <code>&lt;=</code> and <code>&gt;=</code> in both tests. FEniCS will call the
<code>inside</code> function for each vertex in a cell to determine whether or
not the cell belongs to a particular subdomain. For this reason, it is
important that the test holds for all vertices in cells aligned with
the boundary. In addition, we use a tolerance to make sure that
vertices on the internal boundary at \( y = 0.5 \) will belong to <em>both</em>
subdomains. This is a little counter-intuitive, but is necessary to
make the cells both above and below the internal boundary belong to
either \( \Omega_0 \) or \( \Omega_1 \).

<p>
To define the variable coefficient \( \kappa \), we will use a powerful tool in
FEniCS called a <code>MeshFunction</code>. A <code>MeshFunction</code> is a discrete
function that can be evaluated at a set of so-called <em>mesh
entities</em>. A mesh entity in FEniCS is either a vertex, an edge, a
face, or a cell (triangle or tetrahedron). A <code>MeshFunction</code> over cells
is suitable to represent subdomains (materials), while a
<code>MeshFunction</code> over facets (edges or faces) is used to represent
pieces of external or internal boundaries. A <code>MeshFunction</code> over cells
can also be used to represent boundary markers for mesh refinement. A
FEniCS <code>MeshFunction</code> is parameterized both over its data type (like
integers or booleans) and its dimension (0 = vertex, 1 = edge
etc.). Special subclasses <code>VertexFunction</code>, <code>EdgeFunction</code> etc. are
provided for easy definition of a <code>MeshFunction</code> of a particular
dimension.

<p>
Since we need to define subdomains of \( \Omega \) in the present example,
we make use of a <code>CellFunction</code>. The constructor
is fed with two arguments: 1) the type of value: <code>'int'</code> for integers,
<code>'size_t'</code> for non-negative (unsigned) integers, <code>'double'</code> for real
numbers, and <code>'bool'</code> for logical values; 2) a <code>Mesh</code> object.
Alternatively, the constructor can take just a filename and initialize
the <code>CellFunction</code> from data in a file.

<p>
We start with creating a <code>CellFunction</code> whose values are non-negative
integers (<code>'size_t'</code>) for numbering the subdomains:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
</pre></div>
<p>
Next, we use the two subdomains to <em>mark</em> the cells belonging to each
subdomain:
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span># Mark subdomains with numbers 0 and 1
subdomain0 = Omega_0()
subdomain1 = Omega_1()
subdomain0.mark(materials, 0)
subdomain1.mark(materials, 1)
</pre></div>
<p>
This will set the values of the mesh function <code>materials</code> to \( 0 \) on
each cell belonging to \( \Omega_0 \) and \( 1 \) on all cells belonging to
\( \Omega_1 \). Alternatively, we can use the following equivalent code to
mark the cells:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>materials.set_all(0)
subdomain1.mark(materials, 1)
</pre></div>
<p>
To examine the values of the mesh function and see that we have indeed
defined our subdomains correctly, we can simply plot the mesh
function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>plot(materials, interactive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
We may also wish to store the values of the mesh function for later
use:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>File(<span style="color: #BA2121">&#39;materials.xml.gz&#39;</span>) <span style="color: #666666">&lt;&lt;</span> materials
</pre></div>
<p>
which can later be read back from file as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>File(<span style="color: #BA2121">&#39;materials.xml.gz&#39;</span>) <span style="color: #666666">&gt;&gt;</span> materials
</pre></div>
<p>
Now, to use the values of the mesh function <code>materials</code> to define the
variable coefficient \( \kappa \), we create a FEniCS <code>Expression</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">K</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, materials, k_0, k_1, <span style="color: #666666">**</span>kwargs):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>materials <span style="color: #666666">=</span> materials
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k_0 <span style="color: #666666">=</span> k_0
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k_1 <span style="color: #666666">=</span> k_1

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval_cell</span>(<span style="color: #008000">self</span>, values, x, cell):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>materials[cell<span style="color: #666666">.</span>index] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k_0
        <span style="color: #008000; font-weight: bold">else</span>:
            values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k_1

k <span style="color: #666666">=</span> K(materials, k_0, k_1, degree<span style="color: #666666">=0</span>)
</pre></div>
<p>
This is similar to the <code>Expression</code> subclass we defined above, but we
make use of the member function <code>eval_cell</code> in place of the regular
<code>eval</code> function. This version of the evaluation function has an
addition <code>cell</code> argument which we can use to check on which cell we are
currently evaluating the function.

<p>
Since we make use of geometric tests to define the two <code>SubDomains</code>
for \( \Omega_0 \) and \( \Omega_1 \), the <code>MeshFunction</code> method may seem like
an unnecessary complication of the simple method using an
<code>Expression</code> with an if-test. However, in general the definition of
subdomains may be available as a <code>MeshFunction</code> (from a data file),
perhaps generated as part of the mesh generation process, and not as a
simple geometric test. In such cases the method demonstrated here is
the recommended way to define subdomains.

<h2 id="___sec101" class="anchor">Vectorized version of subdomain definitions </h2>

<p>
To speed up this code, we can vectorize the expressions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>materials <span style="color: #666666">=</span> CellFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
materials<span style="color: #666666">.</span>set_all(<span style="color: #666666">0</span>)  <span style="color: #408080; font-style: italic"># &quot;the rest&quot;</span>
<span style="color: #008000; font-weight: bold">for</span> m, subdomain <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(subdomains[<span style="color: #666666">1</span>:], <span style="color: #666666">1</span>):
    subdomain<span style="color: #666666">.</span>mark(materials, m)

kappa_values <span style="color: #666666">=</span> kappa
V0 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
kappa <span style="color: #666666">=</span> Function(V0)
help <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(materials<span style="color: #666666">.</span>array(), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int32)
kappa<span style="color: #666666">.</span>vector()[:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>choose(help, kappa_values)
</pre></div>
<p>
The <code>help</code> array is required since <code>choose</code> cannot work with
<code>materials.array()</code> because this array has elements of
type <code>uint32</code>. We must therefore transform this array to an array
<code>help</code> with standard <code>int32</code> integers.

<h2 id="___sec102" class="anchor">Using C++ code snippets to define subdomains </h2>

<p>
The <code>SubDomain</code> and <code>Expression</code> Python classes are very convenient,
but their use leads to function calls from C++ to Python for each node
in the mesh. Since this involves a significant cost, we need to make
use of C++ code for large-scale computational problems.

<p>
Instead of writing the <code>SubDomain</code> subclass in Python, we may instead use
the <code>CompiledSubDomain</code> tool in FEniCS to specify the subdomain in C++
code and thereby speed up our code. Consider
the definition of the classes <code>Omega_0</code> and <code>Omega_1</code> above in Python. The
key strings that define these subdomains can be expressed in C++ syntax
and fed to <code>CompiledSubDomain</code> as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
subdomain0 <span style="color: #666666">=</span> CompiledSubDomain(<span style="color: #BA2121">&#39;x[1] &lt;= 0.5 + tol&#39;</span>, tol<span style="color: #666666">=</span>tol)
subdomain1 <span style="color: #666666">=</span> CompiledSubDomain(<span style="color: #BA2121">&#39;x[1] &gt;= 0.5 - tol&#39;</span>, tol<span style="color: #666666">=</span>tol)
</pre></div>
<p>
As seen, one can have parameters in the strings and specify their
values by keyword arguments.
The resulting objects, <code>subdomain0</code> and <code>subdomain1</code>, can be used
as ordinary <code>SubDomain</code> objects.

<p>
Compiled subdomain strings can be applied for specifying boundaries as
well:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>boundary_R <span style="color: #666666">=</span> CompiledSubDomain(<span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[0], 1, tol)&#39;</span>,
                               tol<span style="color: #666666">=1E-14</span>)
</pre></div>
<p>
It is also possible to feed the C++ string (without parameters)
directly as the third argument to <code>DirichletBC</code> without explicitly
constructing a <code>CompiledSubDomain</code> object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>bc1 <span style="color: #666666">=</span> DirichletBC(V, value, <span style="color: #BA2121">&#39;on_boundary &amp;&amp; near(x[0], 1, tol)&#39;</span>)
</pre></div>
<p>
Python <code>Expression</code> classes may also be redefined using C++ for more
efficient code. Consider again the definition of the class <code>K</code> above
for the variable coefficient \( \kappa = \kappa(x) \). This may be redefined using a
C++ code snippet and the keyword <code>cppcode</code> to the regular FEniCS
<code>Expression</code> class:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>cppcode = &quot;&quot;&quot;
class K : public Expression
{
public:

  void eval(Array&lt;double&gt;&amp; values,
            const Array&lt;double&gt;&amp; x,
            const ufc::cell&amp; cell) const
  {
    if ((*materials)[cell.index] == 0)
      values[0] = k_0;
    else
      values[0] = k_1;
  }

  std::shared_ptr&lt;MeshFunction&lt;std::size_t&gt;&gt; materials;
  double k_0;
  double k_1;

};
&quot;&quot;&quot;

k = Expression(cppcode=cppcode, degree=0)
k.materials = materials
k.k_0 = k_0
k.k_1 = k_1
</pre></div>
<p>
<!-- --- begin exercise --- -->

<h2 id="ch:poisson0:exer:eff:expression" class="anchor">Exercise 3: Efficiency of Python vs C++ expressions</h2>

<p>
Consider a cube mesh with \( N \) cells in each spatial direction.
We want to define a <code>Function</code> on this mesh where the
values are given by the mathematical function \( f(x,y,z)=a\sin(bxyz) \),
where \( a \) and \( b \) are two parameters. Write a <code>class SineXYZ</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])
</pre></div>
<p>
Create an alternative <code>Expression</code> based on giving the formula for \( f(x,y,z) \)
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using <code>time.clock()</code> to measure the CPU time).

<p>
The <code>sin</code> function used in class <code>SineXYZ.eval</code> can mean many things.
This is an advanced FEniCS function if imported from <code>fenics</code>.
Much more efficient versions for sin of numbers are found in <code>math.sin</code>
and <code>numpy.sin</code>. Compare the use <code>sin</code> from <code>fenics</code>, <code>math</code>, <code>numpy</code>, and
<code>sympy</code> (note that <code>sin</code> from <code>sympy</code> is very slow).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_1">

<p>
Here is an appropriate program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">__future__</span> <span style="color: #008000; font-weight: bold">import</span> print_function
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">make_sine_Function</span>(N, method):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Fill a Function with sin(x*y*z) values.&quot;&quot;&quot;</span>
    mesh <span style="color: #666666">=</span> UnitCubeMesh(N, N, N)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;Lagrange&#39;</span>, <span style="color: #666666">2</span>)

    <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&#39;Python&#39;</span>):
        <span style="color: #008000; font-weight: bold">if</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;fenics.sin&#39;</span>):
            <span style="color: #408080; font-style: italic"># Need sin as local variable in this function</span>
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;math.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;numpy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">elif</span> method<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;sympy.sin&#39;</span>):
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sin
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">NotImplementedError</span>(<span style="color: #BA2121">&#39;method=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> method)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;sin:&#39;</span>, sin, <span style="color: #008000">type</span>(sin))

        <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SineXYZ</span>(Expression):
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b):
                <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> a, b

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
                value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a<span style="color: #666666">*</span>sin(<span style="color: #008000">self</span><span style="color: #666666">.</span>b<span style="color: #666666">*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">2</span>])

        expr <span style="color: #666666">=</span> SineXYZ(a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    <span style="color: #008000; font-weight: bold">elif</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;C++&#39;</span>:
        expr <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;a*sin(b*x[0]*x[1]*x[2])&#39;</span>, a<span style="color: #666666">=1</span>, b<span style="color: #666666">=2</span>)

    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    u <span style="color: #666666">=</span> interpolate(expr, V)
    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> u, t1<span style="color: #666666">-</span>t0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(N):
    u, cpu_py_fenics  <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-fenics.sin&#39;</span>)
    u, cpu_py_math    <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-math.sin&#39;</span>)
    u, cpu_py_numpy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-numpy.sin&#39;</span>)
    u, cpu_py_sympy   <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;Python-sympy.sin&#39;</span>)
    u, cpu_cpp <span style="color: #666666">=</span> make_sine_Function(N, <span style="color: #BA2121">&#39;C++&#39;</span>)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;&quot;&quot;DOFs: </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Python:</span>
<span style="color: #BA2121">fenics.sin: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">math.sin:   </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">numpy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">sympy.sin:  </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">C++:        </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">Speed-up:   math: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">  sympy: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&quot;&quot;&quot;</span> <span style="color: #666666">%</span>
          (u<span style="color: #666666">.</span>function_space()<span style="color: #666666">.</span>dim(),
           cpu_py_fenics, cpu_py_math,
           cpu_py_numpy, cpu_py_sympy,
           cpu_cpp,
           cpu_py_math<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp),
           cpu_py_sympy<span style="color: #666666">/</span><span style="color: #008000">float</span>(cpu_cpp)))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">profile</span>():
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">cProfile</span>
    prof <span style="color: #666666">=</span> cProfile<span style="color: #666666">.</span>Profile()
    prof<span style="color: #666666">.</span>runcall(main)
    prof<span style="color: #666666">.</span>dump_stats(<span style="color: #BA2121">&quot;tmp.profile&quot;</span>)
    <span style="color: #408080; font-style: italic"># http://docs.python.org/2/library/profile.html</span>

main(<span style="color: #666666">20</span>)
<span style="color: #408080; font-style: italic">#profile()</span>
</pre></div>
<p>
Running the program shows that <code>sin</code> from <code>math</code> is the most efficient choice,
but a string C++ runs 40 times faster. Note that <code>fenics.sin</code>, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the <code>sin</code>
functions for numbers in <code>math</code> and <code>numpy</code>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>Expression_efficiency</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="ch:poisson0:multi:bc" class="anchor">Setting multiple Dirichlet, Neumann, and Robin conditions</h1>

<p>
Consider again the model problem from the section <a href="#ch:poisson0:multiple:Dirichlet">Setting multiple Dirichlet conditions</a> where we had both Dirichlet and
Neumann conditions. The term <code>g*v*ds</code> in the expression for <code>L</code>
implies a boundary integral over the complete boundary, or in FEniCS
terms, an integral over all <em>exterior facets</em>. This means that the
boundary integral extends also over the part of the boundary \( \GD \)
where we have Dirichlet conditions. However, only the integral over
\( \GN \) will contribute since \( v = 0 \) on \( \GD \) (which happens when we
apply the Dirichlet boundary condition).

<p>
From an efficiency point of view, we would ideally like to compute the
integral <code>g*v*ds</code> only over the part of the boundary where we actually
have Neumann conditions. More importantly, in other problems one may
have different Neumann conditions or other conditions like the Robin
type condition. This can be handled in FEniCS by defining a
<code>MeshFunction</code> that marks different portions of the boundary. The same
technique can also be used to treat multiple Dirichlet conditions.

<h2 id="___sec105" class="anchor">Three types of boundary conditions </h2>

<p>
We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin. Dirichlet conditions apply to some
parts \( \GD^0 \), \( \GD^1 \), \( ... \), of the boundary:

$$ \ub^0\hbox{ on }\GD^0,\quad
\ub^1\hbox{ on }\GD^1, \quad \ldots$$

where \( \ub^i \) are prescribed functions, \( i=0,1,\ldots \)
On other parts, \( \GN^0 \), \( \GN^1 \), and so on, we have
Neumann conditions:

$$ -\kappa{\partial u\over\partial n} = g_{0}\hbox{ on }\GN^0,\quad
-\kappa{\partial u\over\partial n} = g_{1}\hbox{ on }\GN^1,\quad \ldots
$$

Finally, we have <em>Robin conditions</em>:

$$
\begin{equation*}
-\kappa{\partial u\over\partial n} = r(u-s),
\tag{4.5}
\end{equation*}
$$

where \( r \) and \( s \) are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, \( r \) is a heat
transfer coefficient, and \( s \) is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts \( \GR^0 \), \( \GR^1 \), and so forth:

$$ -\kappa{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\GR^0,\quad
-\kappa{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\GR^1,\quad \ldots
$$

<h2 id="___sec106" class="anchor">PDE problem </h2>

<p>
With the notation above, the model problem to be solved with multiple
Dirichlet, Neumann, and Robin conditions can be formulated as follows:

$$
\begin{align}
-\nabla\cdot(\kappa\nabla u) &= -f, \mbox{ in } \Omega, \tag{4.6}\\ 
u &= \ub^i \mbox{ on } \GD^i,\quad i=0,1,\ldots
\tag{4.7}\\ 
-\kappa{\partial u\over\partial n} &= g_i \mbox{ on } \GN^i,\quad
i=0,1,\ldots
\tag{4.8}\\ 
-\kappa{\partial u\over\partial n} &= r_i(u-s_i) \mbox{ on } \GR^i,\quad
i=0,1,\ldots
\tag{4.9}
\end{align}
$$

<h2 id="___sec107" class="anchor">Variational formulation </h2>

<p>
As usual, we multiply by a test function \( v \) and integrate by parts:

$$
\begin{equation*}
 -\int_\Omega \nabla\cdot(\kappa\nabla u) v \dx
= \int_\Omega \kappa\nabla u\cdot \nabla v \dx -
\int_{\partial\Omega}\kappa\frac{\partial u}{\partial n}v \ds\tp
\end{equation*}
$$

On the Dirichlet part of the boundary (\( \GD^i \)), the boundary integral
vanishes since \( v = 0 \). On the remaining part of the boundary, we
split the boundary integral into contributions from the Neumann part
(\( \GN^i \)) and Robin part (\( \GR^i \)). Inserting the boundary conditions,
we obtain

$$
\begin{align*}
-\int_{\partial\Omega} \kappa\frac{\partial u}{\partial n}v \ds
&=
-\sum_i\int_{\GN^i} \kappa\frac{\partial u}{\partial n} \ds
-\sum_i\int_{\GR^i} \kappa\frac{\partial u}{\partial n} \ds\\ 
&=
\sum_i\int_{\GN^i}g_i \ds +
\sum_i\int_{\GR^i}r_i(u-s_i) \ds\tp
\end{align*}
$$

We thus obtain the following variational problem:

$$
\begin{equation}
F = \int_{\Omega} \kappa\nabla u\cdot \nabla v \dx +
\sum_i\int_{\GN^i} g_iv \ds +
\sum_i\int_{\GR^i}r_i(u-s_i)v \ds
- \int_{\Omega} fv \dx =0\tp
\tag{4.10}
\end{equation}
$$

<p>
We have been used to writing this variational formulation in the
standard notation \( a(u,v)=L(v) \), which requires that we identify all
integrals with <em>both</em> \( u \) and \( v \), and collect these in \( a(u,v) \),
while the remaining integrals with \( v \) and not \( u \) go into \( L(v) \). The
integrals from the Robin condition must for this reason be split in
two parts:

$$
\begin{equation*}
\int_{\GR^i}r_i(u-s_i)v \ds
= \int_{\GR^i} r_iuv \ds - \int_{\GR^i}r_is_iv \ds\tp
\end{equation*}
$$

We then have

$$
\begin{align}
a(u, v) &= \int_{\Omega} \kappa\nabla u\cdot \nabla v \dx
+ \sum_i\int_{\GR^i}r_iuv \ds,
\tag{4.11}\\ 
L(v) &= \int_{\Omega} fv \dx -
\sum_i\int_{\GN^i} g_i v \ds + \sum_i\int_{\GR^i}r_is_iv \ds\tp
\tag{4.12}
\end{align}
$$

Alternatively, we may keep the formulation
<a href="#mjx-eqn-4.10">(4.10)</a> and either solve the variational
problem as a nonlinear problem (<code>F == 0</code>) in FEniCS or use the FEniCS
functions <code>lhs</code> and <code>rhs</code> to extract the bilinear and linear parts of
<code>F</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>a <span style="color: #666666">=</span> lhs(F)
L <span style="color: #666666">=</span> rhs(F)
</pre></div>
<p>
Note that if we choose the solve this linear problem as a nonlinear
problem, the Newton iteration will converge in a single iteration.

<h2 id="___sec108" class="anchor">FEniCS implementation </h2>

<p>
Let us examine how to extend our Poisson solver to handle general
combinations of Dirichlet, Neumann, and Robin boundary conditions.
Compared to our previous code, we must consider the following
extensions:

<ul>
  <li> Defining markers for the different parts of the boundary.</li>
  <li> Splitting the boundary integral into parts using the markers.</li>
</ul>

A general approach to the first task is to mark each of the desired
boundary parts with markers 0, 1, 2, and so forth. Here we aim at the
four sides of the unit square, marked with 0 (\( x=0 \)), 1 (\( x=1 \)), 2
(\( y=0 \)), and 3 (\( y=1 \)).  The markers will be defined using a
<code>MeshFunction</code>, but contrary to the section <a href="#ftut:possion:2D:2mat:impl">Defining subdomains for different materials</a>, this is not a function over cells, but
a function over the facets of the mesh. We use a <code>FacetFunction</code> for
this purpose:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>boundary_markers <span style="color: #666666">=</span> FacetFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh)
</pre></div>
<p>
As in the section <a href="#ftut:possion:2D:2mat:impl">Defining subdomains for different materials</a> we use a subclass of
<code>SubDomain</code> to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the \( x=0 \) boundary can be marked by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">BoundaryX0</span>(SubDomain):
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">0</span>], <span style="color: #666666">0</span>, tol)

bx0 <span style="color: #666666">=</span> BoundaryX0()
bx0<span style="color: #666666">.</span>mark(boundary_markers, <span style="color: #666666">0</span>)
</pre></div>
<p>
Similarly, we make the classes <code>BoundaryX1</code> for the \( x=1 \) boundary,
<code>BoundaryY0</code> for the \( y=0 \) boundary, and <code>BoundaryY1</code> for the \( y=1 \)
boundary, and mark these as subdomains 1, 2, and 3, respectively.

<p>
For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>boundary_conditions = {0: {&#39;Dirichlet&#39;: u_D},
                       1: {&#39;Robin&#39;:     (r, s)},
                       2: {&#39;Neumann&#39;:   g},
                       3: {&#39;Neumann&#39;,   0}}
</pre></div>
<p>
specifies

<ul>
 <li> a Dirichlet condition \( u = \ub \) for \( x = 0 \);</li>
 <li> a Robin condition \( -\kappa\partial_n u = r(u-s) \) for \( x = 1 \);</li>
 <li> a Neumann condition \( -\kappa\partial_n u = g \) for \( y = 0 \);</li>
 <li> a Neumann condition \( -\kappa\partial_n u = 0 \) for \( y = 1 \).</li>
</ul>

As explained in the section <a href="#ch:poisson0:multiple:Dirichlet">Setting multiple Dirichlet conditions</a>, multiple
Dirichlet conditions must be collected in a list of <code>DirichletBC</code>
objects. Based on the <code>boundary_conditions</code> data structure above, we
can construct this list by the following code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>bcs <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Dirichlet&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[i]:
        bc <span style="color: #666666">=</span> DirichletBC(V, boundary_conditions[i][<span style="color: #BA2121">&#39;Dirichlet&#39;</span>],
                         boundary_markers, i))
        bcs<span style="color: #666666">.</span>append(bc)
</pre></div>
<p>
A new aspect of the variational problem is the two distinct
boundary integrals over \( \GN^i \) and \( \GR^i \).
Having a mesh function over exterior cell facets (our
<code>boundary_markers</code> object), where subdomains (boundary parts) are
numbered as \( 0,1,2,\ldots \), the special symbol <code>ds(0)</code>
implies integration over subdomain (part) 0, <code>ds(1)</code> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <code>ds</code>-type objects generalizes to volume
integrals too: <code>dx(0)</code>, <code>dx(1)</code>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside \( \Omega \).

<p>
To express integrals over the boundary parts using <code>ds(i)</code>, we must
first redefine the measure <code>ds</code> in terms of our boundary markers:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>ds <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;ds&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>boundary_markers)
</pre></div>
<p>
Similarly, if we want integration over different parts of the domain,
we redefine <code>dx</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>dx <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;dx&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>domain_markers)
</pre></div>
<p>
where <code>domain_markers</code> is a <code>CellFunction</code> defining subdomains in \( \Omega \).

<p>
Suppose we have a Robin condition with values <code>r</code> and <code>s</code> on subdomain
<code>R</code>, a Neumann condition with value <code>g</code> on subdomain <code>N</code>. The
variational form can then be written

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>a <span style="color: #666666">=</span> kappa<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(N) <span style="color: #666666">+</span> r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(R)
</pre></div>
<p>
In our case, things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the <code>boundary_conditions</code> data structure. We can collect
all Neumann conditions by the following code snippet:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>integrals_N <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Neumann&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[i]:
        <span style="color: #008000; font-weight: bold">if</span> boundary_conditions[i][<span style="color: #BA2121">&#39;Neumann&#39;</span>] <span style="color: #666666">!=</span> <span style="color: #666666">0</span>:
            g <span style="color: #666666">=</span> boundary_conditions[i][<span style="color: #BA2121">&#39;Neumann&#39;</span>]
            integrals_N<span style="color: #666666">.</span>append(g<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(i))
</pre></div>
<p>
Applying <code>sum(integrals_N)</code> will apply the <code>+</code> operator to
the variational forms in the <code>integrals_N</code> list and result
in the integrals we need for the right-hand side <code>L</code> of the
variational form.

<p>
The integrals in the Robin condition can similarly be collected
in lists:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>integrals_R_a <span style="color: #666666">=</span> []
integrals_R_L <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[i]:
        r, s <span style="color: #666666">=</span> boundary_conditions[i][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        integrals_R_a<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(i))
        integrals_R_L<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>s<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(i))
</pre></div>
<p>
We are now in a position to define the <code>a</code> and <code>L</code> expressions
in the variational formulation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>a <span style="color: #666666">=</span> kappa<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(integrals_R_a)
L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> <span style="color: #008000">sum</span>(integrals_N) <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(integrals_R_L)
</pre></div>
<p>
Alternatively, we may use the FEniCS functions <code>lhs</code> and <code>rhs</code> as
mentioned above to simplify the extraction of terms for the Robin
integrals:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>integrals_R <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Robin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> boundary_conditions[i]:
        r, s <span style="color: #666666">=</span> boundary_conditions[i][<span style="color: #BA2121">&#39;Robin&#39;</span>]
        integrals_R<span style="color: #666666">.</span>append(r<span style="color: #666666">*</span>(u <span style="color: #666666">-</span> s)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds(i))

F <span style="color: #666666">=</span> kappa<span style="color: #666666">*</span>dot(grad(u), grad(v))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> \ 
    <span style="color: #008000">sum</span>(integrals_R) <span style="color: #666666">-</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> <span style="color: #008000">sum</span>(integrals_N)
a, L <span style="color: #666666">=</span> lhs(F), rhs(F)
</pre></div>
<p>
This time we can more naturally define the integrals from the
Robin condition as <code>r*(u - s)*v*ds(i)</code>:

<p>
The complete code for this example can be found in the function
<code>solver_bc</code> in the program <code>ft11_poisson_bcs.py</code>.

<h2 id="___sec109" class="anchor">Test problem </h2>

<p>
We will use the same exact solution \( \uex=1+x^2+2y^2 \) as in the chapter <a href="._ftut1004.html#ch:fundamentals">Fundamentals: Solving the Poisson equation</a>, and thus take \( \kappa=1 \) and \( f=-6 \). Our domain
is the unit square, and we assign Dirichlet conditions at \( x=0 \) and
\( x=1 \), a Neumann condition at \( y=1 \), and a Robin condition at
\( y=0 \). With the given \( \uex \), we realize that the Neumann condition is
\( -\partial u / \partial n = - \partial u / \partial y = 4y = 4 \), while
the Robin condition can be selected in many ways. Since \( \partial
u/\partial n=-\partial u/\partial y=0 \) at \( y=0 \), we can select \( s=u \)
and specify \( r \neq 0 \) arbitrarily in the Robin condition. We will set
\( r = 1000 \) and \( s = u \).

<p>
The boundary parts are thus \( \GD^0 \): \( x=0 \), \( \GD^1 \): \( x=1 \),
\( \GR^0 \): \( y=0 \), and \( \GN^0 \): \( y=1 \).

<p>
When implementing this test problem, and especially other test
problems with more complicated expressions, it is advantageous to use
symbolic computing. Below we define the exact solution as a <code>sympy</code>
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can be fed into <code>Expression</code> objects.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Define manufactured solution in sympy and derive f, g, etc.</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)             <span style="color: #408080; font-style: italic"># needed by UFL</span>
u <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span>                       <span style="color: #408080; font-style: italic"># exact solution</span>
u_e <span style="color: #666666">=</span> u                                     <span style="color: #408080; font-style: italic"># exact solution</span>
u_00 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)                         <span style="color: #408080; font-style: italic"># restrict to x = 0</span>
u_01 <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>)                         <span style="color: #408080; font-style: italic"># restrict to x = 1</span>
f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x, <span style="color: #666666">2</span>) <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>diff(u, y, <span style="color: #666666">2</span>)  <span style="color: #408080; font-style: italic"># -Laplace(u)</span>
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(f)                         <span style="color: #408080; font-style: italic"># simplify f</span>
g <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, y)<span style="color: #666666">.</span>subs(y, <span style="color: #666666">1</span>)              <span style="color: #408080; font-style: italic"># compute g = -du/dn</span>
r <span style="color: #666666">=</span> <span style="color: #666666">1000</span>                                    <span style="color: #408080; font-style: italic"># Robin data, arbitrary</span>
s <span style="color: #666666">=</span> u                                       <span style="color: #408080; font-style: italic"># Robin data, u = s</span>

<span style="color: #408080; font-style: italic"># Collect variables</span>
variables <span style="color: #666666">=</span> [u_e, u_00, u_01, f, g, r, s]

<span style="color: #408080; font-style: italic"># Turn into C/C++ code strings</span>
variables <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(var) <span style="color: #008000; font-weight: bold">for</span> var <span style="color: #AA22FF; font-weight: bold">in</span> variables]

<span style="color: #408080; font-style: italic"># Turn into FEniCS Expression</span>
variables <span style="color: #666666">=</span> [Expression(var, degree<span style="color: #666666">=2</span>) <span style="color: #008000; font-weight: bold">for</span> var <span style="color: #AA22FF; font-weight: bold">in</span> variables]

<span style="color: #408080; font-style: italic"># Extract variables</span>
u_e, u_00, u_01, f, g, r, s <span style="color: #666666">=</span> variables

<span style="color: #408080; font-style: italic"># Define boundary conditions</span>
boundary_conditions <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_00},   <span style="color: #408080; font-style: italic"># x=0</span>
                       <span style="color: #666666">1</span>: {<span style="color: #BA2121">&#39;Dirichlet&#39;</span>: u_01},   <span style="color: #408080; font-style: italic"># x=1</span>
                       <span style="color: #666666">2</span>: {<span style="color: #BA2121">&#39;Robin&#39;</span>:     (r, s)}, <span style="color: #408080; font-style: italic"># y=0</span>
                       <span style="color: #666666">3</span>: {<span style="color: #BA2121">&#39;Neumann&#39;</span>:   g}}      <span style="color: #408080; font-style: italic"># y=1</span>
</pre></div>
<p>
This simple test problem is turned into a real unit test for different
function spaces in the function <code>test_solver_bc</code>.

<h2 id="___sec110" class="anchor">Debugging boundary conditions </h2>

<p>
It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. Some
helpful debugging output is to run through all vertex coordinates and
check if the <code>SubDomain.inside</code> method marks the vertex as on the
boundary. Another useful printout is to list which degrees of freedom
that are subject to Dirichlet conditions, and for first-order Lagrange
(\( \mathsf{P}_1 \)) elements, add the corresponding vertex coordinate to the
output.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">if</span> debug:
    <span style="color: #408080; font-style: italic"># Print all vertices that belong to the boundary parts</span>
    <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> mesh<span style="color: #666666">.</span>coordinates():
        <span style="color: #008000; font-weight: bold">if</span> bx0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x = 0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> bx1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on x = 1&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by0<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y = 0&#39;</span> <span style="color: #666666">%</span> x)
        <span style="color: #008000; font-weight: bold">if</span> by1<span style="color: #666666">.</span>inside(x, <span style="color: #008000">True</span>): <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is on y = 1&#39;</span> <span style="color: #666666">%</span> x)

    <span style="color: #408080; font-style: italic"># Print the Dirichlet conditions</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Number of Dirichlet conditions:&#39;</span>, <span style="color: #008000">len</span>(bcs))
    <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:  <span style="color: #408080; font-style: italic"># P1 elements</span>
        d2v <span style="color: #666666">=</span> dof_to_vertex_map(V)
        coor <span style="color: #666666">=</span> mesh<span style="color: #666666">.</span>coordinates()
    <span style="color: #008000; font-weight: bold">for</span> i, bc <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(bcs):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Dirichlet condition </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> i)
        boundary_values <span style="color: #666666">=</span> bc<span style="color: #666666">.</span>get_boundary_values()
        <span style="color: #008000; font-weight: bold">for</span> dof <span style="color: #AA22FF; font-weight: bold">in</span> boundary_values:
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;   dof </span><span style="color: #BB6688; font-weight: bold">%2d</span><span style="color: #BA2121">: u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dof, boundary_values[dof]))
            <span style="color: #008000; font-weight: bold">if</span> V<span style="color: #666666">.</span>ufl_element()<span style="color: #666666">.</span>degree() <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;    at point </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                      (<span style="color: #008000">str</span>(<span style="color: #008000">tuple</span>(coor[d2v[dof]]<span style="color: #666666">.</span>tolist()))))
</pre></div>

<h1 id="___sec111" class="anchor">Generating meshes with subdomains </h1>

<p>
So far, we have worked mostly with simple meshes (the unit square) and
defined boundaries and subdomains in terms of simple geometric tests
like \( x = 0 \) or \( y \leq 0.5 \). For more complex geometries, it is not
realistic to specify boundaries and subdomains in this way. Instead,
the boundaries and subdomains must be defined as part of the mesh
generation process. We will now look at how to use the FEniCS mesh
generation tool <code>mshr</code> to generate meshes and define subdomains.

<h2 id="___sec112" class="anchor">PDE problem </h2>

<p>
We will again solve the Poisson equation, but this time for a
different application. Consider an iron cylinder with copper wires
wound around the cylinder as in Figure
<a href="#ftut1:fig:magnetostatics:geometry">15</a>. Through the copper wires a
static current \( J = 1\,\mathrm{A} \) is flowing and we want to compute
the magnetic field \( B \) in the iron cylinder, the copper wires, and the
surrounding vacuum.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:magnetostatics:geometry"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 15:  Cross-section of an iron cylinder with copper wires wound around the cylinder, here with \( n = 8 \) windings. The inner circles are cross-sections of the copper wire coming up (&quot;north&quot;) and the outer circles are cross-sections of the copper wire going down into the plane (&quot;south&quot;).  <!-- caption label: ftut1:fig:magnetostatics:geometry --> </p></center>
<p><img src="fig/magnetostatics_geometry.png" align="bottom" width=600></p>
</center>

<p>
First, we simplify the problem to a 2D problem. We can do this by
assuming that the cylinder extends far along the \( z \)-axis and as a
consequence the field is virtually independent of the
\( z \)-coordinate. Next, we consider Maxwell's equation to derive a
Poisson equation for the magnetic field (or rather its potential):

$$
\begin{align}
  \nabla\cdot  D &= \varrho, 
\tag{4.13}\\ 
  \nabla\cdot  B &= 0, 
\tag{4.14}\\ 
  \nabla\times E &= -\frac{\partial B}{\partial t}, 
\tag{4.15}\\ 
  \nabla\times H &= \frac{\partial D}{\partial t} + J.
\tag{4.16}
\end{align}
$$

Here, \( D \) is the displacement field, \( B \) is the magnetic
field, \( E \) is the electric field, and \( H \) is the magnetizing field. In
addition to Maxwell's equations, we also need a constitutive relation
between \( B \) and \( H \),

$$
\begin{equation}
  B = \mu H,
\tag{4.17}
\end{equation}
$$

which holds for an isotropic linear magnetic medium. Here, \( \mu \) is the
magnetic permeability of the material. Now, since \( B \) is solenoidal
(divergence free) according to Maxwell's equations, we know that \( B \)
must be the curl of some vector field \( A \). This field is called the
magnetic vector potential. Since \( \partial D/\partial t = 0 \), it
follows that

$$
\begin{equation}
  J = \nabla \times H
    = \nabla \times (\mu^{-1} B)
    = \nabla \times (\mu^{-1} \nabla \times A)
    = -\nabla \cdot (\mu^{-1} \nabla A).
\tag{4.18}
\end{equation}
$$

In the last step, we have expanded the second derivatives and used the
gauge freedom of \( A \) to simplify the equations to a simple
vector-valued Poisson problem for the magnetic vector potential; if \( B
= \nabla \times A \), then \( B = \nabla \times (A + \nabla \psi) \) for any
scalar field \( \psi \) (the gauge function). For the current problem, we
thus need to solve the following 2D Poisson problem for the
\( z \)-component \( A_z \) of the magnetic vector potential:

$$
\begin{align}
  - \nabla \cdot (\mu^{-1} \nabla A_z) &= J_z \quad \text{in } \Real^2, 
\tag{4.19}\\ 
  \lim_{|(x, y)| \rightarrow \infty} A_z &= 0.
\tag{4.20}
\end{align}
$$

Since we cannot solve this problem on an infinite domain, we will
truncate the domain using a large disk and set \( A_z = 0 \) on the
boundary. The current \( J_z \) is set to \( +1\,\mathrm{A} \) in the interior
set of circles (copper wire cross-sections) and to \( -1\,\mathrm{A} \) in
the exterior set of circles in Figure <a href="#ftut1:fig:magnetostatics:geometry">15</a>.

<p>
Once the magnetic vector potential has been computed, we can
compute the magnetic field \( B = B(x, y) \) by

$$
\begin{align}
  B(x, y) =
  \left(\frac{\partial A_z}{\partial y},
       -\frac{\partial A_z}{\partial x}\right).
\tag{4.21}
\end{align}
$$

<h2 id="___sec113" class="anchor">Variational formulation </h2>

<p>
The variational problem is derived as before by multiplying the PDE
with a test function \( v \) and integrating by parts. Since the boundary
integral vanishes due to the Dirichlet condition, we obtain

$$
\begin{equation}
  \int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v \dx
  = \int_{\Omega} J_z v \dx,
\tag{4.22}
\end{equation}
$$

or, in other words, \( a(A_z, v) = L(v) \) with

$$
\begin{align}
  a(A_z, v) &= \int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v \dx, 
\tag{4.23}\\ 
  L(v) &= \int_{\Omega} J_z v \dx.
\tag{4.24}
\end{align}
$$

<h2 id="___sec114" class="anchor">FEniCS implementation </h2>

<p>
The first step is to generate a mesh for the geometry described in
Figure <a href="#ftut1:fig:magnetostatics:geometry">15</a>. We let \( a \) and \( b \) be the
inner and outer radii of the iron cylinder and let \( c_1 \) and \( c_2 \)
be the radii of the two concentric distributions of copper wire
cross-sections. Furthermore, we let \( r \) be the radius of a copper
wire, \( R \) be the radius of our domain, and \( n \) be the number of
windings (giving a total of \( 2n \) copper-wire cross-sections). This
geometry can be described easily using <code>mshr</code> and a little bit of
Python programming:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Define geometry for background</span>
domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), R)

<span style="color: #408080; font-style: italic"># Define geometry for iron cylinder</span>
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), b) <span style="color: #666666">-</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), a)

<span style="color: #408080; font-style: italic"># Define geometry for wires (N = North (up), S = South (down))</span>
angles_N <span style="color: #666666">=</span> [i<span style="color: #666666">*2*</span>pi<span style="color: #666666">/</span>n <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)]
angles_S <span style="color: #666666">=</span> [(i <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>)<span style="color: #666666">*2*</span>pi<span style="color: #666666">/</span>n <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)]
wires_N <span style="color: #666666">=</span> [Circle(Point(c_1<span style="color: #666666">*</span>cos(v), c_1<span style="color: #666666">*</span>sin(v)), r) <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> angles_N]
wires_S <span style="color: #666666">=</span> [Circle(Point(c_2<span style="color: #666666">*</span>cos(v), c_2<span style="color: #666666">*</span>sin(v)), r) <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> angles_S]
</pre></div>
<p>
The mesh that we generate will be a mesh of the entire disk with
radius \( R \) but we need the mesh generation to respect the internal
boundaries defined by the iron cylinder and the copper wires. We also
want <code>mshr</code> to label the subdomains so that we can easily specify
material parameters (\( \mu \)) and currents. To do this, we use the
<code>mshr</code> function <code>set_subdomain</code> as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Set subdomain for iron cylinder</span>
domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">1</span>, cylinder)

<span style="color: #408080; font-style: italic"># Set subdomains for wires</span>
<span style="color: #008000; font-weight: bold">for</span> (i, wire) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(wires_N):
    domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">2</span> <span style="color: #666666">+</span> i, wire)
<span style="color: #008000; font-weight: bold">for</span> (i, wire) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(wires_S):
    domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">2</span> <span style="color: #666666">+</span> n <span style="color: #666666">+</span> i, wire)
</pre></div>
<p>
Once the subdomains have been created, we can generate the mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>mesh <span style="color: #666666">=</span> generate_mesh(domain, <span style="color: #666666">32</span>)
</pre></div>
<p>
A detail of the mesh is shown in Figure
<a href="#ftut1:fig:magnetostatics:mesh">16</a>.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:magnetostatics:mesh"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 16:  Plot of the mesh generated for the magnetostatics test problem. The subdomains for the iron cylinder and copper wires are clearly visible  <!-- caption label: ftut1:fig:magnetostatics:mesh --> </p></center>
<p><img src="fig/magnetostatics_mesh.png" align="bottom" width=600></p>
</center>

<p>
The mesh generated with <code>mshr</code> will contain information about the
subdomains we have defined. To use this information in the definition of
our variational problem and subdomain-dependent parameters, we will need to
create a <code>MeshFunction</code> that marks the subdomains. This can be easily
created by a call to the member function <code>mesh.domains()</code>, which holds
the subdomain data generated by <code>mshr</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>markers <span style="color: #666666">=</span> MeshFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh, <span style="color: #666666">2</span>, mesh<span style="color: #666666">.</span>domains())
</pre></div>
<p>
This line creates a <code>MeshFunction</code> with unsigned integer values (the
subdomain numbers) with dimension 2, which is the cell dimension for
this 2D problem.

<p>
We can now use the markers as we have done before to redefine the
integration measure <code>dx</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>dx <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;dx&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>markers)
</pre></div>
<p>
Integrals over subdomains can then be expressed by <code>dx(0)</code>, <code>dx(1)</code>,
and so on. We use this to define the current \( J_z = \pm 1\,\mathrm{A} \)
in the coppper wires:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>J_N <span style="color: #666666">=</span> Constant(<span style="color: #666666">1.0</span>)
J_S <span style="color: #666666">=</span> Constant(<span style="color: #666666">-1.0</span>)
A_z <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
a <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">/</span> mu)<span style="color: #666666">*</span>dot(grad(A_z), grad(v))<span style="color: #666666">*</span>dx
L_N <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(J_N<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx(i) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span> <span style="color: #666666">+</span> n))
L_S <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(J_S<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx(i) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span> <span style="color: #666666">+</span> n, <span style="color: #666666">2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>n))
L <span style="color: #666666">=</span> L_N <span style="color: #666666">+</span> L_S
</pre></div>
<p>
The permeability is defined as an <code>Expression</code> that depends on the
subdomain number:
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>class Permeability(Expression):
    def __init__(self, mesh, **kwargs):
        self.markers = markers
    def eval_cell(self, values, x, ufc_cell):
        if markers[ufc_cell.index] == 0:
            values[0] = 4*pi*1e-7 # vacuum
        elif markers[ufc_cell.index] == 1:
            values[0] = 1e-5      # iron (should really be 2.5e-1)
        else:
            values[0] = -6.4e-6   # copper

mu = Permeability(mesh, degree=1)
</pre></div>
<p>
As seen in this code snippet, we have used a somewhat less extreme
value for the magnetic permeability of iron. This is to make the
solution a little more interesting. It would otherwise be completely
dominated by the field in the iron cylinder.

<p>
Finally, when \( A_z \) has been computed, we can compute the magnetic
field:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>W <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
B <span style="color: #666666">=</span> project(as_vector((A_z<span style="color: #666666">.</span>dx(<span style="color: #666666">1</span>), <span style="color: #666666">-</span>A_z<span style="color: #666666">.</span>dx(<span style="color: #666666">0</span>))), W)
</pre></div>
<p>
We use <code>as_vector()</code> to interpret the tuple
<code>(A_z.dx(1), -A_z.dx(0))</code> as a vector. The resulting plots of the
magnetic vector potential and magnetic field are shown in Figures
<a href="#ftut1:fig:magnetostatics:potential">17</a> and
<a href="#ftut1:fig:magnetostatics:field">18</a>.

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:magnetostatics:potential"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 17:  Plot of the \( z \)-component \( A_z \) of the magnetic vector potential.  <!-- caption label: ftut1:fig:magnetostatics:potential --> </p></center>
<p><img src="fig/magnetostatics_potential.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure label: --> <div id="ftut1:fig:magnetostatics:field"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 18:  Plot of the magnetic field \( B \) in the \( xy \)-plane.  <!-- caption label: ftut1:fig:magnetostatics:field --> </p></center>
<p><img src="fig/magnetostatics_field.png" align="bottom" width=600></p>
</center>

<p>
The complete code for computing the magnetic field follows below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mshr</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin, cos, pi

a <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>   <span style="color: #408080; font-style: italic"># inner radius of iron cylinder</span>
b <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>   <span style="color: #408080; font-style: italic"># outer radius of iron cylinder</span>
c_1 <span style="color: #666666">=</span> <span style="color: #666666">0.8</span> <span style="color: #408080; font-style: italic"># radius for inner circle of copper wires</span>
c_2 <span style="color: #666666">=</span> <span style="color: #666666">1.4</span> <span style="color: #408080; font-style: italic"># radius for outer circle of copper wires</span>
r <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>   <span style="color: #408080; font-style: italic"># radius of copper wires</span>
R <span style="color: #666666">=</span> <span style="color: #666666">5.0</span>   <span style="color: #408080; font-style: italic"># radius of domain</span>
n <span style="color: #666666">=</span> <span style="color: #666666">10</span>    <span style="color: #408080; font-style: italic"># number of windings</span>

<span style="color: #408080; font-style: italic"># FIXME: Use &#39;domain&#39; instead of &#39;geometry&#39; in other examples</span>

<span style="color: #408080; font-style: italic"># Define geometry for background</span>
domain <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), R)

<span style="color: #408080; font-style: italic"># Define geometry for iron cylinder</span>
cylinder <span style="color: #666666">=</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), b) <span style="color: #666666">-</span> Circle(Point(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>), a)

<span style="color: #408080; font-style: italic"># Define geometry for wires (N = North (up), S = South (down))</span>
angles_N <span style="color: #666666">=</span> [i<span style="color: #666666">*2*</span>pi<span style="color: #666666">/</span>n <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)]
angles_S <span style="color: #666666">=</span> [(i <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>)<span style="color: #666666">*2*</span>pi<span style="color: #666666">/</span>n <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)]
wires_N <span style="color: #666666">=</span> [Circle(Point(c_1<span style="color: #666666">*</span>cos(v), c_1<span style="color: #666666">*</span>sin(v)), r) <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> angles_N]
wires_S <span style="color: #666666">=</span> [Circle(Point(c_2<span style="color: #666666">*</span>cos(v), c_2<span style="color: #666666">*</span>sin(v)), r) <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> angles_S]

<span style="color: #408080; font-style: italic"># Set subdomain for iron cylinder</span>
domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">1</span>, cylinder)

<span style="color: #408080; font-style: italic"># Set subdomains for wires</span>
<span style="color: #008000; font-weight: bold">for</span> (i, wire) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(wires_N):
    domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">2</span> <span style="color: #666666">+</span> i, wire)
<span style="color: #008000; font-weight: bold">for</span> (i, wire) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(wires_S):
    domain<span style="color: #666666">.</span>set_subdomain(<span style="color: #666666">2</span> <span style="color: #666666">+</span> n <span style="color: #666666">+</span> i, wire)

<span style="color: #408080; font-style: italic"># Create mesh</span>
mesh <span style="color: #666666">=</span> generate_mesh(domain, <span style="color: #666666">32</span>)

<span style="color: #408080; font-style: italic"># FIXME: Remove when working</span>
<span style="color: #408080; font-style: italic">#File(&#39;magnetostatics.xml.gz&#39;) &lt;&lt; mesh</span>
<span style="color: #408080; font-style: italic">#mesh = Mesh(&#39;magnetostatics.xml.gz&#39;)</span>

<span style="color: #408080; font-style: italic"># Define function space</span>
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)

<span style="color: #408080; font-style: italic"># Define boundary condition</span>
bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), <span style="color: #BA2121">&#39;on_boundary&#39;</span>)

<span style="color: #408080; font-style: italic"># Define subdomain markers and integration measure</span>
markers <span style="color: #666666">=</span> MeshFunction(<span style="color: #BA2121">&#39;size_t&#39;</span>, mesh, <span style="color: #666666">2</span>, mesh<span style="color: #666666">.</span>domains())
dx <span style="color: #666666">=</span> Measure(<span style="color: #BA2121">&#39;dx&#39;</span>, domain<span style="color: #666666">=</span>mesh, subdomain_data<span style="color: #666666">=</span>markers)

<span style="color: #408080; font-style: italic"># Define current densities</span>
J_N <span style="color: #666666">=</span> Constant(<span style="color: #666666">1.0</span>)
J_S <span style="color: #666666">=</span> Constant(<span style="color: #666666">-1.0</span>)

<span style="color: #408080; font-style: italic"># Define magnetic permeability</span>
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Permeability</span>(Expression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, mesh, <span style="color: #666666">**</span>kwargs):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>markers <span style="color: #666666">=</span> markers
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval_cell</span>(<span style="color: #008000">self</span>, values, x, ufc_cell):
        <span style="color: #008000; font-weight: bold">if</span> markers[ufc_cell<span style="color: #666666">.</span>index] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">4*</span>pi<span style="color: #666666">*1e-7</span> <span style="color: #408080; font-style: italic"># vacuum</span>
        <span style="color: #008000; font-weight: bold">elif</span> markers[ufc_cell<span style="color: #666666">.</span>index] <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
            values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1e-5</span>      <span style="color: #408080; font-style: italic"># iron (should really be 2.5e-1)</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            values[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-6.4e-6</span>   <span style="color: #408080; font-style: italic"># copper</span>

mu <span style="color: #666666">=</span> Permeability(mesh, degree<span style="color: #666666">=1</span>)

<span style="color: #408080; font-style: italic"># Define variational problem</span>
A_z <span style="color: #666666">=</span> TrialFunction(V)
v <span style="color: #666666">=</span> TestFunction(V)
a <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">/</span> mu)<span style="color: #666666">*</span>dot(grad(A_z), grad(v))<span style="color: #666666">*</span>dx
L_N <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(J_N<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx(i) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span> <span style="color: #666666">+</span> n))
L_S <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(J_S<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx(i) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span> <span style="color: #666666">+</span> n, <span style="color: #666666">2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>n))
L <span style="color: #666666">=</span> L_N <span style="color: #666666">+</span> L_S

<span style="color: #408080; font-style: italic"># Solve variational problem</span>
A_z <span style="color: #666666">=</span> Function(V)
solve(a <span style="color: #666666">==</span> L, A_z, bc)

<span style="color: #408080; font-style: italic"># Compute magnetic field (B = curl A)</span>
W <span style="color: #666666">=</span> VectorFunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
B <span style="color: #666666">=</span> project(as_vector((A_z<span style="color: #666666">.</span>dx(<span style="color: #666666">1</span>), <span style="color: #666666">-</span>A_z<span style="color: #666666">.</span>dx(<span style="color: #666666">0</span>))), W)

<span style="color: #408080; font-style: italic"># Plot solution</span>
plot(A_z)
plot(B)

<span style="color: #408080; font-style: italic"># Save solution to file</span>
vtkfile_A_z <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;magneticpotential.pvd&#39;</span>)
vtkfile_B <span style="color: #666666">=</span> File(<span style="color: #BA2121">&#39;magneticfield.pvd&#39;</span>)
vtkfile_A_z <span style="color: #666666">&lt;&lt;</span> A_z
vtkfile_B <span style="color: #666666">&lt;&lt;</span> B

interactive()
</pre></div>
<p>
The complete code can be found in the file <code>ft12_magnetostatics.py</code>.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._ftut1009.html">&laquo;</a></li>
  <li><a href="._ftut1000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._ftut1002.html">3</a></li>
  <li><a href="._ftut1003.html">4</a></li>
  <li><a href="._ftut1004.html">5</a></li>
  <li><a href="._ftut1005.html">6</a></li>
  <li><a href="._ftut1006.html">7</a></li>
  <li><a href="._ftut1007.html">8</a></li>
  <li><a href="._ftut1008.html">9</a></li>
  <li><a href="._ftut1009.html">10</a></li>
  <li class="active"><a href="._ftut1010.html">11</a></li>
  <li><a href="._ftut1011.html">12</a></li>
  <li><a href="._ftut1012.html">13</a></li>
  <li><a href="._ftut1013.html">14</a></li>
  <li><a href="._ftut1011.html">&raquo;</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

